/*! For license information please see 2.49e59758.chunk.js.LICENSE.txt */
(this.webpackJsonpreactapptestausa=this.webpackJsonpreactapptestausa||[]).push([[2],[function(e,t,n){"use strict";n.d(t,"fc",(function(){return m.fc})),n.d(t,"gd",(function(){return m.gd})),n.d(t,"hd",(function(){return m.hd})),n.d(t,"qf",(function(){return m.qf})),n.d(t,"Cf",(function(){return m.Cf})),n.d(t,"rd",(function(){return m.rd})),n.d(t,"sd",(function(){return m.sd})),n.d(t,"td",(function(){return m.td})),n.d(t,"ud",(function(){return m.ud})),n.d(t,"vd",(function(){return m.vd})),n.d(t,"wd",(function(){return m.wd})),n.d(t,"xd",(function(){return m.xd})),n.d(t,"Ad",(function(){return m.Ad})),n.d(t,"Bd",(function(){return m.Bd})),n.d(t,"Cd",(function(){return m.Cd})),n.d(t,"Dd",(function(){return m.Dd})),n.d(t,"Gd",(function(){return m.Gd})),n.d(t,"Hd",(function(){return m.Hd})),n.d(t,"Id",(function(){return m.Id})),n.d(t,"Jd",(function(){return m.Jd})),n.d(t,"Kd",(function(){return m.Kd})),n.d(t,"Ld",(function(){return m.Ld})),n.d(t,"Md",(function(){return m.Md})),n.d(t,"Nd",(function(){return m.Nd})),n.d(t,"Od",(function(){return m.Od})),n.d(t,"Pd",(function(){return m.Pd})),n.d(t,"Qd",(function(){return m.Qd})),n.d(t,"Rd",(function(){return m.Rd})),n.d(t,"Sd",(function(){return m.Sd})),n.d(t,"Td",(function(){return m.Td})),n.d(t,"Ud",(function(){return m.Ud})),n.d(t,"Xd",(function(){return m.Xd})),n.d(t,"Zd",(function(){return m.Zd})),n.d(t,"ce",(function(){return m.ce})),n.d(t,"de",(function(){return m.de})),n.d(t,"ee",(function(){return m.ee})),n.d(t,"fe",(function(){return m.fe})),n.d(t,"ge",(function(){return m.ge})),n.d(t,"he",(function(){return m.he})),n.d(t,"je",(function(){return m.je})),n.d(t,"ke",(function(){return m.ke})),n.d(t,"le",(function(){return m.le})),n.d(t,"qe",(function(){return m.qe})),n.d(t,"se",(function(){return m.se})),n.d(t,"te",(function(){return m.te})),n.d(t,"ue",(function(){return m.ue})),n.d(t,"ve",(function(){return m.ve})),n.d(t,"we",(function(){return m.we})),n.d(t,"xe",(function(){return m.xe})),n.d(t,"ye",(function(){return m.ye})),n.d(t,"ze",(function(){return m.ze})),n.d(t,"Ae",(function(){return m.Ae})),n.d(t,"Be",(function(){return m.Be})),n.d(t,"De",(function(){return m.De})),n.d(t,"Ee",(function(){return m.Ee})),n.d(t,"Fe",(function(){return m.Fe})),n.d(t,"Ge",(function(){return m.Ge})),n.d(t,"Ie",(function(){return m.Ie})),n.d(t,"Je",(function(){return m.Je})),n.d(t,"Ke",(function(){return m.Ke})),n.d(t,"Le",(function(){return m.Le})),n.d(t,"Me",(function(){return m.Me})),n.d(t,"Ne",(function(){return m.Ne})),n.d(t,"Oe",(function(){return m.Oe})),n.d(t,"Pe",(function(){return m.Pe})),n.d(t,"Qe",(function(){return m.Qe})),n.d(t,"Te",(function(){return m.Te})),n.d(t,"Ue",(function(){return m.Ue})),n.d(t,"Ve",(function(){return m.Ve})),n.d(t,"We",(function(){return m.We})),n.d(t,"Xe",(function(){return m.Xe})),n.d(t,"Ye",(function(){return m.Ye})),n.d(t,"bf",(function(){return m.bf})),n.d(t,"cf",(function(){return m.cf})),n.d(t,"df",(function(){return m.df})),n.d(t,"ef",(function(){return m.ef})),n.d(t,"ff",(function(){return m.ff})),n.d(t,"gf",(function(){return m.gf})),n.d(t,"if",(function(){return m.if})),n.d(t,"jf",(function(){return m.jf})),n.d(t,"kf",(function(){return m.kf})),n.d(t,"lf",(function(){return m.lf})),n.d(t,"mf",(function(){return m.mf})),n.d(t,"nf",(function(){return m.nf})),n.d(t,"of",(function(){return m.of})),n.d(t,"pf",(function(){return m.pf})),n.d(t,"rf",(function(){return m.rf})),n.d(t,"sf",(function(){return m.sf})),n.d(t,"tf",(function(){return m.tf})),n.d(t,"uf",(function(){return m.uf})),n.d(t,"xf",(function(){return m.xf})),n.d(t,"Af",(function(){return m.Af})),n.d(t,"Bf",(function(){return m.Bf})),n.d(t,"Ef",(function(){return m.Ef})),n.d(t,"Hf",(function(){return m.Hf})),n.d(t,"If",(function(){return m.If})),n.d(t,"Jf",(function(){return m.Jf})),n.d(t,"zf",(function(){return m.zf})),n.d(t,"Yd",(function(){return m.Yd})),n.d(t,"me",(function(){return m.me})),n.d(t,"re",(function(){return m.re})),n.d(t,"ie",(function(){return m.ie})),n.d(t,"yf",(function(){return m.yf})),n.d(t,"ae",(function(){return m.ae})),n.d(t,"Ce",(function(){return m.Ce})),n.d(t,"wf",(function(){return m.wf})),n.d(t,"Wd",(function(){return m.Wd})),n.d(t,"oe",(function(){return m.oe})),n.d(t,"af",(function(){return m.af})),n.d(t,"Re",(function(){return m.Re})),n.d(t,"yd",(function(){return m.yd})),n.d(t,"Se",(function(){return m.Se})),n.d(t,"Ff",(function(){return m.Ff})),n.d(t,"be",(function(){return m.be})),n.d(t,"Gf",(function(){return m.Gf})),n.d(t,"He",(function(){return m.He})),n.d(t,"Fd",(function(){return m.Fd})),n.d(t,"ne",(function(){return m.ne})),n.d(t,"Ze",(function(){return m.Ze})),n.d(t,"Df",(function(){return m.Df})),n.d(t,"zd",(function(){return m.zd})),n.d(t,"Ed",(function(){return m.Ed})),n.d(t,"vf",(function(){return m.vf})),n.d(t,"hf",(function(){return m.hf})),n.d(t,"Vd",(function(){return m.Vd})),n.d(t,"pe",(function(){return m.pe})),n.d(t,"yb",(function(){return m.yb})),n.d(t,"N",(function(){return m.N})),n.d(t,"a",(function(){return m.a})),n.d(t,"b",(function(){return m.b})),n.d(t,"c",(function(){return m.c})),n.d(t,"d",(function(){return m.d})),n.d(t,"e",(function(){return m.e})),n.d(t,"f",(function(){return m.f})),n.d(t,"g",(function(){return m.g})),n.d(t,"h",(function(){return m.h})),n.d(t,"i",(function(){return m.i})),n.d(t,"j",(function(){return m.j})),n.d(t,"k",(function(){return m.k})),n.d(t,"l",(function(){return m.l})),n.d(t,"n",(function(){return m.n})),n.d(t,"m",(function(){return m.m})),n.d(t,"o",(function(){return m.o})),n.d(t,"r",(function(){return m.r})),n.d(t,"p",(function(){return m.p})),n.d(t,"q",(function(){return m.q})),n.d(t,"s",(function(){return m.s})),n.d(t,"t",(function(){return m.t})),n.d(t,"u",(function(){return m.u})),n.d(t,"v",(function(){return m.v})),n.d(t,"w",(function(){return m.w})),n.d(t,"x",(function(){return m.x})),n.d(t,"y",(function(){return m.y})),n.d(t,"z",(function(){return m.z})),n.d(t,"A",(function(){return m.A})),n.d(t,"B",(function(){return m.B})),n.d(t,"C",(function(){return m.C})),n.d(t,"D",(function(){return m.D})),n.d(t,"E",(function(){return m.E})),n.d(t,"F",(function(){return m.F})),n.d(t,"G",(function(){return m.G})),n.d(t,"H",(function(){return m.H})),n.d(t,"I",(function(){return m.I})),n.d(t,"J",(function(){return m.J})),n.d(t,"L",(function(){return m.L})),n.d(t,"M",(function(){return m.M})),n.d(t,"K",(function(){return m.K})),n.d(t,"O",(function(){return m.O})),n.d(t,"P",(function(){return m.P})),n.d(t,"Q",(function(){return m.Q})),n.d(t,"R",(function(){return m.R})),n.d(t,"S",(function(){return m.S})),n.d(t,"T",(function(){return m.T})),n.d(t,"U",(function(){return m.U})),n.d(t,"W",(function(){return m.W})),n.d(t,"V",(function(){return m.V})),n.d(t,"pc",(function(){return m.pc})),n.d(t,"X",(function(){return m.X})),n.d(t,"Y",(function(){return m.Y})),n.d(t,"Z",(function(){return m.Z})),n.d(t,"bb",(function(){return m.bb})),n.d(t,"ab",(function(){return m.ab})),n.d(t,"cb",(function(){return m.cb})),n.d(t,"db",(function(){return m.db})),n.d(t,"eb",(function(){return m.eb})),n.d(t,"fb",(function(){return m.fb})),n.d(t,"gb",(function(){return m.gb})),n.d(t,"hb",(function(){return m.hb})),n.d(t,"ib",(function(){return m.ib})),n.d(t,"jb",(function(){return m.jb})),n.d(t,"lb",(function(){return m.lb})),n.d(t,"pb",(function(){return m.pb})),n.d(t,"ob",(function(){return m.ob})),n.d(t,"qb",(function(){return m.qb})),n.d(t,"rb",(function(){return m.rb})),n.d(t,"tb",(function(){return m.tb})),n.d(t,"sb",(function(){return m.sb})),n.d(t,"ub",(function(){return m.ub})),n.d(t,"vb",(function(){return m.vb})),n.d(t,"wb",(function(){return m.wb})),n.d(t,"xb",(function(){return m.xb})),n.d(t,"Bb",(function(){return m.Bb})),n.d(t,"Cb",(function(){return m.Cb})),n.d(t,"Db",(function(){return m.Db})),n.d(t,"Eb",(function(){return m.Eb})),n.d(t,"Fb",(function(){return m.Fb})),n.d(t,"Gb",(function(){return m.Gb})),n.d(t,"Hb",(function(){return m.Hb})),n.d(t,"Ib",(function(){return m.Ib})),n.d(t,"Jb",(function(){return m.Jb})),n.d(t,"zb",(function(){return m.zb})),n.d(t,"Ab",(function(){return m.Ab})),n.d(t,"Kb",(function(){return m.Kb})),n.d(t,"Qb",(function(){return m.Qb})),n.d(t,"Lb",(function(){return m.Lb})),n.d(t,"Ob",(function(){return m.Ob})),n.d(t,"Mb",(function(){return m.Mb})),n.d(t,"Nb",(function(){return m.Nb})),n.d(t,"Pb",(function(){return m.Pb})),n.d(t,"Rb",(function(){return m.Rb})),n.d(t,"Sb",(function(){return m.Sb})),n.d(t,"Tb",(function(){return m.Tb})),n.d(t,"Ub",(function(){return m.Ub})),n.d(t,"Vb",(function(){return m.Vb})),n.d(t,"Wb",(function(){return m.Wb})),n.d(t,"Xb",(function(){return m.Xb})),n.d(t,"Yb",(function(){return m.Yb})),n.d(t,"cc",(function(){return m.cc})),n.d(t,"Zb",(function(){return m.Zb})),n.d(t,"ac",(function(){return m.ac})),n.d(t,"bc",(function(){return m.bc})),n.d(t,"ec",(function(){return m.ec})),n.d(t,"dc",(function(){return m.dc})),n.d(t,"gc",(function(){return m.gc})),n.d(t,"hc",(function(){return m.hc})),n.d(t,"ic",(function(){return m.ic})),n.d(t,"jc",(function(){return m.jc})),n.d(t,"kc",(function(){return m.kc})),n.d(t,"lc",(function(){return m.lc})),n.d(t,"mc",(function(){return m.mc})),n.d(t,"nc",(function(){return m.nc})),n.d(t,"oc",(function(){return m.oc})),n.d(t,"qc",(function(){return m.qc})),n.d(t,"rc",(function(){return m.rc})),n.d(t,"tc",(function(){return m.tc})),n.d(t,"wc",(function(){return m.wc})),n.d(t,"xc",(function(){return m.xc})),n.d(t,"uc",(function(){return m.uc})),n.d(t,"vc",(function(){return m.vc})),n.d(t,"sc",(function(){return m.sc})),n.d(t,"yc",(function(){return m.yc})),n.d(t,"Ac",(function(){return m.Ac})),n.d(t,"Bc",(function(){return m.Bc})),n.d(t,"Cc",(function(){return m.Cc})),n.d(t,"Dc",(function(){return m.Dc})),n.d(t,"Ec",(function(){return m.Ec})),n.d(t,"Fc",(function(){return m.Fc})),n.d(t,"Kc",(function(){return m.Kc})),n.d(t,"Ic",(function(){return m.Ic})),n.d(t,"Jc",(function(){return m.Jc})),n.d(t,"Hc",(function(){return m.Hc})),n.d(t,"Gc",(function(){return m.Gc})),n.d(t,"Mc",(function(){return m.Mc})),n.d(t,"Uc",(function(){return m.Uc})),n.d(t,"dd",(function(){return m.dd})),n.d(t,"Nc",(function(){return m.Nc})),n.d(t,"Tc",(function(){return m.Tc})),n.d(t,"Lc",(function(){return m.Lc})),n.d(t,"Oc",(function(){return m.Oc})),n.d(t,"Pc",(function(){return m.Pc})),n.d(t,"Qc",(function(){return m.Qc})),n.d(t,"Rc",(function(){return m.Rc})),n.d(t,"Sc",(function(){return m.Sc})),n.d(t,"Wc",(function(){return m.Wc})),n.d(t,"Vc",(function(){return m.Vc})),n.d(t,"Yc",(function(){return m.Yc})),n.d(t,"Zc",(function(){return m.Zc})),n.d(t,"ad",(function(){return m.ad})),n.d(t,"bd",(function(){return m.bd})),n.d(t,"cd",(function(){return m.cd})),n.d(t,"ed",(function(){return m.ed})),n.d(t,"fd",(function(){return m.fd})),n.d(t,"id",(function(){return m.id})),n.d(t,"jd",(function(){return m.jd})),n.d(t,"kd",(function(){return m.kd})),n.d(t,"ld",(function(){return m.ld})),n.d(t,"md",(function(){return m.md})),n.d(t,"nd",(function(){return m.nd})),n.d(t,"od",(function(){return m.od})),n.d(t,"pd",(function(){return m.pd})),n.d(t,"Xc",(function(){return m.Xc})),n.d(t,"kb",(function(){return m.kb})),n.d(t,"zc",(function(){return m.zc})),n.d(t,"qd",(function(){return m.qd})),n.d(t,"mb",(function(){return m.mb})),n.d(t,"nb",(function(){return m.nb}));var a=n(5),r=(n(127),n(19)),s=n(169),i=n(170),o=n(83);class c{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){window&&Object(r.b)().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))):setTimeout(e,t)}}if(Object(r.b)().get("IS_BROWSER")){Object(r.b)().setPlatform("browser",new c);try{o.a.registerManager(i.a.URL_SCHEME,new i.b)}catch(g){}try{o.a.registerManager(s.a.URL_SCHEME,new s.b)}catch(g){}}n(236);var l=n(43),u=n(11),d=n(62),h=n(135),p=n(6);Object(a.b)();const f={buffer:l.a,cast:u.a,clone:d.a,print:h.a};Object(p.f)(f);var m=n(132)},function(e,t,n){"use strict";n.d(t,"d",(function(){return r})),n.d(t,"e",(function(){return s})),n.d(t,"f",(function(){return i})),n.d(t,"b",(function(){return o})),n.d(t,"g",(function(){return l})),n.d(t,"c",(function(){return u})),n.d(t,"a",(function(){return d}));var a=n(0);function r(e,t,n,r,i){const o=t.inputParams[e];if(o&&void 0!==o.inputIndexStart){const e=o.inputIndexStart,c=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?e+1:o.inputIndexEnd;if("tensor"===o.type)return s(t.inputNames[o.inputIndexStart],n,r,i);if("tensors"===o.type){return t.inputNames.slice(e,c).map(e=>s(e,n,r,i))}const l=s(t.inputNames.slice(e)[0],n,r,i),u=l.dataSync();return"number"===o.type?u[0]:a.Df.toNestedArray(l.shape,u)}const c=t.attrParams[e];return c&&c.value}function s(e,t,n,a){const[r,s]=l(e);if(null!=a){const e=a.getHashTableHandleByName(r);if(null!=e)return e}const i=n.currentContextIds.find(e=>!!t[c(r,e)]);return void 0!==i?t[c(r,i)][s]:void 0}function i(e,t,n){return t[c(e,n.currentContextId)]}function o(e,t){const[n,a,r]=l(e);return[c(n,t&&t.currentContextId),a,r]}function c(e,t){return t?"".concat(e,"-").concat(t):e}function l(e){const t=e.split(":");if(1===t.length)return[e,0,void 0];const n=t[0],a=3===t.length?t[1]:void 0;return[n,Number(t[t.length-1]),a]}function u(e,t,n){let a=r("pad",e,t,n);if("explicit"===a){a=r("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=a[2*e],s[e][1]=a[2*e+1];return s}return a}function d(e){return e.kept?e:Object(a.Jd)(e)}},function(e,t,n){"use strict";n.d(t,"c",(function(){return c})),n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return d}));var a=n(5),r=n(19),s=n(6),i=n(9),o=n(10);function c(e,t){let n=e;if(Object(i.A)(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||Object(i.A)(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&Object(r.b)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function e(t,n,a){if(a=a||[],!Array.isArray(t)&&!Object(i.A)(t))return void Object(i.b)(0===n.length,()=>"Element arr[".concat(a.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(n[0]," elements"));Object(i.b)(n.length>0,()=>"Element arr[".concat(a.join("]["),"] should be a primitive, ")+"but is an array of ".concat(t.length," elements")),Object(i.b)(t.length===n[0],()=>"Element arr[".concat(a.join("]["),"] should have ").concat(n[0]," ")+"elements, but has ".concat(t.length," elements"));const r=n.slice(1);for(let s=0;s<t.length;++s)e(t[s],r,a.concat(s))}(e,a,[]),a}function l(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(a,"' must ")+"be ".concat(e," tensor, but got ").concat(t," tensor"))}}function u(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof s.a)return l(r,e.dtype,t,n),e;let u=Object(i.r)(e);if("string"!==u&&["bool","int32","float32"].indexOf(r)>=0&&(u=r),l(r,u,t,n),null==e||!Object(i.A)(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const a=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(a,"'"))}const d=c(e,u);Object(i.A)(e)||Array.isArray(e)||(e=[e]);const h=!0,p="string"!==u?Object(o.toTypedArray)(e,u):Object(i.m)(e,[],h);return a.a.makeTensor(p,d,u)}function d(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");const r=e;return r.map((e,r)=>u(e,"".concat(t,"[").concat(r,"]"),n,a))}},function(e,t,n){"use strict";n.d(t,"a",(function(){return a})),n.d(t,"b",(function(){return r})),n.d(t,"c",(function(){return s})),n.d(t,"d",(function(){return i})),n.d(t,"e",(function(){return o})),n.d(t,"f",(function(){return c})),n.d(t,"g",(function(){return l})),n.d(t,"h",(function(){return u})),n.d(t,"i",(function(){return d})),n.d(t,"j",(function(){return h})),n.d(t,"k",(function(){return p})),n.d(t,"l",(function(){return f})),n.d(t,"n",(function(){return m})),n.d(t,"m",(function(){return g})),n.d(t,"o",(function(){return b})),n.d(t,"r",(function(){return y})),n.d(t,"p",(function(){return v})),n.d(t,"q",(function(){return x})),n.d(t,"s",(function(){return w})),n.d(t,"t",(function(){return k})),n.d(t,"u",(function(){return I})),n.d(t,"w",(function(){return S})),n.d(t,"v",(function(){return N})),n.d(t,"x",(function(){return T})),n.d(t,"y",(function(){return O})),n.d(t,"z",(function(){return C})),n.d(t,"A",(function(){return E})),n.d(t,"B",(function(){return _})),n.d(t,"C",(function(){return A})),n.d(t,"D",(function(){return R})),n.d(t,"E",(function(){return D})),n.d(t,"F",(function(){return F})),n.d(t,"G",(function(){return M})),n.d(t,"H",(function(){return j})),n.d(t,"I",(function(){return z})),n.d(t,"J",(function(){return L})),n.d(t,"K",(function(){return P})),n.d(t,"M",(function(){return B})),n.d(t,"N",(function(){return W})),n.d(t,"L",(function(){return U})),n.d(t,"O",(function(){return V})),n.d(t,"P",(function(){return G})),n.d(t,"Q",(function(){return H})),n.d(t,"R",(function(){return q})),n.d(t,"S",(function(){return K})),n.d(t,"T",(function(){return X})),n.d(t,"U",(function(){return Z})),n.d(t,"W",(function(){return Y})),n.d(t,"V",(function(){return J})),n.d(t,"oc",(function(){return Q})),n.d(t,"X",(function(){return $})),n.d(t,"Y",(function(){return ee})),n.d(t,"Z",(function(){return te})),n.d(t,"bb",(function(){return ne})),n.d(t,"ab",(function(){return ae})),n.d(t,"cb",(function(){return re})),n.d(t,"db",(function(){return se})),n.d(t,"eb",(function(){return ie})),n.d(t,"fb",(function(){return oe})),n.d(t,"gb",(function(){return ce})),n.d(t,"hb",(function(){return le})),n.d(t,"ib",(function(){return ue})),n.d(t,"jb",(function(){return de})),n.d(t,"lb",(function(){return he})),n.d(t,"pb",(function(){return pe})),n.d(t,"ob",(function(){return fe})),n.d(t,"qb",(function(){return me})),n.d(t,"rb",(function(){return ge})),n.d(t,"tb",(function(){return be})),n.d(t,"sb",(function(){return ye})),n.d(t,"ub",(function(){return ve})),n.d(t,"vb",(function(){return xe})),n.d(t,"wb",(function(){return we})),n.d(t,"xb",(function(){return ke})),n.d(t,"Ab",(function(){return Ie})),n.d(t,"Bb",(function(){return Se})),n.d(t,"Cb",(function(){return Ne})),n.d(t,"Db",(function(){return Te})),n.d(t,"Eb",(function(){return Oe})),n.d(t,"Fb",(function(){return Ce})),n.d(t,"Hb",(function(){return Ee})),n.d(t,"Ib",(function(){return _e})),n.d(t,"Jb",(function(){return Ae})),n.d(t,"Gb",(function(){return Re})),n.d(t,"yb",(function(){return De})),n.d(t,"zb",(function(){return Fe})),n.d(t,"Kb",(function(){return Me})),n.d(t,"Qb",(function(){return je})),n.d(t,"Lb",(function(){return ze})),n.d(t,"Ob",(function(){return Le})),n.d(t,"Mb",(function(){return Pe})),n.d(t,"Nb",(function(){return Be})),n.d(t,"Pb",(function(){return We})),n.d(t,"Rb",(function(){return Ue})),n.d(t,"Sb",(function(){return Ve})),n.d(t,"Tb",(function(){return Ge})),n.d(t,"Ub",(function(){return He})),n.d(t,"Vb",(function(){return qe})),n.d(t,"Wb",(function(){return Ke})),n.d(t,"Xb",(function(){return Xe})),n.d(t,"Yb",(function(){return Ze})),n.d(t,"cc",(function(){return Ye})),n.d(t,"Zb",(function(){return Je})),n.d(t,"ac",(function(){return Qe})),n.d(t,"bc",(function(){return $e})),n.d(t,"ec",(function(){return et})),n.d(t,"dc",(function(){return tt})),n.d(t,"fc",(function(){return nt})),n.d(t,"gc",(function(){return at})),n.d(t,"hc",(function(){return rt})),n.d(t,"ic",(function(){return st})),n.d(t,"jc",(function(){return it})),n.d(t,"kc",(function(){return ot})),n.d(t,"lc",(function(){return ct})),n.d(t,"mc",(function(){return lt})),n.d(t,"nc",(function(){return ut})),n.d(t,"pc",(function(){return dt})),n.d(t,"qc",(function(){return ht})),n.d(t,"sc",(function(){return pt})),n.d(t,"vc",(function(){return ft})),n.d(t,"wc",(function(){return mt})),n.d(t,"tc",(function(){return gt})),n.d(t,"uc",(function(){return bt})),n.d(t,"rc",(function(){return yt})),n.d(t,"xc",(function(){return vt})),n.d(t,"zc",(function(){return xt})),n.d(t,"Ac",(function(){return wt})),n.d(t,"Bc",(function(){return kt})),n.d(t,"Cc",(function(){return It})),n.d(t,"Dc",(function(){return St})),n.d(t,"Ec",(function(){return Nt})),n.d(t,"Jc",(function(){return Tt})),n.d(t,"Hc",(function(){return Ot})),n.d(t,"Ic",(function(){return Ct})),n.d(t,"Gc",(function(){return Et})),n.d(t,"Fc",(function(){return _t})),n.d(t,"Lc",(function(){return At})),n.d(t,"Tc",(function(){return Rt})),n.d(t,"cd",(function(){return Dt})),n.d(t,"Mc",(function(){return Ft})),n.d(t,"Sc",(function(){return Mt})),n.d(t,"Kc",(function(){return jt})),n.d(t,"Nc",(function(){return zt})),n.d(t,"Oc",(function(){return Lt})),n.d(t,"Pc",(function(){return Pt})),n.d(t,"Qc",(function(){return Bt})),n.d(t,"Rc",(function(){return Wt})),n.d(t,"Vc",(function(){return Ut})),n.d(t,"Uc",(function(){return Vt})),n.d(t,"Xc",(function(){return Gt})),n.d(t,"Yc",(function(){return Ht})),n.d(t,"Zc",(function(){return qt})),n.d(t,"ad",(function(){return Kt})),n.d(t,"bd",(function(){return Xt})),n.d(t,"dd",(function(){return Zt})),n.d(t,"ed",(function(){return Yt})),n.d(t,"fd",(function(){return Jt})),n.d(t,"gd",(function(){return Qt})),n.d(t,"hd",(function(){return $t})),n.d(t,"id",(function(){return en})),n.d(t,"jd",(function(){return tn})),n.d(t,"kd",(function(){return nn})),n.d(t,"ld",(function(){return an})),n.d(t,"md",(function(){return rn})),n.d(t,"Wc",(function(){return sn})),n.d(t,"kb",(function(){return on})),n.d(t,"yc",(function(){return cn})),n.d(t,"nd",(function(){return ln})),n.d(t,"mb",(function(){return un})),n.d(t,"nb",(function(){return dn}));const a="Abs",r="Acos",s="Acosh",i="Add",o="AddN",c="All",l="Any",u="ArgMax",d="ArgMin",h="Asin",p="Asinh",f="Atan",m="Atanh",g="Atan2",b="AvgPool",y="AvgPoolGrad",v="AvgPool3D",x="AvgPool3DGrad",w="BatchMatMul",k="BatchToSpaceND",I="Bincount",S="BroadcastTo",N="BroadcastArgs",T="Cast",O="Ceil",C="ClipByValue",E="Complex",_="ComplexAbs",A="Concat",R="Conv2D",D="Conv2DBackpropFilter",F="Conv2DBackpropInput",M="Conv3D",j="Conv3DBackpropFilterV2",z="Conv3DBackpropInputV2",L="Cos",P="Cosh",B="Cumprod",W="Cumsum",U="CropAndResize",V="DenseBincount",G="DepthToSpace",H="DepthwiseConv2dNative",q="DepthwiseConv2dNativeBackpropFilter",K="DepthwiseConv2dNativeBackpropInput",X="Diag",Z="Dilation2D",Y="Dilation2DBackpropInput",J="Dilation2DBackpropFilter",Q="RealDiv",$="Einsum",ee="Elu",te="EluGrad",ne="Erf",ae="Equal",re="Exp",se="ExpandDims",ie="Expm1",oe="FFT",ce="Fill",le="FlipLeftRight",ue="Floor",de="FloorDiv",he="FusedBatchNorm",pe="GatherV2",fe="GatherNd",me="Greater",ge="GreaterEqual",be="Identity",ye="IFFT",ve="Imag",xe="IsFinite",we="IsInf",ke="IsNan",Ie="LeakyRelu",Se="Less",Ne="LessEqual",Te="LinSpace",Oe="Log",Ce="Log1p",Ee="LogicalAnd",_e="LogicalNot",Ae="LogicalOr",Re="LogSoftmax",De="LRN",Fe="LRNGrad",Me="Max",je="Maximum",ze="MaxPool",Le="MaxPoolGrad",Pe="MaxPool3D",Be="MaxPool3DGrad",We="MaxPoolWithArgmax",Ue="Mean",Ve="Min",Ge="Minimum",He="MirrorPad",qe="Mod",Ke="Multinomial",Xe="Multiply",Ze="Neg",Ye="NotEqual",Je="NonMaxSuppressionV3",Qe="NonMaxSuppressionV4",$e="NonMaxSuppressionV5",et="OnesLike",tt="OneHot",nt="Pack",at="PadV2",rt="Pow",st="Prelu",it="Prod",ot="RaggedGather",ct="RaggedTensorToTensor",lt="Range",ut="Real",dt="Reciprocal",ht="Relu",pt="Reshape",ft="ResizeNearestNeighbor",mt="ResizeNearestNeighborGrad",gt="ResizeBilinear",bt="ResizeBilinearGrad",yt="Relu6",vt="Reverse",xt="Round",wt="Rsqrt",kt="ScatterNd",It="SearchSorted",St="Select",Nt="Selu",Tt="Slice",Ot="Sin",Ct="Sinh",Et="Sign",_t="Sigmoid",At="Softplus",Rt="Sqrt",Dt="Sum",Ft="SpaceToBatchND",Mt="SplitV",jt="Softmax",zt="SparseFillEmptyRows",Lt="SparseReshape",Pt="SparseSegmentMean",Bt="SparseSegmentSum",Wt="SparseToDense",Ut="SquaredDifference",Vt="Square",Gt="StridedSlice",Ht="StringNGrams",qt="StringSplit",Kt="StringToHashBucketFast",Xt="Sub",Zt="Tan",Yt="Tanh",Jt="Tile",Qt="TopK",$t="Transform",en="Transpose",tn="Unique",nn="Unpack",an="UnsortedSegmentSum",rn="ZerosLike",sn="Step",on="FromPixels",cn="RotateWithOffset",ln="_FusedMatMul",un="FusedConv2D",dn="FusedDepthwiseConv2D"},function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return i}));var a=n(5),r=n(9);const s="__op";function i(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(t.length," keys."));let n=t[0];const i=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=s;const o=function(){a.a.startScope(n);try{const e=i(...arguments);return Object(r.x)(e)&&console.error("Cannot return a Promise inside of tidy."),a.a.endScope(e),e}catch(e){throw a.a.endScope(null),e}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}},function(e,t,n){"use strict";n.d(t,"b",(function(){return v})),n.d(t,"a",(function(){return x}));var a=n(129),r=n(19),s=n(99),i=n(3),o=n(56),c=n(68),l=n(10),u=n(9);class d{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new p)}profileKernel(e,t,n){let a;const s=()=>{a=n()};let i;const o=l.now();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(const e of a)e.dataSync();i=Promise.resolve({kernelMs:l.now()-o})}if(Object(r.b)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let r=0;r<a.length;r++){const t=a[r];t.data().then(n=>{h(n,t.dtype,e)})}return{kernelName:e,outputs:a,inputs:t,timeMs:i.then(e=>e.kernelMs),extraInfo:i.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:s}=e;n.forEach(e=>{Promise.all([e.data(),a,s]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])})})}}function h(e,t,n){if("float32"!==t)return!1;for(let a=0;a<e.length;a++){const t=e[a];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}class p{logKernelProfile(e,t,n,a,r,s){const i="number"===typeof a?u.L("".concat(a,"ms"),9):a.error,o=u.L(e,25),c=t.rank,l=t.size,d=u.L(t.shape.toString(),14);let h="";for(const u in r){const e=r[u];if(null!=e){const n=e.shape||t.shape,a=n.length;h+="".concat(u,": ").concat(a,"D ").concat(a>0?n:""," ")}}console.log("%c".concat(o,"\t%c").concat(i,"\t%c").concat(c,"D ").concat(d,"\t%c").concat(l,"\t%c").concat(h,"\t%c").concat(s),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var f=n(6),m=n(21);function g(e){return null!=e.kernelName}class b{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class y{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new b}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(c.b("".concat(e," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new d(this.backendInstance),!0}setupRegisteredKernels(){Object(o.c)(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Object(o.c)(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{const n=t.factory();if(!n||n instanceof a.b||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,a=n.then(n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0)).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,c.b("Initialization of backend ".concat(e," failed")),c.b(n.stack||n.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(n){return c.b("Initialization of backend ".concat(e," failed")),c.b(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:a,asyncInit:r}=this.initializeBackend(n);if(r||a)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),a=n.backend,r=this.readSync(t),s=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun(()=>this.startScope(a),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(a){throw t(),a}}nextTensorId(){return y.nextTensorId++}nextVariableId(){return y.nextVariableId++}clone(e){const t=x.runKernel(i.tb,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],e=>({x:()=>{const t={x:e},n={dtype:"float32"};return x.runKernel(i.x,t,n)}}),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=Object(o.b)(e,this.backendName)))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const a=this.backend.numDataIds();let r=0;n.forEach(e=>{r+="complex64"===e.dtype?3:1});const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=a-t-r-s;if(i>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(i," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n=[];const a=this.isTapeOn(),r=this.state.numBytes,s=this.state.numTensors;let i,c;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=g(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(g(e)){const{kernelName:t,inputs:r,attrs:s}=e;null==this.backendName&&this.backend;const l=Object(o.b)(t,this.backendName);u.b(null!=l,()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'")),i=()=>{const e=this.backend.numDataIds();c=l.kernelFunc({inputs:r,attrs:s,backend:this.backend});const i=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const o=i.map(e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e));if(a){const e=this.getTensorsForGradient(t,r,o);n=this.saveTensorsForBackwardMode(e)}return o}}else{const{forwardFunc:t}=e,r=e=>{a&&(n=e.map(e=>this.keep(this.clone(e))))};i=()=>{const e=this.backend.numDataIds();c=this.tidy(()=>t(this.backend,r));const n=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:d,attrs:h}=e,p=g(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(l,d,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs):t=i()}),a&&this.addTapeNode(l,d,t,p,n,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(e=>null!=d[e]?d[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(c)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,n){const a=Object(o.a)(e);if(null!=a){const e=a.inputsToSave||[],r=a.outputsToSave||[];let s;a.saveAllInputs?(u.b(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),s=Object.keys(t).map(e=>t[e])):s=e.map(e=>t[e]);const i=n.filter((e,t)=>r[t]);return s.concat(i)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let r=e;"string"===n&&u.z(e[0])&&(r=e.map(e=>l.encodeString(e)));const s=a.write(r,t,n),i=new f.a(t,n,s,this.nextTensorId());if(this.trackTensor(i,a),"string"===n){const e=this.state.tensorInfo.get(s),t=Object(u.f)(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,a){const r={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(r,a)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:a,dtype:r}=e,s=new f.a(a,r,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const r=new f.c(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error("Variable with name ".concat(r.name," was already registered"));return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*u.g(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof f.c||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*u.g(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,r,s){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},c=Object(o.a)(e);null!=c&&(a=c.gradFunc),null!=a&&(i.gradient=e=>(e=e.map((e,t)=>{if(null==e){const e=n[t],a=u.F(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e}),a(e.length>1?e:e[0],r,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Object(m.getTensorsInContainer)(e),n=new Set(t.map(e=>e.id));for(let r=0;r<this.state.activeScope.track.length;r++){const e=this.state.activeScope.track[r];e.kept||n.has(e.id)||e.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==a.id||this.track(e)})}gradients(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(u.b(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));u.b(r instanceof f.a,()=>"The result y returned by f() must be a tensor.");const s=function(e,t,n){const a={},r={};for(let c=0;c<t.length;c++)a[t[c].id]=!0;for(let c=0;c<e.length;c++){const n=e[c],s=n.inputs;for(const e in s){const i=s[e];let o=!1;for(let e=0;e<t.length;e++)if(a[i.id]){n.outputs.forEach(e=>a[e.id]=!0),o=!0,r[n.id]=!0;break}if(o)break}}const s={};s[n.id]=!0;const i={};for(let c=e.length-1;c>=0;c--){const t=e[c],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(const e in n)s[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let c=0;c<e.length;c++){const t=e[c];if(r[t.id]&&i[t.id]){const e={};for(const r in t.inputs){const n=t.inputs[r];a[n.id]&&(e[r]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,r);if(!a&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[r.id]=null==n?function(e){const t=Object(u.D)(Object(u.O)(e),"float32");return x.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,a){for(let r=t.length-1;r>=0;r--){const s=t[r],i=[];if(s.outputs.forEach(t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)}),null==s.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(s.kernelName,"."));const o=s.gradient(i);for(const t in s.inputs){if(!(t in o))throw new Error("Cannot backprop through input ".concat(t,". ")+"Available gradients found: ".concat(Object.keys(o),"."));const r=n(()=>o[t]());if("float32"!==r.dtype)throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"".concat(t," must have 'float32' dtype, but has '").concat(r.dtype,"'"));const i=s.inputs[t];if(!u.a(r.shape,i.shape))throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"'".concat(t,"' has shape '").concat(r.shape,"', which does not match ")+"the shape of the input '".concat(i.shape,"'"));if(null==e[i.id])e[i.id]=r;else{const t=e[i.id];e[i.id]=a(t,r),t.dispose()}}}}(e,s,e=>this.tidy(e),w);const a=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:r,grads:a}})}customGrad(e){var t=this;return u.b(u.u(e),()=>"The f passed in customGrad(f) must be a function."),function(){for(var n=arguments.length,a=new Array(n),r=0;r<n;r++)a[r]=arguments[r];let s;u.b(a.every(e=>e instanceof f.a),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const i={};a.forEach((e,t)=>{i[t]=e});const o=(t,n)=>(s=e(...a,n),u.b(s.value instanceof f.a,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),u.b(u.u(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),c=(e,t)=>{const n=s.gradFunc(e,t),r=Array.isArray(n)?n:[n];u.b(r.length===a.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),u.b(r.every(e=>e instanceof f.a),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const i={};return r.forEach((e,t)=>{i[t]=()=>e}),i};return t.runKernelFunc({forwardFunc:o,backwardsFunc:c,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Object(l.now)(),n=await this.backend.time(e);return n.wallMs=Object(l.now)()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new b;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function v(){const e=Object(s.b)();if(null==e._tfengine){const t=new r.a(e);e._tfengine=new y(t)}return Object(r.c)(e._tfengine.ENV),Object(f.g)(()=>e._tfengine),e._tfengine}y.nextTensorId=0,y.nextVariableId=0;const x=v();function w(e,t){const n={a:e,b:t};return x.runKernel(i.d,n)}},function(e,t,n){"use strict";n.d(t,"b",(function(){return u})),n.d(t,"g",(function(){return f})),n.d(t,"f",(function(){return m})),n.d(t,"e",(function(){return g})),n.d(t,"a",(function(){return b})),n.d(t,"d",(function(){return y})),n.d(t,"c",(function(){return v}));var a=n(99),r=n(9);function s(e,t,n,a){const s=Object(r.j)(t),l=function(e,t,n,a){const s=Object(r.O)(t),o=a[a.length-1],l=new Array(o).fill(0),u=t.length,d="complex64"===n?c(e):e;if(u>1)for(let r=0;r<s/o;r++){const e=r*o;for(let t=0;t<o;t++)l[t]=Math.max(l[t],i(d[e+t],0,n).length)}return l}(e,t,n,s),u=t.length,d=function e(t,n,a,r,s){let l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const u="complex64"===a?2:1,d=n[0],h=n.length;if(0===h){if("complex64"===a){return[i(c(t)[0],0,a)]}return"bool"===a?[o(t[0])]:[t[0].toString()]}if(1===h){if(d>20){const e=3*u;let n=Array.from(t.slice(0,e)),r=Array.from(t.slice((d-3)*u,d*u));return"complex64"===a&&(n=c(n),r=c(r)),["["+n.map((e,t)=>i(e,s[t],a)).join(", ")+", ..., "+r.map((e,t)=>i(e,s[d-3+t],a)).join(", ")+"]"]}return["["+("complex64"===a?c(t):Array.from(t)).map((e,t)=>i(e,s[t],a)).join(", ")+"]"]}const p=n.slice(1),f=r.slice(1),m=r[0]*u,g=[];if(d>20){for(let n=0;n<3;n++){const r=n*m,i=r+m;g.push(...e(t.slice(r,i),p,a,f,s,!1))}g.push("...");for(let n=d-3;n<d;n++){const r=n*m,i=r+m;g.push(...e(t.slice(r,i),p,a,f,s,n===d-1))}}else for(let i=0;i<d;i++){const n=i*m,r=n+m;g.push(...e(t.slice(n,r),p,a,f,s,i===d-1))}const b=2===h?",":"";g[0]="["+g[0]+b;for(let i=1;i<g.length-1;i++)g[i]=" "+g[i]+b;let y=",\n";for(let i=2;i<h;i++)y+="\n";return g[g.length-1]=" "+g[g.length-1]+"]"+(l?"":y),g}(e,t,n,s,l),h=["Tensor"];return a&&(h.push("  dtype: ".concat(n)),h.push("  rank: ".concat(u)),h.push("  shape: [".concat(t,"]")),h.push("  values:")),h.push(d.map(e=>"    "+e).join("\n")),h.join("\n")}function i(e,t,n){let a;return a=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(7))," + ")+"".concat(parseFloat(e[1].toFixed(7)),"j"):Object(r.z)(e)?"'".concat(e,"'"):"bool"===n?o(e):parseFloat(e.toFixed(7)).toString(),Object(r.L)(a,t)}function o(e){return 0===e?"false":"true"}function c(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var l=n(10);class u{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=r.O(e),null!=n){const e=n.length;r.b(e===this.size,()=>"Length of values '".concat(e,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'."))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||r.n(t,this.size),this.strides=Object(r.j)(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];0===n.length&&(n=[0]),r.b(n.length===this.rank,()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")"));const s=this.locToIndex(n);this.values[s]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let a=0;for(const s of t){if(s<0||s>=this.shape[a]){const e="Requested out of range element at ".concat(t,". ")+"  Buffer shape=".concat(this.shape);throw new Error(e)}a++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return d().makeTensor(this.values,this.shape,this.dtype)}}let d=null,h=null,p=null;function f(e){d=e}function m(e){h=e}function g(e){p=e}class b{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=r.O(e),this.strides=Object(r.j)(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return h.buffer(this.shape,this.dtype,e)}bufferSync(){return h.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Object(r.U)(this.shape,e,"complex64"===this.dtype)}arraySync(){return Object(r.U)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=d().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map(e=>l.decodeString(e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),d().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=d().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>l.decodeString(e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await d().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(d().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return h.print(this,e)}clone(){return this.throwIfDisposed(),h.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return s(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),h.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),d().makeVariable(this,e,t,n)}}function y(){return Object(a.a)("Tensor",()=>b)}Object.defineProperty(b,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),y();class v extends b{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!r.a(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and ")+"previous value (".concat(this.shape,") must match"));d().disposeTensor(this),this.dataId=e.dataId,d().incRef(this,null)}dispose(){d().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(v,Symbol.hasInstance,{value:e=>e instanceof b&&null!=e.assign&&e.assign instanceof Function})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({reshape_:function(e,t){const n={x:Object(s.a)(e,"x","reshape","string_or_numeric")},i={shape:t};return a.a.runKernel(r.sc,n,i)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(4);const c=Object(o.b)({mul_:function(e,t){let n=Object(i.a)(e,"a","mul"),o=Object(i.a)(t,"b","mul");[n,o]=Object(s.makeTypesMatch)(n,o);const c={a:n,b:o};return a.a.runKernel(r.Xb,c)}})},function(e,t,n){"use strict";function a(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,o(e,t,n)}function r(e,t){if(e.length!==t.length)throw new Error("Array sizes must match to be shuffled together "+"First array length was ".concat(e.length)+"Second array length was ".concat(t.length));let n=e.length,a=0;for(;n>0;)a=Math.random()*n|0,n--,o(e,n,a),o(t,n,a)}function s(e,t,n){return Math.max(e,Math.min(t,n))}function i(e){return e%2===0?e:e+1}function o(e,t,n){const a=e[t];e[t]=e[n],e[n]=a}function c(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function l(e,t){const n=Math.random();return t*n+(1-n)*e}function u(e,t){let n=0;for(let a=0;a<e.length;a++){const r=Number(e[a])-Number(t[a]);n+=r*r}return n}function d(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function h(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";d(b(e,t),()=>n+" Shapes ".concat(e," and ").concat(t," must match"))}function p(e){d(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function f(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),Array.isArray(e)||R(e)&&!n)for(let a=0;a<e.length;++a)f(e[a],t,n);else t.push(e);return t}function m(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function g(e){return 0===e.length}function b(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function y(e){return e%1===0}function v(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function x(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function w(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return a(t),t}function k(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function I(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:setTimeout;return new Promise((r,s)=>{let i=0;const o=()=>{if(e())return void r();i++;const c=t(i);null!=n&&i>=n?s():a(o,c)};o()})}function S(e,t){let n=1,a=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==a)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(a," and dim ").concat(s));a=s}else if(e[s]<0)throw Error("Shapes can not be < 0. Found ".concat(e[s]," at dim ").concat(s));if(-1===a){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when ")+"there are 0 elements");if(t%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(t," / ").concat(n));const r=e.slice();return r[a]=t/n,r}function N(e,t){const n=t.length;return d((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(e)),d(e.every(e=>y(e)),()=>"All values in axis param must be integers but "+"got axis ".concat(e)),e.map(e=>e<0?n+e:e)}function T(e,t){const n=[],a=[],r=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||r?null:N(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=s){if(s[i]===o&&1!==e[o])throw new Error("Can't squeeze axis ".concat(o," since its dim '").concat(e[o],"' is not 1"));(null==s[i]||s[i]>o)&&1===e[o]&&(n.push(e[o]),a.push(o)),s[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),a.push(o))}return{newShape:n,keptDims:a}}function O(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error("Unknown data type ".concat(e));n=new Uint8Array(t)}return n}function C(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function E(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(a,"."))}}function _(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function A(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function R(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function D(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function F(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}function M(e){return"string"===typeof e||e instanceof String}function j(e){return"boolean"===typeof e}function z(e){return"number"===typeof e}function L(e){return Array.isArray(e)?L(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":z(e)?"float32":M(e)?"string":j(e)?"bool":"float32"}function P(e){return!!(e&&e.constructor&&e.call&&e.apply)}function B(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function W(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function U(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=new Array;if(1===t.length){const s=t[0]*(a?2:1);for(let t=0;t<s;t++)r[t]=n[e+t]}else{const s=t[0],i=t.slice(1),o=i.reduce((e,t)=>e*t)*(a?2:1);for(let t=0;t<s;t++)r[t]=U(e+t*o,i,n,a)}return r}function V(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const a=e.reduce((e,t)=>e*t)*(n?2:1);if(0===a)return[];if(a!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return U(0,e,t,n)}function G(e,t){const n=H(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function H(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function q(e,t){const n=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return V(e,new Float32Array(n));if("int32"===t)return V(e,new Int32Array(n));if("bool"===t)return V(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function K(e){e.forEach(t=>{d(Number.isInteger(t)&&t>=0,()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(e,"]."))})}function X(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function Z(e,t,n){if(0===t)return[];if(1===t)return[e];const a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function Y(e){return e&&e.then&&"function"===typeof e.then}n.d(t,"M",(function(){return a})),n.d(t,"N",(function(){return r})),n.d(t,"i",(function(){return s})),n.d(t,"H",(function(){return i})),n.d(t,"S",(function(){return o})),n.d(t,"R",(function(){return c})),n.d(t,"J",(function(){return l})),n.d(t,"l",(function(){return u})),n.d(t,"b",(function(){return d})),n.d(t,"e",(function(){return h})),n.d(t,"d",(function(){return p})),n.d(t,"m",(function(){return f})),n.d(t,"O",(function(){return m})),n.d(t,"y",(function(){return g})),n.d(t,"a",(function(){return b})),n.d(t,"v",(function(){return y})),n.d(t,"T",(function(){return v})),n.d(t,"P",(function(){return x})),n.d(t,"k",(function(){return w})),n.d(t,"L",(function(){return k})),n.d(t,"K",(function(){return I})),n.d(t,"s",(function(){return S})),n.d(t,"I",(function(){return N})),n.d(t,"Q",(function(){return T})),n.d(t,"o",(function(){return O})),n.d(t,"n",(function(){return C})),n.d(t,"h",(function(){return E})),n.d(t,"B",(function(){return _})),n.d(t,"p",(function(){return A})),n.d(t,"A",(function(){return R})),n.d(t,"g",(function(){return D})),n.d(t,"f",(function(){return F})),n.d(t,"z",(function(){return M})),n.d(t,"t",(function(){return j})),n.d(t,"w",(function(){return z})),n.d(t,"r",(function(){return L})),n.d(t,"u",(function(){return P})),n.d(t,"G",(function(){return B})),n.d(t,"j",(function(){return W})),n.d(t,"U",(function(){return V})),n.d(t,"D",(function(){return G})),n.d(t,"F",(function(){return H})),n.d(t,"E",(function(){return q})),n.d(t,"c",(function(){return K})),n.d(t,"C",(function(){return X})),n.d(t,"q",(function(){return Z})),n.d(t,"x",(function(){return Y}))},function(e,t,n){"use strict";n.r(t),n.d(t,"shuffle",(function(){return r.M})),n.d(t,"shuffleCombo",(function(){return r.N})),n.d(t,"clamp",(function(){return r.i})),n.d(t,"nearestLargerEven",(function(){return r.H})),n.d(t,"swap",(function(){return r.S})),n.d(t,"sum",(function(){return r.R})),n.d(t,"randUniform",(function(){return r.J})),n.d(t,"distSquared",(function(){return r.l})),n.d(t,"assert",(function(){return r.b})),n.d(t,"assertShapesMatch",(function(){return r.e})),n.d(t,"assertNonNull",(function(){return r.d})),n.d(t,"flatten",(function(){return r.m})),n.d(t,"sizeFromShape",(function(){return r.O})),n.d(t,"isScalarShape",(function(){return r.y})),n.d(t,"arraysEqual",(function(){return r.a})),n.d(t,"isInt",(function(){return r.v})),n.d(t,"tanh",(function(){return r.T})),n.d(t,"sizeToSquarishShape",(function(){return r.P})),n.d(t,"createShuffledIndices",(function(){return r.k})),n.d(t,"rightPad",(function(){return r.L})),n.d(t,"repeatedTry",(function(){return r.K})),n.d(t,"inferFromImplicitShape",(function(){return r.s})),n.d(t,"parseAxisParam",(function(){return r.I})),n.d(t,"squeezeShape",(function(){return r.Q})),n.d(t,"getTypedArrayFromDType",(function(){return r.o})),n.d(t,"getArrayFromDType",(function(){return r.n})),n.d(t,"checkConversionForErrors",(function(){return r.h})),n.d(t,"isValidDtype",(function(){return r.B})),n.d(t,"hasEncodingLoss",(function(){return r.p})),n.d(t,"isTypedArray",(function(){return r.A})),n.d(t,"bytesPerElement",(function(){return r.g})),n.d(t,"bytesFromStringArray",(function(){return r.f})),n.d(t,"isString",(function(){return r.z})),n.d(t,"isBoolean",(function(){return r.t})),n.d(t,"isNumber",(function(){return r.w})),n.d(t,"inferDtype",(function(){return r.r})),n.d(t,"isFunction",(function(){return r.u})),n.d(t,"nearestDivisor",(function(){return r.G})),n.d(t,"computeStrides",(function(){return r.j})),n.d(t,"toNestedArray",(function(){return r.U})),n.d(t,"makeOnesTypedArray",(function(){return r.D})),n.d(t,"makeZerosTypedArray",(function(){return r.F})),n.d(t,"makeZerosNestedTypedArray",(function(){return r.E})),n.d(t,"assertNonNegativeIntegerDimensions",(function(){return r.c})),n.d(t,"locToIndex",(function(){return r.C})),n.d(t,"indexToLoc",(function(){return r.q})),n.d(t,"isPromise",(function(){return r.x})),n.d(t,"hexToLong",(function(){return o})),n.d(t,"fingerPrint64",(function(){return w})),n.d(t,"createScalarValue",(function(){return k})),n.d(t,"toTypedArray",(function(){return I})),n.d(t,"now",(function(){return S})),n.d(t,"fetch",(function(){return N})),n.d(t,"encodeString",(function(){return T})),n.d(t,"decodeString",(function(){return O}));var a=n(19),r=n(9),s=n(177);const i=n.n(s).a||s;function o(e){return i.fromString(e,!0,16)}const c=o("c3a5c85c97cb3127"),l=o("b492b66fbe98f273"),u=o("9ae16a3b2f90404f");function d(e){return e.xor(e.shru(47))}function h(e,t,n){const a=e.slice(t,t+n);return i.fromBytes(Array.from(a),!0,!0)}function p(e,t){return h(e,t,8)}function f(e,t){return h(e,t,4)}function m(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function g(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:o("9ddfea08eb382d69"),a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function b(e,t,n,a){return function(e,t,n,a,r,s){r=r.add(e),s=m(s.add(r).add(a),21);const i=r;return r=(r=r.add(t)).add(n),s=s.add(m(r,44)),[r.add(a),s.add(i)]}(p(e,t),p(e,t+8),p(e,t+16),p(e,t+24),n,a)}function y(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=u.add(2*t),a=p(e,0).add(u),r=p(e,t-8);return g(m(r,37).mul(n).add(a),m(a,25).add(r).mul(n),n)}if(t>=4){const n=u.add(2*t);return g(f(e,0).shl(3).add(t),f(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),a=t+(e[t-1]<<2);return d(u.mul(n).xor(c.mul(a))).mul(u)}return u}function v(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=u.add(2*t),a=p(e,0).mul(l),r=p(e,8),s=p(e,t-8).mul(n),i=p(e,t-16).mul(u);return g(m(a.add(r),43).add(m(s,30)).add(i),a.add(m(r.add(u),18)).add(s),n)}function x(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=u.add(2*t),a=p(e,0).mul(u),r=p(e,8),s=p(e,t-8).mul(n),i=p(e,t-16).mul(u),o=m(a.add(r),43).add(m(s,30)).add(i),c=g(o,a.add(m(r.add(u),18)).add(s),n),l=p(e,16).mul(n),d=p(e,24),h=o.add(p(e,t-32)).mul(n),f=c.add(p(e,t-24)).mul(n);return g(m(l.add(d),43).add(m(h,30)).add(f),l.add(m(d.add(a),18)).add(h),n)}function w(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=i.fromNumber(81,!0);if(t<=32)return t<=16?y(e,t):v(e,t);if(t<=64)return x(e,t);let a=n,r=n.mul(l).add(113),s=d(r.mul(u).add(113)).mul(u),o=[i.UZERO,i.UZERO],h=[i.UZERO,i.UZERO];a=a.mul(u).add(p(e,0));let f=0;const w=64*(t-1>>6),k=w+(t-1&63)-63;do{a=m(a.add(r).add(o[0]).add(p(e,f+8)),37).mul(l),r=m(r.add(o[1]).add(p(e,f+48)),42).mul(l),a=a.xor(h[1]),r=r.add(o[0]).add(p(e,f+40)),s=m(s.add(h[0]),33).mul(l),o=b(e,f,o[1].mul(l),a.add(h[0])),h=b(e,f+32,s.add(h[1]),r.add(p(e,f+16))),[s,a]=[a,s],f+=64}while(f!==w);const I=l.add(s.and(255).shl(1));return f=k,h[0]=h[0].add(t-1&63),o[0]=o[0].add(h[0]),h[0]=h[0].add(o[0]),a=m(a.add(r).add(o[0]).add(p(e,f+8)),37).mul(I),r=m(r.add(o[1]).add(p(e,f+48)),42).mul(I),a=a.xor(h[1].mul(9)),r=r.add(o[0].mul(9).add(p(e,f+40))),s=m(s.add(h[0]),33).mul(I),o=b(e,f,o[1].mul(I),a.add(h[0])),h=b(e,f+32,s.add(h[1]),r.add(p(e,f+16))),[s,a]=[a,s],g(g(o[0],h[0],I).add(d(r).mul(c)).add(s),g(o[1],h[1],I).add(a),I)}function k(e,t){return"string"===t?T(e):I([e],t)}function I(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=r.m(e)),Object(a.b)().getBool("DEBUG")&&r.h(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function S(){return Object(a.b)().platform.now()}function N(e,t){return Object(a.b)().platform.fetch(e,t)}function T(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",Object(a.b)().platform.encode(e,t)}function O(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",Object(a.b)().platform.decode(e,t)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4);const c=Object(o.b)({cast_:function(e,t){const n=Object(s.a)(e,"x","cast");if(!i.B(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const o={x:n},c={dtype:t};return a.a.runKernel(r.x,o,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(4);const c=Object(o.b)({add_:function(e,t){let n=Object(i.a)(e,"a","add"),o=Object(i.a)(t,"b","add");[n,o]=Object(s.makeTypesMatch)(n,o);const c={a:n,b:o};return a.a.runKernel(r.d,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(4);const c=Object(o.b)({sub_:function(e,t){let n=Object(i.a)(e,"a","sub"),o=Object(i.a)(t,"b","sub");[n,o]=Object(s.makeTypesMatch)(n,o);const c={a:n,b:o};return a.a.runKernel(r.bd,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(108),c=n(4);const l=Object(c.b)({div_:function(e,t){let n=Object(i.a)(e,"a","div"),c=Object(i.a)(t,"b","div");if([n,c]=Object(s.makeTypesMatch)(n,c),"int32"===n.dtype&&"int32"===c.dtype)return Object(o.a)(n,c);const l={a:n,b:c};return a.a.runKernel(r.oc,l,{})}})},function(e,t,n){"use strict";function a(e,t){const n=e.length,a=[];for(let r=0;r<n;r++){const s=n-1-r,i=e[s]||1;(t[t.length-1-r]||1)>1&&1===i&&a.unshift(s)}return a}function r(e,t){const n=[];for(let a=0;a<t.length;a++){const r=e[e.length-a-1],s=t.length-a-1,i=t[s];(null==r||1===r&&i>1)&&n.unshift(s)}return n}function s(e,t){const n=[],a=Math.max(e.length,t.length);for(let r=0;r<a;r++){let a=e[e.length-r-1];null==a&&(a=1);let s=t[t.length-r-1];if(null==s&&(s=1),1===a)n.unshift(s);else if(1===s)n.unshift(a);else{if(a!==s){const n="Operands could not be broadcast together with shapes "+"".concat(e," and ").concat(t,".");throw Error(n)}n.unshift(a)}}return n}n.r(t),n.d(t,"getBroadcastDims",(function(){return a})),n.d(t,"getReductionAxes",(function(){return r})),n.d(t,"assertAndGetBroadcastShape",(function(){return s}))},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(11),o=n(4);const c=Object(o.b)({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=Object(s.a)(e,"x","sum");"bool"===o.dtype&&(o=Object(i.a)(o,"int32"));const c={x:o},l={axis:t,keepDims:n};return a.a.runKernel(r.cd,c,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var a=n(9),r=n(46);function s(e,t){if((Object(a.A)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Object(a.A)(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Object(r.a)(e,[],[],t)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({zerosLike_:function(e){const t={x:Object(s.a)(e,"x","zerosLike")};return a.a.runKernel(r.md,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return r})),n.d(t,"b",(function(){return o})),n.d(t,"c",(function(){return l}));var a=n(9);class r{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=s,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(o().getBool("IS_TEST")||o().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];o().getBool("IS_TEST")||o().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Object(a.x)(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if("tfjsflags"in e){e.tfjsflags.split(",").forEach(e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if("".concat(+t)===t)return+t;throw new Error("Could not parse value flag value ".concat(t," for flag ").concat(e,"."))}(t,n)})}}}function s(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];return i(t,a[0],a[1]),a.join("=")})),t}function i(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function o(){return c}let c=null;function l(e){c=e}},function(e,t,n){"use strict";n.d(t,"b",(function(){return r.a})),n.d(t,"c",(function(){return s.a})),n.d(t,"d",(function(){return i.a})),n.d(t,"e",(function(){return o.a})),n.d(t,"f",(function(){return p})),n.d(t,"g",(function(){return f.a})),n.d(t,"h",(function(){return m.a})),n.d(t,"i",(function(){return g.a})),n.d(t,"j",(function(){return b.a})),n.d(t,"k",(function(){return y.a})),n.d(t,"l",(function(){return v.a})),n.d(t,"m",(function(){return x.a})),n.d(t,"n",(function(){return w.a})),n.d(t,"o",(function(){return k.a})),n.d(t,"p",(function(){return I.a})),n.d(t,"q",(function(){return O})),n.d(t,"r",(function(){return F})),n.d(t,"w",(function(){return M.a})),n.d(t,"s",(function(){return j.a})),n.d(t,"t",(function(){return z})),n.d(t,"u",(function(){return L})),n.d(t,"v",(function(){return P})),n.d(t,"x",(function(){return B})),n.d(t,"z",(function(){return W})),n.d(t,"A",(function(){return U.a})),n.d(t,"B",(function(){return V.a})),n.d(t,"C",(function(){return N.a})),n.d(t,"D",(function(){return G.a})),n.d(t,"E",(function(){return H.a})),n.d(t,"F",(function(){return q.a})),n.d(t,"G",(function(){return K.a})),n.d(t,"H",(function(){return C.a})),n.d(t,"I",(function(){return X})),n.d(t,"J",(function(){return Z})),n.d(t,"K",(function(){return Y})),n.d(t,"L",(function(){return J})),n.d(t,"M",(function(){return Q.a})),n.d(t,"N",(function(){return $.a})),n.d(t,"O",(function(){return ee.a})),n.d(t,"P",(function(){return te})),n.d(t,"Q",(function(){return ae})),n.d(t,"R",(function(){return re.a})),n.d(t,"S",(function(){return se.a})),n.d(t,"U",(function(){return ie.a})),n.d(t,"V",(function(){return oe.a})),n.d(t,"W",(function(){return ce})),n.d(t,"X",(function(){return le.a})),n.d(t,"Y",(function(){return ue.a})),n.d(t,"Z",(function(){return de})),n.d(t,"ab",(function(){return he.a})),n.d(t,"bb",(function(){return pe.a})),n.d(t,"cb",(function(){return fe.a})),n.d(t,"db",(function(){return me.a})),n.d(t,"fb",(function(){return ge})),n.d(t,"gb",(function(){return be.a})),n.d(t,"ib",(function(){return ye.a})),n.d(t,"jb",(function(){return ve.a})),n.d(t,"kb",(function(){return xe.a})),n.d(t,"lb",(function(){return we.a})),n.d(t,"mb",(function(){return ke.a})),n.d(t,"nb",(function(){return Ie.a})),n.d(t,"ob",(function(){return Ne})),n.d(t,"qb",(function(){return Te.a})),n.d(t,"rb",(function(){return Oe.a})),n.d(t,"sb",(function(){return Ce.a})),n.d(t,"ub",(function(){return Ee.a})),n.d(t,"wb",(function(){return _e.a})),n.d(t,"xb",(function(){return Ae.a})),n.d(t,"zb",(function(){return Re.a})),n.d(t,"Db",(function(){return De.a})),n.d(t,"Eb",(function(){return Fe.a})),n.d(t,"Fb",(function(){return Me.a})),n.d(t,"Gb",(function(){return je.a})),n.d(t,"Hb",(function(){return ze.a})),n.d(t,"Ib",(function(){return Le.a})),n.d(t,"Kb",(function(){return Pe})),n.d(t,"Lb",(function(){return Be.a})),n.d(t,"Mb",(function(){return We.a})),n.d(t,"Nb",(function(){return Ue.a})),n.d(t,"Ob",(function(){return Ve.a})),n.d(t,"Pb",(function(){return Ge.a})),n.d(t,"Qb",(function(){return He.a})),n.d(t,"Rb",(function(){return qe.a})),n.d(t,"Sb",(function(){return Ke.a})),n.d(t,"Tb",(function(){return Xe.a})),n.d(t,"Ub",(function(){return Ze.a})),n.d(t,"Wb",(function(){return Je})),n.d(t,"Xb",(function(){return E.a})),n.d(t,"Yb",(function(){return Qe.a})),n.d(t,"Zb",(function(){return $e.a})),n.d(t,"ac",(function(){return et})),n.d(t,"bc",(function(){return tt})),n.d(t,"cc",(function(){return nt.a})),n.d(t,"dc",(function(){return at.a})),n.d(t,"ec",(function(){return it})),n.d(t,"fc",(function(){return ot.a})),n.d(t,"gc",(function(){return ct.a})),n.d(t,"hc",(function(){return lt.a})),n.d(t,"ic",(function(){return ut.a})),n.d(t,"jc",(function(){return ft})),n.d(t,"lc",(function(){return _.a})),n.d(t,"mc",(function(){return mt})),n.d(t,"nc",(function(){return gt})),n.d(t,"oc",(function(){return bt.a})),n.d(t,"qc",(function(){return yt.a})),n.d(t,"rc",(function(){return vt.a})),n.d(t,"sc",(function(){return rt.a})),n.d(t,"tc",(function(){return xt.a})),n.d(t,"vc",(function(){return wt})),n.d(t,"wc",(function(){return kt.a})),n.d(t,"xc",(function(){return It})),n.d(t,"yc",(function(){return St})),n.d(t,"zc",(function(){return Nt})),n.d(t,"Ac",(function(){return Tt})),n.d(t,"Bc",(function(){return Ot.a})),n.d(t,"Cc",(function(){return Ct.a})),n.d(t,"Dc",(function(){return Et.a})),n.d(t,"Ec",(function(){return _t.a})),n.d(t,"Fc",(function(){return At.a})),n.d(t,"Gc",(function(){return Rt})),n.d(t,"Hc",(function(){return Dt})),n.d(t,"Ic",(function(){return Ft})),n.d(t,"Jc",(function(){return Pt})),n.d(t,"Kc",(function(){return Bt})),n.d(t,"Lc",(function(){return Wt})),n.d(t,"Mc",(function(){return Ut})),n.d(t,"Nc",(function(){return Vt})),n.d(t,"Oc",(function(){return Gt.a})),n.d(t,"Pc",(function(){return Ht.a})),n.d(t,"Qc",(function(){return qt.a})),n.d(t,"Rc",(function(){return Kt.a})),n.d(t,"Sc",(function(){return T.a})),n.d(t,"Tc",(function(){return Xt.a})),n.d(t,"Uc",(function(){return Zt})),n.d(t,"Vc",(function(){return Yt})),n.d(t,"Wc",(function(){return Jt})),n.d(t,"Xc",(function(){return Qt})),n.d(t,"Zc",(function(){return $t.a})),n.d(t,"ad",(function(){return en.a})),n.d(t,"bd",(function(){return tn.a})),n.d(t,"ed",(function(){return nn.a})),n.d(t,"fd",(function(){return an.a})),n.d(t,"gd",(function(){return rn})),n.d(t,"hd",(function(){return A.a})),n.d(t,"id",(function(){return sn.a})),n.d(t,"kd",(function(){return on.a})),n.d(t,"ld",(function(){return cn.a})),n.d(t,"md",(function(){return R.a})),n.d(t,"nd",(function(){return ln})),n.d(t,"od",(function(){return un})),n.d(t,"pd",(function(){return dn})),n.d(t,"qd",(function(){return hn})),n.d(t,"rd",(function(){return pn.a})),n.d(t,"sd",(function(){return fn.a})),n.d(t,"td",(function(){return mn.a})),n.d(t,"pb",(function(){return gn.a})),n.d(t,"yb",(function(){return bn.a})),n.d(t,"Cb",(function(){return yn.a})),n.d(t,"Yc",(function(){return vn.a})),n.d(t,"xd",(function(){return xn.a})),n.d(t,"yd",(function(){return wn.a})),n.d(t,"zd",(function(){return ht.a})),n.d(t,"Ad",(function(){return kn.a})),n.d(t,"Bd",(function(){return In.a})),n.d(t,"Cd",(function(){return Sn.a})),n.d(t,"Dd",(function(){return Nn.a})),n.d(t,"Ed",(function(){return Tn.a})),n.d(t,"Gd",(function(){return pt.a})),n.d(t,"Hd",(function(){return On.a})),n.d(t,"Id",(function(){return Cn.a})),n.d(t,"Jd",(function(){return D.a})),n.d(t,"Kd",(function(){return En.a})),n.d(t,"Ld",(function(){return An})),n.d(t,"Md",(function(){return Rn})),n.d(t,"Nd",(function(){return Dn.a})),n.d(t,"Od",(function(){return Fn})),n.d(t,"Pd",(function(){return Mn})),n.d(t,"Qd",(function(){return jn})),n.d(t,"Rd",(function(){return Se.a})),n.d(t,"Sd",(function(){return zn.a})),n.d(t,"Ud",(function(){return Ln})),n.d(t,"Vd",(function(){return Pn.a})),n.d(t,"Wd",(function(){return Bn.a})),n.d(t,"Xd",(function(){return Wn.a})),n.d(t,"Yd",(function(){return Un})),n.d(t,"Zd",(function(){return Vn})),n.d(t,"ae",(function(){return Gn.a})),n.d(t,"be",(function(){return qn})),n.d(t,"ce",(function(){return Kn.a})),n.d(t,"de",(function(){return Xn.a})),n.d(t,"y",(function(){return Zn})),n.d(t,"Td",(function(){return Yn.a})),n.d(t,"pc",(function(){return Jn.a})),n.d(t,"kc",(function(){return $n})),n.d(t,"cd",(function(){return ta})),n.d(t,"dd",(function(){return Ye})),n.d(t,"vd",(function(){return aa})),n.d(t,"vb",(function(){return ra})),n.d(t,"eb",(function(){return sa})),n.d(t,"hb",(function(){return ia})),n.d(t,"T",(function(){return oa})),n.d(t,"Bb",(function(){return ca})),n.d(t,"uc",(function(){return h.b})),n.d(t,"a",(function(){return h.a})),n.d(t,"Ab",(function(){return hr})),n.d(t,"Jb",(function(){return pr})),n.d(t,"Vb",(function(){return fr})),n.d(t,"wd",(function(){return ur})),n.d(t,"tb",(function(){return a})),n.d(t,"jd",(function(){return dr})),n.d(t,"ud",(function(){return mr})),n.d(t,"Fd",(function(){return gr}));var a={};n.r(a),n.d(a,"conv2d",(function(){return fa})),n.d(a,"depthwiseConv2d",(function(){return ba})),n.d(a,"matMul",(function(){return ya}));var r=n(38),s=n(179),i=n(180),o=n(12),c=n(5),l=n(3),u=n(2),d=n(9),h=n(4);const p=Object(h.b)({addN_:function(e){d.b(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),d.b(e.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got "+"".concat(e.length));const t=e.map((e,t)=>Object(u.a)(e,"tensors".concat(t),"addN")),n=t[0];t.forEach(e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(e=>{if(!d.a(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const a=t;return c.a.runKernel(l.e,a)}});var f=n(136),m=n(137),g=n(138),b=n(139),y=n(181),v=n(182),x=n(183),w=n(140),k=n(184),I=n(105),S=n(22),N=n(11),T=n(7);const O=Object(h.b)({avgPool3d_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=Object(u.a)(e,"x","avgPool3d","float32");let o=i,h=!1;4===i.rank&&(h=!0,o=Object(T.a)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),d.b(5===o.rank,()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(o.rank,".")),d.b("NDHWC"===s,()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s)),Object(S.a)("avgPool3d",a,r);const p={x:o},f={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s};let m=c.a.runKernel(l.p,p,f);return m=Object(N.a)(m,o.dtype),h?Object(T.a)(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}});var C=n(29),E=n(25),_=n(8),A=n(63),R=n(26),D=n(130);const F=Object(h.b)({basicLSTMCell_:function(e,t,n,a,r,s){const i=Object(u.a)(e,"forgetBias","basicLSTMCell"),c=Object(u.a)(t,"lstmKernel","basicLSTMCell"),l=Object(u.a)(n,"lstmBias","basicLSTMCell"),d=Object(u.a)(a,"data","basicLSTMCell"),h=Object(u.a)(r,"c","basicLSTMCell"),p=Object(u.a)(s,"h","basicLSTMCell"),f=Object(C.a)([d,p],1),m=Object(E.a)(f,c),g=Object(o.a)(m,l),b=g.shape[0],y=g.shape[1]/4,v=[b,y],x=Object(R.a)(g,[0,0],v),w=Object(R.a)(g,[0,y],v),k=Object(R.a)(g,[0,2*y],v),I=Object(R.a)(g,[0,3*y],v),S=Object(o.a)(Object(_.a)(Object(A.a)(x),Object(D.a)(w)),Object(_.a)(h,Object(A.a)(Object(o.a)(i,k))));return[S,Object(_.a)(Object(D.a)(S),Object(A.a)(I))]}});var M=n(84),j=n(76);const z=Object(h.b)({batchNorm2d_:function(e,t,n,a,r,s){const i=Object(u.a)(e,"x","batchNorm"),o=Object(u.a)(t,"mean","batchNorm"),c=Object(u.a)(n,"variance","batchNorm");let l,h;return null!=r&&(l=Object(u.a)(r,"scale","batchNorm")),null!=a&&(h=Object(u.a)(a,"offset","batchNorm")),d.b(2===i.rank,()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(i.rank,".")),d.b(2===o.rank||1===o.rank,()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(o.rank,".")),d.b(2===c.rank||1===c.rank,()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,".")),null!=l&&d.b(2===l.rank||1===l.rank,()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,".")),null!=h&&d.b(2===h.rank||1===h.rank,()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(h.rank,".")),Object(j.a)(i,o,c,h,l,s)}});const L=Object(h.b)({batchNorm3d_:function(e,t,n,a,r,s){const i=Object(u.a)(e,"x","batchNorm"),o=Object(u.a)(t,"mean","batchNorm"),c=Object(u.a)(n,"variance","batchNorm");let l,h;return null!=r&&(l=Object(u.a)(r,"scale","batchNorm")),null!=a&&(h=Object(u.a)(a,"offset","batchNorm")),d.b(3===i.rank,()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(i.rank,".")),d.b(3===o.rank||1===o.rank,()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(o.rank,".")),d.b(3===c.rank||1===c.rank,()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,".")),null!=l&&d.b(3===l.rank||1===l.rank,()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,".")),null!=h&&d.b(3===h.rank||1===h.rank,()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(h.rank,".")),Object(j.a)(i,o,c,h,l,s)}});const P=Object(h.b)({batchNorm4d_:function(e,t,n,a,r,s){const i=Object(u.a)(e,"x","batchNorm"),o=Object(u.a)(t,"mean","batchNorm"),c=Object(u.a)(n,"variance","batchNorm");let l,h;return null!=r&&(l=Object(u.a)(r,"scale","batchNorm")),null!=a&&(h=Object(u.a)(a,"offset","batchNorm")),d.b(4===i.rank,()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(i.rank,".")),d.b(4===o.rank||1===o.rank,()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(o.rank,".")),d.b(4===c.rank||1===c.rank,()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,".")),null!=l&&d.b(4===l.rank||1===l.rank,()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,".")),null!=h&&d.b(4===h.rank||1===h.rank,()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(h.rank,".")),Object(j.a)(i,o,c,h,l,s)}});const B=Object(h.b)({bincount_:function(e,t,n){const a=Object(u.a)(e,"x","bincount"),r=Object(u.a)(t,"weights","bincount");d.b("int32"===a.dtype,()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(a.dtype)),d.b(n>=0,()=>"size must be non-negative, but got ".concat(n,".")),d.b(r.size===a.size||0===r.size,()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(a.shape,", weights shape: ")+"".concat(r.shape,"."));const s={x:a,weights:r},i={size:n};return c.a.runKernel(l.u,s,i)}});const W=Object(h.b)({broadcastArgs_:function(e,t){const n=Object(u.a)(e,"s0","broadcastArgs","int32"),a=Object(u.a)(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error("broadcastArgs(): first input must be a vector (rank=1). "+"Has rank ".concat(n.rank));if(1!==a.rank)throw new Error("broadcastArgs(): second input must be a vector (rank=1). "+"Has rank ".concat(a.rank));const r={s0:n,s1:a};return c.a.runKernel(l.v,r)}});var U=n(94),V=n(43),G=n(185),H=n(186),q=n(62),K=n(47);const X=Object(h.b)({concat1d_:function(e){return Object(C.a)(e,0)}});const Z=Object(h.b)({concat2d_:function(e,t){return Object(C.a)(e,t)}});const Y=Object(h.b)({concat3d_:function(e,t){return Object(C.a)(e,t)}});const J=Object(h.b)({concat4d_:function(e,t){return Object(C.a)(e,t)}});var Q=n(141),$=n(60),ee=n(142);const te=Object(h.b)({conv3d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const i=Object(u.a)(e,"x","conv3d"),o=Object(u.a)(t,"filter","conv3d");let h=i,p=!1;4===i.rank&&(p=!0,h=Object(T.a)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),d.b(5===h.rank,()=>"Error in conv3d: input must be rank 5, but got rank ".concat(h.rank,".")),d.b(5===o.rank,()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(o.rank,".")),d.b(h.shape[4]===o.shape[3],()=>"Error in conv3d: depth of input (".concat(h.shape[4],") must match ")+"input depth for filter ".concat(o.shape[3],".")),d.b(Object(S.i)(n,s),()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'")),d.b("NDHWC"===r,()=>"Error in conv3d: got dataFormat of ".concat(r," but only NDHWC is currently supported."));const f={x:h,filter:o},m={strides:n,pad:a,dataFormat:r,dilations:s},g=c.a.runKernel(l.G,f,m);return p?Object(T.a)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}});var ne=n(171);const ae=Object(h.b)({conv3dTranspose_:function(e,t,n,a,r){const s=Object(u.a)(e,"x","conv3dTranspose"),i=Object(u.a)(t,"filter","conv3dTranspose");return Object(ne.a)(n,s,i,a,r)}});var re=n(106),se=n(143),ie=n(96),oe=n(107);const ce=Object(h.b)({denseBincount_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Object(u.a)(e,"x","denseBincount"),s=Object(u.a)(t,"weights","denseBincount");d.b("int32"===r.dtype,()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(r.dtype)),d.b(r.rank<=2,()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(r.rank,".")),d.b(n>=0,()=>"size must be non-negative, but got ".concat(n,".")),d.b(s.size===r.size||0===s.size,()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(r.shape,", weights shape: ")+"".concat(s.shape,"."));const i={x:r,weights:s},o={size:n,binaryOutput:a};return c.a.runKernel(l.O,i,o)}});var le=n(144),ue=n(85);const de=Object(h.b)({diag_:function(e){const t={x:Object(u.a)(e,"x","diag")};return c.a.runKernel(l.T,t)}});var he=n(145),pe=n(14),fe=n(146),me=n(147);const ge=Object(h.b)({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];const r=n.map((e,t)=>Object(u.a)(e,"tensors".concat(t),"einsum")),s={equation:e};return c.a.runKernel(l.X,r,s)}});var be=n(109),ye=n(86),ve=n(187),xe=n(148),we=n(35),ke=n(57),Ie=n(188),Se=n(65);const Ne=Object(h.b)({eye_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";null==t&&(t=e);const r=Object(V.a)([e,t],a),s=e<=t?e:t;for(let o=0;o<s;++o)r.set(1,o,o);const i=Object(T.a)(r.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return Object(Se.a)(Object(ke.a)(i,0),[n[0],1,1]);if(2===n.length)return Object(Se.a)(Object(ke.a)(Object(ke.a)(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return Object(Se.a)(Object(ke.a)(Object(ke.a)(Object(ke.a)(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});var Te=n(71),Oe=n(110),Ce=n(108),Ee=n(88),_e=n(37),Ae=n(61),Re=n(89),De=n(189),Fe=n(190),Me=n(191),je=n(111),ze=n(112),Le=n(50);function Pe(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const a={start:e,stop:t,num:n};return c.a.runKernel(l.Db,{},a)}var Be=n(149),We=n(67),Ue=n(150),Ve=n(192),Ge=n(193),He=n(113),qe=n(53),Ke=n(90),Xe=n(114),Ze=n(152);const Ye=Object(h.b)({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const a=Object(u.a)(e,"sortedSequence","searchSorted"),r=Object(u.a)(t,"values","searchSorted"),s=a.shape[a.shape.length-1],i=r.shape[r.shape.length-1],o=Object(T.a)(a,[-1,s]),h=Object(T.a)(r,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==h.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Object(d.O)(h.shape)>=2147483648)throw new Error("values tensor size must less than ".concat(2147483648));if(o.shape[1]>=2147483648)throw new Error("trailing dim_size must less than ".concat(2147483648," for int32 output type, was ").concat(o.shape[1]));const p={sortedSequence:o,values:h},f={side:n};return c.a.runKernel(l.Cc,p,f)}});function Je(e,t){return Ye(e,t,"left")}var Qe=n(64),$e=n(115);const et=Object(h.b)({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=Object(u.a)(e,"x","maxPool3d");let o=i,h=!1;4===i.rank&&(h=!0,o=Object(T.a)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),d.b(5===o.rank,()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(o.rank,".")),d.b("NDHWC"===s,()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s)),Object(S.a)("maxPool3d",a,r);const p={x:o},f={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},m=c.a.runKernel(l.Mb,p,f);return h?Object(T.a)(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}});const tt=Object(h.b)({maxPoolWithArgmax_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const s=Object(u.a)(e,"x","maxPoolWithArgmax"),i={x:s},o={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},d=c.a.runKernel(l.Pb,i,o);return{result:d[0],indexes:d[1]}}});var nt=n(91),at=n(80),rt=n(49),st=n(6);function it(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError("".concat(n," is not a valid third argument to meshgrid"));if(void 0===e)return[];let a=Object(u.a)(e,"x","meshgrid",e instanceof st.a?e.dtype:"float32");if(void 0===t)return[a];let r=Object(u.a)(t,"y","meshgrid",t instanceof st.a?t.dtype:"float32");const s=Object(d.O)(a.shape),i=Object(d.O)(r.shape);return"xy"===n?(a=Object(T.a)(a,[1,-1]),r=Object(T.a)(r,[-1,1]),[Object(E.a)(Object(rt.a)([i,1],a.dtype),a),Object(E.a)(r,Object(rt.a)([1,s],r.dtype))]):(a=Object(T.a)(a,[-1,1]),r=Object(T.a)(r,[1,-1]),[Object(E.a)(a,Object(rt.a)([1,i],a.dtype)),Object(E.a)(Object(rt.a)([s,1],r.dtype),r)])}var ot=n(97),ct=n(116),lt=n(153),ut=n(154),dt=n(34),ht=n(23),pt=n(13);const ft=Object(h.b)({moments_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];e=Object(u.a)(e,"x","moments");const a=Object(d.I)(t,e.shape),r=Object(at.a)(e,a,n);let s=r.shape;n||(s=Object(dt.e)(r.shape,a));const i=Object(ht.a)(Object(pt.a)(Object(N.a)(e,"float32"),Object(T.a)(r,s))),o=Object(at.a)(i,a,n);return{mean:r,variance:o}}});const mt=Object(h.b)({multiRNNCell_:function(e,t,n,a){const r=Object(u.a)(t,"data","multiRNNCell"),s=Object(u.b)(n,"c","multiRNNCell"),i=Object(u.b)(a,"h","multiRNNCell");let o=r;const c=[];for(let u=0;u<e.length;u++){const t=e[u](o,s[u],i[u]);c.push(t[0]),c.push(t[1]),o=t[1]}const l=[],d=[];for(let u=0;u<c.length;u+=2)l.push(c[u]),d.push(c[u+1]);return[l,d]}});const gt=Object(h.b)({multinomial_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Object(u.a)(e,"logits","multinomial"),s=r.size,i=r.rank;if(s<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+"".concat(s,"."));if(i>2)throw new Error("Rank of probabilities must be 1 or 2, but is ".concat(i));n=n||Math.random();const o=1===i?Object(T.a)(r,[1,-1]):r,d={logits:o},h={numSamples:t,seed:n,normalized:a},p=c.a.runKernel(l.Wb,d,h);return 1===i?Object(T.a)(p,[p.size]):p}});var bt=n(27),yt=n(117),vt=n(155),xt=n(194);const wt=Object(h.b)({outerProduct_:function(e,t){const n=Object(u.a)(e,"v1","outerProduct"),a=Object(u.a)(t,"v2","outerProduct");d.b(1===n.rank&&1===a.rank,()=>"Error in outerProduct: inputs must be rank 1, but got ranks "+"".concat(n.rank," and ").concat(a.rank,"."));const r=Object(T.a)(n,[-1,1]),s=Object(T.a)(a,[1,-1]);return Object(E.a)(r,s)}});var kt=n(51);const It=Object(h.b)({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Object(d.b)(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),Object(kt.a)(e,[t],n)}});const St=Object(h.b)({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Object(d.b)(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),Object(kt.a)(e,t,n)}});const Nt=Object(h.b)({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Object(d.b)(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),Object(kt.a)(e,t,n)}});const Tt=Object(h.b)({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Object(d.b)(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),Object(kt.a)(e,t,n)}});var Ot=n(156),Ct=n(48),Et=n(118),_t=n(135),At=n(157);const Rt=Object(h.b)({raggedGather_:function(e,t,n,a){const r={paramsNestedSplits:e.map((e,t)=>Object(u.a)(e,"tensors".concat(t),"raggedGather","int32")),paramsDenseValues:Object(u.a)(t,"paramsDenseValues","raggedGather"),indices:Object(u.a)(n,"indices","raggedGather","int32")},s={outputRaggedRank:a},i=c.a.runKernel(l.kc,r,s);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});const Dt=Object(h.b)({raggedTensorToTensor_:function(e,t,n,a,r){const s=Object(u.a)(e,"shape","raggedTensorToTensor","int32"),i=Object(u.a)(t,"values","raggedTensorToTensor"),o={shape:s,values:i,defaultValue:Object(u.a)(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:a.map((e,t)=>Object(u.a)(e,"tensors".concat(t),"raggedTensorToTensor","int32"))},d={rowPartitionTypes:r};return c.a.runKernel(l.lc,o,d)}});const Ft=Object(h.b)({rand_:function(e,t,n){const a=Object(d.O)(e);let r=null;if(null==n||"float32"===n)r=new Float32Array(a);else if("int32"===n)r=new Int32Array(a);else{if("bool"!==n)throw new Error("Unknown data type ".concat(n));r=new Uint8Array(a)}for(let s=0;s<a;s++)r[s]=t();return c.a.makeTensor(r,e,n)}});var Mt=n(78);n(125);class jt{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=r||Math.random();this.random=Mt.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,r,s;do{a=2*this.random()-1,r=2*this.random()-1,s=a*a+r*r}while(s>=1||0===s);const i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*a*i,t=this.mean+this.stdDev*r*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class zt{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;const r=a||Math.random();this.randu=Mt.alea(r.toString()),this.randn=new jt(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,r,s;for(;;){do{a=this.randn.nextValue(),s=1+this.c*a}while(s<=0);if(s*=s*s,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),r=this.randu(),r<t||Math.log(r)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class Lt{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"===typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=Mt.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Pt=Object(h.b)({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;if(null==n&&(n=1),null==a&&(a="float32"),"float32"!==a&&"int32"!==a)throw new Error("Unsupported data type ".concat(a));const s=new zt(t,n,a,r),i=Object(V.a)(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});const Bt=Object(h.b)({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(null!=a&&"bool"===a)throw new Error("Unsupported data type ".concat(a));const s=new jt(t,n,a,!1,r),i=Object(V.a)(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});const Wt=Object(h.b)({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error("Unsupported data type ".concat(t));return Bt(e,0,1,t,n)}});const Ut=Object(h.b)({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;const s=Object(V.a)(e,a),i=new Lt(t,n,null,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}});function Vt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:a};return c.a.runKernel(l.mc,{},r)}var Gt=n(81),Ht=n(195),qt=n(73),Kt=n(119),Xt=n(44);const Zt=Object(h.b)({reverse1d_:function(e){const t=Object(u.a)(e,"x","reverse");return d.b(1===t.rank,()=>"Error in reverse1D: x must be rank 1 but got rank ".concat(t.rank,".")),Object(Xt.a)(t,0)}});const Yt=Object(h.b)({reverse2d_:function(e,t){const n=Object(u.a)(e,"x","reverse");return d.b(2===n.rank,()=>"Error in reverse2D: x must be rank 2 but got rank ".concat(n.rank,".")),Object(Xt.a)(n,t)}});const Jt=Object(h.b)({reverse3d_:function(e,t){const n=Object(u.a)(e,"x","reverse");return d.b(3===n.rank,()=>"Error in reverse3D: x must be rank 3 but got rank ".concat(n.rank,".")),Object(Xt.a)(n,t)}});const Qt=Object(h.b)({reverse4d_:function(e,t){const n=Object(u.a)(e,"x","reverse");return d.b(4===n.rank,()=>"Error in reverse4D: x must be rank 4 but got rank ".concat(n.rank,".")),Object(Xt.a)(n,t)}});var $t=n(158),en=n(159),tn=n(17),nn=n(160),an=n(161);const rn=async function(e,t){const n=Object(u.a)(e,"x","setdiff1d"),a=Object(u.a)(t,"y","setdiff1d");d.b(n.dtype===a.dtype,()=>"x and y should have the same dtype, but got x (".concat(n.dtype,") and y (").concat(a.dtype,").")),d.b(1===n.rank,()=>"x should be 1D tensor, but got x (".concat(n.shape,").")),d.b(1===a.rank,()=>"y should be 1D tensor, but got y (".concat(a.shape,")."));const r=await n.data(),s=await a.data(),i=new Set(s);let o=0;for(let u=0;u<r.length;u++)i.has(r[u])||o++;const c=new st.b([o],n.dtype),l=new st.b([o],"int32");for(let u=0,d=0;u<r.length;u++)i.has(r[u])||(c.values[d]=r[u],l.values[d]=u,d++);return[c.toTensor(),l.toTensor()]};var sn=n(196),on=n(162),cn=n(163);const ln=Object(h.b)({slice1d_:function(e,t,n){const a=Object(u.a)(e,"x","slice1d");return d.b(1===a.rank,()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(a.rank," tensor")),Object(R.a)(a,[t],[n])}});const un=Object(h.b)({slice2d_:function(e,t,n){const a=Object(u.a)(e,"x","slice2d");return d.b(2===a.rank,()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(a.rank," tensor")),Object(R.a)(a,t,n)}});const dn=Object(h.b)({slice3d_:function(e,t,n){const a=Object(u.a)(e,"x","slice3d");return d.b(3===a.rank,()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(a.rank," tensor")),Object(R.a)(a,t,n)}});const hn=Object(h.b)({slice4d_:function(e,t,n){const a=Object(u.a)(e,"x","slice4d");return d.b(4===a.rank,()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(a.rank," tensor")),Object(R.a)(a,t,n)}});var pn=n(197),fn=n(151),mn=n(92),gn=n(120),bn=n(98),yn=n(164),vn=n(121),xn=n(54),wn=n(33),kn=n(122),In=n(93),Sn=n(55),Nn=n(74),Tn=n(198),On=n(16),Cn=n(199),En=n(77),_n=n(46);function An(e,t){Object(d.d)(e);const n=Object(u.c)(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Object(_n.a)(e,null,n,t)}function Rn(e,t,n){if(Object(d.d)(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=Object(u.c)(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Object(_n.a)(e,t,a,n)}var Dn=n(165);function Fn(e,t,n){if(Object(d.d)(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const a=Object(u.c)(e,n);if(4!==a.length&&1!==a.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Object(_n.a)(e,t,a,n)}function Mn(e,t,n){if(Object(d.d)(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const a=Object(u.c)(e,n);if(5!==a.length&&1!==a.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Object(_n.a)(e,t,a,n)}function jn(e,t,n){if(Object(d.d)(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const a=Object(u.c)(e,n);if(6!==a.length&&1!==a.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||a,Object(_n.a)(e,t,a,n)}var zn=n(166);const Ln=Object(h.b)({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const s=new jt(t,n,a,!0,r),i=Object(V.a)(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var Pn=n(167),Bn=n(123),Wn=n(75);function Un(e,t){return Ye(e,t,"right")}function Vn(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return c.a.makeVariable(e,t,n,a)}var Gn=n(30),Hn=n(168);const qn=async function(e){const t=Object(u.a)(e,"condition","whereAsync","bool"),n=await t.data(),a=Object(Hn.a)(t.shape,n);return e!==t&&t.dispose(),a};var Kn=n(72),Xn=n(18);const Zn=async function(e,t,n){const a=Object(u.a)(e,"tensor","boolMask"),r=Object(u.a)(t,"mask","boolMask","bool"),s=null==n?0:n,i=r.rank,o=a.shape;d.b(i>0,()=>"mask cannot be scalar"),d.e(o.slice(s,s+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let u=s;u<s+i;u++)c*=o[u];const l=o.slice(0,s).concat([c],o.slice(s+i)),h=Object(T.a)(a,l),p=Object(T.a)(r,[-1]),f=await qn(p),m=Object(In.a)(f,[1]),g=Object(Ee.a)(h,m,s);return e!==a&&a.dispose(),t!==r&&r.dispose(),m.dispose(),h.dispose(),p.dispose(),f.dispose(),g};var Yn=n(45),Jn=n(87),Qn=n(21);const $n=Object(h.b)({movingAverage_:function(e,t,n,a){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const s=Object(u.a)(e,"v","movingAverage"),i=Object(u.a)(t,"x","movingAverage"),c=Object(u.a)(n,"decay","movingAverage");Object(Qn.assertTypesMatch)(s,i),d.b(d.a(s.shape,i.shape),()=>"Shape mismatch in v and x");const l=Object(tn.a)(1),h=Object(pt.a)(l,c);let p=Object(_.a)(Object(pt.a)(i,s),h);if(r){d.b(null!=a,()=>"When using zeroDebias: true, step is required.");const e=Object(u.a)(a,"step","movingAverage");p=Object(pe.a)(p,Object(pt.a)(l,Object(Ct.a)(c,e)))}return Object(o.a)(s,p)}});var ea=n(103);const ta=Object(h.b)({scatterND_:function(e,t,n){const a=Object(u.a)(e,"indices","scatterND","int32"),r=Object(u.a)(t,"updates","scatterND");ea.b(r,a,n);const s={indices:a,updates:r},i={shape:n};return c.a.runKernel(l.Bc,s,i)}});function na(e,t,n,a){if("int32"!==e.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type,"+" but the dtype was ".concat(e.dtype,"."));if(e.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix,"+" but got shape ".concat(e.shape,"."));const r=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error("outputShape has incorrect number of elements:,"+" ".concat(n.length,", should be: ").concat(s,"."));const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==r))throw new Error("sparseValues has incorrect shape "+"".concat(t.shape,", should be [] or [").concat(r,"]"));if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}const aa=Object(h.b)({sparseToDense_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r=Object(u.a)(e,"sparseIndices","sparseToDense","int32"),s=Object(u.a)(t,"sparseValues","sparseToDense","string_or_numeric"),i=Object(u.a)(a,"defaultValue","sparseToDense",s.dtype);na(r,s,n,i);const o={sparseIndices:r,sparseValues:s,defaultValue:i},d={outputShape:n};return c.a.runKernel(l.Rc,o,d)}});const ra=Object(h.b)({gatherND_:function(e,t){const n=Object(u.a)(t,"indices","gatherND","int32"),a={params:Object(u.a)(e,"x","gatherND","string_or_numeric"),indices:n};return c.a.runKernel(l.ob,a)}});const sa=Object(h.b)({dropout_:function(e,t,n,a){const r=Object(u.a)(e,"x","dropout");if(d.b("float32"===r.dtype,()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(r.dtype," tensor instead.")),d.b(t>=0&&t<1,()=>"rate must be a float in the range [0, 1), but got ".concat(t,".")),0===t)return e instanceof st.a?r.clone():r;const s=function(e,t){if(null==t)return e.shape.slice();if(d.a(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?n.push(e.shape[a]):n.push(t[a]);return n}return t}(r,n),i=1-t,c=Object(pe.a)(Object(Oe.a)(Object(o.a)(Ut(s,0,1,"float32",a),i)),i);return Object(_.a)(r,c)}});function ia(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function oa(e,t,n){const a=1-e%2,r=new Float32Array(e);for(let s=0;s<e;++s){const i=2*Math.PI*s/(e+a-1);r[s]=t-n*Math.cos(i)}return An(r,"float32")}const ca=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const a=Object(u.a)(e,"predictions","inTopK"),r=Object(u.a)(t,"targets","inTopK");Object(d.b)(a.rank>1,()=>"inTopK() expects the predictions to be of rank 2 or higher, "+"but got ".concat(a.rank)),Object(d.b)(a.rank-1===r.rank,()=>"predictions rank should be 1 larger than targets rank, but got predictions rank "+"".concat(a.rank," and targets rank ").concat(r.rank)),Object(d.e)(a.shape.slice(0,a.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=a.shape[a.shape.length-1];Object(d.b)(n>0&&n<=s,()=>"'k' passed to inTopK() must be > 0 && <= the predictions last "+"dimension (".concat(s,"), but got ").concat(n));const i=await a.data(),o=await r.data(),[c,l]=[i.length/s,s],h=Object(d.o)("bool",c);for(let u=0;u<c;u++){const e=u*l,t=i.subarray(e,e+l),a=[];for(let n=0;n<t.length;n++)a.push({value:t[n],index:n});a.sort((e,t)=>t.value-e.value),h[u]=0;for(let r=0;r<n;r++)if(a[r].index===o[u]){h[u]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),Object(En.a)(h,r.shape,"bool")};var la=n(31),ua=n(15),da=n(126),ha=n(124),pa=n(39);const fa=Object(h.b)({fusedConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:h,bias:p,activation:f="linear",preluActivationWeights:m,leakyreluAlpha:g}=e;if(f=f||"linear",!1===Object(pa.d)(c.a.state.gradientDepth,f)){d.b("NHWC"===s,()=>"Error in fused conv2d: got dataFormat of ".concat(s," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.");let e=Object($.a)(t,n,a,r,s,i,h);return null!=p&&(e=Object(o.a)(e,p)),Object(pa.a)(e,f,m,g)}const b=Object(u.a)(t,"x","conv2d","float32"),y=Object(u.a)(n,"filter","conv2d","float32");let v=b,x=!1;3===b.rank&&(x=!0,v=Object(T.a)(b,[1,b.shape[0],b.shape[1],b.shape[2]])),d.b(4===v.rank,()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(v.rank,".")),d.b(4===y.rank,()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(y.rank,".")),S.a("fused conv2d",r,h);const w="NHWC"===s?v.shape[3]:v.shape[1];d.b(y.shape[2]===w,()=>"Error in conv2d: depth of input (".concat(w,") must match ")+"input depth for filter ".concat(y.shape[2],".")),d.b(S.i(a,i),()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(a," and dilations '").concat(i,"'"));const k=S.b(v.shape,y.shape,a,i,r,h);let I,N;if(null!=p&&(I=Object(u.a)(p,"bias","fused conv2d"),[I]=Object(Qn.makeTypesMatch)(I,b),"NHWC"===s?ua.assertAndGetBroadcastShape(k.outShape,I.shape):(d.b(I.shape.length<=1,()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(I.shape.length,".")),d.b(0===I.shape.length||I.shape[0]===k.outChannels||1===I.shape[0],()=>"Error in fused conv2d: bias shape (".concat(I.shape,") is not ")+"compatible with the number of output channels "+"(".concat(k.outChannels,")")))),null!=m){const e=m.shape;if(d.b(e.length<=1||3===e.length,()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(e.length,".")),1===e.length)d.b(1===e[0]||e[0]===k.outChannels,()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(e,") is not compatible with the number of output ")+"channels (".concat(k.outChannels,")."));else if(3===e.length)try{ua.assertAndGetBroadcastShape(e,k.outShape)}catch(_){const t="Error in fused conv2d: PReLU activation weights (".concat(e,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(k.outShape,").");throw Error(t)}N=Object(u.a)(m,"prelu weights","fused conv2d")}const O=(e,t)=>{d.b("NHWC"===s,()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(s," but only NHWC is currently supported."));const[n,o,c,l]=t,u=Object(pa.c)(e,c,f);d.b(S.j(i),()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(i,"'"));const h=[Object(ha.a)(o.shape,u,n,a,r),Object(da.a)(o,u,n.shape,a,r)];if(null!=l){const e=Object(pa.b)(l,u);h.push(e)}return h},C={x:v,filter:y,bias:I,preluActivationWeights:N},E={strides:a,pad:r,dataFormat:s,dilations:i,dimRoundingMode:h,activation:f,leakyreluAlpha:g};if(null==p){return Object(la.a)((e,t,n)=>{let a=c.a.runKernel(l.mb,C,E);return n([t,e,a]),x&&(a=Object(T.a)(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:O}})(v,y)}return Object(la.a)((e,t,n,a)=>{let r=c.a.runKernel(l.mb,C,E);return a([t,e,r,n]),x&&(r=Object(T.a)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:O}})(v,y,I)}});var ma=n(175),ga=n(174);const ba=Object(h.b)({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:h,bias:p,activation:f="linear",preluActivationWeights:m,leakyreluAlpha:g}=e;if(!1===Object(pa.d)(c.a.state.gradientDepth,f)){let e=Object(ue.a)(t,n,a,r,s,i,h);return null!=p&&(e=Object(o.a)(e,p)),Object(pa.a)(e,f,m,g)}const b=Object(u.a)(t,"x","depthwiseConv2d","float32"),y=Object(u.a)(n,"filter","depthwiseConv2d","float32");let v=b,x=!1;3===b.rank&&(x=!0,v=Object(T.a)(b,[1,b.shape[0],b.shape[1],b.shape[2]])),d.b(4===v.rank,()=>"Error in fused depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(v.rank,".")),d.b(4===y.rank,()=>"Error in fused depthwiseConv2d: filter must be rank 4, "+"but got rank ".concat(y.rank,".")),d.b(v.shape[3]===y.shape[2],()=>"Error in fused depthwiseConv2d: number of input channels "+"(".concat(v.shape[3],") must match the inChannels dimension in ")+"filter ".concat(y.shape[2],".")),null==i&&(i=[1,1]),d.b(S.i(a,i),()=>"Error in fused depthwiseConv2d: Either strides or dilations must "+"be 1. Got strides ".concat(a," and dilations '").concat(i,"'")),S.a("fused depthwiseConv2d",r,h);const w=S.b(v.shape,y.shape,a,i,r,h,!0);let k,I;null!=p&&(k=Object(u.a)(p,"bias","fused conv2d"),[k]=Object(Qn.makeTypesMatch)(k,b),ua.assertAndGetBroadcastShape(w.outShape,k.shape)),null!=m&&(I=Object(u.a)(m,"prelu weights","fused depthwiseConv2d"));const N=(e,t)=>{d.b(S.j(i),()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'"));const[n,s,o,c]=t,l=Object(pa.c)(e,o,f),u=Object(ga.a)(s.shape,l,n,a,r,i,h),p=Object(ma.a)(s,l,n.shape,a,r,i,h);if(null!=c){return[u,p,Object(pa.b)(k,l)]}return[u,p]},O={x:v,filter:y,bias:k,preluActivationWeights:I},C={strides:a,pad:r,dataFormat:s,dilations:i,dimRoundingMode:h,activation:f,leakyreluAlpha:g};if(null==p){return Object(la.a)((e,t,n)=>{let a=c.a.runKernel(l.nb,O,C);return n([t,e,a]),x&&(a=Object(T.a)(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:N}})(v,y)}return Object(la.a)((e,t,n,a)=>{let r=c.a.runKernel(l.nb,O,C);return a([t,e,r,n]),x&&(r=Object(T.a)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:N}})(v,y,k)}});const ya=Object(h.b)({fusedMatMul_:function(e){let{a:t,b:n,transposeA:a=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:h,leakyreluAlpha:p=.2}=e;if(!1===Object(pa.d)(c.a.state.gradientDepth,i)){let e=Object(E.a)(t,n,a,r);return null!=s&&(e=Object(o.a)(e,s)),Object(pa.a)(e,i,h,p)}let f=Object(u.a)(t,"a","fused matMul"),m=Object(u.a)(n,"b","fused matMul");[f,m]=Object(Qn.makeTypesMatch)(f,m);const g=a?f.shape[f.rank-2]:f.shape[f.rank-1],b=r?m.shape[m.rank-1]:m.shape[m.rank-2],y=a?f.shape[f.rank-1]:f.shape[f.rank-2],v=r?m.shape[m.rank-2]:m.shape[m.rank-1],x=f.shape.slice(0,-2),w=m.shape.slice(0,-2),k=d.O(x),I=d.O(w);d.b(g===b,()=>"Error in fused matMul: inner shapes (".concat(g,") and (")+"".concat(b,") of Tensors with shapes ").concat(f.shape," and ")+"".concat(m.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match."));const S=ua.assertAndGetBroadcastShape(f.shape.slice(0,-2),m.shape.slice(0,-2)).concat([y,v]),N=a?Object(T.a)(f,[k,g,y]):Object(T.a)(f,[k,y,g]),O=r?Object(T.a)(m,[I,v,b]):Object(T.a)(m,[I,b,v]);let C,_;null!=s&&(C=Object(u.a)(s,"bias","fused matMul"),[C]=Object(Qn.makeTypesMatch)(C,f),ua.assertAndGetBroadcastShape(S,C.shape)),null!=h&&(_=Object(u.a)(h,"prelu weights","fused matMul"));const A=(e,t)=>{const[n,o,c,l]=t,u=Object(pa.c)(Object(T.a)(e,c.shape),c,i);let d,h;if(a||r?!a&&r?(d=Object(E.a)(u,o,!1,!1),h=Object(E.a)(u,n,!0,!1)):a&&!r?(d=Object(E.a)(o,u,!1,!0),h=Object(E.a)(n,u,!1,!1)):(d=Object(E.a)(o,u,!0,!0),h=Object(E.a)(u,n,!0,!0)):(d=Object(E.a)(u,o,!1,!0),h=Object(E.a)(n,u,!0,!1)),null!=s){return[d,h,Object(pa.b)(l,u)]}return[d,h]},R={a:N,b:O,bias:C,preluActivationWeights:_},D={transposeA:a,transposeB:r,activation:i,leakyreluAlpha:p};if(null==s){return Object(la.a)((e,t,n)=>{const a=c.a.runKernel(l.nd,R,D);return n([e,t,a]),{value:Object(T.a)(a,S),gradFunc:A}})(N,O)}return Object(la.a)((e,t,n,a)=>{const r=c.a.runKernel(l.nd,R,D);return a([e,t,r,n]),{value:Object(T.a)(r,S),gradFunc:A}})(N,O,C)}});const va=Object(h.b)({hammingWindow_:function(e){return oa(e,.54,.46)}});const xa=Object(h.b)({hannWindow_:function(e){return oa(e,.5,.5)}});const wa=Object(h.b)({frame_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=0;const i=[];for(;s+t<=e.size;)i.push(Object(R.a)(e,s,t)),s+=n;if(a)for(;s<e.size;){const a=s+t-e.size,o=Object(C.a)([Object(R.a)(e,s,t-a),Object(Te.a)([a],r)]);i.push(o),s+=n}return 0===i.length?Rn([],[0,t]):Object(T.a)(Object(C.a)(i),[i.length,t])}});const ka=Object(h.b)({stft_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:xa;null==a&&(a=ia(t));const s=wa(e,t,n),i=Object(_.a)(s,r(t));return Object(vn.a)(i,a)}});const Ia=Object(h.b)({cropAndResize_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=Object(u.a)(e,"image","cropAndResize"),o=Object(u.a)(t,"boxes","cropAndResize","float32"),h=Object(u.a)(n,"boxInd","cropAndResize","int32"),p=o.shape[0];d.b(4===i.rank,()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(i.rank,".")),d.b(2===o.rank&&4===o.shape[1],()=>"Error in cropAndResize: boxes must be have size [".concat(p,",4] ")+"but had shape ".concat(o.shape,".")),d.b(1===h.rank&&h.shape[0]===p,()=>"Error in cropAndResize: boxInd must be have size [".concat(p,"] ")+"but had shape ".concat(o.shape,".")),d.b(2===a.length,()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(a.length,".")),d.b(a[0]>=1&&a[1]>=1,()=>"cropSize must be atleast [1,1], but was ".concat(a)),d.b("bilinear"===r||"nearest"===r,()=>"method must be bilinear or nearest, but was ".concat(r));const f={image:i,boxes:o,boxInd:h},m={method:r,extrapolationValue:s,cropSize:a},g=c.a.runKernel(l.L,f,m);return g}});const Sa=Object(h.b)({flipLeftRight_:function(e){const t=Object(u.a)(e,"image","flipLeftRight","float32");d.b(4===t.rank,()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(t.rank,"."));const n={image:t};return c.a.runKernel(l.hb,n,{})}});const Na=Object(h.b)({grayscaleToRGB_:function(e){const t=Object(u.a)(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];d.b(t.rank>=2,()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(t.rank,".")),d.b(1===a,()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(a,"."));const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,Object(Se.a)(t,r)}});const Ta=Object(h.b)({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Object(u.a)(e,"image","rotateWithOffset","float32");d.b(4===r.rank,()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(r.rank,"."));const s={image:r},i={radians:t,fillValue:n,center:a},o=c.a.runKernel(l.yc,s,i);return o}});function Oa(e,t,n,a,r,s){null==a&&(a=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==s&&(s=0);const i=e.shape[0];return n=Math.min(n,i),d.b(0<=a&&a<=1,()=>"iouThreshold must be in [0, 1], but was '".concat(a,"'")),d.b(2===e.rank,()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'")),d.b(4===e.shape[1],()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1])),d.b(1===t.rank,()=>"scores must be a 1D tensor"),d.b(t.shape[0]===i,()=>"scores has incompatible shape with boxes. Expected ".concat(i,", ")+"but was ".concat(t.shape[0])),d.b(0<=s&&s<=1,()=>"softNmsSigma must be in [0, 1], but was '".concat(s,"'")),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s}}const Ca=Object(h.b)({nonMaxSuppression_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=Object(u.a)(e,"boxes","nonMaxSuppression","float32"),i=Object(u.a)(t,"scores","nonMaxSuppression","float32"),o=Oa(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;const d={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return c.a.runKernel(l.Zb,{boxes:s,scores:i},d)}});var Ea=n(70);const _a=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=Object(u.a)(e,"boxes","nonMaxSuppressionAsync"),i=Object(u.a)(t,"scores","nonMaxSuppressionAsync"),o=Oa(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;const c=await Promise.all([s.data(),i.data()]),l=c[0],d=c[1],{selectedIndices:h}=Object(Ea.a)(l,d,n,a,r);return s!==e&&s.dispose(),i!==t&&i.dispose(),An(h,"int32")};const Aa=Object(h.b)({nonMaxSuppressionWithScore_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=Object(u.a)(e,"boxes","nonMaxSuppression"),o=Object(u.a)(t,"scores","nonMaxSuppression"),d=Oa(i,o,n,a,r,s);n=d.maxOutputSize,a=d.iouThreshold,r=d.scoreThreshold,s=d.softNmsSigma;const h={boxes:i,scores:o},p={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s},f=c.a.runKernel(l.bc,h,p);return{selectedIndices:f[0],selectedScores:f[1]}}});const Ra=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=Object(u.a)(e,"boxes","nonMaxSuppressionAsync"),o=Object(u.a)(t,"scores","nonMaxSuppressionAsync"),c=Oa(i,o,n,a,r,s);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,s=c.softNmsSigma;const l=await Promise.all([i.data(),o.data()]),d=l[0],h=l[1],{selectedIndices:p,selectedScores:f}=Object(Ea.c)(d,h,n,a,r,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:An(p,"int32"),selectedScores:An(f)}};const Da=Object(h.b)({nonMaxSuppressionPadded_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=Object(u.a)(e,"boxes","nonMaxSuppression"),o=Object(u.a)(t,"scores","nonMaxSuppression"),d=Oa(i,o,n,a,r,null),h=d.maxOutputSize,p=d.iouThreshold,f=d.scoreThreshold,m={boxes:i,scores:o},g={maxOutputSize:h,iouThreshold:p,scoreThreshold:f,padToMaxOutputSize:s},b=c.a.runKernel(l.ac,m,g);return{selectedIndices:b[0],validOutputs:b[1]}}});const Fa=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=Object(u.a)(e,"boxes","nonMaxSuppressionAsync"),o=Object(u.a)(t,"scores","nonMaxSuppressionAsync"),c=Oa(i,o,n,a,r,null),l=c.maxOutputSize,d=c.iouThreshold,h=c.scoreThreshold,[p,f]=await Promise.all([i.data(),o.data()]),{selectedIndices:m,validOutputs:g}=Object(Ea.b)(p,f,l,d,h,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:An(m,"int32"),validOutputs:Object(tn.a)(g,"int32")}};var Ma=n(173),ja=n(172);function za(e,t){let n,a,r,s,i,c,l=An([-1]),u=An([0]),d=An([0]);for(let h=0;h<e.size-1;h++){n=Object(R.a)(e,0,h+1),a=Object(R.a)(e,h+1),i=Object(pe.a)(Object(On.a)(n),t),c=Object(pe.a)(Object(On.a)(a),t);const p=Object(On.a)(Object(_.a)(n,Vt(0,n.size)));r=Object(pe.a)(p,Object(On.a)(n));const f=Object(Te.a)(a.shape,n.size),m=Object(o.a)(Vt(0,a.size),f),g=Object(_.a)(a,m);s=Object(pe.a)(Object(On.a)(g),Object(On.a)(a));const b=Object(pt.a)(r,s),y=Object(pt.a)(r,s),v=Object(_.a)(i,c);d=Object(_.a)(Object(_.a)(v,b),y);const x=Object(_e.a)(d,u);u=Object(Gn.a)(x,d,u),l=Object(Gn.a)(x,An([h]),l)}return l}const La=Object(h.b)({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Object(u.a)(e,"image","threshold"),s=.2989,i=.587,c=.114,l=r.shape[0]*r.shape[1];let h,p,f,m,g=Object(_.a)(An([a]),255);if(d.b(3===r.rank,()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(r.rank,".")),d.b(3===r.shape[2]||1===r.shape[2],()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(r.shape[2],".")),d.b("int32"===r.dtype||"float32"===r.dtype,()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(r.dtype,".")),d.b("otsu"===t||"binary"===t,()=>"Method must be binary or otsu, but was ".concat(t)),3===r.shape[2]){[h,p,f]=Object(xn.a)(r,[1,1,1],-1);const e=Object(_.a)(h,s),t=Object(_.a)(p,i),n=Object(_.a)(f,c);m=Object(o.a)(Object(o.a)(e,t),n)}else m=e;if("otsu"===t){g=za(B(Object(N.a)(Object($t.a)(m),"int32"),Object(En.a)([]),256),l)}const b=n?Object(Le.a)(m,g):Object(_e.a)(m,g),y=Object(N.a)(Object(_.a)(b,255),"int32");return y}});const Pa=Object(h.b)({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const i=Object(u.a)(e,"image","transform","float32"),o=Object(u.a)(t,"transforms","transform","float32");d.b(4===i.rank,()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(i.rank,".")),d.b(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),d.b(null==s||2===s.length,()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(s,"."));const h={image:i,transforms:o},p={interpolation:n,fillMode:a,fillValue:r,outputShape:s};return c.a.runKernel(l.hd,h,p)}});const Ba=Object(h.b)({bandPart_:function(e,t,n){Object(d.b)(t%1===0,()=>"bandPart(): numLower must be an integer, got ".concat(t,".")),Object(d.b)(n%1===0,()=>"bandPart(): numUpper must be an integer, got ".concat(n,"."));const a=Object(u.a)(e,"a","bandPart");Object(d.b)(a.rank>=2,()=>"bandPart(): Rank must be at least 2, got ".concat(a.rank,"."));const r=a.shape,[s,i]=a.shape.slice(-2);if(!(t<=s))throw new Error("bandPart(): numLower (".concat(t,")")+" must not be greater than the number of rows (".concat(s,")."));if(!(n<=i))throw new Error("bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(i,")."));t<0&&(t=s),n<0&&(n=i);const o=Object(T.a)(Vt(0,s,1,"int32"),[-1,1]),c=Vt(0,i,1,"int32"),l=Object(pt.a)(o,c),h=Object(qe.a)(Object(Le.a)(l,Object(tn.a)(+t,"int32")),Object(Ae.a)(l,Object(tn.a)(-n,"int32"))),p=Object(Kn.a)([s,i],a.dtype);return Object(T.a)(Object(Sn.a)(Object(Wn.a)(Object(T.a)(a,[-1,s,i])).map(e=>Object(Gn.a)(h,e,p))),r)}});const Wa=Object(h.b)({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Object(d.b)(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=e[0].shape[0];for(let t=1;t<e.length;++t)Object(d.b)(e[t].shape[0]===n,()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(e[t].shape[0]," vs. ").concat(n,")"))}else t=!0,e=Object(xn.a)(e,e.shape[0],0).map(e=>Object(In.a)(e,[0]));Object(d.b)(e.length<=e[0].shape[0],()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds ")+"number of dimensions (".concat(e[0].shape[0],")."));const n=[],a=e;for(let r=0;r<e.length;++r)n.push(c.a.tidy(()=>{let e=a[r];if(r>0)for(let t=0;t<r;++t){const a=Object(_.a)(Object(On.a)(Object(_.a)(n[t],e)),n[t]);e=Object(pt.a)(e,a)}return Object(pe.a)(e,Object(Jn.a)(e,"euclidean"))}));return t?Object(Sn.a)(n,0):n}});var Ua=n(24);function Va(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return c.a.tidy(()=>{Object(d.b)(2===e.shape.length,()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor."));const n=e.shape[0],a=e.shape[1];let r=Ne(n),s=Object(q.a)(e);const i=Rn([[1]],[1,1]);let o=Object(q.a)(i);const l=n>=a?a:n;for(let e=0;e<l;++e){const t=s,l=o,u=r;[o,s,r]=c.a.tidy(()=>{const t=Object(R.a)(s,[e,e],[n-e,1]),c=Object(Jn.a)(t),l=Object(R.a)(s,[e,e],[1,1]),u=Object(Gn.a)(Object(_e.a)(l,0),Rn([[-1]]),Rn([[1]])),d=Object(pt.a)(l,Object(_.a)(u,c)),h=Object(pe.a)(t,d);o=1===h.shape[0]?Object(q.a)(i):Object(C.a)([i,Object(R.a)(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=Object(bt.a)(Object(pe.a)(Object(E.a)(u,d),c)),f=Object(R.a)(s,[e,0],[n-e,a]),m=Object(_.a)(p,o),g=Object(Yn.a)(o);if(0===e)s=Object(pt.a)(f,Object(E.a)(m,Object(E.a)(g,f)));else{const t=Object(pt.a)(f,Object(E.a)(m,Object(E.a)(g,f)));s=Object(C.a)([Object(R.a)(s,[0,0],[e,a]),t],0)}const b=Object(Yn.a)(m),y=Object(R.a)(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=Object(pt.a)(y,Object(E.a)(Object(E.a)(y,o),b));else{const t=Object(pt.a)(y,Object(E.a)(Object(E.a)(y,o),b));r=Object(C.a)([Object(R.a)(r,[0,0],[n,e]),t],1)}return[o,s,r]}),Object(Ua.b)([t,l,u])}return!t&&n>a&&(r=Object(R.a)(r,[0,0],[n,a]),s=Object(R.a)(s,[0,0],[a,a])),[r,s]})}const Ga=Object(h.b)({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Object(d.b)(e.rank>=2,()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank)),2===e.rank)return Va(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),a=Object(Wn.a)(Object(T.a)(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];a.forEach(e=>{const[n,a]=Va(e,t);r.push(n),s.push(a)});return[Object(T.a)(Object(Sn.a)(r,0),e.shape),Object(T.a)(Object(Sn.a)(s,0),e.shape)]}}});var Ha=n(32);const qa=Object(h.b)({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ha.a.SUM_BY_NONZERO_WEIGHTS;const a=Object(u.a)(e,"losses","computeWeightedLoss");let r=null;null!=t&&(r=Object(u.a)(t,"weights","computeWeightedLoss"));const s=null==r?a:Object(_.a)(a,r);if(n===Ha.a.NONE)return s;if(n===Ha.a.SUM)return Object(On.a)(s);if(n===Ha.a.MEAN){if(null==r)return Object(at.a)(s);{const e=a.size/r.size,t=Object(pe.a)(Object(On.a)(s),Object(On.a)(r));return e>1?Object(pe.a)(t,Object(tn.a)(e)):t}}if(n===Ha.a.SUM_BY_NONZERO_WEIGHTS){if(null==r)return Object(pe.a)(Object(On.a)(s),Object(tn.a)(a.size));{const e=Object(_.a)(r,Object(rt.a)(a.shape)),t=Object(N.a)(Object(On.a)(Object(yt.a)(e,Object(tn.a)(0))),"float32");return Object(pe.a)(Object(On.a)(s),t)}}throw Error("Unknown reduction: ".concat(n))}});const Ka=Object(h.b)({absoluteDifference_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Ha.a.SUM_BY_NONZERO_WEIGHTS;const s=Object(u.a)(e,"labels","absoluteDifference"),i=Object(u.a)(t,"predictions","absoluteDifference");let o=null;null!=n&&(o=Object(u.a)(n,"weights","absoluteDifference")),Object(d.e)(s.shape,i.shape,"Error in absoluteDifference: ");const c=Object(r.a)(Object(pt.a)(s,i));return qa(c,o,a)}});const Xa=Object(h.b)({cosineDistance_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Ha.a.SUM_BY_NONZERO_WEIGHTS;const s=Object(u.a)(e,"labels","cosineDistance"),i=Object(u.a)(t,"predictions","cosineDistance");let o=null;null!=a&&(o=Object(u.a)(a,"weights","cosineDistance")),Object(d.e)(s.shape,i.shape,"Error in cosineDistance: ");const c=Object(tn.a)(1),l=Object(pt.a)(c,Object(On.a)(Object(_.a)(s,i),n,!0));return qa(l,o,r)}});const Za=Object(h.b)({hingeLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Ha.a.SUM_BY_NONZERO_WEIGHTS,r=Object(u.a)(e,"labels","hingeLoss");const s=Object(u.a)(t,"predictions","hingeLoss");let i=null;null!=n&&(i=Object(u.a)(n,"weights","hingeLoss")),Object(d.e)(r.shape,s.shape,"Error in hingeLoss: ");const o=Object(tn.a)(1);r=Object(pt.a)(Object(_.a)(Object(tn.a)(2),r),o);const c=Object(qt.a)(Object(pt.a)(o,Object(_.a)(r,s)));return qa(c,i,a)}});const Ya=Object(h.b)({huberLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Ha.a.SUM_BY_NONZERO_WEIGHTS;const i=Object(u.a)(e,"labels","huberLoss"),c=Object(u.a)(t,"predictions","huberLoss");let l=null;null!=n&&(l=Object(u.a)(n,"weights","huberLoss")),Object(d.e)(i.shape,c.shape,"Error in huberLoss: ");const h=Object(tn.a)(a),p=Object(r.a)(Object(pt.a)(c,i)),f=Object(ct.a)(p,h),m=Object(pt.a)(p,f),g=Object(o.a)(Object(_.a)(Object(tn.a)(.5),Object(ht.a)(f)),Object(_.a)(h,m));return qa(g,l,s)}});const Ja=Object(h.b)({logLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Ha.a.SUM_BY_NONZERO_WEIGHTS;const s=Object(u.a)(e,"labels","logLoss"),i=Object(u.a)(t,"predictions","logLoss");let c=null;null!=n&&(c=Object(u.a)(n,"weights","logLoss")),Object(d.e)(s.shape,i.shape,"Error in logLoss: ");const l=Object(tn.a)(1),h=Object(tn.a)(a),p=Object(bt.a)(Object(_.a)(s,Object(We.a)(Object(o.a)(i,h)))),f=Object(_.a)(Object(pt.a)(l,s),Object(We.a)(Object(o.a)(Object(pt.a)(l,i),h))),m=Object(pt.a)(p,f);return qa(m,c,r)}});const Qa=Object(h.b)({meanSquaredError_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Ha.a.SUM_BY_NONZERO_WEIGHTS;const r=Object(u.a)(e,"labels","meanSquaredError"),s=Object(u.a)(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=Object(u.a)(n,"weights","meanSquaredError")),Object(d.e)(r.shape,s.shape,"Error in meanSquaredError: ");const o=Object(kn.a)(r,s);return qa(o,i,a)}});function $a(e,t){const n=Object(u.a)(e,"labels","sigmoidCrossEntropyWithLogits"),a=Object(u.a)(t,"logits","sigmoidCrossEntropyWithLogits");Object(d.e)(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Object(qt.a)(a),i=Object(_.a)(a,n),c=Object(Ue.a)(Object(we.a)(Object(bt.a)(Object(r.a)(a))));return Object(o.a)(Object(pt.a)(s,i),c)}const er=Object(h.b)({sigmoidCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Ha.a.SUM_BY_NONZERO_WEIGHTS,s=Object(u.a)(e,"multiClassLabels","sigmoidCrossEntropy");const i=Object(u.a)(t,"logits","sigmoidCrossEntropy");let c=null;if(null!=n&&(c=Object(u.a)(n,"weights","sigmoidCrossEntropy")),Object(d.e)(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),a>0){const e=Object(tn.a)(a),t=Object(tn.a)(1),n=Object(tn.a)(.5);s=Object(o.a)(Object(_.a)(s,Object(pt.a)(t,e)),Object(_.a)(n,e))}const l=$a(s,i);return qa(l,c,r)}});function tr(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet "+"supported. Labels / logits was rank ".concat(t.rank," ")+"and dim was ".concat(n));const a=Object(la.a)((e,t,a)=>{const r=Object(He.a)(t,[n],!0),s=Object(pt.a)(Object(N.a)(t,"float32"),r);a([e,s]);const i=Object(bt.a)(Object(_.a)(s,e));return{value:Object(On.a)(i,[n]),gradFunc:(e,t)=>{const[a,r]=t,s=Object(dt.e)(e.shape,[n]);return[Object(_.a)(Object(T.a)(e,s),Object(pt.a)(Object(N.a)(a,"float32"),Object(we.a)(r))),Object(_.a)(Object(T.a)(e,s),Object(pt.a)(Object(we.a)(r),Object(N.a)(a,"float32")))]}}});return a(e,t)}const nr=Object(h.b)({softmaxCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Ha.a.SUM_BY_NONZERO_WEIGHTS,s=Object(u.a)(e,"onehotLabels","softmaxCrossEntropy");const i=Object(u.a)(t,"logits","softmaxCrossEntropy");let c=null;if(null!=n&&(c=Object(u.a)(n,"weights","softmaxCrossEntropy")),Object(d.e)(s.shape,i.shape,"Error in softmaxCrossEntropy: "),a>0){const e=Object(tn.a)(a),t=Object(tn.a)(1),n=Object(tn.a)(s.shape[1]);s=Object(o.a)(Object(_.a)(s,Object(pt.a)(t,e)),Object(pe.a)(e,n))}const l=tr(s,i);return qa(l,c,r)}});const ar=Object(h.b)({sparseFillEmptyRows_:function(e,t,n,a){const r=Object(u.a)(e,"indices","sparseFillEmptyRows","int32"),s=Object(u.a)(t,"values","sparseFillEmptyRows"),i=Object(u.a)(n,"denseShape","sparseFillEmptyRows","int32"),o=Object(u.a)(a,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==r.rank)throw new Error("Indices should be Tensor2D but received shape\n        ".concat(r.shape));if(1!==s.rank)throw new Error("Values should be Tensor1D but received shape ".concat(s.shape));if(1!==i.rank)throw new Error("Dense shape should be Tensor1D but received shape ".concat(i.shape));if(0!==o.rank)throw new Error("Default value should be a scalar but received shape ".concat(o.shape));const d={indices:r,values:s,denseShape:i,defaultValue:o},h=c.a.runKernel(l.Nc,d);return{outputIndices:h[0],outputValues:h[1],emptyRowIndicator:h[2],reverseIndexMap:h[3]}}});const rr=Object(h.b)({sparseReshape_:function(e,t,n){const a=Object(u.a)(e,"inputIndices","sparseReshape","int32"),r=Object(u.a)(t,"inputShape","sparseReshape","int32"),s=Object(u.a)(n,"newShape","sparseReshape","int32");if(2!==a.rank)throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(a.shape));if(1!==r.rank)throw new Error("Input shape should be Tensor1D but received shape ".concat(r.shape));if(1!==s.rank)throw new Error("New shape should be Tensor1D but received shape ".concat(s.shape));const i={inputIndices:a,inputShape:r,newShape:s},o=c.a.runKernel(l.Oc,i);return{outputIndices:o[0],outputShape:o[1]}}});const sr=Object(h.b)({sparseSegmentMean_:function(e,t,n){const a=Object(u.a)(e,"data","sparseSegmentMean"),r=Object(u.a)(t,"indices","sparseSegmentMean","int32"),s=Object(u.a)(n,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error("Indices should be Tensor1D but received shape\n          ".concat(r.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(s.shape));const i={data:a,indices:r,segmentIds:s};return c.a.runKernel(l.Pc,i)}});const ir=Object(h.b)({sparseSegmentSum_:function(e,t,n){const a=Object(u.a)(e,"data","sparseSegmentSum"),r=Object(u.a)(t,"indices","sparseSegmentSum","int32"),s=Object(u.a)(n,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error("Indices should be Tensor1D but received shape\n         ".concat(r.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(s.shape));const i={data:a,indices:r,segmentIds:s};return c.a.runKernel(l.Qc,i)}});const or=Object(h.b)({stringNGrams_:function(e,t,n,a,r,s,i,o){const d=Object(u.a)(e,"data","stringNGrams","string");if("string"!==d.dtype)throw new Error("Data must be of datatype string");if(1!==d.shape.length)throw new Error("Data must be a vector, saw: ".concat(d.shape));const h=Object(u.a)(t,"dataSplits","stringNGrams");if("int32"!==h.dtype)throw new Error("Data splits must be of datatype int32");const p={separator:n,nGramWidths:a,leftPad:r,rightPad:s,padWidth:i,preserveShortSequences:o},f={data:d,dataSplits:h},m=c.a.runKernel(l.Yc,f,p);return{nGrams:m[0],nGramsSplits:m[1]}}});const cr=Object(h.b)({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=Object(u.a)(e,"input","stringSplit","string"),r=Object(u.a)(t,"delimiter","stringSplit","string");if(1!==a.rank)throw new Error("Input should be Tensor1D but received shape ".concat(a.shape));if(0!==r.rank)throw new Error("Delimiter should be a scalar but received shape ".concat(r.shape));const s={skipEmpty:n},i={input:a,delimiter:r},o=c.a.runKernel(l.Zc,i,s);return{indices:o[0],values:o[1],shape:o[2]}}});const lr=Object(h.b)({stringToHashBucketFast_:function(e,t){const n=Object(u.a)(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return c.a.runKernel(l.ad,r,a)}}),ur={fft:gn.a,ifft:bn.a,rfft:vn.a,irfft:yn.a},dr={hammingWindow:va,hannWindow:xa,frame:wa,stft:ka},hr={flipLeftRight:Sa,grayscaleToRGB:Na,resizeNearestNeighbor:ja.a,resizeBilinear:Ma.a,rotateWithOffset:Ta,cropAndResize:Ia,nonMaxSuppression:Ca,nonMaxSuppressionAsync:_a,nonMaxSuppressionWithScore:Aa,nonMaxSuppressionWithScoreAsync:Ra,nonMaxSuppressionPadded:Da,nonMaxSuppressionPaddedAsync:Fa,threshold:La,transform:Pa},pr={bandPart:Ba,gramSchmidt:Wa,qr:Ga},fr={absoluteDifference:Ka,computeWeightedLoss:qa,cosineDistance:Xa,hingeLoss:Za,huberLoss:Ya,logLoss:Ja,meanSquaredError:Qa,sigmoidCrossEntropy:er,softmaxCrossEntropy:nr},mr={sparseFillEmptyRows:ar,sparseReshape:rr,sparseSegmentMean:sr,sparseSegmentSum:ir},gr={stringNGrams:or,stringSplit:cr,stringToHashBucketFast:lr}},function(e,t,n){"use strict";n.r(t),n.d(t,"makeTypesMatch",(function(){return i})),n.d(t,"assertTypesMatch",(function(){return o})),n.d(t,"isTensorInList",(function(){return c})),n.d(t,"getTensorsInContainer",(function(){return l}));var a=n(6),r=n(82),s=n(9);function i(e,t){if(e.dtype===t.dtype)return[e,t];const n=Object(r.b)(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function o(e,t){Object(s.b)(e.dtype===t.dtype,()=>"The dtypes of the first(".concat(e.dtype,") and")+" second(".concat(t.dtype,") input must match"))}function c(e,t){return t.some(t=>t.id===e.id)}function l(e){const t=[];return function e(t,n,r){if(null==t)return;if(t instanceof a.a)return void n.push(t);if(s=t,!Array.isArray(s)&&"object"!==typeof s)return;var s;const i=t;for(const a in i){const t=i[a];r.has(t)||(r.add(t),e(t,n,r))}}(e,t,new Set),t}},function(e,t,n){"use strict";n.d(t,"e",(function(){return r})),n.d(t,"f",(function(){return s})),n.d(t,"g",(function(){return i})),n.d(t,"b",(function(){return o})),n.d(t,"c",(function(){return c})),n.d(t,"d",(function(){return l})),n.d(t,"j",(function(){return g})),n.d(t,"i",(function(){return b})),n.d(t,"h",(function(){return y})),n.d(t,"a",(function(){return v}));var a=n(9);function r(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;const i=e[3],c=[...t,i],l=y(r);return o(e,c,n,s,a,null,null,l)}function s(e,t,n,a,r,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[c,l]=u(t);let d;if("channelsLast"===i)d=[c,l,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));d=[c,l,e[1],e[1]]}return o(e,d,n,a,r,s,!1,i)}function i(e,t,n,a,r,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[o,l,u]=d(t);let h,p;if("NDHWC"===i)p="channelsLast",h=[o,l,u,e[4],e[4]];else{if("NCDHW"!==i)throw new Error("Unknown dataFormat ".concat(i));p="channelsFirst",h=[o,l,u,e[1],e[1]]}return c(e,h,n,a,r,!1,p,s)}function o(e,t,n,a,r,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[c,l,d,f]=[-1,-1,-1,-1];if("channelsLast"===o)[c,l,d,f]=e;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));[c,f,l,d]=e}const[m,g,,b]=t,[y,v]=u(n),[x,w]=u(a),k=h(m,x),I=h(g,w),{padInfo:S,outHeight:N,outWidth:T}=p(r,l,d,y,v,k,I,s,o),O=i?b*f:b;let C;return"channelsFirst"===o?C=[c,O,N,T]:"channelsLast"===o&&(C=[c,N,T,O]),{batchSize:c,dataFormat:o,inHeight:l,inWidth:d,inChannels:f,outHeight:N,outWidth:T,outChannels:O,padInfo:S,strideHeight:y,strideWidth:v,filterHeight:m,filterWidth:g,effectiveFilterHeight:k,effectiveFilterWidth:I,dilationHeight:x,dilationWidth:w,inShape:e,outShape:C,filterShape:t}}function c(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[c,l,u,p,m]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[c,l,u,p,m]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[c,m,l,u,p]=e}const[g,b,y,,v]=t,[x,w,k]=d(n),[I,S,N]=d(a),T=h(g,I),O=h(b,S),C=h(y,N),{padInfo:E,outDepth:_,outHeight:A,outWidth:R}=f(r,l,u,p,x,w,k,T,O,C,o),D=s?v*m:v;let F;return"channelsFirst"===i?F=[c,D,_,A,R]:"channelsLast"===i&&(F=[c,_,A,R,D]),{batchSize:c,dataFormat:i,inDepth:l,inHeight:u,inWidth:p,inChannels:m,outDepth:_,outHeight:A,outWidth:R,outChannels:D,padInfo:E,strideDepth:x,strideHeight:w,strideWidth:k,filterDepth:g,filterHeight:b,filterWidth:y,effectiveFilterDepth:T,effectiveFilterHeight:O,effectiveFilterWidth:C,dilationDepth:I,dilationHeight:S,dilationWidth:N,inShape:e,outShape:F,filterShape:t}}function l(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;const r=h(t,a);return Math.floor((e[0]*(n-1)-n+r)/2)}function u(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function d(e){return"number"===typeof e?[e,e,e]:e}function h(e,t){return t<=1?e:e+(e-1)*(t-1)}function p(e,t,n,a,r,s,i,o,c){let u,d,h;if("number"===typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=function(e,t,n,a,r){null==a&&(a=l(e,t,n));const s=e[0],i=e[1];return[m((s-t+2*a)/n+1,r),m((i-t+2*a)/n+1,r)]}([t,n],s,a,e,o);d=r[0],h=r[1]}else if("same"===e){d=Math.ceil(t/a),h=Math.ceil(n/r);const e=Math.max(0,(d-1)*a+s-t),o=Math.max(0,(h-1)*r+i-n),c=Math.floor(e/2),l=e-c,p=Math.floor(o/2);u={top:c,bottom:l,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((t-s+1)/a),h=Math.ceil((n-i+1)/r);else{if("object"!==typeof e)throw Error("Unknown padding parameter: ".concat(e));{const l="channelsLast"===c?e[1][0]:e[2][0],p="channelsLast"===c?e[1][1]:e[2][1],f="channelsLast"===c?e[2][0]:e[3][0],g="channelsLast"===c?e[2][1]:e[3][1];u={top:l,bottom:p,left:f,right:g,type:0===l&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},d=m((t-s+l+p)/a+1,o),h=m((n-i+f+g)/r+1,o)}}return{padInfo:u,outHeight:d,outWidth:h}}function f(e,t,n,a,r,s,i,o,c,u,d){let h,p,f,g;if("number"===typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,a,r,s){null==r&&(r=l(e,t,a));const i=e[0],o=e[1],c=e[2];return[m((i-t+2*r)/a+1,s),m((o-t+2*r)/a+1,s),m((c-t+2*r)/a+1,s),n]}([t,n,a,1],o,1,r,e,d);p=s[0],f=s[1],g=s[2]}else if("same"===e){p=Math.ceil(t/r),f=Math.ceil(n/s),g=Math.ceil(a/i);const e=(p-1)*r+o-t,l=(f-1)*s+c-n,d=(g-1)*i+u-a,m=Math.floor(e/2),b=e-m,y=Math.floor(l/2),v=l-y,x=Math.floor(d/2);h={top:y,bottom:v,left:x,right:d-x,front:m,back:b,type:"SAME"}}else{if("valid"!==e)throw Error("Unknown padding parameter: ".concat(e));h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((t-o+1)/r),f=Math.ceil((n-c+1)/s),g=Math.ceil((a-u+1)/i)}return{padInfo:h,outDepth:p,outHeight:f,outWidth:g}}function m(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function g(e){const[t,n,a]=u(e);return 1===t&&1===n&&1===a}function b(e,t){return g(e)||g(t)}function y(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function v(e,t,n){if(null!=n){if("string"===typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));if("number"===typeof t)a.b(a.v(t),()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));else{if("object"!==typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach(t=>{t.forEach(t=>{a.b(a.v(t),()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."))})})}}}},function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var a=n(5),r=n(2),s=n(4);const i=Object(s.b)({square_:function(e){const t=Object(r.a)(e,"x","square");return a.a.runKernel("Square",{x:t},{})}})},function(e,t,n){"use strict";n.d(t,"c",(function(){return o})),n.d(t,"e",(function(){return c})),n.d(t,"h",(function(){return l})),n.d(t,"b",(function(){return u})),n.d(t,"d",(function(){return d})),n.d(t,"g",(function(){return h})),n.d(t,"f",(function(){return p})),n.d(t,"a",(function(){return f}));var a=n(5),r=n(19),s=n(6),i=n(21);function o(){return a.a}function c(){return a.a.memory()}function l(e,t){return a.a.tidy(e,t)}function u(e){Object(i.getTensorsInContainer)(e).forEach(e=>e.dispose())}function d(e){return a.a.keep(e)}function h(e){return a.a.setBackend(e)}function p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return a.a.registerBackend(e,t,n)}function f(){return a.a.backend}Object(s.e)((function(e){Object(r.b)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}))},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(4);const c=Object(o.b)({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]&&arguments[3],c=Object(i.a)(e,"a","matMul"),l=Object(i.a)(t,"b","matMul");[c,l]=Object(s.makeTypesMatch)(c,l);const u={a:c,b:l},d={transposeA:n,transposeB:o};return a.a.runKernel(r.s,u,d)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({slice_:function(e,t,n){const i=Object(s.a)(e,"x","slice","string_or_numeric");if(0===i.rank)throw new Error("Slicing scalar is not possible");const o={x:i},c={begin:t,size:n};return a.a.runKernel(r.Jc,o,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({neg_:function(e){const t={x:Object(s.a)(e,"x","neg")};return a.a.runKernel(r.Yb,t)}})},function(e,t,n){"use strict";(function(e){n.d(t,"f",(function(){return o})),n.d(t,"e",(function(){return c})),n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return p})),n.d(t,"d",(function(){return f})),n.d(t,"c",(function(){return m})),n.d(t,"j",(function(){return g})),n.d(t,"h",(function(){return b})),n.d(t,"g",(function(){return y})),n.d(t,"i",(function(){return v})),n.d(t,"k",(function(){return x}));var a=n(47),r=n(77),s=n(9),i=n(133);async function o(e,t){const n=[],a=[],r=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let s=0;s<r.length;++s){const i=r[s],o=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error("Unsupported dtype in weight '".concat(i,"': ").concat(o.dtype));const c={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise(async e=>{const t=await o.bytes(),n=t.reduce((e,t)=>e+t.length,0)+4*t.length,a=new Uint8Array(n);let r=0;for(let s=0;s<t.length;s++){const e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);a.set(n,r),r+=4,a.set(e,r),r+=e.length}e(a)});a.push(e)}else a.push(o.data());null!=t&&(c.group=t),n.push(c)}return{data:l(await Promise.all(a)),specs:n}}function c(e,t){const n={};let o,c=0;for(const l of t){const t=l.name,u=l.dtype,d=l.shape,h=Object(s.O)(d);let p;if("quantization"in l){const n=l.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error("Weight ".concat(l.name," with quantization ").concat(n.dtype," ")+"doesn't have corresponding metadata min and scale.")}else{if("float16"!==n.dtype)throw new Error("Weight ".concat(l.name," has unknown ")+"quantization dtype ".concat(n.dtype,". ")+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");if("float32"!==u)throw new Error("Weight ".concat(l.name," is quantized with ").concat(n.dtype," ")+"which only supports weights of type float32 not ".concat(u,"."))}const a=i.a[n.dtype],r=e.slice(c,c+h*a),s="uint8"===n.dtype?new Uint8Array(r):new Uint16Array(r);if("float32"===u)if("uint8"===n.dtype||"uint16"===n.dtype){p=new Float32Array(s.length);for(let e=0;e<s.length;e++){const t=s[e];p[e]=t*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error("Unsupported quantization type ".concat(n.dtype," ")+"for weight type float32.");void 0===o&&(o=w()),p=o(s)}else{if("int32"!==u)throw new Error("Unsupported dtype in weight '".concat(t,"': ").concat(u));if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error("Unsupported quantization type ".concat(n.dtype," ")+"for weight type int32.");p=new Int32Array(s.length);for(let e=0;e<s.length;e++){const t=s[e];p[e]=Math.round(t*n.scale+n.min)}}c+=h*a}else if("string"===u){const t=Object(s.O)(l.shape);p=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(c,c+4))[0];c+=4;const n=new Uint8Array(e.slice(c,c+t));p.push(n),c+=t}}else{const s=i.a[u],o=e.slice(c,c+h*s);if("float32"===u)p=new Float32Array(o);else if("int32"===u)p=new Int32Array(o);else if("bool"===u)p=new Uint8Array(o);else{if("complex64"!==u)throw new Error("Unsupported dtype in weight '".concat(t,"': ").concat(u));{p=new Float32Array(o);const e=new Float32Array(p.length/2),s=new Float32Array(p.length/2);for(let t=0;t<e.length;t++)e[t]=p[2*t],s[t]=p[2*t+1];const i=Object(r.a)(e,d,"float32"),c=Object(r.a)(s,d,"float32");n[t]=Object(a.a)(i,c),i.dispose(),c.dispose()}}c+=h*s}"complex64"!==u&&(n[t]=Object(r.a)(p,d,u))}return n}function l(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0;const n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))});const a=new Uint8Array(t);let r=0;return n.forEach(e=>{a.set(new Uint8Array(e.buffer),r),r+=e.byteLength}),a.buffer}const u="undefined"!==typeof e&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function d(t){return u?e.byteLength(t):new Blob([t]).size}function h(t){if(u)return e.from(t).toString("base64");const n=new Uint8Array(t);let a="";for(let e=0,r=n.length;e<r;e++)a+=String.fromCharCode(n[e]);return btoa(a)}function p(t){if(u){const n=e.from(t,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const n=atob(t),a=new Uint8Array(n.length);for(let e=0;e<n.length;++e)a.set([n.charCodeAt(e)],e);return a.buffer}function f(e){if(1===e.length)return e[0];let t=0;e.forEach(e=>{t+=e.byteLength});const n=new Uint8Array(t);let a=0;return e.forEach(e=>{n.set(new Uint8Array(e),a),a+=e.byteLength}),n.buffer}function m(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function g(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function b(e,t,n){const a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(a.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),a}async function y(e,t){let n,a;return null!=e.weightsManifest&&([n,a]=await t(e.weightsManifest)),b(e,n,a)}function v(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:d(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:d(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function x(e){const t=[];for(const n of e)t.push(...n.weights);return t}function w(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return a=>{const r=new ArrayBuffer(4*a.length),s=new Uint32Array(r);for(let i=0;i<a.length;i++){const r=a[i],o=e[n[r>>10]+(1023&r)]+t[r>>10];s[i]=o}return new Float32Array(r)}}}).call(this,n(128).Buffer)},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(62),c=n(4);const l=Object(c.b)({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Object(i.b)(e.length>=1,()=>"Pass at least one tensor to concat");const n=Object(s.b)(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))}),1===n.length)return Object(o.a)(n[0]);const c=n,l={axis:t};return a.a.runKernel(r.C,c,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(2),i=n(94),o=n(15),c=n(4);const l=Object(c.b)({where_:function(e,t,n){const c=Object(s.a)(t,"a","where"),l=Object(s.a)(n,"b","where"),u=Object(s.a)(e,"condition","where","bool"),d=Object(o.assertAndGetBroadcastShape)(Object(o.assertAndGetBroadcastShape)(u.shape,c.shape),l.shape),h={condition:Object(i.a)(u,d),t:Object(i.a)(c,d),e:Object(i.a)(l,d)};return a.a.runKernel(r.Dc,h)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o})),n.d(t,"b",(function(){return i}));var a=n(5),r=n(6),s=(n(2),n(9));function i(e,t){s.b(s.u(e),()=>"The f passed in variableGrads(f) must be a function"),s.b(null==t||Array.isArray(t)&&t.every(e=>e instanceof r.c),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=t;if(!n){t=[];for(const e in a.a.registeredVariables)t.push(a.a.registeredVariables[e])}const i=n?t.filter(e=>!e.trainable):null,o=t.length;t=t.filter(e=>e.trainable),s.b(t.length>0,()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(o," variables is ")+"trainable.");const{value:c,grads:l}=a.a.gradients(e,t,null,!0);s.b(l.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),s.b(0===c.rank,()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(c.rank," tensor"));const u={};return t.forEach((e,t)=>{null!=l[t]&&(u[e.name]=l[t])}),null!=i&&i.forEach(e=>u[e.name]=null),{value:c,grads:u}}function o(e){return a.a.customGrad(e)}},function(e,t,n){"use strict";var a;n.d(t,"a",(function(){return a})),function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(a||(a={}))},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({sqrt_:function(e){const t={x:Object(s.a)(e,"x","sqrt","float32")};return a.a.runKernel(r.Tc,t)}})},function(e,t,n){"use strict";n.d(t,"b",(function(){return r})),n.d(t,"c",(function(){return s})),n.d(t,"d",(function(){return i})),n.d(t,"e",(function(){return o})),n.d(t,"a",(function(){return c})),n.d(t,"f",(function(){return l})),n.d(t,"h",(function(){return u})),n.d(t,"g",(function(){return d}));var a=n(9);function r(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function s(e,t,n){const a=e.length+t.length,r=[];let s=0,i=0;for(let o=0;o<a;o++)-1===n.indexOf(o)?r.push(e[s++]):r.push(t[i++]);return r}function i(e,t){const n=[],a=e.length;for(let r=0;r<a;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map(t=>e[t])]}function o(e,t){return s(e,t.map(e=>1),t)}function c(e,t,n){a.b(r(t,n),()=>"".concat(e," supports only inner-most axes for now. ")+"Got axes ".concat(t," and rank-").concat(n," input."))}function l(e,t){if(r(e,t))return null;const n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach(e=>n.push(e)),n}function u(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function d(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({exp_:function(e){const t={x:Object(s.a)(e,"x","exp")};return a.a.runKernel(r.cb,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return a})),n.d(t,"e",(function(){return r})),n.d(t,"d",(function(){return s})),n.d(t,"c",(function(){return i})),n.d(t,"b",(function(){return o}));class a{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==a.instance&&(a.instance=new a),a.instance}static registerSaveRouter(e){a.getInstance().saveRouters.push(e)}static registerLoadRouter(e){a.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return a.getHandlers(e,"save")}static getLoadHandlers(e,t){return a.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?a.getInstance().loadRouters:a.getInstance().saveRouters).forEach(t=>{const a=t(e,n);null!==a&&r.push(a)}),r}}const r=e=>a.registerSaveRouter(e),s=e=>a.registerLoadRouter(e),i=e=>a.getSaveHandlers(e),o=(e,t)=>a.getLoadHandlers(e,t)},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(15),c=n(4);const l=Object(c.b)({greater_:function(e,t){let n=Object(i.a)(e,"a","greater","string_or_numeric"),c=Object(i.a)(t,"b","greater","string_or_numeric");[n,c]=Object(s.makeTypesMatch)(n,c),Object(o.assertAndGetBroadcastShape)(n.shape,c.shape);const l={a:n,b:c};return a.a.runKernel(r.qb,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({abs_:function(e){const t=Object(s.a)(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return a.a.runKernel(r.B,e)}{const e={x:t};return a.a.runKernel(r.a,e)}}})},function(e,t,n){"use strict";n.d(t,"c",(function(){return f})),n.d(t,"b",(function(){return m})),n.d(t,"a",(function(){return g})),n.d(t,"d",(function(){return b}));var a=n(15),r=n(109),s=n(111),i=n(8),o=n(118),c=n(73),l=n(119),u=n(7),d=n(63),h=n(74),p=n(16);function f(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Object(i.a)(e,Object(h.a)(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function m(e,t){let n=t;const r=a.getReductionAxes(e.shape,t.shape);return r.length>0&&(n=Object(p.a)(n,r)),Object(u.a)(n,e.shape)}function g(e,t,n,a){if("linear"===t)return e;if("relu"===t)return Object(c.a)(e);if("elu"===t)return Object(r.a)(e);if("relu6"===t)return Object(l.a)(e);if("prelu"===t)return Object(o.a)(e,n);if("leakyrelu"===t)return Object(s.a)(e,a);if("sigmoid"===t)return Object(d.a)(e);throw new Error("Unknown fused activation ".concat(t,"."))}const b=(e,t)=>!(e>0)||"linear"===t},function(e,t,n){"use strict";n.d(t,"f",(function(){return u})),n.d(t,"e",(function(){return d})),n.d(t,"d",(function(){return h})),n.d(t,"g",(function(){return p})),n.d(t,"a",(function(){return f})),n.d(t,"b",(function(){return N})),n.d(t,"c",(function(){return a}));var a,r=n(0),s=n(78),i=n(66);function o(e){return e instanceof r.gd?{value:e.clone(),recurse:!1}:Object(i.e)(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class c{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class l extends c{constructor(){super(l.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let a=0;a<n;a++)t[a]=this.get(this.wrap(this.begin+a));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function u(e){return new m(e)}function d(e){return new g(e)}function h(e,t){return new O(e,t)}function p(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:a.FAIL;return new C(e,t)}l.INITIAL_CAPACITY=32;class f{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new I(this,e)}filter(e){return new w(this,e)}map(e){return new k(this,e)}mapAsync(e){return new S(this,e)}serialMapAsync(e){return new S(this,e).serial()}flatmap(e){return new T(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(e=>!0===e)}rowMajorBatch(e){return new x(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.f;return this.rowMajorBatch(e,t).map(e=>Object(i.d)(e,n))}concatenate(e,t){return new O(u([this,e]),t)}take(e){return e<0||null==e?this:new v(this,e)}skip(e){return e<0||null==e?this:new y(this,e)}prefetch(e){return new E(this,e)}shuffle(e,t){return new _(this,e,t)}serial(){return new b(this)}}class m extends f{constructor(e){super(),this.items=e,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:(t=e,Object(i.b)(t,o)),done:!1};var t}}class g extends f{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message="Error thrown while iterating through a dataset: ".concat(e.message),e}}}class b extends f{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class y extends f{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;r.Wd(e.value)}return this.upstream.next()}}class v extends f{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class x extends f{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class w extends f{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;r.Wd(e.value)}}}class k extends f{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=r.vf.getTensorsInContainer(e.value),n=this.transform(e.value),a=r.vf.getTensorsInContainer(n);for(const s of t)r.vf.isTensorInList(s,a)||s.dispose();return{value:n,done:!1}}}class I extends f{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class S extends f{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=r.vf.getTensorsInContainer(e.value),n=await this.transform(e.value),a=r.vf.getTensorsInContainer(n);for(const s of t)r.vf.isTensorInList(s,a)||s.dispose();return{value:n,done:!1}}}class N extends f{constructor(){super(),this.outputQueue=new l,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class T extends N{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=r.vf.getTensorsInContainer(e.value),n=this.transform(e.value),a=r.vf.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(const s of t)r.vf.isTensorInList(s,a)||s.dispose();return!0}}class O extends f{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(a||(a={}));class C extends f{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:a.FAIL;super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{".concat("TODO: fill in upstream of zip summaries","} -> Zip")}async nextState(e){await e;let t=0,n=0;const r=await Object(i.c)(this.iterators,(function(e){if(e instanceof f){return{value:e.next().then(e=>(t++,e.done&&n++,e.value)),recurse:!1}}return{value:null,recurse:!0}}));if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case a.FAIL:throw new Error("Zipped streams should have the same length. "+"Mismatched at element ".concat(this.count,"."));case a.SHORTEST:return{value:null,done:!0};case a.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class E extends f{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new c(t)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class _ extends E{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=s.alea(n||r.Df.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}},function(e,t,n){"use strict";e.exports=n(228)},function(e,t,n){"use strict";n.d(t,"c",(function(){return s.me})),n.d(t,"b",(function(){return s.Wd})),n.d(t,"a",(function(){return s.Fd})),n.d(t,"d",(function(){return wu}));var a={};n.r(a),n.d(a,"abs",(function(){return Fl.b})),n.d(a,"acos",(function(){return Fl.c})),n.d(a,"acosh",(function(){return Fl.d})),n.d(a,"add",(function(){return Fl.e})),n.d(a,"addN",(function(){return Fl.f})),n.d(a,"all",(function(){return Fl.g})),n.d(a,"any",(function(){return Fl.h})),n.d(a,"argMax",(function(){return Fl.i})),n.d(a,"argMin",(function(){return Fl.j})),n.d(a,"asin",(function(){return Fl.k})),n.d(a,"asinh",(function(){return Fl.l})),n.d(a,"atan",(function(){return Fl.m})),n.d(a,"atan2",(function(){return Fl.n})),n.d(a,"atanh",(function(){return Fl.o})),n.d(a,"avgPool",(function(){return Fl.p})),n.d(a,"avgPool3d",(function(){return Fl.q})),n.d(a,"basicLSTMCell",(function(){return Fl.r})),n.d(a,"batchToSpaceND",(function(){return Fl.w})),n.d(a,"batchNorm",(function(){return Fl.s})),n.d(a,"batchNorm2d",(function(){return Fl.t})),n.d(a,"batchNorm3d",(function(){return Fl.u})),n.d(a,"batchNorm4d",(function(){return Fl.v})),n.d(a,"bincount",(function(){return Fl.x})),n.d(a,"broadcastArgs",(function(){return Fl.z})),n.d(a,"broadcastTo",(function(){return Fl.A})),n.d(a,"buffer",(function(){return Fl.B})),n.d(a,"cast",(function(){return Fl.C})),n.d(a,"ceil",(function(){return Fl.D})),n.d(a,"clipByValue",(function(){return Fl.E})),n.d(a,"clone",(function(){return Fl.F})),n.d(a,"complex",(function(){return Fl.G})),n.d(a,"concat",(function(){return Fl.H})),n.d(a,"concat1d",(function(){return Fl.I})),n.d(a,"concat2d",(function(){return Fl.J})),n.d(a,"concat3d",(function(){return Fl.K})),n.d(a,"concat4d",(function(){return Fl.L})),n.d(a,"conv1d",(function(){return Fl.M})),n.d(a,"conv2d",(function(){return Fl.N})),n.d(a,"conv2dTranspose",(function(){return Fl.O})),n.d(a,"conv3d",(function(){return Fl.P})),n.d(a,"conv3dTranspose",(function(){return Fl.Q})),n.d(a,"cos",(function(){return Fl.R})),n.d(a,"cosh",(function(){return Fl.S})),n.d(a,"cumprod",(function(){return Fl.U})),n.d(a,"cumsum",(function(){return Fl.V})),n.d(a,"denseBincount",(function(){return Fl.W})),n.d(a,"depthToSpace",(function(){return Fl.X})),n.d(a,"depthwiseConv2d",(function(){return Fl.Y})),n.d(a,"diag",(function(){return Fl.Z})),n.d(a,"dilation2d",(function(){return Fl.ab})),n.d(a,"div",(function(){return Fl.bb})),n.d(a,"divNoNan",(function(){return Fl.cb})),n.d(a,"dot",(function(){return Fl.db})),n.d(a,"einsum",(function(){return Fl.fb})),n.d(a,"elu",(function(){return Fl.gb})),n.d(a,"equal",(function(){return Fl.ib})),n.d(a,"erf",(function(){return Fl.jb})),n.d(a,"euclideanNorm",(function(){return Fl.kb})),n.d(a,"exp",(function(){return Fl.lb})),n.d(a,"expandDims",(function(){return Fl.mb})),n.d(a,"expm1",(function(){return Fl.nb})),n.d(a,"eye",(function(){return Fl.ob})),n.d(a,"fill",(function(){return Fl.qb})),n.d(a,"floor",(function(){return Fl.rb})),n.d(a,"floorDiv",(function(){return Fl.sb})),n.d(a,"gather",(function(){return Fl.ub})),n.d(a,"greater",(function(){return Fl.wb})),n.d(a,"greaterEqual",(function(){return Fl.xb})),n.d(a,"imag",(function(){return Fl.zb})),n.d(a,"isFinite",(function(){return Fl.Db})),n.d(a,"isInf",(function(){return Fl.Eb})),n.d(a,"isNaN",(function(){return Fl.Fb})),n.d(a,"leakyRelu",(function(){return Fl.Gb})),n.d(a,"less",(function(){return Fl.Hb})),n.d(a,"lessEqual",(function(){return Fl.Ib})),n.d(a,"linspace",(function(){return Fl.Kb})),n.d(a,"localResponseNormalization",(function(){return Fl.Lb})),n.d(a,"log",(function(){return Fl.Mb})),n.d(a,"log1p",(function(){return Fl.Nb})),n.d(a,"logSigmoid",(function(){return Fl.Ob})),n.d(a,"logSoftmax",(function(){return Fl.Pb})),n.d(a,"logSumExp",(function(){return Fl.Qb})),n.d(a,"logicalAnd",(function(){return Fl.Rb})),n.d(a,"logicalNot",(function(){return Fl.Sb})),n.d(a,"logicalOr",(function(){return Fl.Tb})),n.d(a,"logicalXor",(function(){return Fl.Ub})),n.d(a,"lowerBound",(function(){return Fl.Wb})),n.d(a,"matMul",(function(){return Fl.Xb})),n.d(a,"max",(function(){return Fl.Yb})),n.d(a,"maxPool",(function(){return Fl.Zb})),n.d(a,"maxPool3d",(function(){return Fl.ac})),n.d(a,"maxPoolWithArgmax",(function(){return Fl.bc})),n.d(a,"maximum",(function(){return Fl.cc})),n.d(a,"mean",(function(){return Fl.dc})),n.d(a,"meshgrid",(function(){return Fl.ec})),n.d(a,"min",(function(){return Fl.fc})),n.d(a,"minimum",(function(){return Fl.gc})),n.d(a,"mirrorPad",(function(){return Fl.hc})),n.d(a,"mod",(function(){return Fl.ic})),n.d(a,"moments",(function(){return Fl.jc})),n.d(a,"mul",(function(){return Fl.lc})),n.d(a,"multiRNNCell",(function(){return Fl.mc})),n.d(a,"multinomial",(function(){return Fl.nc})),n.d(a,"neg",(function(){return Fl.oc})),n.d(a,"notEqual",(function(){return Fl.qc})),n.d(a,"oneHot",(function(){return Fl.rc})),n.d(a,"ones",(function(){return Fl.sc})),n.d(a,"onesLike",(function(){return Fl.tc})),n.d(a,"outerProduct",(function(){return Fl.vc})),n.d(a,"pad",(function(){return Fl.wc})),n.d(a,"pad1d",(function(){return Fl.xc})),n.d(a,"pad2d",(function(){return Fl.yc})),n.d(a,"pad3d",(function(){return Fl.zc})),n.d(a,"pad4d",(function(){return Fl.Ac})),n.d(a,"pool",(function(){return Fl.Bc})),n.d(a,"pow",(function(){return Fl.Cc})),n.d(a,"prelu",(function(){return Fl.Dc})),n.d(a,"print",(function(){return Fl.Ec})),n.d(a,"prod",(function(){return Fl.Fc})),n.d(a,"raggedGather",(function(){return Fl.Gc})),n.d(a,"raggedTensorToTensor",(function(){return Fl.Hc})),n.d(a,"rand",(function(){return Fl.Ic})),n.d(a,"randomGamma",(function(){return Fl.Jc})),n.d(a,"randomNormal",(function(){return Fl.Kc})),n.d(a,"randomStandardNormal",(function(){return Fl.Lc})),n.d(a,"randomUniform",(function(){return Fl.Mc})),n.d(a,"range",(function(){return Fl.Nc})),n.d(a,"real",(function(){return Fl.Oc})),n.d(a,"reciprocal",(function(){return Fl.Pc})),n.d(a,"relu",(function(){return Fl.Qc})),n.d(a,"relu6",(function(){return Fl.Rc})),n.d(a,"reshape",(function(){return Fl.Sc})),n.d(a,"reverse",(function(){return Fl.Tc})),n.d(a,"reverse1d",(function(){return Fl.Uc})),n.d(a,"reverse2d",(function(){return Fl.Vc})),n.d(a,"reverse3d",(function(){return Fl.Wc})),n.d(a,"reverse4d",(function(){return Fl.Xc})),n.d(a,"round",(function(){return Fl.Zc})),n.d(a,"rsqrt",(function(){return Fl.ad})),n.d(a,"scalar",(function(){return Fl.bd})),n.d(a,"selu",(function(){return Fl.ed})),n.d(a,"separableConv2d",(function(){return Fl.fd})),n.d(a,"setdiff1dAsync",(function(){return Fl.gd})),n.d(a,"sigmoid",(function(){return Fl.hd})),n.d(a,"sign",(function(){return Fl.id})),n.d(a,"sin",(function(){return Fl.kd})),n.d(a,"sinh",(function(){return Fl.ld})),n.d(a,"slice",(function(){return Fl.md})),n.d(a,"slice1d",(function(){return Fl.nd})),n.d(a,"slice2d",(function(){return Fl.od})),n.d(a,"slice3d",(function(){return Fl.pd})),n.d(a,"slice4d",(function(){return Fl.qd})),n.d(a,"softmax",(function(){return Fl.rd})),n.d(a,"softplus",(function(){return Fl.sd})),n.d(a,"spaceToBatchND",(function(){return Fl.td})),n.d(a,"fft",(function(){return Fl.pb})),n.d(a,"ifft",(function(){return Fl.yb})),n.d(a,"irfft",(function(){return Fl.Cb})),n.d(a,"rfft",(function(){return Fl.Yc})),n.d(a,"split",(function(){return Fl.xd})),n.d(a,"sqrt",(function(){return Fl.yd})),n.d(a,"square",(function(){return Fl.zd})),n.d(a,"squaredDifference",(function(){return Fl.Ad})),n.d(a,"squeeze",(function(){return Fl.Bd})),n.d(a,"stack",(function(){return Fl.Cd})),n.d(a,"step",(function(){return Fl.Dd})),n.d(a,"stridedSlice",(function(){return Fl.Ed})),n.d(a,"sub",(function(){return Fl.Gd})),n.d(a,"sum",(function(){return Fl.Hd})),n.d(a,"tan",(function(){return Fl.Id})),n.d(a,"tanh",(function(){return Fl.Jd})),n.d(a,"tensor",(function(){return Fl.Kd})),n.d(a,"tensor1d",(function(){return Fl.Ld})),n.d(a,"tensor2d",(function(){return Fl.Md})),n.d(a,"tensor3d",(function(){return Fl.Nd})),n.d(a,"tensor4d",(function(){return Fl.Od})),n.d(a,"tensor5d",(function(){return Fl.Pd})),n.d(a,"tensor6d",(function(){return Fl.Qd})),n.d(a,"tile",(function(){return Fl.Rd})),n.d(a,"topk",(function(){return Fl.Sd})),n.d(a,"truncatedNormal",(function(){return Fl.Ud})),n.d(a,"unique",(function(){return Fl.Vd})),n.d(a,"unsortedSegmentSum",(function(){return Fl.Wd})),n.d(a,"unstack",(function(){return Fl.Xd})),n.d(a,"upperBound",(function(){return Fl.Yd})),n.d(a,"variable",(function(){return Fl.Zd})),n.d(a,"where",(function(){return Fl.ae})),n.d(a,"whereAsync",(function(){return Fl.be})),n.d(a,"zeros",(function(){return Fl.ce})),n.d(a,"zerosLike",(function(){return Fl.de})),n.d(a,"booleanMaskAsync",(function(){return Fl.y})),n.d(a,"transpose",(function(){return Fl.Td})),n.d(a,"norm",(function(){return Fl.pc})),n.d(a,"movingAverage",(function(){return Fl.kc})),n.d(a,"scatterND",(function(){return Fl.cd})),n.d(a,"searchSorted",(function(){return Fl.dd})),n.d(a,"sparseToDense",(function(){return Fl.vd})),n.d(a,"gatherND",(function(){return Fl.vb})),n.d(a,"dropout",(function(){return Fl.eb})),n.d(a,"enclosingPowerOfTwo",(function(){return Fl.hb})),n.d(a,"cosineWindow",(function(){return Fl.T})),n.d(a,"inTopKAsync",(function(){return Fl.Bb})),n.d(a,"op",(function(){return Fl.uc})),n.d(a,"OP_SCOPE_SUFFIX",(function(){return Fl.a})),n.d(a,"image",(function(){return Fl.Ab})),n.d(a,"linalg",(function(){return Fl.Jb})),n.d(a,"losses",(function(){return Fl.Vb})),n.d(a,"spectral",(function(){return Fl.wd})),n.d(a,"fused",(function(){return Fl.tb})),n.d(a,"signal",(function(){return Fl.jd})),n.d(a,"sparse",(function(){return Fl.ud})),n.d(a,"string",(function(){return Fl.Fd}));var r={};n.r(r),n.d(r,"simpleAbsImpl",(function(){return vd})),n.d(r,"addImpl",(function(){return ud})),n.d(r,"bincountImpl",(function(){return nh})),n.d(r,"bincountReduceImpl",(function(){return ah})),n.d(r,"castImpl",(function(){return sd})),n.d(r,"ceilImpl",(function(){return ih})),n.d(r,"concatImpl",(function(){return hh})),n.d(r,"equalImpl",(function(){return Zh})),n.d(r,"expImpl",(function(){return ip})),n.d(r,"expm1Impl",(function(){return dp})),n.d(r,"floorImpl",(function(){return Op})),n.d(r,"gatherNdImpl",(function(){return Mp})),n.d(r,"gatherV2Impl",(function(){return zp})),n.d(r,"greaterImpl",(function(){return Pp})),n.d(r,"greaterEqualImpl",(function(){return Up})),n.d(r,"lessImpl",(function(){return Qp})),n.d(r,"lessEqualImpl",(function(){return tf})),n.d(r,"linSpaceImpl",(function(){return rf})),n.d(r,"logImpl",(function(){return of})),n.d(r,"maxImpl",(function(){return kf})),n.d(r,"maximumImpl",(function(){return Nf})),n.d(r,"minimumImpl",(function(){return Mf})),n.d(r,"multiplyImpl",(function(){return Wh})),n.d(r,"negImpl",(function(){return Hf})),n.d(r,"notEqualImpl",(function(){return $f})),n.d(r,"prodImpl",(function(){return hm})),n.d(r,"raggedGatherImpl",(function(){return bm})),n.d(r,"raggedTensorToTensorImpl",(function(){return Im})),n.d(r,"rangeImpl",(function(){return Nm})),n.d(r,"rsqrtImpl",(function(){return zm})),n.d(r,"scatterImpl",(function(){return Bm})),n.d(r,"sigmoidImpl",(function(){return Yu})),n.d(r,"sliceImpl",(function(){return Qd})),n.d(r,"sparseFillEmptyRowsImpl",(function(){return ig})),n.d(r,"sparseReshapeImpl",(function(){return cg})),n.d(r,"sparseSegmentReductionImpl",(function(){return ug})),n.d(r,"sqrtImpl",(function(){return mg})),n.d(r,"squaredDifferenceImpl",(function(){return vg})),n.d(r,"stridedSliceImpl",(function(){return Sg})),n.d(r,"stringNGramsImpl",(function(){return Og})),n.d(r,"stringSplitImpl",(function(){return _g})),n.d(r,"stringToHashBucketFastImpl",(function(){return Rg})),n.d(r,"subImpl",(function(){return bp})),n.d(r,"tileImpl",(function(){return Lg})),n.d(r,"topKImpl",(function(){return Ug})),n.d(r,"transposeImpl",(function(){return Td})),n.d(r,"uniqueImpl",(function(){return Zg}));var s=n(0),i=n(3),o=n(11),c=n(8),l=n(74);const u={kernelName:i.a,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(c.a)(e,Object(l.a)(Object(o.a)(n,"float32"),-1))}}};var d=n(14),h=n(27),p=n(17),f=n(33),m=n(23),g=n(13);const b={kernelName:i.b,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Object(m.a)(Object(o.a)(n,"float32")),a=Object(f.a)(Object(g.a)(Object(p.a)(1),t));return Object(h.a)(Object(d.a)(e,a))}}}},y={kernelName:i.c,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Object(f.a)(Object(g.a)(Object(m.a)(Object(o.a)(n,"float32")),1));return Object(d.a)(e,t)}}}};var v=n(15),x=n(7),w=n(16);const k={kernelName:i.d,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=v.assertAndGetBroadcastShape(n.shape,a.shape);return{a:()=>{let t=e;const a=v.getReductionAxes(n.shape,r);return a.length>0&&(t=Object(w.a)(t,a)),Object(x.a)(t,n.shape)},b:()=>{let t=e;const n=v.getReductionAxes(a.shape,r);return n.length>0&&(t=Object(w.a)(t,n)),Object(x.a)(t,a.shape)}}}},I={kernelName:i.e,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((t,a)=>{n[a]=()=>e.clone()}),n}};var S=n(18);const N={kernelName:i.h,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(S.a)(n)}}},T={kernelName:i.i,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(S.a)(n)}}},O={kernelName:i.j,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(d.a)(e,Object(f.a)(Object(g.a)(Object(p.a)(1),Object(m.a)(Object(o.a)(n,"float32")))))}}};var C=n(12);const E={kernelName:i.k,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Object(f.a)(Object(C.a)(Object(p.a)(1),Object(m.a)(Object(o.a)(n,"float32"))));return Object(d.a)(e,t)}}}},_={kernelName:i.m,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Object(v.assertAndGetBroadcastShape)(n.shape,a.shape);return{a:()=>{const t=Object(C.a)(Object(m.a)(n),Object(m.a)(a));let s=Object(c.a)(e,Object(d.a)(a,t));const i=Object(v.getReductionAxes)(n.shape,r);return i.length>0&&(s=Object(w.a)(s,i)),Object(x.a)(s,n.shape)},b:()=>{const t=Object(C.a)(Object(m.a)(n),Object(m.a)(a));let s=Object(h.a)(Object(c.a)(e,Object(d.a)(n,t)));const i=Object(v.getReductionAxes)(a.shape,r);return i.length>0&&(s=Object(w.a)(s,i)),Object(x.a)(s,a.shape)}}}},A={kernelName:i.l,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(d.a)(e,Object(C.a)(Object(m.a)(Object(o.a)(n,"float32")),1))}}},R={kernelName:i.n,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(d.a)(e,Object(g.a)(Object(p.a)(1),Object(m.a)(Object(o.a)(n,"float32"))))}}};var D=n(5),F=n(2),M=n(9),j=n(22),z=n(4);const L=Object(z.b)({avgPool3dGrad_:function(e,t,n,a,r,s){const o=Object(F.a)(e,"dy","avgPool3dGrad"),c=Object(F.a)(t,"input","avgPool3dGrad");let l=o,u=c,d=!1;4===c.rank&&(d=!0,l=Object(x.a)(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=Object(x.a)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),M.b(5===l.rank,()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(l.rank,".")),M.b(5===u.rank,()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(u.rank,".")),Object(j.a)("avgPool3dGrad",r,s);const h={dy:l,input:u},p={filterSize:n,strides:a,pad:r,dimRoundingMode:s},f=D.a.runKernel(i.q,h,p);return d?Object(x.a)(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),P={kernelName:i.p,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>L(e,a,r,s,i,o)}}};const B=Object(z.b)({avgPoolGrad_:function(e,t,n,a,r){const s=Object(F.a)(e,"dy","avgPoolGrad"),o=Object(F.a)(t,"input","avgPoolGrad");M.b(o.rank===s.rank,()=>"Rank of input (".concat(o.rank,") does not match rank of dy (").concat(s.rank,")"));let c=o,l=s,u=!1;3===o.rank&&(u=!0,c=Object(x.a)(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=Object(x.a)(s,[1,s.shape[0],s.shape[1],s.shape[2]])),M.b(4===l.rank,()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(l.rank,".")),M.b(4===c.rank,()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(c.rank,"."));const d={dy:l,input:c},h={filterSize:n,strides:a,pad:r},p=D.a.runKernel(i.r,d,h);return u?Object(x.a)(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),W={kernelName:i.o,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:s,pad:i}=n;return{x:()=>B(e,a,r,s,i)}}};var U=n(25);const V={kernelName:i.s,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[a,r]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>Object(U.a)(e,r,!1,!1),b:()=>Object(U.a)(e,a,!0,!1)}:s&&!i?{a:()=>Object(U.a)(r,e,!1,!0),b:()=>Object(U.a)(a,e,!1,!1)}:{a:()=>Object(U.a)(r,e,!0,!0),b:()=>Object(U.a)(e,a,!0,!0)}:{a:()=>Object(U.a)(e,r,!1,!0),b:()=>Object(U.a)(a,e,!0,!1)}}};var G=n(92);const H={kernelName:i.t,gradFunc:(e,t,n)=>{const{blockShape:a,crops:r}=n;return{x:()=>Object(G.a)(e,a,r)}}},q={kernelName:i.w,gradFunc:(e,t,n)=>{const a=n,r=a.inputShape,s=a.shape,i=Array.from(s);for(let c=r.length-1;c>=0;c--)if(r[c]===s[c])i[c]=1;else if(1!==r[c])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(s,"]."));const o=[];for(let c=0;c<i.length;c++)i[c]>1&&o.push(c);return{x:()=>Object(w.a)(e,o,!0)}}},K={kernelName:i.x,gradFunc:e=>({x:()=>e.clone()})},X={kernelName:i.y,gradFunc:e=>({x:()=>Object(S.a)(e)})};var Z=n(61),Y=n(50),J=n(53),Q=n(30);const $={kernelName:i.z,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{clipValueMin:r,clipValueMax:s}=n;return{x:()=>Object(Q.a)(Object(J.a)(Object(Z.a)(a,r),Object(Y.a)(a,s)),e,Object(S.a)(e))}}},ee={kernelName:i.B,inputsToSave:["x"],gradFunc:u.gradFunc};var te=n(54);const ne={kernelName:i.C,saveAllInputs:!0,gradFunc:(e,t,n)=>{const a=t.map(e=>e.shape),{axis:r}=n,s=Object(M.I)(r,t[0].shape)[0],i=a.map(e=>e[s]);return Object(te.a)(e,i,s).map(e=>()=>e)}};var ae=n(126),re=n(124);const se={kernelName:i.D,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{dilations:s,strides:i,pad:o,dataFormat:c}=n;return M.b(j.j(s),()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'")),{x:()=>Object(re.a)(a.shape,e,r,i,o,c),filter:()=>Object(ae.a)(a,e,r.shape,i,o,c)}}};var ie=n(60);const oe={kernelName:i.F,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:c}=n;return{dy:()=>Object(ie.a)(e,r,s,i,o,1,c),filter:()=>Object(ae.a)(e,a,r.shape,s,i,o,c)}}};const ce=Object(z.b)({conv3DBackpropFilter_:function(e,t,n,a,r){let s=e;4===e.rank&&(s=Object(x.a)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let o=t;4===o.rank&&(o=Object(x.a)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),M.b(5===s.rank,()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(s.shape,".")),M.b(5===o.rank,()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(o.shape,".")),M.b(5===n.length,()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,".")),M.b(s.shape[4]===n[3],()=>"Error in conv3dDerFilter: depth of input ".concat(s.shape[4],") must ")+"match input depth in filter (".concat(n[3],".")),M.b(o.shape[4]===n[4],()=>"Error in conv3dDerFilter: depth of dy (".concat(o.shape[4],") must ")+"match output depth for filter (".concat(n[4],")."));const c={x:s,dy:o},l={strides:a,pad:r,filterShape:n};return D.a.runKernel(i.H,c,l)}});var le=n(171);const ue={kernelName:i.G,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:s}=n;M.b(Object(j.j)(a),()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(a,"'"));const[i,o]=t;return{x:()=>Object(le.a)(i.shape,e,o,r,s),filter:()=>ce(i,e,o.shape,r,s)}}};var de=n(162);const he={kernelName:i.J,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(c.a)(Object(h.a)(Object(de.a)(Object(o.a)(n,"float32"))),e)}}};var pe=n(163);const fe={kernelName:i.K,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(c.a)(Object(pe.a)(Object(o.a)(n,"float32")),e)}}};var me=n(34),ge=n(107),be=n(45);const ye={kernelName:i.N,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r,exclusive:s,reverse:i}=n;return{x:()=>{const t=Object(me.f)([r],a.rank);let n=Object(ge.a)(e,r,s,!i);return null!=t&&(n=Object(be.a)(n,t)),n}}}};var ve=n(175),xe=n(174);const we={kernelName:i.Q,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:s,dimRoundingMode:i}=n,o=null==a?[1,1]:a;M.b(j.j(o),()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(o,"'"));const[c,l]=t;return M.b(4===c.rank,()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(c.rank,".")),M.b(4===l.rank,()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(l.rank,".")),M.b(c.shape[3]===l.shape[2],()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(c.shape[3],") must match the inChannels dimension ")+"in filter ".concat(l.shape[2],".")),M.b(j.i(r,o),()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(r," and dilations ")+"'".concat(o,"'.")),j.a("depthwiseConv2d",s,i),{x:()=>Object(xe.a)(c.shape,e,l,r,s,o,i),filter:()=>Object(ve.a)(c,e,l.shape,r,s,o,i)}}},ke={kernelName:i.U,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,s={x:a,filter:r,dy:e},o={x:a,filter:r,dy:e};return{x:()=>D.a.runKernel(i.W,s,n),filter:()=>D.a.runKernel(i.V,o,n)}}},Ie={kernelName:i.Y,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,a={dy:e,y:n};return{x:()=>D.a.runKernel(i.Z,a)}}};var Se=n(35);const Ne={kernelName:i.bb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=Object(c.a)(Object(Se.a)(Object(h.a)(Object(m.a)(n))),2/Math.sqrt(Math.PI));return{x:()=>Object(c.a)(e,a)}}},Te={kernelName:i.cb,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(c.a)(e,n)}}},Oe={kernelName:i.db,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Object(x.a)(e,n.shape)}}},Ce={kernelName:i.eb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(c.a)(e,Object(Se.a)(n))}}},Ee={kernelName:i.ib,gradFunc:e=>({x:()=>Object(S.a)(e)})},_e={kernelName:i.jb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Object(v.assertAndGetBroadcastShape)(n.shape,a.shape);return{a:()=>{const t=Object(d.a)(e,Object(o.a)(a,"float32")),s=Object(v.getReductionAxes)(n.shape,r);return s.length>0?Object(x.a)(Object(w.a)(t,s),n.shape):t},b:()=>{let t=Object(c.a)(e,Object(o.a)(n,"float32"));const s=Object(v.getReductionAxes)(a.shape,r);s.length>0&&(t=Object(x.a)(Object(w.a)(t,s),a.shape));const i=Object(m.a)(a);return Object(h.a)(Object(d.a)(t,Object(o.a)(i,"float32")))}}}};var Ae=n(159),Re=n(65);const De={kernelName:i.lb,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:a}=n,[r,s,i,o]=t,l=null==o?Object(p.a)(1):o,u=Object(v.getReductionAxes)(s.shape,r.shape),d=[];if(1===s.rank){for(let e=0;e<r.shape.length-1;++e)d.push(r.shape[e]);d.push(1)}const h=Object(g.a)(r,s),f=Object(c.a)(e,l),m=Object(Ae.a)(Object(C.a)(i,Object(p.a)(a))),b=Object(c.a)(Object(c.a)(Object(c.a)(m,m),m),Object(p.a)(-.5));return{x:()=>1===s.rank?Object(x.a)(Object(c.a)(Object(c.a)(e,Object(Re.a)(Object(x.a)(m,[1,1,1,s.shape[0]]),d)),l),r.shape):Object(x.a)(Object(c.a)(Object(c.a)(e,m),l),r.shape),mean:()=>{let e=Object(c.a)(Object(c.a)(m,Object(p.a)(-1)),f);return 1===s.rank&&(e=Object(w.a)(e,u)),Object(x.a)(e,s.shape)},variance:()=>{let e=Object(c.a)(Object(c.a)(b,h),f);return 1===s.rank&&(e=Object(w.a)(e,u)),Object(x.a)(e,s.shape)},scale:()=>{const t=Object(c.a)(h,m);let n=Object(c.a)(e,t);return 1===s.rank&&(n=Object(w.a)(n,u)),Object(x.a)(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=Object(w.a)(t,u)),Object(x.a)(t,s.shape)}}}};var Fe=n(123);const Me={kernelName:i.pb,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[a,r]=t,{axis:s}=n,i=Object(M.I)(s,a.shape)[0];return{x:()=>{const t=a.shape,n=r.size,o=t.slice(0,i),c=o.length,l=t.slice(s,t.length).slice(1),u=l.length,d=je(0,c),h=je(c+1,c+1+u),p=ze([o,[n],l]),f=Object(x.a)(e,p),m=Object(x.a)(r,[n]),g=ze([[c],d,h]),b=Object(be.a)(f,g);let y=Object(Fe.a)(b,m,a.shape[i]);const v=Object(me.h)(g);return y=Object(be.a)(y,v),y},indices:()=>r}}};function je(e,t){const n=[];for(let a=e;a<t;++a)n.push(a);return n}function ze(e){const t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}const Le={kernelName:i.rb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>Object(S.a)(n),b:()=>Object(S.a)(a)}}},Pe={kernelName:i.tb,gradFunc:e=>({x:()=>Object(o.a)(e,"float32")})},Be={kernelName:i.vb,gradFunc:e=>({x:()=>Object(S.a)(e)})},We={kernelName:i.wb,gradFunc:e=>({x:()=>Object(S.a)(e)})},Ue={kernelName:i.xb,gradFunc:e=>({x:()=>Object(S.a)(e)})};var Ve=n(37);const Ge={kernelName:i.Ab,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{alpha:r}=n,s=Object(Ve.a)(a,0);return{x:()=>Object(Q.a)(s,e,Object(c.a)(e,r))}}},He={kernelName:i.Fb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(d.a)(e,Object(C.a)(n,1))}}},qe={kernelName:i.Eb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(d.a)(e,Object(o.a)(n,"float32"))}}},Ke={kernelName:i.Gb,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;return{logits:()=>{const t=Object(Se.a)(a);return Object(g.a)(e,Object(c.a)(Object(w.a)(e,r,!0),t))}}}};const Xe=Object(z.b)({localResponseNormalizationBackprop_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5;const c={x:e,y:t,dy:n},l={depthRadius:a,bias:r,alpha:s,beta:o};return D.a.runKernel(i.zb,c,l)}}),Ze={kernelName:i.yb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{depthRadius:s,bias:i,alpha:o,beta:c}=n;return{x:()=>Xe(a,r,e,s,i,o,c)}}};var Ye=n(86);function Je(e,t,n,a){return t.rank<n.rank&&(t=Object(x.a)(t,me.e(t.shape,a))),e.rank<n.rank&&(e=Object(x.a)(e,me.e(e.shape,a))),{x:()=>Object(c.a)(e,Object(o.a)(Object(Ye.a)(n,t),e.dtype))}}const Qe={kernelName:i.Kb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{reductionIndices:r}=a,s=t[0],i=Je(e,t[1],s,M.I(r,s.shape));return{x:()=>i.x()}}};var $e=n(112);const et={kernelName:i.Qb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>Object(c.a)(e,Object(o.a)(Object(Z.a)(n,a),"float32")),b:()=>Object(c.a)(e,Object(o.a)(Object($e.a)(n,a),"float32"))}}};const tt=Object(z.b)({maxPool3dGrad_:function(e,t,n,a,r,s,o){const c=Object(F.a)(e,"dy","maxPool3dGrad"),l=Object(F.a)(t,"input","maxPool3dGrad"),u=Object(F.a)(n,"output","maxPool3dGrad");let d=c,h=l,p=u,f=!1;4===l.rank&&(f=!0,d=Object(x.a)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),h=Object(x.a)(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=Object(x.a)(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),M.b(5===d.rank,()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(d.rank,".")),M.b(5===h.rank,()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(h.rank,".")),M.b(5===p.rank,()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(p.rank,".")),Object(j.a)("maxPool3dGrad",s,o);const m={dy:d,input:h,output:p},g={filterSize:a,strides:r,pad:s,dimRoundingMode:o},b=D.a.runKernel(i.Nb,m,g);return f?Object(x.a)(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}}),nt={kernelName:i.Mb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:c}=n;return{x:()=>tt(e,a,r,s,i,o,c)}}};const at=Object(z.b)({maxPoolGrad_:function(e,t,n,a,r,s,o){const c=Object(F.a)(e,"dy","maxPoolGrad"),l=Object(F.a)(t,"input","maxPoolGrad"),u=Object(F.a)(n,"output","maxPoolGrad");M.b(l.rank===c.rank,()=>"Rank of input (".concat(l.rank,") does not match rank of dy ")+"(".concat(c.rank,")")),M.b(4===c.rank,()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(c.rank,".")),M.b(4===l.rank,()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(l.rank,".")),j.a("maxPoolGrad",s,o);const d={dy:c,input:l,output:u},h={filterSize:a,strides:r,pad:s,dimRoundingMode:o};return D.a.runKernel(i.Ob,d,h)}}),rt={kernelName:i.Lb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>at(e,a,r,s,i,o)}}};var st=n(49);const it={kernelName:i.Rb,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n,s=M.I(r,a.shape),i=Object(me.d)(a.shape,s)[1],o=M.O(i);return{x:()=>{const t=a.shape.slice();s.forEach(e=>{t[e]=1});const n=Object(x.a)(e,t);return Object(d.a)(Object(c.a)(n,Object(st.a)(a.shape,"float32")),o)}}}},ot={kernelName:i.Sb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{axis:r}=a,[s,i]=t,o=Je(e,i,s,M.I(r,s.shape));return{x:()=>o.x()}}},ct={kernelName:i.Tb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>Object(c.a)(e,Object(o.a)(Object(Y.a)(n,a),"float32")),b:()=>Object(c.a)(e,Object(o.a)(Object(Ve.a)(n,a),"float32"))}}};var lt=n(26);const ut={kernelName:i.Ub,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,s=r.map(e=>e[0]);return{x:()=>Object(lt.a)(e,s,a.shape)}}};var dt=n(110);const ht={kernelName:i.Vb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Object(v.assertAndGetBroadcastShape)(n.shape,a.shape);return{a:()=>{const t=Object(v.getReductionAxes)(n.shape,r);return t.length>0?Object(x.a)(Object(w.a)(e,t),n.shape):e},b:()=>{const t=Object(c.a)(e,Object(h.a)(Object(dt.a)(Object(d.a)(n,a)))),s=Object(v.getReductionAxes)(a.shape,r);return s.length>0?Object(x.a)(Object(w.a)(t,s),a.shape):t}}}},pt={kernelName:i.Xb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Object(v.assertAndGetBroadcastShape)(n.shape,a.shape);return{a:()=>{const t=Object(c.a)(e,Object(o.a)(a,"float32")),s=Object(v.getReductionAxes)(n.shape,r);return s.length>0?Object(x.a)(Object(w.a)(t,s),n.shape):t},b:()=>{const t=Object(c.a)(e,Object(o.a)(n,"float32")),s=Object(v.getReductionAxes)(a.shape,r);return s.length>0?Object(x.a)(Object(w.a)(t,s),a.shape):t}}}},ft={kernelName:i.Yb,gradFunc:e=>({x:()=>Object(h.a)(e)})};var mt=n(72);const gt={kernelName:i.dc,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>Object(mt.a)(n.shape,"float32")}}},bt={kernelName:i.ec,gradFunc:e=>({x:()=>Object(S.a)(e)})};var yt=n(75);const vt={kernelName:i.fc,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:a}=n;return Object(yt.a)(e,a).map(e=>()=>e)}},xt={kernelName:i.gc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,s=r.map(e=>e[0]);return{x:()=>Object(lt.a)(e,s,a.shape)}}};var wt=n(67),kt=n(48);const It={kernelName:i.hc,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,a,r]=t,s=n,i=a,l=v.assertAndGetBroadcastShape(s.shape,i.shape);return{a:()=>{const t=Object(o.a)(i,"float32");let n=Object(c.a)(e,Object(c.a)(t,Object(kt.a)(s,Object(g.a)(t,Object(p.a)(1)))));const a=v.getReductionAxes(s.shape,l);return a.length>0&&(n=Object(w.a)(n,a)),Object(x.a)(n,s.shape)},b:()=>{const t=Object(Ve.a)(s,0),n=Object(Q.a)(t,Object(wt.a)(s),Object(S.a)(s));let a=Object(c.a)(e,Object(c.a)(r,n));const o=v.getReductionAxes(i.shape,l);return o.length>0&&(a=Object(w.a)(a,o)),Object(x.a)(a,i.shape)}}}},St={kernelName:i.ic,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,a]=t,r=Object(Ve.a)(n,0);return{x:()=>Object(Q.a)(r,e,Object(c.a)(e,a)),alpha:()=>{let t=Object(Q.a)(r,Object(S.a)(e),Object(c.a)(e,n));const s=Object(v.getReductionAxes)(a.shape,e.shape);return s.length>0&&(t=Object(w.a)(t,s)),Object(x.a)(t,a.shape)}}}};var Nt=n(132),Tt=n(96);function Ot(e,t,n){const a=e.shape.length,r=a-n.length,s=Nt.zd.getAxesPermutation(n,a);let i=e;null!=s&&(i=Object(be.a)(e,s));const o=i.shape.slice(),l=o.splice(a-n.length,n.length).reduce((e,t)=>e*t,1);o.push(l);let u=function(e,t,n){const a=e.shape.slice();a[n]=1;const r=Object(x.a)(t,a),s=Object(Tt.a)(e,n,!0,!1),i=Object(Tt.a)(e,n,!0,!0),o=Object(c.a)(s,i);return Object(c.a)(r,o)}(i.reshape(o),t,r);if(u=u.reshape(i.shape),null!=s){const e=Nt.zd.getUndoAxesPermutation(s);u=Object(be.a)(u,e)}return u}const Ct={kernelName:i.jc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;let s=[];return s=void 0===r||null===r?a.shape.map((e,t)=>t):"number"===typeof r?[r]:r,{x:()=>Ot(a,e,s)}}},Et={kernelName:i.oc,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=v.assertAndGetBroadcastShape(n.shape,a.shape);return{a:()=>{const t=Object(d.a)(e,Object(o.a)(a,"float32")),s=v.getReductionAxes(n.shape,r);return s.length>0?Object(x.a)(Object(w.a)(t,s),n.shape):t},b:()=>{let t=Object(c.a)(e,Object(o.a)(n,"float32"));const s=v.getReductionAxes(a.shape,r);s.length>0&&(t=Object(x.a)(Object(w.a)(t,s),a.shape));const i=Object(m.a)(a);return Object(h.a)(Object(d.a)(t,Object(o.a)(i,"float32")))}}}},_t={kernelName:i.pc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(d.a)(e,Object(h.a)(Object(m.a)(n)))}}},At={kernelName:i.rc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=Object(c.a)(Object(Y.a)(n,6),Object(l.a)(n));return{x:()=>Object(c.a)(e,Object(o.a)(a,"float32"))}}},Rt={kernelName:i.qc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(c.a)(e,Object(o.a)(Object(l.a)(n),"float32"))}}},Dt={kernelName:i.sc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(x.a)(e,n.shape)}}},Ft={kernelName:i.tc,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>D.a.runKernel(i.uc,r,n)}}},Mt={kernelName:i.vc,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>D.a.runKernel(i.wc,r,n)}}};var jt=n(44);const zt={kernelName:i.xc,gradFunc:(e,t,n)=>{const{dims:a}=n,r=Object(M.I)(a,e.shape);return{x:()=>Object(jt.a)(e,r)}}},Lt={kernelName:i.zc,gradFunc:e=>({x:()=>Object(S.a)(e)})},Pt={kernelName:i.Ac,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(h.a)(Object(d.a)(e,Object(c.a)(Object(kt.a)(n,1.5),2)))}}};var Bt=n(90);const Wt={kernelName:i.Dc,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Object(o.a)(Object(S.a)(n),"float32"),t:()=>Object(c.a)(e,Object(o.a)(n,e.dtype)),e:()=>Object(c.a)(e,Object(o.a)(Object(Bt.a)(n),e.dtype))}}};var Ut=n(131);const Vt={kernelName:i.Ec,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Object(Ve.a)(n,Object(p.a)(0)),a=Object(p.a)(Ut.b),r=Object(p.a)(Ut.a),s=Object(c.a)(e,r),i=Object(c.a)(Object(c.a)(e,a),Object(Se.a)(Object(o.a)(n,"float32")));return Object(Q.a)(t,s,i)}}}},Gt={kernelName:i.Fc,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(c.a)(e,Object(c.a)(n,Object(g.a)(Object(p.a)(1),n)))}}},Ht={kernelName:i.Gc,gradFunc:e=>({x:()=>Object(S.a)(e)})};var qt=n(106);const Kt={kernelName:i.Hc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(c.a)(Object(qt.a)(Object(o.a)(n,"float32")),e)}}};var Xt=n(143);const Zt={kernelName:i.Ic,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(c.a)(Object(Xt.a)(Object(o.a)(n,"float32")),e)}}};var Yt=n(51),Jt=n(104);const Qt={kernelName:i.Jc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{begin:r,size:s}=n,i=a.shape,[o,c]=Object(Jt.parseSliceParams)(a,r,s),l=[];for(let u=0;u<e.rank;u++)l.push([o[u],i[u]-o[u]-c[u]]);return{x:()=>Object(Yt.a)(e,l)}}},$t={kernelName:i.Kc,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{dim:r}=n,s=Object(c.a)(e,a);return{logits:()=>Object(g.a)(s,Object(c.a)(Object(w.a)(s,[r],!0),a))}}};var en=n(63);const tn={kernelName:i.Lc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(c.a)(e,Object(en.a)(n))}}};var nn=n(84);const an={kernelName:i.Mc,gradFunc:(e,t,n)=>{const{blockShape:a,paddings:r}=n;return{x:()=>Object(nn.a)(e,a,r)}}};var rn=n(29);const sn={kernelName:i.Sc,gradFunc:(e,t,n)=>{const{axis:a}=n;return{x:()=>Object(rn.a)(e,a)}}},on={kernelName:i.Tc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(d.a)(e,Object(c.a)(Object(f.a)(Object(o.a)(n,"float32")),2))}}},cn={kernelName:i.Uc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(c.a)(e,Object(c.a)(Object(o.a)(n,"float32"),2))}}},ln={kernelName:i.Vc,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Object(p.a)(2);return{a:()=>Object(c.a)(e,Object(c.a)(r,Object(g.a)(n,a))),b:()=>Object(c.a)(e,Object(c.a)(r,Object(g.a)(a,n)))}}},un={kernelName:i.Wc,gradFunc:e=>({x:()=>Object(S.a)(e)})},dn={kernelName:i.bd,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=v.assertAndGetBroadcastShape(n.shape,a.shape);return{a:()=>{let t=e;const a=v.getReductionAxes(n.shape,r);return a.length>0&&(t=Object(w.a)(t,a)),Object(x.a)(t,n.shape)},b:()=>{let t=e;const n=v.getReductionAxes(a.shape,r);return n.length>0&&(t=Object(w.a)(t,n)),Object(x.a)(Object(h.a)(t),a.shape)}}}},hn={kernelName:i.cd,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,r=a.shape.slice(),{axis:s}=n;Object(M.I)(s,a.shape).forEach(e=>{r[e]=1});const i=Object(x.a)(e,r),o=Object(c.a)(i,Object(st.a)(a.shape,"float32"));return{x:()=>o}}},pn={kernelName:i.dd,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(d.a)(e,Object(m.a)(Object(qt.a)(n)))}}},fn={kernelName:i.ed,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Object(c.a)(Object(g.a)(Object(p.a)(1),Object(m.a)(n)),e)}}},mn={kernelName:i.fd,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{reps:r}=n;return{x:()=>{let t=Object(S.a)(a);if(1===a.rank)for(let n=0;n<r[0];++n)t=Object(C.a)(t,Object(lt.a)(e,[n*a.shape[0]],[a.shape[0]]));else if(2===a.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)t=Object(C.a)(t,Object(lt.a)(e,[n*a.shape[0],s*a.shape[1]],[a.shape[0],a.shape[1]]));else if(3===a.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let i=0;i<r[2];++i)t=Object(C.a)(t,Object(lt.a)(e,[n*a.shape[0],s*a.shape[1],i*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else{if(4!==a.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(a.rank," tensors yet."));for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let i=0;i<r[2];++i)for(let o=0;o<r[3];++o)t=Object(C.a)(t,Object(lt.a)(e,[n*a.shape[0],s*a.shape[1],i*a.shape[2],o*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]))}return t}}}},gn={kernelName:i.id,gradFunc:(e,t,n)=>{const a=n,{perm:r}=a,s=me.h(r);return{x:()=>Object(be.a)(e,s)}}};var bn=n(55);const yn={kernelName:i.kd,gradFunc:(e,t,n)=>{const a=n,{axis:r}=a;return{value:()=>Object(bn.a)(e,r)}}};var vn=n(57),xn=n(88),wn=n(91);const kn={kernelName:i.ld,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Object(wn.a)(t,Object(S.a)(t)),a=Object(xn.a)(e,n);let r=Object(Z.a)(t,Object(p.a)(0,"int32"));const s=a.rank-r.rank;for(let o=0;o<s;++o)r=Object(vn.a)(r,o+1);r=Object(J.a)(r,Object(st.a)(a.shape,"bool"));const i=Object(S.a)(a);return Object(Q.a)(r,a,i)}(e,n)}}};const In={kernelName:i.md,gradFunc:e=>({x:()=>Object(S.a)(e)})};var Sn=n(56);const Nn=[u,b,y,k,I,N,T,O,E,_,A,R,P,W,V,H,q,K,X,$,ee,ne,oe,se,ue,he,fe,ye,we,ke,Et,Ie,Ne,Te,Oe,Ce,_e,Ee,De,Me,Le,Pe,Be,We,Ue,Ge,He,qe,Ke,Ze,Qe,Qe,et,nt,rt,it,ot,ct,ut,ht,pt,ft,gt,bt,vt,xt,xt,It,St,Ct,_t,At,Rt,Dt,Ft,Mt,zt,Lt,Pt,Wt,Vt,Gt,Ht,Kt,Zt,Qt,$t,tn,an,an,sn,sn,on,ln,cn,un,dn,hn,pn,fn,mn,gn,yn,kn,In];for(const NT of Nn)Object(Sn.d)(NT);var Tn=n(38),On=n(6);Object(On.d)().prototype.abs=function(){return this.throwIfDisposed(),Object(Tn.a)(this)};var Cn=n(179);Object(On.d)().prototype.acos=function(){return this.throwIfDisposed(),Object(Cn.a)(this)};var En=n(180);Object(On.d)().prototype.acosh=function(){return this.throwIfDisposed(),Object(En.a)(this)},Object(On.d)().prototype.add=function(e){return this.throwIfDisposed(),Object(C.a)(this,e)};var _n=n(136);Object(On.d)().prototype.all=function(e,t){return this.throwIfDisposed(),Object(_n.a)(this,e,t)};var An=n(137);Object(On.d)().prototype.any=function(e,t){return this.throwIfDisposed(),Object(An.a)(this,e,t)};var Rn=n(138);Object(On.d)().prototype.argMax=function(e){return this.throwIfDisposed(),Object(Rn.a)(this,e)};var Dn=n(139);Object(On.d)().prototype.argMin=function(e){return this.throwIfDisposed(),Object(Dn.a)(this,e)},Object(On.d)().prototype.asScalar=function(){return this.throwIfDisposed(),Object(M.b)(1===this.size,()=>"The array must have only 1 element."),Object(x.a)(this,[])},Object(On.d)().prototype.asType=function(e){return this.throwIfDisposed(),Object(o.a)(this,e)},Object(On.d)().prototype.as1D=function(){return this.throwIfDisposed(),Object(x.a)(this,[this.size])},Object(On.d)().prototype.as2D=function(e,t){return this.throwIfDisposed(),Object(x.a)(this,[e,t])},Object(On.d)().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Object(x.a)(this,[e,t,n])},Object(On.d)().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),Object(x.a)(this,[e,t,n,a])},Object(On.d)().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),Object(x.a)(this,[e,t,n,a,r])};var Fn=n(181);Object(On.d)().prototype.asin=function(){return this.throwIfDisposed(),Object(Fn.a)(this)};var Mn=n(182);Object(On.d)().prototype.asinh=function(){return this.throwIfDisposed(),Object(Mn.a)(this)};var jn=n(183);Object(On.d)().prototype.atan=function(){return this.throwIfDisposed(),Object(jn.a)(this)};var zn=n(140);Object(On.d)().prototype.atan2=function(e){return this.throwIfDisposed(),Object(zn.a)(this,e)};var Ln=n(184);Object(On.d)().prototype.atanh=function(){return this.throwIfDisposed(),Object(Ln.a)(this)};var Pn=n(105);Object(On.d)().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),Object(Pn.a)(this,e,t,n,a)},Object(On.d)().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Object(nn.a)(this,e,t)};var Bn=n(76);Object(On.d)().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),Object(Bn.a)(this,e,t,n,a,r)};var Wn=n(94);Object(On.d)().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Object(Wn.a)(this,e)},Object(On.d)().prototype.cast=function(e){return this.throwIfDisposed(),Object(o.a)(this,e)};var Un=n(185);Object(On.d)().prototype.ceil=function(){return this.throwIfDisposed(),Object(Un.a)(this)};var Vn=n(186);Object(On.d)().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Object(Vn.a)(this,e,t)},Object(On.d)().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof On.a&&(e=[e]),Object(rn.a)([this,...e],t)};var Gn=n(141);Object(On.d)().prototype.conv1d=function(e,t,n,a,r,s){return this.throwIfDisposed(),Object(Gn.a)(this,e,t,n,a,r,s)};var Hn=n(142);Object(On.d)().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),Object(Hn.a)(this,e,t,n,a,r)},Object(On.d)().prototype.conv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),Object(ie.a)(this,e,t,n,a,r,s)},Object(On.d)().prototype.cos=function(){return this.throwIfDisposed(),Object(qt.a)(this)},Object(On.d)().prototype.cosh=function(){return this.throwIfDisposed(),Object(Xt.a)(this)},Object(On.d)().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Object(Tt.a)(this,e,t,n)},Object(On.d)().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Object(ge.a)(this,e,t,n)};var qn=n(144);Object(On.d)().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Object(qn.a)(this,e,t)};var Kn=n(85);Object(On.d)().prototype.depthwiseConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),Object(Kn.a)(this,e,t,n,a,r,s)};var Xn=n(145);Object(On.d)().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),Object(Xn.a)(this,e,t,n,a,r)};var Zn=n(146);Object(On.d)().prototype.divNoNan=function(e){return this.throwIfDisposed(),Object(Zn.a)(this,e)},Object(On.d)().prototype.div=function(e){return this.throwIfDisposed(),Object(d.a)(this,e)};var Yn=n(147);Object(On.d)().prototype.dot=function(e){return this.throwIfDisposed(),Object(Yn.a)(this,e)};var Jn=n(109);Object(On.d)().prototype.elu=function(){return this.throwIfDisposed(),Object(Jn.a)(this)},Object(On.d)().prototype.equal=function(e){return this.throwIfDisposed(),Object(Ye.a)(this,e)};var Qn=n(187);Object(On.d)().prototype.erf=function(){return this.throwIfDisposed(),Object(Qn.a)(this)};var $n=n(148);Object(On.d)().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Object($n.a)(this,e,t)},Object(On.d)().prototype.exp=function(){return this.throwIfDisposed(),Object(Se.a)(this)},Object(On.d)().prototype.expandDims=function(e){return this.throwIfDisposed(),Object(vn.a)(this,e)};var ea=n(188);Object(On.d)().prototype.expm1=function(){return this.throwIfDisposed(),Object(ea.a)(this)};var ta=n(120);Object(On.d)().prototype.fft=function(){return this.throwIfDisposed(),Object(ta.a)(this)},Object(On.d)().prototype.flatten=function(){return this.throwIfDisposed(),Object(x.a)(this,[this.size])},Object(On.d)().prototype.floor=function(){return this.throwIfDisposed(),Object(dt.a)(this)};var na=n(108);Object(On.d)().prototype.floorDiv=function(e){return this.throwIfDisposed(),Object(na.a)(this,e)},Object(On.d)().prototype.gather=function(e,t){return this.throwIfDisposed(),Object(xn.a)(this,e,t)},Object(On.d)().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Object(Z.a)(this,e)},Object(On.d)().prototype.greater=function(e){return this.throwIfDisposed(),Object(Ve.a)(this,e)};var aa=n(98);Object(On.d)().prototype.ifft=function(){return this.throwIfDisposed(),Object(aa.a)(this)};var ra=n(164);Object(On.d)().prototype.irfft=function(){return this.throwIfDisposed(),Object(ra.a)(this)};var sa=n(189);Object(On.d)().prototype.isFinite=function(){return this.throwIfDisposed(),Object(sa.a)(this)};var ia=n(190);Object(On.d)().prototype.isInf=function(){return this.throwIfDisposed(),Object(ia.a)(this)};var oa=n(191);Object(On.d)().prototype.isNaN=function(){return this.throwIfDisposed(),Object(oa.a)(this)};var ca=n(111);Object(On.d)().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Object(ca.a)(this,e)},Object(On.d)().prototype.lessEqual=function(e){return this.throwIfDisposed(),Object(Y.a)(this,e)},Object(On.d)().prototype.less=function(e){return this.throwIfDisposed(),Object($e.a)(this,e)};var la=n(149);Object(On.d)().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),Object(la.a)(this,e,t,n,a)};var ua=n(192);Object(On.d)().prototype.logSigmoid=function(){return this.throwIfDisposed(),Object(ua.a)(this)};var da=n(193);Object(On.d)().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Object(da.a)(this,e)};var ha=n(113);Object(On.d)().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Object(ha.a)(this,e,t)},Object(On.d)().prototype.log=function(){return this.throwIfDisposed(),Object(wt.a)(this)};var pa=n(150);Object(On.d)().prototype.log1p=function(){return this.throwIfDisposed(),Object(pa.a)(this)},Object(On.d)().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Object(J.a)(this,e)},Object(On.d)().prototype.logicalNot=function(){return this.throwIfDisposed(),Object(Bt.a)(this)};var fa=n(114);Object(On.d)().prototype.logicalOr=function(e){return this.throwIfDisposed(),Object(fa.a)(this,e)};var ma=n(152);Object(On.d)().prototype.logicalXor=function(e){return this.throwIfDisposed(),Object(ma.a)(this,e)},Object(On.d)().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Object(U.a)(this,e,t,n)};var ga=n(115);Object(On.d)().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),Object(ga.a)(this,e,t,n,a)};var ba=n(64);Object(On.d)().prototype.max=function(e,t){return this.throwIfDisposed(),Object(ba.a)(this,e,t)},Object(On.d)().prototype.maximum=function(e){return this.throwIfDisposed(),Object(wn.a)(this,e)};var ya=n(80);Object(On.d)().prototype.mean=function(e,t){return this.throwIfDisposed(),Object(ya.a)(this,e,t)};var va=n(97);Object(On.d)().prototype.min=function(e,t){return this.throwIfDisposed(),Object(va.a)(this,e,t)};var xa=n(116);Object(On.d)().prototype.minimum=function(e){return this.throwIfDisposed(),Object(xa.a)(this,e)};var wa=n(153);Object(On.d)().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Object(wa.a)(this,e,t)};var ka=n(154);Object(On.d)().prototype.mod=function(e){return this.throwIfDisposed(),Object(ka.a)(this,e)},Object(On.d)().prototype.mul=function(e){return this.throwIfDisposed(),Object(c.a)(this,e)},Object(On.d)().prototype.neg=function(){return this.throwIfDisposed(),Object(h.a)(this)};var Ia=n(87);Object(On.d)().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Object(Ia.a)(this,e,t,n)};var Sa=n(117);Object(On.d)().prototype.notEqual=function(e){return this.throwIfDisposed(),Object(Sa.a)(this,e)};var Na=n(155);Object(On.d)().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),Object(Na.a)(this,e,t,n)};var Ta=n(194);Object(On.d)().prototype.onesLike=function(){return this.throwIfDisposed(),Object(Ta.a)(this)},Object(On.d)().prototype.pad=function(e,t){return this.throwIfDisposed(),Object(Yt.a)(this,e,t)};var Oa=n(156);Object(On.d)().prototype.pool=function(e,t,n,a,r,s){return this.throwIfDisposed(),Object(Oa.a)(this,e,t,n,a,r,s)},Object(On.d)().prototype.pow=function(e){return this.throwIfDisposed(),Object(kt.a)(this,e)};var Ca=n(118);Object(On.d)().prototype.prelu=function(e){return this.throwIfDisposed(),Object(Ca.a)(this,e)};var Ea=n(157);Object(On.d)().prototype.prod=function(e,t){return this.throwIfDisposed(),Object(Ea.a)(this,e,t)};var _a=n(195);Object(On.d)().prototype.reciprocal=function(){return this.throwIfDisposed(),Object(_a.a)(this)};var Aa=n(73);Object(On.d)().prototype.relu=function(){return this.throwIfDisposed(),Object(Aa.a)(this)};var Ra=n(119);Object(On.d)().prototype.relu6=function(){return this.throwIfDisposed(),Object(Ra.a)(this)},Object(On.d)().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Object(x.a)(this,e.shape)},Object(On.d)().prototype.reshape=function(e){return this.throwIfDisposed(),Object(x.a)(this,e)};var Da=n(173);Object(On.d)().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Object(Da.a)(this,e,t,n)};var Fa=n(172);Object(On.d)().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Object(Fa.a)(this,e,t,n)},Object(On.d)().prototype.reverse=function(e){return this.throwIfDisposed(),Object(jt.a)(this,e)};var Ma=n(121);Object(On.d)().prototype.rfft=function(){return this.throwIfDisposed(),Object(Ma.a)(this)};var ja=n(158);Object(On.d)().prototype.round=function(){return this.throwIfDisposed(),Object(ja.a)(this)},Object(On.d)().prototype.rsqrt=function(){return this.throwIfDisposed(),Object(Ae.a)(this)};var za=n(160);Object(On.d)().prototype.selu=function(){return this.throwIfDisposed(),Object(za.a)(this)};var La=n(161);Object(On.d)().prototype.separableConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),Object(La.a)(this,e,t,n,a,r,s)},Object(On.d)().prototype.sigmoid=function(){return this.throwIfDisposed(),Object(en.a)(this)};var Pa=n(196);Object(On.d)().prototype.sign=function(){return this.throwIfDisposed(),Object(Pa.a)(this)},Object(On.d)().prototype.sin=function(){return this.throwIfDisposed(),Object(de.a)(this)},Object(On.d)().prototype.sinh=function(){return this.throwIfDisposed(),Object(pe.a)(this)},Object(On.d)().prototype.slice=function(e,t){return this.throwIfDisposed(),Object(lt.a)(this,e,t)};var Ba=n(197);Object(On.d)().prototype.softmax=function(e){return this.throwIfDisposed(),Object(Ba.a)(this,e)};var Wa=n(151);Object(On.d)().prototype.softplus=function(){return this.throwIfDisposed(),Object(Wa.a)(this)},Object(On.d)().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Object(G.a)(this,e,t)},Object(On.d)().prototype.split=function(e,t){return this.throwIfDisposed(),Object(te.a)(this,e,t)},Object(On.d)().prototype.sqrt=function(){return this.throwIfDisposed(),Object(f.a)(this)},Object(On.d)().prototype.square=function(){return this.throwIfDisposed(),Object(m.a)(this)};var Ua=n(122);Object(On.d)().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Object(Ua.a)(this,e)};var Va=n(93);Object(On.d)().prototype.squeeze=function(e){return this.throwIfDisposed(),Object(Va.a)(this,e)},Object(On.d)().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof On.a?[this,e]:[this,...e];return Object(bn.a)(n,t)},Object(On.d)().prototype.step=function(e){return this.throwIfDisposed(),Object(l.a)(this,e)};var Ga=n(198);Object(On.d)().prototype.stridedSlice=function(e,t,n,a,r,s,i,o){return this.throwIfDisposed(),Object(Ga.a)(this,e,t,n,a,r,s,i,o)},Object(On.d)().prototype.sub=function(e){return this.throwIfDisposed(),Object(g.a)(this,e)},Object(On.d)().prototype.sum=function(e,t){return this.throwIfDisposed(),Object(w.a)(this,e,t)};var Ha=n(199);Object(On.d)().prototype.tan=function(){return this.throwIfDisposed(),Object(Ha.a)(this)};var qa=n(130);Object(On.d)().prototype.tanh=function(){return this.throwIfDisposed(),Object(qa.a)(this)},Object(On.d)().prototype.tile=function(e){return this.throwIfDisposed(),Object(Re.a)(this,e)},Object(On.d)().prototype.toBool=function(){return this.throwIfDisposed(),Object(o.a)(this,"bool")},Object(On.d)().prototype.toFloat=function(){return this.throwIfDisposed(),Object(o.a)(this,"float32")},Object(On.d)().prototype.toInt=function(){return this.throwIfDisposed(),Object(o.a)(this,"int32")};var Ka=n(166);Object(On.d)().prototype.topk=function(e,t){return this.throwIfDisposed(),Object(Ka.a)(this,e,t)},Object(On.d)().prototype.transpose=function(e){return this.throwIfDisposed(),Object(be.a)(this,e)};var Xa=n(167);Object(On.d)().prototype.unique=function(e){return this.throwIfDisposed(),Object(Xa.a)(this,e)},Object(On.d)().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Object(Fe.a)(this,e,t)},Object(On.d)().prototype.unstack=function(e){return this.throwIfDisposed(),Object(yt.a)(this,e)},Object(On.d)().prototype.where=function(e,t){return this.throwIfDisposed(),Object(Q.a)(e,this,t)},Object(On.d)().prototype.zerosLike=function(){return this.throwIfDisposed(),Object(S.a)(this)};class Za extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Za.prototype)}}class Ya extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ya.prototype)}}class Ja extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ja.prototype)}}class Qa extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Qa.prototype)}}class $a extends Error{constructor(e){super(e),Object.setPrototypeOf(this,$a.prototype)}}Error;class er{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(e,"."));if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function tr(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function nr(e,t){if(!e)throw new $a(t)}function ar(e,t){let n=0;for(const a of e)a===t&&n++;return n}function rr(e){return 1===e.length?e[0]:e}function sr(e){return Array.isArray(e)?e:[e]}function ir(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function or(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let cr={};function lr(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function ur(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach(e=>ur(e));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?ur(t):e[n]=t.value)}}}function dr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const r=e;let s;if(r in n)s=n[r];else if(r in cr)s=cr[r];else if(s=t[r],null==s)throw new Ja("Unknown ".concat(a,": ").concat(e,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return s}{const s=e;if(null==s.className||null==s.config)throw new Ja("".concat(a,": Improper config format: ")+"".concat(JSON.stringify(s),".\n")+"'className' and 'config' must set.");const i=s.className;let o,c;if(i in n?[o,c]=n[i]:i in cr?[o,c]=cr.className:i in t&&([o,c]=t[i]),null==o)throw new Ja("Unknown ".concat(a,": ").concat(i,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=c){const e={};for(const n of Object.keys(cr))e[n]=cr[n];for(const r of Object.keys(n))e[r]=n[r];s.config.customObjects=e;const t=Object.assign({},cr);for(const r of Object.keys(n))cr[r]=n[r];ur(s.config);const a=c(o,s.config,n,r);return cr=Object.assign({},t),a}{const e=Object.assign({},cr);for(const a of Object.keys(n))cr[a]=n[a];const t=new o(s.config);return cr=Object.assign({},e),t}}}function hr(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function pr(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function fr(e){if(null==e)throw new Ja("Invalid value in obj: ".concat(JSON.stringify(e)));for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function mr(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new Ja("".concat(n," is not a valid ").concat(t,".  Valid values are ").concat(e," or null/undefined."))}function gr(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return nr(n>=0),nr(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every(e=>typeof e===t)}function br(e,t){Array.isArray(e)?(s.Df.assert(e.length>0,()=>"".concat(t," is unexpectedly an empty array.")),e.forEach((e,n)=>br(e,"element ".concat(n+1," of ").concat(t)))):s.Df.assert(Number.isInteger(e)&&e>0,()=>"Expected ".concat(t," to be a positive integer, but got ")+"".concat(function e(t){return null===t?"null":Array.isArray(t)?"["+t.map(t=>e(t)).join(",")+"]":"string"===typeof t?'"'.concat(t,'"'):"".concat(t)}(e),"."))}function yr(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let vr=0;function xr(){return vr++}const wr={};function kr(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in wr||(wr[e]=0),wr[e]+=1,e+wr[e].toString()}const Ir=["channelsFirst","channelsLast"],Sr=["nearest","bilinear"],Nr=["valid","same","causal"],Tr=["max","avg"],Or=["sum","mul","concat","ave"],Cr=new Map;function Er(e){mr(Ir,"DataFormat",e)}function _r(e){mr(Nr,"PaddingMode",e)}function Ar(e){mr(Tr,"PoolMode",e)}const Rr=[];function Dr(e,t){Rr.push(e);try{const e=t();return Rr.pop(),e}catch(n){throw Rr.pop(),n}}function Fr(e){if(!zr(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===Rr.length?"":Rr.join("/")+"/")+e}function Mr(e){if(!zr(e))throw new Error("Not a valid tensor name: '"+e+"'");Cr.has(e)||Cr.set(e,0);const t=Cr.get(e);if(Cr.set(e,Cr.get(e)+1),t>0){const n="".concat(e,"_").concat(t);return Cr.set(n,1),n}return e}const jr=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function zr(e){return!!e.match(jr)}function Lr(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function Pr(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a<t&&(t=a)}return t}function Br(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a>t&&(t=a)}return t}function Wr(e,t){if(t<e)throw new Ja("end (".concat(t,") < begin (").concat(e,") is forbidden."));const n=[];for(let a=e;a<t;++a)n.push(a);return n}let Ur;function Vr(){return null==Ur&&(Ur=Object(s.yd)().epsilon()),Ur}function Gr(e,t){return s.Hd(e,t)}function Hr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),s.Ue(e,n)}function qr(e){const t=[Lr(e.shape)];return s.Ue(e,t)}function Kr(e,t,n){return Object(s.wf)(()=>{switch(e.rank){case 1:return s.df(e,t,n);case 2:return s.ef(e,[t,0],[n,e.shape[1]]);case 3:return s.ff(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return s.gf(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return s.cf(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return s.cf(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new Ja("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(e.rank))}})}function Xr(e,t,n){return Object(s.wf)(()=>{switch(e.rank){case 1:return s.df(e,t,n);case 2:return s.ef(e,[0,t],[e.shape[0],n]);case 3:return s.ff(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return s.gf(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new Ja("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}})}function Zr(e,t,n,a){return Object(s.wf)(()=>{switch(e.rank){case 1:return s.df(e,t,n);case 2:switch(a){case 1:return Kr(e,t,n);case 2:return Xr(e,t,n);default:throw new Ja("The axis is not within the rank of the tensor "+"".concat(a))}case 3:switch(a){case 1:return Kr(e,t,n);case 2:return s.ff(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Xr(e,t,n);default:throw new Ja("The axis is not within the rank of the tensor "+"".concat(a))}case 4:switch(a){case 1:return Kr(e,t,n);case 2:return s.gf(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return s.gf(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Xr(e,t,n);default:throw new Ja("The axis is not within the rank of the tensor "+"".concat(a))}default:throw new Ja("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}})}function Yr(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),s.Kd(e,n)}function Jr(e,t){switch(e.rank){case 1:return s.Ld([e,t]);case 2:return s.Md([e,t],0);case 3:return s.Nd([e,t],0);case 4:return s.Od([e,t],0);default:throw new Ja("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(e.rank))}}function Qr(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new Ja("The length of input n (".concat(t.length,") does not match ")+"the number of dimensions in input x (".concat(e.rank,")"));return s.xf(e,t)}function $r(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;return s.Pe(e,t,n,a,r)}function es(e,t,n,a){if(e.rank<2||t.rank<2)throw new Qa("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(e.shape," and y shape = ").concat(t.shape));if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new Qa("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(e.shape," and ")+" y shape = ".concat(t.shape))}if(2===e.rank&&2===t.rank){const r=!1,i=!1;return s.ie.matMul({a:e,b:t,transposeA:r,transposeB:i,bias:a?as(e.rank,a,"channelsLast"):null,activation:n})}{const r=e.shape.slice(),i=r.pop();e=s.Ue(e,[-1,i]);const o=t.shape.slice(),c=o.pop(),l=o.pop(),u=[...o,c],d=Array.from({length:t.rank},(e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n);t=s.Ue(s.zf(t,d),[l,-1]);const h=[...r,...u],p=!1,f=!1;return s.Ue(s.ie.matMul({a:e,b:t,transposeA:p,transposeB:f,bias:a?as(e.rank,a,"channelsLast"):null,activation:n}),h)}}function ts(e,t,n){return Object(s.wf)(()=>(t=Array.isArray(t)?Object(s.tf)(t,"int32"):s.Hd(t,"int32"),s.je(e,t,n)))}function ns(e){return s.Fe(e,e)}function as(e,t,n){const a=t.shape;if(1!==t.rank&&t.rank!==e)throw new Ja("Unexpected bias dimensions: ".concat(t.rank)+"; expected it to be 1 or ".concat(e));if(5===e){if("channelsFirst"===n)return 1===a.length?s.Ue(t,[1,a[0],1,1,1]):s.Ue(t,[1,a[3],a[0],a[1],a[2]]);if("channelsLast"===n)return 1===a.length?s.Ue(t,[1,1,1,1,a[0]]):s.Ue(t,[1].concat(a))}else if(4===e){if("channelsFirst"===n)return 1===a.length?s.Ue(t,[1,a[0],1,1]):s.Ue(t,[1,a[2],a[0],a[1]]);if("channelsLast"===n)return 1===a.length?s.Ue(t,[1,1,1,a[0]]):s.Ue(t,[1].concat(a))}else if(3===e){if("channelsFirst"===n)return 1===a.length?s.Ue(t,[1,a[0],1]):s.Ue(t,[1,a[1],a[0]]);if("channelsLast"===n)return 1===a.length?s.Ue(t,[1,1,a[0]]):s.Ue(t,[1].concat(a))}else if(e<3)return t;throw new Ja("Unsupported input rank by biasAdd: ".concat(t.rank))}function rs(e,t,n){return Object(s.wf)(()=>(null==n&&(n="channelsLast"),Er(n),s.sd(e,as(e.rank,t,n))))}function ss(e,t,n,a){return Object(s.wf)(()=>s.Yd(e,t,n,a))}function is(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return n?e():t()}const os=["fanIn","fanOut","fanAvg"],cs=["normal","uniform","truncatedNormal"];class ls extends s.Ze.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class us extends ls{apply(e,t){return Object(s.If)(e,t)}}us.className="Zeros",s.Ze.registerClass(us);class ds extends ls{apply(e,t){return Object(s.Ke)(e,t)}}ds.className="Ones",s.Ze.registerClass(ds);class hs extends ls{constructor(e){if(super(),"object"!==typeof e)throw new Ja("Expected argument of type ConstantConfig but got ".concat(e));if(void 0===e.value)throw new Ja("config must have value set but got ".concat(e));this.value=e.value}apply(e,t){return Object(s.wf)(()=>Object(s.Fe)(Object(s.We)(this.value),Object(s.Ke)(e,t)))}getConfig(){return{value:this.value}}}hs.className="Constant",s.Ze.registerClass(hs);class ps extends ls{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Object(s.Qe)(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}ps.className="RandomUniform",s.Ze.registerClass(ps);class fs extends ls{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Qa("randomNormal does not support dType ".concat(t,"."));return $r(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}fs.className="RandomNormal",s.Ze.registerClass(fs);class ms extends ls{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Qa("truncatedNormal does not support dType ".concat(t,"."));return Object(s.Af)(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}ms.className="TruncatedNormal",s.Ze.registerClass(ms);class gs extends ls{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Object(s.wf)(()=>{if(2!==e.length||e[0]!==e[1])throw new Ja("Identity matrix initializer can only be used for 2D square matrices.");return Object(s.Fe)(this.gain,Object(s.fe)(e[0]))})}getConfig(){return{gain:this.gain}}}gs.className="Identity",s.Ze.registerClass(gs);class bs extends ls{constructor(e){if(super(),e.scale<0)throw new Ja("scale must be a positive float. Got: ".concat(e.scale));var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,mr(os,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){mr(cs,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(Er(a),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===a){const a=Lr(e,2);t=e[1]*a,n=e[0]*a}else if("channelsLast"===a){const a=Lr(e,0,e.length-2);t=e[e.length-2]*a,n=e[e.length-1]*a}}else{const a=Lr(e);t=Math.sqrt(a),n=Math.sqrt(a)}return[t,n]}(e),a=n[0],r=n[1];let i=this.scale;if("fanIn"===this.mode?i/=Math.max(1,a):"fanOut"===this.mode?i/=Math.max(1,r):i/=Math.max(1,(a+r)/2),"normal"===this.distribution){const n=Math.sqrt(i);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Qa("".concat(this.getClassName()," does not support dType ").concat(t,"."));return Object(s.Af)(e,0,n,t,this.seed)}{const n=Math.sqrt(3*i);return Object(s.Qe)(e,-n,n,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}bs.className="VarianceScaling",s.Ze.registerClass(bs);class ys extends bs{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return bs.className}}ys.className="GlorotUniform",s.Ze.registerClass(ys);class vs extends bs{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return bs.className}}vs.className="GlorotNormal",s.Ze.registerClass(vs);class xs extends bs{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return bs.className}}xs.className="HeNormal",s.Ze.registerClass(xs);class ws extends bs{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return bs.className}}ws.className="HeUniform",s.Ze.registerClass(ws);class ks extends bs{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return bs.className}}ks.className="LeCunNormal",s.Ze.registerClass(ks);class Is extends bs{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return bs.className}}Is.className="LeCunNormal",s.Ze.registerClass(Is);class Ss extends ls{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new Qa("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return Object(s.wf)(()=>{if(e.length<2)throw new Qa("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than 2000 (".concat(e[0]*e[1],") elements: ")+"Slowness may result.");const t=$r(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let n=s.re.gramSchmidt(t);return e[0]>e[1]&&(n=Object(s.zf)(n)),Object(s.Fe)(this.gain,n)})}getConfig(){return{gain:this.gain,seed:this.seed}}}Ss.className="Orthogonal",s.Ze.registerClass(Ss);const Ns={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Ts(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return dr(e,s.Ze.SerializationMap.getMap().classNameMap,t,"initializer")}function Os(e){return lr(e)}function Cs(e){if("string"===typeof e){const t=e in Ns?Ns[e]:e;if("GlorotNormal"===t)return new vs;if("GlorotUniform"===t)return new ys;if("HeNormal"===t)return new xs;if("HeUniform"===t)return new ws;if("LeCunNormal"===t)return new ks;if("LeCunUniform"===t)return new Is;{const e={};return e.className=t,e.config={},Ts(e)}}return e instanceof ls?e:Ts(e)}function Es(e){return Array.isArray(e)&&Array.isArray(e[0])}function _s(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function As(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new Ja("Expected Tensor length to be 1; got ".concat(e.length));t=e[0]}else t=e;return t}function Rs(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return(e=e)[0];throw new Ja("Expected exactly 1 Shape; got ".concat(e.length))}return e}function Ds(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce((e,t)=>e*t);return t}class Fs{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Variable",a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=xr(),n=null==n?"Variable":n,this.originalName=Fr(n),this.name=Mr(this.originalName),this.trainable_=a,this.constraint=r,this.val=s.Ef(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Ms(e){return e.map(e=>e.read())}function js(e){e.forEach(e=>{e[0].write(e[1])})}class zs{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Ls{constructor(e,t,n,a,r,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=i,this.id=xr(),null!=s&&(this.originalName=Fr(s),this.name=Mr(this.originalName)),this.rank=t.length}}let Ps=0;class Bs{constructor(e,t){this.callArgs=t,this.id=Ps++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Ws=0;class Us extends s.Ze.Serializable{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Ws++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=ir(e)+"_"+kr(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new Ya("The layer has never been called "+"and thus has no defined ".concat(t,"."));if(this.inboundNodes.length<=e)throw new Ja("Asked to get ".concat(t," at node ").concat(e,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[e]}getInputAt(e){return rr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return rr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Za("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new Za("Layer ".concat(this.name)+" is not connected, no input to return.");return rr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Za("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new Za("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return rr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=sr(e),null==this.inputSpec||0===this.inputSpec.length)return;const t=sr(this.inputSpec);if(e.length!==t.length)throw new Ja("Layer ".concat(this.name," expects ").concat(t.length," inputs, ")+"but it received ".concat(e.length," input tensors. ")+"Input received: ".concat(e));for(let n=0;n<e.length;n++){const a=e[n],r=t[n];if(null==r)continue;const s=a.rank;if(null!=r.ndim&&s!==r.ndim)throw new Ja("Input ".concat(n," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(r.ndim,", found ndim=").concat(s));if(null!=r.maxNDim&&s>r.maxNDim)throw new Ja("Input ".concat(n," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(r.maxNDim,", found ndim=").concat(s));if(null!=r.minNDim&&s<r.minNDim)throw new Ja("Input ".concat(n," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(r.minNDim,", found ndim=").concat(s,"."));if(null!=r.dtype&&a.dtype!==r.dtype)throw new Ja("Input ".concat(n," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(r.dtype,", found dtype=").concat(a.dtype,"."));if(r.axes){const e=a.shape;for(const t in r.axes){const a=Number(t),s=r.axes[t],i=a>=0?e[a]:e[e.length+a];if(null!=s&&-1===[s,null].indexOf(i))throw new Ja("Input ".concat(n," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(a," of input shape to ")+"have value ".concat(s," but got shape ").concat(e,"."))}}if(null!=r.shape)for(let e=0;e<r.shape.length;++e){const t=r.shape[e],s=a.shape[e];if(null!=t&&null!=s&&t!==s)throw new Ja("Input ".concat(n," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(r.shape,", ")+"found shape=".concat(a.shape,"."))}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=sr(e);let a=!0;for(const s of n)if(!(s instanceof Ls)){a=!1;break}let r=!0;for(const s of n)if(s instanceof Ls){r=!1;break}if(a===r)throw new Ja("Arguments to apply() must be all SymbolicTensors or all Tensors");return Dr(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of sr(e))t.push(n.shape);this.build(rr(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let a=this.call(e,t);const r=sr(a),s=[];for(let e of r)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(a=rr(s),null!=this.activityRegularizer)throw new Qa("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}{const n=function(e){e=sr(e);const t=[];for(const n of e)t.push(n.shape);return rr(t)}(e),a=this.computeOutputShape(n);let r;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),r=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((n,a)=>new Ls(s,n,this,sr(e),t,this.name,a)):new Ls(s,a,this,sr(e),t,this.name),this.addInboundNode(e,r,null,null,n,a,t),this._refCount++,null!=this.activityRegularizer)throw new Qa("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}})}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(e),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let t=!1;this.batchInputShape.forEach((n,a)=>{null!=n&&null!=e[a]&&e[a]!==n&&(t=!0)}),t&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(e),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Za("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Za("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new Ya("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return Ds(this.weights)}build(e){this.built=!0}getWeights(){return Ms(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){Object(s.wf)(()=>{const t=this.weights;if(t.length!==e.length)throw new Ja('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(e.length,", ")+"but the layer was expecting ".concat(t.length," weights. ")+"Provided weights: ".concat(e,"..."));if(0===t.length)return;const n=[],a=Ms(t);for(let r=0;r<a.length;++r){const i=a[r],o=t[r],c=e[r];if(!s.Df.arraysEqual(i.shape,c.shape))throw new Ja("Layer weight shape ".concat(i.shape," ")+"not compatible with provided weight shape ".concat(c.shape));n.push([o,c])}js(n)})}addWeight(e,t,n,a,r,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new Ja("Duplicate weight name ".concat(e," for layer ").concat(this.name));this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(a=null!=o?o():Cs("zeros"));const c=a.apply(t,n),l=new Fs(c,n,e,s,i);return c.dispose(),null!=r&&this.addLoss(()=>r.apply(l.read())),null==s&&(s=!0),s?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=sr(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");t.forEach(e=>{if(null!=e)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")})}return null}return t}addInboundNode(e,t,n,a,r,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const o=sr(e);t=sr(t),n=sr(n),a=sr(a),r=_s(r),s=_s(s);const c=[],l=[],u=[];for(const d of o)c.push(d.sourceLayer),l.push(d.nodeIndex),u.push(d.tensorIndex);new Bs({outboundLayer:this,inboundLayers:c,nodeIndices:l,tensorIndices:u,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:s},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}class Vs extends Us{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:kr("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new Ja("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new Ja("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new Ja("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const a=new Ls(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new Bs({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Ja("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function Gs(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new Ja("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;null==n&&(n="float32");return new Vs({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}Vs.className="InputLayer",s.Ze.registerClass(Vs);class Hs{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Hs)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new Ja("Duplicate key: name=".concat(e.name,", id=").concat(e.id));return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Object(s.Hd)(t,e.dtype)}catch(n){throw new Ja("The dtype of the feed (".concat(t.dtype,") can not be cast to the dtype ")+"of the key '".concat(e.name,"' (").concat(e.dtype,")."))}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Ls){if(null==this.id2Value[e.id])throw new Ja("Nonexistent key: ".concat(e.name));return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new Ja("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Value[t]}}getMask(e){if(e instanceof Ls){if(null==this.id2Value[e.id])throw new Ja("Nonexistent key: ".concat(e.name));return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new Ja("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&Object(s.Wd)(this.id2Mask)}}const qs=new er,Ks=new er;function Xs(e,t,n,a){const r=null!=n&&n.training,i=Array.isArray(e),o=i?e:[e],c=o.map(e=>e.name),l=[],u=t.names();for(const s of c)-1!==u.indexOf(s)?l.push(t.getValue(s)):l.push(null);null!=a&&(a.maxNumTensors=-1/0,a.minNumTensors=1/0);const d=c.join(",")+"|"+t.names().sort().join(",");let h,p=qs.get(d);if(null==p){const e=function(e,t){s.Df.assert(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],a={};if(1===e.length){const r=Ys(e[0],t);n=r.sorted,a=r.recipientMap}else{const r=new Set;for(const s of e){const{sorted:e,recipientMap:i}=Ys(s,t);for(const t of e)r.has(t.name)||(n.push(t),r.add(t.name));for(const t in i)null==a[t]&&(a[t]=new Set),i[t].forEach(e=>a[t].add(e))}}return{sorted:n,recipientCounts:Zs(a)}}(o,t);p=e.sorted,h=e.recipientCounts,qs.put(d,p),Ks.put(d,h)}h={},r||Object.assign(h,Ks.get(d));const f=new Hs(t);for(let m=0;m<p.length;++m){if(null!=a){const e=Object(s.Ce)().numTensors;e>a.maxNumTensors&&(a.maxNumTensors=e),e<a.minNumTensors&&(a.minNumTensors=e)}const e=p[m],i=e.sourceLayer;if(i instanceof Vs)continue;const o=[],u=[],d=[];let g=!1;for(const n of e.inputs){const e=f.getValue(n),a=f.getMask(n);o.push(e),u.push(a),null!=a&&(g=!0),r||(h[n.name]--,0!==h[n.name]||t.hasKey(n)||-1!==c.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||d.push(e))}g&&((n=n||{}).mask=u[0]);const b=sr(i.apply(o,n));let y=null;i.supportsMasking&&(y=i.computeMask(o,u));const v=Js(e),x=Array.isArray(v)?v:[v];for(let t=0;t<x.length;++t){f.hasKey(x[t])||f.add(x[t],b[t],Array.isArray(y)?y[0]:y);const e=c.indexOf(x[t].name);-1!==e&&(l[e]=b[t])}r||Object(s.Wd)(d)}return f.disposeMasks(),i?l:l[0]}function Zs(e){const t={};for(const n in e)t[n]=e[n].size;return t}function Ys(e,t){const n=new Set,a=[],r={};for(const o of t.names())n.add(o);const s=[],i=[];for(s.push(e);s.length>0;){const e=s[s.length-1];if(n.has(e.name)){s.pop();continue}const t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),a.push(e),n.add(e.name),t&&i.pop();else{i.push(s.length-1);for(const t of e.inputs)null==r[t.name]&&(r[t.name]=new Set),r[t.name].add(e.name),n.has(t.name)||s.push(t)}}return{sorted:a,recipientMap:r}}function Js(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const a of e.sourceLayer.inboundNodes[t].outputTensors)if(a.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function Qs(e,t){return Object(s.wf)(()=>s.lf(s.pf(s.Fe(e,e),t,!0)))}Object(s.be)().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,(function(e){null!=qs&&qs.setMaxEntries(e),null!=Ks&&Ks.setMaxEntries(e)}));class $s extends s.Ze.Serializable{getConfig(){return{}}}class ei extends $s{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Object(s.wf)(()=>{const t=Qs(e,this.axis),n=s.Id(t,0,this.maxValue);return s.Fe(e,s.Xd(n,s.sd(Vr(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}ei.className="MaxNorm",s.Ze.registerClass(ei);class ti extends $s{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Object(s.wf)(()=>s.Xd(e,s.sd(Vr(),Qs(e,this.axis))))}getConfig(){return{axis:this.axis}}}ti.className="UnitNorm",s.Ze.registerClass(ti);class ni extends $s{apply(e){return s.Te(e)}}ni.className="NonNeg",s.Ze.registerClass(ni);class ai extends $s{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Object(s.wf)(()=>{const t=Qs(e,this.axis),n=s.sd(s.Fe(this.rate,s.Id(t,this.minValue,this.maxValue)),s.Fe(1-this.rate,t));return s.Fe(e,s.Xd(n,s.sd(Vr(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}ai.className="MinMaxNorm",s.Ze.registerClass(ai);const ri={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function si(e){return lr(e)}function ii(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return dr(e,s.Ze.SerializationMap.getMap().classNameMap,t,"constraint")}function oi(e){if(null==e)return null;if("string"===typeof e){return ii({className:e in ri?ri[e]:e,config:{}})}return e instanceof $s?e:ii(e)}async function ci(e){if(null==e)return;const t=[],n=[],a=[];for(const r in e){const s=e[r];if("number"!==typeof s){const e=s;t.push(e.data()),n.push(r),a.push(e)}}if(t.length>0){const r=await Promise.all(t);for(let t=0;t<r.length;++t)e[n[t]]=r[t][0];Object(s.Wd)(a)}}function li(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var ui;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(ui||(ui={}));class di{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class hi{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class pi extends di{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const a in t){const e=t[a];if("number"===typeof e)this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+e*n;else{let t;a in this.totals?t=this.totals[a]:this.totals[a]=0;const r=Object(s.wf)(()=>Object(s.sd)(this.totals[a],Object(s.Fe)(e,n)));this.totals[a]=r,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:Object(s.wf)(()=>{const e=Object(s.Fe)(Object(s.Xd)(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),Object(s.oe)(t[n])}))}}class fi extends di{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const a=this.history[r];for(let s=0;s<a.length;++s)if("number"!==typeof a[s]){const i=a[s];e.push(i.data()),t.push(r),n.push(s)}}const a=await Promise.all(e);for(let r=0;r<a.length;++r){this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=a[r][0]}}}class mi extends di{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||s.He,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");s.Df.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let a,r=null!=n?n():s.Df.now();return function(){const i=null!=n?n():s.Df.now();return i-r<t||(r=i,a=e(...arguments)),a}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const a=[];null!=this.yield&&(await ci(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await ci(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await ci(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await ci(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await ci(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):s.Df.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await ci(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await ci(e),await this.trainEnd(e))}}function gi(e,t){if(null==e&&(e={}),e instanceof di)return[e];if(Array.isArray(e)&&e[0]instanceof di)return e;return sr(e).map(e=>new mi(e,t))}class bi{constructor(){}static registerCallbackConstructor(e,t){s.Df.assert(e>=0&&Number.isInteger(e),()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(e)),bi.checkForDuplicate(t),null==bi.constructors[e]&&(bi.constructors[e]=[]),bi.constructors[e].push(t)}static checkForDuplicate(e){for(const t in bi.constructors){bi.constructors[+t].forEach(t=>{if(t===e)throw new Ja("Duplicate callback constructor.")})}}static clear(){bi.constructors={}}static createCallbacks(e){const t=[];for(const n in bi.constructors){const a=+n;e>=a&&t.push(...bi.constructors[a])}return t.map(e=>new e)}}function yi(e,t,n,a,r,s,i,o,c){const l=new fi,u=[new pi,...bi.createCallbacks(t)];null!=e&&u.push(...e),u.push(l);const d=new hi(u);return d.setParams({epochs:n,initialEpoch:a,samples:r,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:c}),{callbackList:d,history:l}}function vi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return dr(e,s.Ze.SerializationMap.getMap().classNameMap,t,"layer",n)}function xi(e,t){return Object(s.wf)(()=>{"float32"!==e.dtype&&(e=s.Hd(e,"float32"));const n=s.pf(ns(e),t,!0),a=s.ge(n.shape,Vr()),r=s.lf(s.Ae(n,a));return s.Xd(e,r)})}function wi(e,t){return Object(s.wf)(()=>s.Be(ns(s.of(t,e)),-1))}function ki(e,t){return Object(s.wf)(()=>s.Be(s.rd(s.of(t,e)),-1))}function Ii(e,t){return Object(s.wf)(()=>{const n=s.of(e,t),a=s.Id(s.rd(e),Vr(),Number.MAX_VALUE),r=s.rd(s.Xd(n,a));return s.Fe(100,s.Be(r,-1))})}function Si(e,t){return Object(s.wf)(()=>{const n=s.Id(t,Vr(),Number.MAX_VALUE),a=s.se(s.sd(1,n)),r=s.Id(e,Vr(),Number.MAX_VALUE),i=s.se(s.sd(1,r));return s.Be(ns(s.of(a,i)),-1)})}function Ni(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Object(s.wf)(()=>{if(n)t=s.if(t);else{const e=s.pf(t,t.shape.length-1,!0);t=s.Xd(t,e)}return t=s.Id(t,Vr(),1-Vr()),s.Ge(s.pf(s.Fe(s.Hd(e,"float32"),s.se(t)),t.shape.length-1))})}function Ti(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Object(s.wf)(()=>{const a=s.Hd(s.he(qr(e)),"int32"),r=(t=s.Id(t,Vr(),1-Vr())).shape;return Ni(s.Ue(s.Je(a,r[r.length-1]),r),t,n)})}function Oi(e,t){return Object(s.wf)(()=>{let n;return n=s.Id(t,Vr(),1-Vr()),n=s.se(s.Xd(n,s.of(1,n))),s.Be(function(e,t){if(!s.Df.arraysEqual(e.shape,t.shape))throw new Ja("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(e.shape)," and ").concat(JSON.stringify(t.shape)));return Object(s.wf)(()=>{const n=s.Te(t),a=s.Ge(s.rd(t));return s.sd(s.of(n,s.Fe(t,e)),s.te(s.de(a)))})}(e,n),-1)})}function Ci(e,t){return Object(s.wf)(()=>{const n=s.Id(e,Vr(),1),a=s.Id(t,Vr(),1);return s.pf(s.Fe(e,s.se(s.Xd(n,a))),-1)})}function Ei(e,t){return Object(s.wf)(()=>{const n=xi(e,-1),a=xi(t,-1),r=s.Fe(n,a);return s.Ge(s.pf(r,-1))})}bi.constructors={};const _i={meanSquaredError:wi,meanAbsoluteError:ki,meanAbsolutePercentageError:Ii,meanSquaredLogarithmicError:Si,squaredHinge:function(e,t){return Object(s.wf)(()=>{const n=s.Ae(0,s.of(1,s.Fe(e,t)));return s.Be(ns(n),-1)})},hinge:function(e,t){return Object(s.wf)(()=>{const n=s.Ae(0,s.of(1,s.Fe(e,t)));return s.Be(n,-1)})},categoricalHinge:function(e,t){return Object(s.wf)(()=>{const n=s.pf(s.Fe(e,t),-1),a=s.xe(s.Fe(s.of(1,e),t),-1);return s.Ae(0,s.sd(1,s.of(a,n)))})},logcosh:function(e,t){return Object(s.wf)(()=>{const n=Math.log(2),a=s.of(t,e),r=s.of(s.sd(a,s.jf(s.Fe(-2,a))),n);return s.Be(r,-1)})},categoricalCrossentropy:Ni,sparseCategoricalCrossentropy:Ti,binaryCrossentropy:Oi,kullbackLeiblerDivergence:Ci,poisson:function(e,t){return Object(s.wf)(()=>{const n=s.se(s.sd(Vr(),t));return s.Be(s.of(t,s.Fe(e,n)),-1)})},cosineProximity:Ei};function Ai(e){if("string"===typeof e){if(e in _i)return _i[e];let t="Unknown loss ".concat(e);throw e.toLowerCase().includes("softmaxcrossentropy")&&(t="Unknown loss ".concat(e,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new Ja(t)}return e}function Ri(e,t){return Object(s.wf)(()=>{const n=s.Fe(.5,s.Le(t)),a=Gr(s.ke(t,n),e.dtype);return s.Be(s.ce(e,a),-1)})}function Di(e,t){return Object(s.wf)(()=>Gr(s.ce(s.vd(e,-1),s.vd(t,-1)),"float32"))}function Fi(e,t){return Object(s.wf)(()=>s.Hd(s.pf(s.ve(s.ce(e,1),s.ce(t,1))),"float32"))}function Mi(e,t){return Object(s.wf)(()=>{const n=Fi(e,t),a=function(e,t){return Object(s.wf)(()=>s.Hd(s.pf(s.ve(s.ce(e,0),s.ce(t,1))),"float32"))}(e,t),r=s.sd(n,a);return s.Hd(s.Hf(s.ke(r,0),s.Xd(n,r),0),"float32")})}function ji(e,t){return Oi(e,t)}function zi(e,t){return e.rank===t.rank&&(e=s.mf(e,[e.rank-1])),(t=s.vd(t,-1)).dtype!==e.dtype&&(t=s.Hd(t,e.dtype)),s.Hd(s.ce(e,t),"float32")}const Li=Ni,Pi=Ti,Bi={binaryAccuracy:Ri,categoricalAccuracy:Di,precision:Mi,categoricalCrossentropy:Li,sparseCategoricalCrossentropy:Pi,mse:wi,MSE:wi,mae:ki,MAE:ki,mape:Ii,MAPE:Ii,cosine:Ei};function Wi(e){if("string"===typeof e&&e in Bi)return Bi[e];if("string"!==typeof e&&null!=e)return e;throw new Ja("Unknown metric ".concat(e))}function Ui(e){if(nr(null!==e,"Unknown LossOrMetricFn ".concat(e)),"string"===typeof e)return e;{let t;for(const n of Object.keys(_i))if(_i[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(Bi))if(Bi[n]===e){t=n;break}return void 0!==t?t:e.name}}function Vi(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!Gi(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>1048576&&console.warn('User-defined metadata of model "'.concat(t,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(1048576,"."))}}function Gi(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!Gi(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!Gi(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function Hi(e){let t;return t=null!=e.collectedTrainableWeights?Ds(e.collectedTrainableWeights):Ds(e.trainableWeights),t}function qi(e){let t=!0;const n=[],a=[];for(const r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(const r of e.layers){let e=!1;for(const n of r.inboundNodes)if(-1!==a.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}function Ki(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,a="";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+" "),a+=e[r],a=a.slice(0,t[r]),a+=" ".repeat(t[r]-a.length);n(a)}function Xi(e,t,n){let a,r;try{r=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(o){r="multiple"}try{a=JSON.stringify(e.outputShape)}catch(o){a="multiple"}const s=e.name,i=e.getClassName();Ki(["".concat(s," (").concat(i,")"),r,a,e.countParams().toString()],t,n)}function Zi(e,t,n,a){let r,s;try{s=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(u){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch(u){r="multiple"}const i=[];for(const d of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(d)))for(let e=0;e<d.inboundLayers.length;++e){const t=d.inboundLayers[e].name,n=d.nodeIndices[e],a=d.tensorIndices[e];i.push("".concat(t,"[").concat(n,"][").concat(a,"]"))}const o=e.name,c=e.getClassName(),l=0===i.length?"":i[0];Ki(["".concat(o," (").concat(c,")"),s,r,e.countParams().toString(),l],t,a);for(let d=1;d<i.length;++d)Ki(["","","","",i[d]],t,a)}function Yi(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function Ji(e,t){if(null===e)return null;if("string"===typeof e)return or(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const a=e[r];Yi(t,r,a)?n.push(a):n.push(Ji(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n];if("name"===n&&"string"===typeof a)t[n]=a;else{const e=or(n);t[e]=Ji(a,e)}}return t}}class Qi extends Us{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=kr(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],pr(this.inputs).length!==this.inputs.length)throw new Ja("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map(e=>e.name)));pr(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map(e=>e.name))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const b of this.inputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;nr(0===t,"input layer has >1 nodes"),nr(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const t=this.inputLayers[b];if(!(t instanceof Vs))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(e.inputs,". ")+"Input ".concat(b," (0-based) originates ")+"from layer type ".concat(t.getClassName(),"."));this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);const t={},n={},a={},r={},s={},i=[],o=(e,t,n,a,r,c)=>{null!=a&&null!=r&&null!=c||(a=e.sourceLayer,r=e.nodeIndex,c=e.tensorIndex);const l=a.inboundNodes[r];if(-1!==n.indexOf(l))throw new Ya("The tensor ".concat(e.name,' at layer "').concat(a.name,'" ')+"is part of a cycle.");if(-1!==t.indexOf(l))return;this.containerNodes.add(Qi.nodeKey(a,r)),a.id in s||(s[a.id]=Object.keys(s).length),-1===n.indexOf(l)&&n.push(l);const u=l.inboundLayers.length;for(let s=0;s<u;s++){const e=l.inputTensors[s],a=l.inboundLayers[s],r=l.nodeIndices[s],i=l.tensorIndices[s];o(e,t,n,a,r,i)}for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);i.push(l)},c=[],l=[];for(const b of this.outputs)o(b,c,l);const u=i.slice().reverse();for(const b of u){n[b.id]=b,b.id in t||(t[b.id]=0);let e=t[b.id];const s=null==a[b.outboundLayer.id]?0:a[b.outboundLayer.id];e=Math.max(e,s),a[b.outboundLayer.id]=e,r[b.outboundLayer.id]=b.outboundLayer,t[b.id]=e;for(let a=0;a<b.inboundLayers.length;a++){const r=b.inboundLayers[a],s=b.nodeIndices[a],i=r.inboundNodes[s],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}const d={};for(const b in t){const e=t[b];e in d||(d[e]=[]),d[e].push(n[b])}const h={};for(const b in a){const e=a[b];e in h||(h[e]=[]),h[e].push(r[b])}let p=Object.keys(h).map(e=>parseInt(e,10)).sort(hr);this.layers=[];for(const b of p){const e=h[b];e.sort((e,t)=>{const n=s[e.id],a=s[t.id];return n<a?-1:n>a?1:0});for(const t of e)t instanceof Qi&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=h,p=Object.keys(d).map(e=>parseInt(e,10)).sort(hr);const f=this.inputs.slice(),m=[];for(const b of p)for(const e of d[b]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new Ya("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(t.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(m));for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=d;const g=this.layers.map(e=>e.name);for(const b of g){const e=g.filter(e=>e===b).length;if(1!==e)throw new Ya('The name "'.concat(b,'" is used ').concat(e," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new Bs({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Ja("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let a=0;for(const s of this.layers)for(const e of s.weights){if(null!=n[e.originalName])throw new Ja("Duplicate weight name: ".concat(e.originalName));n[e.originalName]=e,a++}const r=[];for(const s in e){let a=s;if(null==n[s]){const e=s.split("/");a=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[a])r.push([n[a],e[s]]);else if(t)throw new Ja("Provided weight data has no target variable: ".concat(s));delete n[a]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new Ja("".concat(e.length," of ").concat(a," weights are not set: ")+"".concat(e))}js(r)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers ".concat("3.21.0"),t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=function e(t,n){if(null===t||void 0===t)return null;if("string"===typeof t)return ir(t);if("number"===typeof t||"boolean"===typeof t)return t;if(t instanceof Array){const a=[],r=t.length;for(let s=0;s<r;++s){const r=t[s];Yi(n,s,r)?a.push(r):a.push(e(r,n))}return a}{const n={};for(const a of Object.keys(t)){const r=t[a],s=ir(a);n[s]="name"!==a&&"className"!==a||"string"!==typeof r?e(r,a):r}return n}}(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Object(s.wf)(()=>{e=sr(e);const n=new Hs;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return Xs(this.outputs,n,t)})}computeMask(e,t){return Object(s.wf)(()=>{let n;return e=sr(e),n=null==t?tr(null,e.length):sr(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){const t=_s(e);if(t.length!==this.inputLayers.length)throw new Ja("Invalid inputShape argument ".concat(e,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],a=t[i];n[e.name+"_0_0"]=a}const a=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(hr);if(a.length>1)for(const i of a){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map(e=>e.id).indexOf(e.id))continue;const a=[];for(let i=0;i<t.inboundLayers.length;i++){const e=t.inboundLayers[i],r=t.nodeIndices[i],s=t.tensorIndices[i],o=n["".concat(e.name,"_").concat(r,"_").concat(s)];a.push(o)}const r=_s(e.computeOutputShape(rr(a))),s=e.inboundNodes.indexOf(t);for(let t=0;t<r.length;t++){n["".concat(e.name,"_").concat(s,"_").concat(t)]=r[t]}}}const r=[],s=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],a="".concat(e.name,"_").concat(t,"_").concat(n);s.push(a)}for(let i=0;i<s.length;i++){const e=s[i];nr(e in n),r.push(n[e])}return rr(r)}runInternalGraph(e,t){null==t&&(t=tr(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const a=this.inputs[o],r=e[o],s=t[o];n[a.id]=[r,s]}const a=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(hr);for(const o of a){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,a=t.inputTensors,r=t.outputTensors,s=new Array;for(const t of a)t.id in n&&s.push(n[t.id]);if(s.length===a.length){let a,i,o,c,l={};if(null!=t.callArgs&&(l=t.callArgs),1===s.length){const[t,n]=s[0];null==l.mask&&(l.mask=n),o=sr(e.call(t,l)),c=sr(e.computeMask(t,n)),a=[t],i=[n]}else a=s.map(e=>e[0]),i=s.map(e=>e[1]),null==l.mask&&(l.mask=i),o=sr(e.call(a,l)),c=sr(e.computeMask(a,i));if(e.activityRegularizer)throw new Qa("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<r.length;++e){const t=r[e],a=o[e],s=c[e];n[t.id]=[a,s]}}}}const r=[],s=[],i=[];for(const o of this.outputs){nr(o.id in n,"Could not compute output ".concat(o.name," : ").concat(o.id));const[e,t]=n[o.id];i.push(e.shape),r.push(e),s.push(t)}return[r,s,i]}buildNodeConversionMap(e){const t={};let n;for(const a of this.layers){n=a instanceof Qi?1:0;for(let e=0;e<a.inboundNodes.length;e++){const r=Qi.nodeKey(a,e);this.containerNodes.has(r)&&(t[r]=n,n+=1)}}return t}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new Ja("Was asked to retrieve layer at index ".concat(t,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[t]}if(null==e)throw new Ja("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===e)return n;throw new Ja("No such layer: ".concat(e))}calculateLosses(){return Object(s.wf)(()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const a=Qi.nodeKey(t,n);this.containerNodes.has(a)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const i of this.layers){const e=i.getClassName(),a=i.getConfig(),r=[];for(let n=0;n<i.inboundNodes.length;n++){const e=i.inboundNodes[n],a=Qi.nodeKey(i,n);let o={};if(this.containerNodes.has(a)){if(e.callArgs)try{JSON.stringify(e.callArgs),o=e.callArgs}catch(s){console.warn("Layer ".concat(i.name," was passed ")+"non-serializable keyword arguments: "+"".concat(e.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),o={}}if(e.inboundLayers.length>0){const n=[];for(let a=0;a<e.inboundLayers.length;a++){const r=e.inboundLayers[a],s=e.nodeIndices[a],i=e.tensorIndices[a];let c=t[Qi.nodeKey(r,s)];null==c&&(c=0),n.push([r.name,c,i,o])}r.push(n)}}}const o={};o.name=i.name,o.className=e,o.config=a,o.inboundNodes=r,n.push(o)}e.layers=n;const a=[];for(let i=0;i<this.inputLayers.length;i++){const e=this.inputLayers[i],n=this.inputLayersNodeIndices[i],r=Qi.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let s=t[r];null!==s&&void 0!==s||(s=0);const o=this.inputLayersTensorIndices[i];a.push([e.name,s,o])}e.inputLayers=a;const r=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],n=this.outputLayersNodeIndices[i],a=Qi.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let s=t[a];null!==s&&void 0!==s||(s=0);const o=this.outputLayersTensorIndices[i];r.push([e.name,s,o])}return e.outputLayers=r,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={},r={};function s(e,t){e.name in r?r[e.name].push(t):r[e.name]=[t]}function i(e,t){const n=[];let r;for(const i of t){const o=i[0],c=i[1],l=i[2];if(r=null==i[3]?{}:i[3],!(o in a))return void s(e,t);const u=a[o];if(u.inboundNodes.length<=c)return void s(e,t);const d=u.inboundNodes[c];n.push(d.outputTensors[l])}n.length>0&&e.apply(rr(n),r)}function o(e){const r=e.name,i=vi(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),a[r]=i;e.inboundNodes.forEach(e=>{if(!(e instanceof Array))throw new Ja("Corrupted configuration, expected array for nodeData: ".concat(e));s(i,e)})}const c=t.name,l=t.layers;for(const f of l)o(f);for(;!fr(r);)for(const e of l){const t=a[e.name];if(t.name in r){const e=r[t.name];delete r[t.name];for(const n of e)i(t,n)}}const u=[],d=[],h=t.inputLayers;for(const f of h){const e=f[0],t=f[1],n=f[2];nr(e in a);const r=a[e].inboundNodes[t].outputTensors;u.push(r[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];nr(e in a);const r=a[e].inboundNodes[t].outputTensors;d.push(r[n])}return new e({inputs:u,outputs:d,name:c})}get stateful(){if(this._stateful)throw new Ja("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Object(s.wf)(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function $i(e,t,n){const a=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>null);if(1===a)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error("Provided ".concat(n," is an array of ").concat(e.length," ")+"element(s), but the model has ".concat(a," outputs. ")+"Make sure a set of weights is provided for each model output.");return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach(t=>{t in e?n.push(e[t]):n.push(null)}),n}throw new Error("The model has multiple (".concat(a,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(a," elements or an object with ").concat(t," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(e)))}function eo(e,t){return $i(e,t,"classWeight")}async function to(e,t,n,a){if(null!=t||null!=a)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Object(s.wf)(()=>{if(1===e.shape.length)return Object(s.Jd)(e);if(2===e.shape.length){if(e.shape[1]>1){const t=1;return Object(s.vd)(e,t)}if(1===e.shape[1])return Object(s.Ue)(e,[e.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")}),a=Array.from(await t.data());Object(s.Wd)(t);const r=[];return a.forEach(e=>{if(null==n[e])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(e," exists in the data but not in ")+"classWeight");r.push(n[e])}),Object(s.tf)(r,"float32")}return null}function no(e,t){return Object(s.Fe)(e,t)}function ao(e,t){let n,a;const r=t;n=r.xs,a=r.ys,s.Df.assert(null!=n&&null!=a,()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(t));const i=ro("input",e.inputNames,n),o=ro("output",e.outputNames,a),c=i[0].shape[0];s.Df.assert(i.length===e.inputs.length,()=>"LayersModel has ".concat(e.inputs.length," inputs, but the dataset ")+"provides ".concat(i.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(e.inputNames),")")),s.Df.assert(o.length===e.outputs.length,()=>"LayersModel has ".concat(e.outputs.length," outputs, but the dataset ")+"provides ".concat(o.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(e.outputNames),")"));for(let l=0;l<i.length;l++)s.Df.assert(i[l].shape[0]===c,()=>"Batch size mismatch: input "+"".concat(e.inputNames[l]," has ").concat(i[l].shape[0],"; ")+"expected  ".concat(c," based on input ").concat(e.inputNames[0],"."));for(let l=0;l<o.length;l++)s.Df.assert(o[l].shape[0]===c,()=>"Batch size mismatch: output "+"".concat(e.outputNames[l]," has ").concat(o[l].shape[0],"; ")+"expected  ".concat(c," based on input ").concat(e.inputNames[0],"."));return{xs:i,ys:o}}function ro(e,t,n){if(n instanceof s.gd)return[n];if(Array.isArray(n))return s.Df.assert(n.length===t.length,()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(t.length," to match the ").concat(e," keys ").concat(t,".")),n;{const a=[];for(const r of t){if(null==n[r])throw new Ja("The feature data generated by the dataset lacks the required "+"".concat(e," key '").concat(r,"'."));a.push(n[r])}return a}}async function so(e,t,n){const a=null!=n.batchesPerEpoch;if(s.Df.assert(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),s.Df.assert(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),s.Df.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs)),s.Df.assert(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch)),s.Df.assert(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const r=null!=n.validationData;let i,o;if(r)if(io(n.validationData))s.Df.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches));else{const e=function(e){if(3===e.length)throw new Qa("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);i=e.xs,o=e.ys}const c=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=r?l.slice().concat(l.map(e=>"val_"+e)):l.slice();const d=gi(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:p,history:f}=yi(d,h,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,r,u);p.setModel(e),e.history=f,await p.onTrainBegin(),e.stopTraining_=!1;let m=null==n.initialEpoch?0:n.initialEpoch,g=await t.iterator();for(;m<n.epochs;){const u={};await p.onEpochBegin(m);let d=0,h=0;for(a||(g=await t.iterator());!a||d<n.batchesPerEpoch;){const t=await g.next();if(a&&t.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(d," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:a,ys:r}=ao(e,t.value),i={};i.batch=h,i.size=a[0].shape[0],await p.onBatchBegin(h,i);const o=[];if(null!=n.classWeight){const t=eo(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)o.push(await to(r[e],null,t[e]))}const u=a.concat(r).concat(o),f=c(u);s.Wd(u);for(let e=0;e<l.length;++e){const t=l[e],n=f[e];i[t]=n,s.oe(n)}await p.onBatchEnd(h,i),li(i),h++,d++}if(a?d>=n.batchesPerEpoch:t.done){if(r){let t;t=io(n.validationData)?sr(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):sr(e.evaluate(i,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u["val_".concat(e.metricsNames[n])]=t[n]}break}if(e.stopTraining_)break}if(await p.onEpochEnd(m,u),m++,e.stopTraining_)break}return await p.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function io(e){return"function"===typeof e.iterator}function oo(e){s.Df.assert(e>0&&Number.isInteger(e),()=>"batchSize is required to be a positive integer, but got ".concat(e))}function co(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(e=>Kr(e,t,n-t)):Kr(e,t,n-t)}function lo(e,t){return s.wf(()=>null==e?null:Array.isArray(e)?e.map(e=>lo(e,t)):ts(e,"int32"===t.dtype?t:s.Hd(t,"int32")))}function uo(e,t){const n=[];let a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}async function ho(e,t,n,a,r,i,o,c,l,u,d,h,p,f,m){null==r&&(r=32),null==i&&(i=1),null==d&&(d=!0),null==p&&(p=0);let g=!1;if(null!=l&&null!=u&&(g=!0),null!=m&&(g=!0,null==f))throw new Ja("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=e.checkNumSamples(n,r,f,"steps_per_epoch");let y;null!=b&&(y=Wr(0,b)),null==o&&(o=1);const{callbackList:v,history:x}=yi(c,o,i,p,b,f,r,g,h);v.setModel(e),e.history=x,await v.onTrainBegin(),e.stopTraining_=!1;for(let w=p;w<i;++w){await v.onEpochBegin(w);const i={};if(null!=f)throw new Qa("stepsPerEpoch mode is not implemented yet.");{if("batch"===d)throw new Qa("batch shuffling is not implemneted yet");d&&s.Df.shuffle(y);const o=Object(s.tf)(y),c=uo(b,r);for(let d=0;d<c.length;++d){const h={};if(await v.onBatchBegin(d,h),s.wf(()=>{const p=c[d][0],f=c[d][1],m=Kr(o,p,f-p);h.batch=d,h.size=f-p;const b=lo(n,m),y=t(b);for(let e=0;e<a.length;++e){const t=a[e],n=y[e];h[t]=n,s.oe(n)}if(d===c.length-1&&g){const t=e.testLoop(l,u,r);for(let e=0;e<a.length;++e){const n=a[e],r=t[e];s.oe(r),i["val_"+n]=r}}}),await v.onBatchEnd(d,h),li(h),e.stopTraining_)break}o.dispose()}if(await v.onEpochEnd(w,i),e.stopTraining_)break}return await v.onTrainEnd(),await e.history.syncData(),e.history}function po(e){const t=[];e instanceof s.gd&&(e=[e]);for(let n=0;n<e.length;++n){const a=e[n];if(1===a.rank)t.push(Hr(a,1));else{if(0===a.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function fo(e,t){if(null==e)return;const n=[];if(t instanceof s.gd)n.push(t.id);else if(Array.isArray(t))t.forEach(e=>n.push(e.id));else if(null!=t)for(const r in t){const e=t[r];n.push(e.id)}const a=[];if(e instanceof s.gd)-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach(e=>{-1===n.indexOf(e.id)&&a.push(e)});else if(null!=e)for(const r in e){const t=e[r];-1===n.indexOf(t.id)&&a.push(t)}a.forEach(e=>{e.isDisposed||e.dispose()})}function mo(e){return Array.isArray(e)}function go(e){return!function(e){return e instanceof s.gd}(e)&&!mo(e)}function bo(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(mo(e)&&e.length>0)t=!0;else if(go(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new Ja("Error when checking model ".concat(s," expected no data, ")+"but got ".concat(e))}return[]}if(null==e)return t.map(e=>null);if(go(e)){e=e,a=[];for(const n of t){if(null==e[n])throw new Ja('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(t));a.push(e[n])}}else if(mo(e)){if((e=e).length!==t.length)throw new Ja("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(t.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(e));a=e}else{if(e=e,t.length>1)throw new Ja("The model ".concat(s," expects ").concat(t.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(e.shape));a=[e]}if(a=po(a),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new Ja("Error when checking ".concat(s,": expected ").concat(t[i]," ")+"to have ".concat(n[i].length," dimension(s). but got array with ")+"shape ".concat(e.shape));for(let t=0;t<n[i].length;++t){if(0===t&&!r)continue;const a=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&a!==o)throw new Ja("".concat(s," expected a batch of elements where each ")+"example has shape [".concat(n[i].slice(1,n[i].length),"] ")+"(i.e.,tensor shape [*,".concat(n[i].slice(1,n[i].length),"])")+" but the ".concat(s," received an input with ").concat(e.shape[0])+" examples, each with shape [".concat(e.shape.slice(1,e.shape.length),"]")+" (tensor shape [".concat(e.shape,"])"))}}return a}function yo(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new Ja("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(t.length," Tensor(s),")+" but instead got ".concat(e.length," Tensors(s)."));a=e}else{if(t.length>1)throw new Ja("The model expects ".concat(t.length," ").concat(s," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(e.shape),"."));a=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new Ja("Error when checking ".concat(s,": expected ").concat(t[i]," ")+"to have ".concat(n[i].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(e.shape)));for(let a=0;a<n[i].length;++a){if(0===a&&!r)continue;const o=e.shape[a],c=n[i][a];if(null!=c&&c!==o)throw new Ja("Error when checking ".concat(s,": expected ")+"".concat(t[i]," to have shape ").concat(JSON.stringify(n[i])," but ")+"got array with shape ".concat(JSON.stringify(e.shape),"."))}}}class vo extends Qi{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new Ja("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const r=qi(e),s=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(e=>Math.floor(t*e))),!r){s.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}a("_".repeat(t)),Ki(s,n,a),a("=".repeat(t));const o=e.layers;for(let u=0;u<o.length;++u)r?Xi(o[u],n,a):Zi(o[u],n,i,a),a((u===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const c=Hi(e),l=Ds(e.nonTrainableWeights);a("Total params: ".concat(c+l)),a("Trainable params: ".concat(c)),a("Non-trainable params: ".concat(l)),a("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>s.yf.adagrad(.01),Adadelta:()=>s.yf.adadelta(1,.95,Vr()),Adam:()=>s.yf.adam(.001,.9,.999,Vr()),Adamax:()=>s.yf.adamax(.002,.9,.999,Vr(),0),RMSProp:()=>s.yf.rmsprop(.001,.9,0,Vr()),SGD:()=>s.yf.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new Ja("Unknown Optimizer ".concat(e))}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof s.fc))throw new Ja("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Ja("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(e.loss,"."));const n=e.loss;t=n.map(e=>Ai(e))}else{const n=Ai(e.loss);this.outputs.forEach(e=>{t.push(n)})}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new Ja('Unknown entry in loss dictionary: "'.concat(t,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==e.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),t.push(Ai(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Dr("loss",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}});const a=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>[]);let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(e));n=e}if(Array.isArray(n))return t.map(e=>n);{const e=[];for(const a of t){let t=n.hasOwnProperty(a)?n[a]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),r=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};Dr("metric",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,a,s;for(const i of t){if("string"===typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let r;1===t[t.length-1]||this.lossFunctions[e]===Oi?-1!==["accuracy","acc"].indexOf(i)?a=Ri:-1!==["crossentropy","ce"].indexOf(i)&&(a=ji):this.lossFunctions[e]===Ti?-1!==["accuracy","acc"].indexOf(i)?a=zi:-1!==["crossentropy","ce"].indexOf(i)&&(a=Pi):-1!==["accuracy","acc"].indexOf(i)?a=Di:-1!==["crossentropy","ce"].indexOf(i)&&(a=Li),-1!==["accuracy","acc"].indexOf(i)?r="acc":-1!==["crossentropy","ce"].indexOf(i)&&(r="ce"),s=a,n=""+r}else{const e=Wi(i);s=e,n=""+Ui(i)}let t;Dr(n,()=>{t=s}),r(e,n,t)}})(a[e])}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=null==n.batchSize?32:n.batchSize;oo(a);const r=this.standardizeUserDataXY(e,t,!0,a);try{const s=r[0].concat(r[1]);this.makeTestFunction();const i=this.testFunction;return rr(this.testLoop(i,s,a,n.verbose,n.steps))}finally{fo(r[0],e),fo(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const a=null!=(n=n||{}).batches,r=e.testFunction;let i=[];if(n.verbose>0)throw new Qa("Verbose mode is not implemented yet.");s.Df.assert(!a||n.batches>0&&Number.isInteger(n.batches),()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches)));const o="function"===typeof t.next?t:await t.iterator();let c=0,l=0;for(;!a||l<n.batches;){const t=await o.next();if(i=s.wf(()=>{if(t.value){const{xs:n,ys:a}=ao(e,t.value),o=n.concat(a),u=s.wf(()=>r(o));if(s.Wd(o),0===l)for(let e=0;e<u.length;++e)i.push(Object(s.We)(0));const d=o[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=i[e];i[e]=s.wf(()=>s.sd(i[e],s.Fe(d,t))),l>0&&s.Wd(n)}s.Wd(u),c+=d,++l}return i}),t.done){a&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let u=0;u<i.length;++u){const e=i[u];i[u]=s.Xd(i[u],c),s.Wd(e)}return rr(i)}(this,e,t)}checkNumSamples(e,t,n){let a,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(a=null,null!=t)throw new Ja("If ".concat(r," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(t))}else{if(null==e)throw new Ja("Either the input data should have a defined shape, or "+"".concat(r," shoud be specified."));a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new Ja("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),i=new Hs;if(e instanceof s.gd&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Ja("The number of inputs provided (".concat(e.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let t=0;t<this.inputs.length;++t)i.add(this.inputs[t],e[t])}else for(const s of this.inputs){const t=e[s.name];if(null==t)throw new Ja("No value is provided for the model's input ".concat(s.name));i.add(s,t)}const o=Xs(r,i);return n?o:o[0]}retrieveSymbolicTensors(e){const t=tr(null,e.length);let n=e.length;for(const a of this.layers){const r=Array.isArray(a.output)?a.output:[a.output],s=r.map(e=>e.name);for(let a=0;a<e.length;++a){const i=s.indexOf(e[a]);if(-1!==i&&(t[a]=r[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach((t,a)=>{null==t&&n.push(e[a])}),new Ja("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return s.wf(()=>{const a=this.checkNumSamples(e);if(n)throw new Qa("Verbose predictLoop() is not implemented yet.");const r=uo(a,t),i=this.outputs.map(e=>[]);for(let t=0;t<r.length;++t){s.wf(()=>{const n=r[t][0],a=r[t][1],s=co(e,n,a),i=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)i.push({key:this.inputs[e],value:s[e]});else i.push({key:this.inputs[0],value:s});const o=new Hs(i);return Xs(this.outputs,o)}).forEach((e,t)=>i[t].push(e))}return rr(i.map(e=>s.Kd(e,0)))})}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=po(e);yo(n,this.inputNames,this.feedInputShapes,!1);try{const a=null==t.batchSize?32:t.batchSize;return oo(a),this.predictLoop(n,a)}finally{fo(n,e)}}predictOnBatch(e){yo(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new Ya("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let r=0;r<this.feedOutputShapes.length;++r){const e=this.feedOutputShapes[r];this.feedLossFns[r]===Ti?a.push(e.slice(0,e.length-1).concat([1])):a.push(e)}if(function(e,t,n){const a=pr(e.map(e=>e.shape[0]));a.sort();const r=pr(t.map(e=>e.shape[0]));if(r.sort(),a.length>1)throw new Ja("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map(e=>e.shape))));if(r.length>1)throw new Ja("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map(e=>e.shape))));if(a.length>0&&r.length>0&&!s.Df.arraysEqual(a,r))throw new Ja("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(a[0]," input sample(s) and ").concat(r[0]," target ")+"sample(s).")}(e=bo(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=bo(t,this.feedOutputNames,a,!1,"target")),function(e,t,n){const a=[wi,Oi,Ni];for(let r=0;r<e.length;++r){const s=e[r],i=t[r],o=n[r];if(null!=i){if(i===Ni&&1===s.shape[s.shape.length-1])throw new Ja("You are passing a target array of shape ".concat(s.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==a.indexOf(i)){const e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const a=e[n],r=t[n];if(null!=r&&a!==r)throw new Ja("A target Tensor with shape ".concat(s.shape," was passed for an ")+"output of shape ".concat(o,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new Ja("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(e[0].shape[0]," sample(s)."));return[e,t]}async standardizeUserData(e,t,n,a){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0;const[i,o]=this.standardizeUserDataXY(e,t,r,s);if(null!=n)throw new Error("sample weight is not supported yet.");let c=null;if(null!=a){const e=eo(a,this.outputNames);c=[];for(let t=0;t<e.length;++t)c.push(await to(o[t],null,e[t]))}return[i,o,c]}testLoop(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4?arguments[4]:void 0;return s.wf(()=>{const i=this.checkNumSamples(t,n,r,"steps"),o=[];if(a>0)throw new Qa("Verbose mode is not implemented yet.");if(null!=r)throw new Qa("steps mode in testLoop() is not implemented yet");{const a=uo(i,n),r=Object(s.tf)(Wr(0,i));for(let n=0;n<a.length;++n){const i=a[n][0],c=a[n][1],l=Kr(r,i,c-i),u=lo(t,l),d=e(u);if(0===n)for(let e=0;e<d.length;++e)o.push(Object(s.We)(0));for(let e=0;e<d.length;++e){const t=d[e];o[e]=s.sd(o[e],s.Fe(c-i,t))}}for(let e=0;e<o.length;++e)o[e]=s.Xd(o[e],i)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const a=e[n];let r=a;if(ar(e,a)>1){const t=ar(e.slice(0,n),a);r+="_".concat(t)}t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],o=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const o=new Hs(e),c=Xs(this.outputs,o,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(a[n],c[n]);null!=r[n]&&(e=no(e,r[n]));const i=s.Be(e);t.push(i),l=0===n?e:s.sd(l,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],r=this.metricsTensors[n][1];e=s.Be(t(a[r],c[r]))}s.oe(e),i.push(e)}return l=s.Be(l),this.calculateLosses().forEach(e=>{l=s.sd(l,e)}),l},!0,o)].concat(i)}}makeTestFunction(){this.testFunction=e=>s.wf(()=>{const t=[];let n;const a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let e=0;e<this.inputs.length;++e)i.push({key:this.inputs[e],value:a[e]});const o=new Hs(i),c=Xs(this.outputs,o);for(let e=0;e<this.lossFunctions.length;++e){const a=this.lossFunctions[e],i=s.Be(a(r[e],c[e]));n=0===e?i:s.sd(n,i),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],a=this.metricsTensors[e][1],i=s.Be(n(r[a],c[a]));t.push(i)}return t})}async fit(e,t){return async function(e,t,n){let a,r,i,o,c,l,u,d,h,p=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const f=null==p.batchSize?32:p.batchSize;oo(f);const m=!1,g=await e.standardizeUserData(t,n,p.sampleWeight,p.classWeight,m,f);a=g[0],r=g[1],h=g[2];let b,y=!1;if(null!=p.validationData&&p.validationData.length>0){if(y=!0,2!==p.validationData.length)throw 3===p.validationData.length?new Qa("validationData including sample weights is not supported yet."):new Ja("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(p.validationData," is invalid."));c=p.validationData[0],l=p.validationData[1];const t=!0,n=await e.standardizeUserData(c,l,null,null,t,f);u=n[0],d=n[1],b=u.concat(d)}else if(null!=p.validationSplit&&p.validationSplit>0&&p.validationSplit<1){y=!0;const e=Math.floor(a[0].shape[0]*(1-p.validationSplit)),t=a[0].shape[0];u=co(a,e,t),i=a,a=co(a,0,e),d=co(r,e,t),o=r,r=co(r,0,e),b=u.concat(d)}else null!=p.validationSteps&&(y=!0);const v=a.concat(r).concat(h);e.checkTrainableWeightsConsistency();const x=e.makeTrainFunction(),w=e.getDedupedMetricsNames();let k,I;y?(e.makeTestFunction(),k=e.testFunction,I=w.slice().concat(w.map(e=>"val_"+e))):(k=null,b=[],I=w.slice());const S=gi(p.callbacks,p.yieldEvery);return await ho(e,x,v,w,f,p.epochs,p.verbose,S,k,b,p.shuffle,I,p.initialEpoch,null,null)}finally{e.isTraining=!1,fo(a,t),fo(r,n),fo(i,t),fo(o,n),fo(u,c),fo(d,l),null!=h&&s.Wd(h)}}(this,e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}async fitDataset(e,t){return so(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),a=n[0],r=n[1],i=this.makeTrainFunction()(a.concat(r)),o=[];for(const s of i){const e=await s.data();o.push(e[0])}return s.Wd(i),fo(n[0],e),fo(n[1],t),rr(o)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let s=0;s<a.length;++s)n&&!a[s].trainable||t.push({name:a[s].originalName,tensor:r[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=s.Ce().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-s.Ce().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=ir(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(e=>ir(e))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const a of t){if("string"!==typeof n[a])throw new Error("Serialization of non-string loss is not supported.");e[a]=ir(n[a])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[ir(Ui(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>ir(Ui(e)));{const e={};for(const t in this.metrics)e[t]=ir(Ui(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=vi(Ji(e.optimizer_config));let n,a;if("string"===typeof e.loss)n=or(e.loss);else if(Array.isArray(e.loss))n=e.loss.map(e=>or(e));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=or(e.loss[t])}if(Array.isArray(e.metrics))a=e.metrics.map(e=>or(e));else if(null!=e.metrics){a={};for(const t in e.metrics)a[t]=or(e.metrics[t])}this.compile({loss:n,metrics:a,optimizer:t})}async save(e,t){if("string"===typeof e){const t=s.ne.getSaveHandlers(e);if(0===t.length)throw new Ja("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new Ja("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}if(null==e.save)throw new Ja("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await s.ne.encodeWeights(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat("3.21.0"),convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:r}=await s.ne.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...r),n.data=s.ne.concatenateArrayBuffers([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;Vi(this.userDefinedMetadata,this.name,e),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){Vi(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}vo.className="Model",s.Ze.registerClass(vo);class xo extends vo{}xo.className="Functional",s.Ze.registerClass(xo);class wo extends vo{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:kr("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new Ja("Negative dimension size caused by adding layer "+"".concat(e.name," with input shape [")+"".concat(e.inboundNodes[0].inputTensors[0].shape,"]"))}add(e){const t=e instanceof wo||e instanceof vo;let n;if(t){if(n=e,1!==n.outputs.length)throw new Ja("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new Ja("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new Ja("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=Gs({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new Ja("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(e.name," ")+"which has ".concat(e.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new Ja("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=function e(t,n,a){if((null==n||null!=a&&a>0)&&(n=t.sourceLayer,a=t.nodeIndex),0===n.inboundNodes.length)return[t];{const t=n.inboundNodes[a];if(0===t.inboundLayers.length)return t.inputTensors;{const n=[];for(let a=0;a<t.inboundLayers.length;a++){const r=e(t.inputTensors[a],t.inboundLayers[a],t.nodeIndices[a]);for(const e of r)-1===n.indexOf(e)&&n.push(e)}return n}}}(this.outputs[0])}this.inboundNodes=[],new Bs({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:tr(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(Rs(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new vo({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new Ya("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Ya("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new Ya("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Ya("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new Ja("Legacy serialization format not supported yet.");n=t}else s.Df.assert(null!=t.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),n=t.layers,delete t.layers,r=t;const i=new e(r);if(!(i instanceof wo))throw new Qa("Sequential.fromConfig called on non-Sequential input: ".concat(i));for(const s of n){const e=vi(s,void 0,a);a&&e.setFastWeightInitDuringBuild(!0),i.add(e)}return i}set stopTraining(e){if(null==this.model)throw new Ja("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new Ja("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}wo.className="Sequential",s.Ze.registerClass(wo);class ko extends s.Ze.Serializable{getConfig(){return{}}}class Io extends ko{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new Qa("Support for alpha values other than 1 (".concat(t,") is not implemented ")+"yet.");return s.Zd(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}Io.className="elu",s.Ze.registerClass(Io);class So extends ko{apply(e){return s.Xe(e)}}So.className="selu",s.Ze.registerClass(So);class No extends ko{apply(e){return s.Te(e)}}No.className="relu",s.Ze.registerClass(No);class To extends ko{apply(e){return Object(s.wf)(()=>s.De(6,s.Te(e)))}}To.className="relu6",s.Ze.registerClass(To);class Oo extends ko{apply(e){return e}}Oo.className="linear",s.Ze.registerClass(Oo);class Co extends ko{apply(e){return s.bf(e)}}Co.className="sigmoid",s.Ze.registerClass(Co);class Eo extends ko{apply(e){return function(e){return Object(s.wf)(()=>{const t=s.sd(.5,s.Fe(.2,e));return s.Id(t,0,1)})}(e)}}Eo.className="hardSigmoid",s.Ze.registerClass(Eo);class _o extends ko{apply(e){return s.jf(e)}}_o.className="softplus",s.Ze.registerClass(_o);class Ao extends ko{apply(e){return function(e){return Object(s.wf)(()=>s.Xd(e,s.sd(s.rd(e),1)))}(e)}}Ao.className="softsign",s.Ze.registerClass(Ao);class Ro extends ko{apply(e){return s.rf(e)}}Ro.className="tanh",s.Ze.registerClass(Ro);class Do extends ko{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return s.if(e,t)}}Do.className="softmax",s.Ze.registerClass(Do);class Fo extends ko{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return s.ue(e,t)}}Fo.className="logSoftmax",s.Ze.registerClass(Fo);class Mo extends ko{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return Object(s.wf)(()=>s.Fe(s.bf(s.Fe(e,t)),e))}}Mo.className="swish",s.Ze.registerClass(Mo);class jo extends ko{apply(e){return Object(s.wf)(()=>s.Fe(e,s.rf(s.jf(e))))}}function zo(e){return e.getClassName()}function Lo(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return dr(e,s.Ze.SerializationMap.getMap().classNameMap,t,"activation")}function Po(e){if(null==e){const e={className:"linear",config:{}};return Lo(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},Lo(t)}return e instanceof ko?e:Lo(e)}function Bo(e){if(null!=e&&"object"!==typeof e)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(e))}jo.className="mish",s.Ze.registerClass(jo);class Wo extends s.Ze.Serializable{}class Uo extends Wo{constructor(e){super(),Bo(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Object(s.wf)(()=>{let t=Object(s.If)([1]);return this.hasL1&&(t=Object(s.sd)(t,Object(s.pf)(s.Fe(this.l1,Object(s.rd)(e))))),this.hasL2&&(t=Object(s.sd)(t,Object(s.pf)(s.Fe(this.l2,ns(e))))),s.Ue(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}Uo.className="L1L2",s.Ze.registerClass(Uo);const Vo={l1l2:"L1L2"};function Go(e){return lr(e)}function Ho(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return dr(e,s.Ze.SerializationMap.getMap().classNameMap,t,"regularizer")}function qo(e){if(null==e)return null;if("string"===typeof e){return Ho({className:e in Vo?Vo[e]:e,config:{}})}return e instanceof Wo?e:Ho(e)}class Ko extends Us{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=As(e);let n=Object(s.Te)(e);return null!=this.maxValue&&(n=Object(s.Id)(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}Ko.className="ReLU",s.Ze.registerClass(Ko);class Xo extends Us{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=As(e);return Object(s.qe)(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Xo.className="LeakyReLU",s.Ze.registerClass(Xo);class Zo extends Us{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Cs(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=qo(e.alphaRegularizer),this.alphaConstraint=oi(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new Ja("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(e.sharedAxes));this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=Rs(e)).slice(1);if(null!=this.sharedAxes)for(const a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new zs({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=As(e),Object(s.Oe)(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Os(this.alphaInitializer),alphaRegularizer:Go(this.alphaRegularizer),alphaConstraint:si(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}Zo.className="PReLU",s.Ze.registerClass(Zo);class Yo extends Us{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Qa("Non-default alpha value (".concat(e.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=As(e);return Object(s.Zd)(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Yo.className="ELU",s.Ze.registerClass(Yo);class Jo extends Us{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=As(e);return Object(s.Fe)(n,Object(s.Hd)(Object(s.ke)(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}Jo.className="ThresholdedReLU",s.Ze.registerClass(Jo);class Qo extends Us{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Do).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){const n=As(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function $o(e,t,n){if("number"===typeof e)return tr(e,t);if(e.length!==t)throw new Ja("The ".concat(n," argument must be an integer or tuple of ").concat(t," integers.")+" Received: ".concat(e.length," elements."));for(let r=0;r<t;++r){const s=e[r];if((a=s)!==parseInt(a.toString(),10))throw new Ja("The ".concat(n," argument must be an integer or tuple of ").concat(t)+" integers. Received: ".concat(JSON.stringify(e)," including a")+" non-integer number ".concat(s))}return e;var a}function ec(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1;if(null==e)return e;const s=t+(t-1)*(r-1);let i;return i="same"===n?e:e-s+1,Math.floor((i+a-1)/a)}function tc(e,t,n,a){if(null==e)return null;if("valid"===a)e=e*t+Br([n-t,0]);else{if("same"!==a)throw new Ja("Unsupport padding mode: ".concat(a,"."));e*=t}return e}function nc(e,t){return Object(s.wf)(()=>(Er(t),"channelsFirst"===t?s.zf(e,[0,2,3,1]):e))}function ac(e,t){return Object(s.wf)(()=>(Er(t),"channelsFirst"===t?s.zf(e,[0,2,3,4,1]):e))}function rc(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",i=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return Object(s.wf)(()=>{if(null==i&&(i="channelsLast"),Er(i),3!==e.shape.length)throw new Ja("The input of a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead."));if(3!==t.shape.length)throw new Ja("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new Ja("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(t.shape.length," instead"));if("channelsFirst"===i&&(e=s.zf(e,[0,2,1])),"causal"===r)throw new Qa("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let c=s.Pd(e,t,a,"same"===r?"same":"valid","NWC",o);return null!=n&&(c=rs(c,n)),c})}function sc(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",i=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0,c=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return Object(s.wf)(()=>{if(null==i&&(i="channelsLast"),Er(i),3!==e.rank&&4!==e.rank)throw new Ja("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));if(3!==t.rank&&4!==t.rank)throw new Ja("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));let l=nc(e,i);if("causal"===r)throw new Qa("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=s.ie.conv2d({x:l,filter:t,strides:a,pad:"same"===r?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:c}),"channelsFirst"===i&&(l=s.zf(l,[0,3,1,2])),l})}function ic(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",i=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0;return Object(s.wf)(()=>{if(null==i&&(i="channelsLast"),Er(i),4!==e.rank&&5!==e.rank)throw new Ja("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(e.rank,"."));if(4!==t.rank&&5!==t.rank)throw new Ja("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(e.rank,"."));let c=ac(e,i);if("causal"===r)throw new Qa("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return c=s.Sd(c,t,a,"same"===r?"same":"valid","NDHWC",o),null!=n&&(c=rs(c,n)),"channelsFirst"===i&&(c=s.zf(c,[0,4,1,2,3])),c})}Qo.className="Softmax",s.Ze.registerClass(Qo);class oc extends Us{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",oc.verifyArgs(t),this.rank=e,br(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Qa("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=$o(t.kernelSize,e,"kernelSize"),this.strides=$o(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,_r(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Er(this.dataFormat),this.activation=Po(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=Cs(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=oi(t.biasConstraint),this.biasRegularizer=qo(t.biasRegularizer),this.activityRegularizer=qo(t.activityRegularizer),this.dilationRate=$o(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new Ja("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new Ja("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new Ja("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(e){if(nr("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!gr(e.kernelSize,"number",1,3))throw new Ja("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize),"."))}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:zo(this.activation),useBias:this.useBias,biasInitializer:Os(this.biasInitializer),biasRegularizer:Go(this.biasRegularizer),activityRegularizer:Go(this.activityRegularizer),biasConstraint:si(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class cc extends oc{constructor(e,t){super(e,t),this.kernel=null,cc.verifyArgs(t),this.filters=t.filters,br(this.filters,"filters"),this.kernelInitializer=Cs(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=oi(t.kernelConstraint),this.kernelRegularizer=qo(t.kernelRegularizer)}build(e){e=Rs(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Ja("The channel dimension of the input should be defined. "+"Found ".concat(e[t]));const n=e[t],a=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Object(s.wf)(()=>{let t;e=As(e);const n=null==this.bias?null:this.bias.read(),a=yr(this.activation.getClassName());if(null!=a&&2===this.rank)t=sc(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(1===this.rank)t=rc(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=sc(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Qa("convolutions greater than 3D are not implemented yet.");t=ic(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t})}computeOutputShape(e){e=Rs(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<n.length;++r){const e=ec(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(e)}let a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t),a.push(this.filters)):(a.push(this.filters),a=a.concat(t)),a}getConfig(){const e={filters:this.filters,kernelInitializer:Os(this.kernelInitializer),kernelRegularizer:Go(this.kernelRegularizer),kernelConstraint:si(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new Ja("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(e.filters)))}}class lc extends cc{constructor(e){super(2,e),lc.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!gr(e.kernelSize,"number",1,2))throw new Ja("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize),"."))}}lc.className="Conv2D",s.Ze.registerClass(lc);class uc extends cc{constructor(e){super(3,e),uc.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new Ja("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(e.kernelSize),"."))}}uc.className="Conv3D",s.Ze.registerClass(uc);class dc extends lc{constructor(e){if(super(e),this.inputSpec=[new zs({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new Ja("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(4!==(e=Rs(e)).length)throw new Ja("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Ja("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new zs({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return s.wf(()=>{let t=As(e);if(4!==t.shape.length)throw new Ja("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let r,i;"channelsFirst"===this.dataFormat?(r=2,i=3):(r=1,i=2);const o=n[r],c=n[i],l=this.kernelSize[0],u=this.kernelSize[1],d=this.strides[0],h=this.strides[1],p=[a,tc(o,d,l,this.padding),tc(c,h,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=s.zf(t,[0,2,3,1]));let f=s.Rd(t,this.kernel.read(),p,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(f=s.zf(f,[0,3,1,2])),null!=this.bias&&(f=rs(f,this.bias.read(),this.dataFormat)),null!=this.activation&&(f=this.activation.apply(f)),f})}computeOutputShape(e){const t=(e=Rs(e)).slice();let n,a,r;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3):(n=3,a=1,r=2);const s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],c=this.strides[1];return t[n]=this.filters,t[a]=tc(t[a],o,s,this.padding),t[r]=tc(t[r],c,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}dc.className="Conv2DTranspose",s.Ze.registerClass(dc);class hc extends uc{constructor(e){if(super(e),this.inputSpec=[new zs({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new Ja("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(5!==(e=Rs(e)).length)throw new Ja("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Ja("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new zs({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return s.wf(()=>{let t=As(e);if(5!==t.shape.length)throw new Ja("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let r,i,o;"channelsFirst"===this.dataFormat?(o=2,r=3,i=4):(o=1,r=2,i=3);const c=n[o],l=n[r],u=n[i],d=this.kernelSize[0],h=this.kernelSize[1],p=this.kernelSize[2],f=this.strides[0],m=this.strides[1],g=this.strides[2],b=[a,tc(c,f,d,this.padding),tc(l,m,h,this.padding),tc(u,g,p,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=s.zf(t,[0,2,3,4,1]));let y=s.Td(t,this.kernel.read(),b,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=s.zf(y,[0,4,1,2,3])),null!==this.bias&&(y=rs(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y})}computeOutputShape(e){const t=(e=Rs(e)).slice();let n,a,r,s;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3,s=4):(n=4,a=1,r=2,s=3);const i=this.kernelSize[0],o=this.kernelSize[1],c=this.kernelSize[2],l=this.strides[0],u=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[a]=tc(t[a],l,i,this.padding),t[r]=tc(t[r],u,o,this.padding),t[s]=tc(t[s],d,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}hc.className="Conv3DTranspose",s.Ze.registerClass(hc);class pc extends cc{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new Ja("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new Ja("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new Ja("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(t.padding)));this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Cs(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=qo(t.depthwiseRegularizer),this.depthwiseConstraint=oi(t.depthwiseConstraint),this.pointwiseInitializer=Cs(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=qo(t.pointwiseRegularizer),this.pointwiseConstraint=oi(t.pointwiseConstraint)}build(e){if((e=Rs(e)).length<this.rank+2)throw new Ja("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(e)));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new Ja("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(e[t])));const n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let s=0;s<this.rank;++s)r.push(1);r.push(n*this.depthMultiplier,this.filters);this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.inputSpec=[new zs({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Object(s.wf)(()=>{let t;if(e=As(e),1===this.rank)throw new Qa("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=s.zf(e,[0,2,3,1])),t=s.Ye(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=rs(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=s.zf(t,[0,3,1,2])),t})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Os(this.depthwiseInitializer),e.pointwiseInitializer=Os(this.pointwiseInitializer),e.depthwiseRegularizer=Go(this.depthwiseRegularizer),e.pointwiseRegularizer=Go(this.pointwiseRegularizer),e.depthwiseConstraint=si(this.depthwiseConstraint),e.pointwiseConstraint=si(this.pointwiseConstraint),e}}pc.className="SeparableConv";class fc extends pc{constructor(e){super(2,e)}}fc.className="SeparableConv2D",s.Ze.registerClass(fc);class mc extends cc{constructor(e){super(1,e),mc.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!gr(e.kernelSize,"number",1,1))throw new Ja("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(e.kernelSize),"."))}}mc.className="Conv1D",s.Ze.registerClass(mc);class gc extends Us{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Object(s.wf)(()=>{if(e=As(e),"channelsLast"===this.dataFormat){const t=Zr(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Zr(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=Zr(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Zr(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}gc.className="Cropping2D",s.Ze.registerClass(gc);class bc extends Us{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Er(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,mr(Sr,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return s.wf(()=>{let t=As(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=s.zf(t,[0,2,3,1]);const e=this.size[0]*n[2],a=this.size[1]*n[3],r="nearest"===this.interpolation?s.me.resizeNearestNeighbor(t,[e,a]):s.me.resizeBilinear(t,[e,a]);return s.zf(r,[0,3,1,2])}{const e=this.size[0]*n[1],a=this.size[1]*n[2];return"nearest"===this.interpolation?s.me.resizeNearestNeighbor(t,[e,a]):s.me.resizeBilinear(t,[e,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}bc.className="UpSampling2D",s.Ze.registerClass(bc);class yc extends oc{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Cs(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=oi(e.depthwiseConstraint),this.depthwiseRegularizer=qo(e.depthwiseRegularizer)}build(e){if((e=Rs(e)).length<4)throw new Ja("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(e),"."));const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new Ja("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(e[t],")."));const n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Object(s.wf)(()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",r=arguments.length>4?arguments[4]:void 0,i=arguments.length>5?arguments[5]:void 0;return Object(s.wf)(()=>{null==r&&(r="channelsLast"),Er(r);let o=nc(e,r);if(4!==e.rank)throw new Ja("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));if(4!==t.rank)throw new Ja("depthwiseKernel is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));return o=s.Ud(o,t,n,"same"===a?"same":"valid","NHWC",i),"channelsFirst"===r&&(o=s.zf(o,[0,3,1,2])),o})}(e=As(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=rs(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t})}computeOutputShape(e){e=Rs(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=ec(t,this.kernelSize[0],this.padding,this.strides[0]),s=ec(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],a,r,s]:[e[0],r,s,a]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Os(this.depthwiseInitializer),e.depthwiseRegularizer=Go(this.depthwiseRegularizer),e.depthwiseConstraint=si(this.depthwiseRegularizer),e}}function vc(e,t,n,a){if(Array.isArray(e)){if(null!=t||null!=n)throw new Ja("When inputs is an array, neither initialState or constants should be provided");null!=a&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=r(t),constants:n=r(n)}}function xc(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4?arguments[4]:void 0,i=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],c=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return s.wf(()=>{const l=t.shape.length;if(l<3)throw new Ja("Input should be at least 3D, but is ".concat(l,"D."));const u=[1,0].concat(Wr(2,l));if(t=s.zf(t,u),null!=i)throw new Qa("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&(r=s.Hd(s.Hd(r,"bool"),"float32"),r.rank===l-1&&(r=s.ee(r,-1)),r=s.zf(r,u)),a&&(t=s.Ve(t,0),null!=r&&(r=s.Ve(r,0)));const d=[];let h,p=n;const f=t.shape[0],m=s.Bf(t);let g,b;null!=r&&(g=s.Bf(r));for(let t=0;t<f;++t){const n=m[t],a=s.wf(()=>e(n,p));if(null==r)h=a[0],p=a[1];else{const e=s.wf(()=>{const e=g[t],n=s.of(s.Le(e),e);return{output:s.sd(s.Fe(a[0],e),s.Fe(p[0],n)),newStates:p.map((t,r)=>s.sd(s.Fe(a[1][r],e),s.Fe(t,n)))}});h=e.output,p=e.newStates}c&&d.push(h)}if(c){const e=1;b=s.nf(d,e)}return[h,b,p]})}yc.className="DepthwiseConv2D",s.Ze.registerClass(yc);class wc extends Us{constructor(e){let t;if(super(e),null==e.cell)throw new Ja("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new Ec({cells:e.cell}):e.cell,null==t.stateSize)throw new Ja("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new zs({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return Wr(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(e=>null)}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Es(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let a;if(a=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const a of t)n.push([e[0],a]);return[a].concat(n)}return a}computeMask(e,t){return s.wf(()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map(e=>null);return[e].concat(t)}return e})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Qa("Constants support is not implemented in RNN yet.");Es(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new zs({shape:[t,null,...n]});const a=[e[0]].concat(e.slice(2));let r;if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!s.Df.arraysEqual(this.stateSpec.map(e=>e.shape[e.shape.length-1]),r))throw new Ja("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=r.map(e=>new zs({shape:[null,e]}));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Object(s.wf)(()=>{if(!this.stateful)throw new Za("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new Ja("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>s.If([n,e])):this.states_=[s.If([n,this.cell.stateSize])];else if(null==e)s.Wd(this.states_),null!=this.keptStates&&(s.Wd(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>s.If([n,e])):this.states_[0]=s.If([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Ja("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));!0===t?this.keptStates.push(this.states_.slice()):s.Wd(this.states_);for(let t=0;t<this.states_.length;++t){const a=e[t],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,i=[n,r];if(!s.Df.arraysEqual(a.shape,i))throw new Ja("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(i,", received shape=").concat(a.shape));this.states_[t]=a}}this.states_=this.states_.map(e=>s.oe(e.clone()))})}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=vc(e,n,a,this.numConstants);e=r.inputs,n=r.initialState,a=r.constants;let s=[],i=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new zs({shape:e.shape}));i=i.concat(this.stateSpec)}null!=a&&(t.constants=a,s=s.concat(a),this.numConstants=a.length);if(s[0]instanceof Ls){const n=[e].concat(s),a=this.inputSpec.concat(i),r=this.inputSpec;this.inputSpec=a;const o=super.apply(n,t);return this.inputSpec=r,o}return super.apply(e,t)}call(e,t){return Object(s.wf)(()=>{const n=null==t?null:t.mask,a=null==t?null:t.training;let r=null==t?null:t.initialState;e=As(e),null==r&&(r=this.stateful?this.states_:this.getInitialState(e));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==s)throw new Ja("RNN Layer has ".concat(s," state(s) but was passed ")+"".concat(r.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:a},o=xc((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]},e,r,this.goBackwards,n,null,this.unroll,this.returnSequences),c=o[0],l=o[1],u=o[2];this.stateful&&this.resetStates(u,a);const d=this.returnSequences?l:c;return this.returnState?[d].concat(u):d})}getInitialState(e){return Object(s.wf)(()=>{let t=s.If(e.shape);return t=s.pf(t,[1,2]),t=Hr(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>e>1?Qr(t,[1,e]):t):this.cell.stateSize>1?[Qr(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===wc.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,e,t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=vi(t.cell,n);return new e(Object.assign(t,{cell:a}))}}wc.className="RNN",s.Ze.registerClass(wc);class kc extends Us{}class Ic extends kc{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,br(this.units,"units"),this.activation=Po(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Cs(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Cs(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Cs(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=qo(e.kernelRegularizer),this.recurrentRegularizer=qo(e.recurrentRegularizer),this.biasRegularizer=qo(e.biasRegularizer),this.kernelConstraint=oi(e.kernelConstraint),this.recurrentConstraint=oi(e.recurrentConstraint),this.biasConstraint=oi(e.biasConstraint),this.dropout=Pr([1,Br([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Pr([1,Br([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Rs(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Object(s.wf)(()=>{if(2!==(e=e).length)throw new Ja("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length,"."));let n=e[1];e=e[0];const a=null!=t.training&&t.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=_c({ones:()=>s.Le(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=_c({ones:()=>s.Le(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;r=es(null!=i?s.Fe(e,i):e,this.kernel.read()),null!=this.bias&&(r=rs(r,this.bias.read())),null!=o&&(n=s.Fe(n,o));let c=s.sd(r,es(n,this.recurrentKernel.read()));return null!=this.activation&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:zo(this.activation),useBias:this.useBias,kernelInitializer:Os(this.kernelInitializer),recurrentInitializer:Os(this.recurrentInitializer),biasInitializer:Os(this.biasInitializer),kernelRegularizer:Go(this.kernelRegularizer),recurrentRegularizer:Go(this.recurrentRegularizer),biasRegularizer:Go(this.biasRegularizer),activityRegularizer:Go(this.activityRegularizer),kernelConstraint:si(this.kernelConstraint),recurrentConstraint:si(this.recurrentConstraint),biasConstraint:si(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}}Ic.className="SimpleRNNCell",s.Ze.registerClass(Ic);class Sc extends wc{constructor(e){e.cell=new Ic(e),super(e)}call(e,t){return Object(s.wf)(()=>{null!=this.cell.dropoutMask&&(s.Wd(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(s.Wd(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return new e(t)}}Sc.className="SimpleRNN",s.Ze.registerClass(Sc);class Nc extends kc{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Ja("GRUCell does not support reset_after parameter set to true.");this.units=e.units,br(this.units,"units"),this.activation=Po(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Po(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Cs(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Cs(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Cs(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=qo(e.kernelRegularizer),this.recurrentRegularizer=qo(e.recurrentRegularizer),this.biasRegularizer=qo(e.biasRegularizer),this.kernelConstraint=oi(e.kernelConstraint),this.recurrentConstraint=oi(e.recurrentConstraint),this.biasConstraint=oi(e.biasConstraint),this.dropout=Pr([1,Br([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Pr([1,Br([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=Rs(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Object(s.wf)(()=>{if(2!==(e=e).length)throw new Ja("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=null!=t.training&&t.training;let a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=_c({ones:()=>s.Le(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=_c({ones:()=>s.Le(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,i=this.recurrentDropoutMask;let o,c,l;0<this.dropout&&this.dropout<1&&(e=s.Fe(e,r[0]));let u=es(e,this.kernel.read());this.useBias&&(u=rs(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=s.Fe(a,i[0]));const d=this.recurrentKernel.read(),[h,p]=s.kf(d,[2*this.units,this.units],d.rank-1),f=es(a,h),[m,g,b]=s.kf(u,3,u.rank-1),[y,v]=s.kf(f,2,f.rank-1);o=this.recurrentActivation.apply(s.sd(m,y)),c=this.recurrentActivation.apply(s.sd(g,v));const x=es(s.Fe(c,a),p);l=this.activation.apply(s.sd(b,x));const w=s.sd(s.Fe(o,a),s.Fe(s.sd(1,s.Ge(o)),l));return[w,w]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:zo(this.activation),recurrentActivation:zo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Os(this.kernelInitializer),recurrentInitializer:Os(this.recurrentInitializer),biasInitializer:Os(this.biasInitializer),kernelRegularizer:Go(this.kernelRegularizer),recurrentRegularizer:Go(this.recurrentRegularizer),biasRegularizer:Go(this.biasRegularizer),activityRegularizer:Go(this.activityRegularizer),kernelConstraint:si(this.kernelConstraint),recurrentConstraint:si(this.recurrentConstraint),biasConstraint:si(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}}Nc.className="GRUCell",s.Ze.registerClass(Nc);class Tc extends wc{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Nc(e),super(e)}call(e,t){return Object(s.wf)(()=>{null!=this.cell.dropoutMask&&(s.Wd(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(s.Wd(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}Tc.className="GRU",s.Ze.registerClass(Tc);class Oc extends kc{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,br(this.units,"units"),this.activation=Po(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Po(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Cs(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Cs(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Cs(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=qo(e.kernelRegularizer),this.recurrentRegularizer=qo(e.recurrentRegularizer),this.biasRegularizer=qo(e.biasRegularizer),this.kernelConstraint=oi(e.kernelConstraint),this.recurrentConstraint=oi(e.recurrentConstraint),this.biasConstraint=oi(e.biasConstraint),this.dropout=Pr([1,Br([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Pr([1,Br([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=Rs(e))[e.length-1];let a;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;a=new((t=class extends ls{apply(t,a){const r=e.apply([n]),s=(new ds).apply([n]),i=e.apply([2*n]);return Jr(Jr(r,s),i)}}).className="CustomInit",t)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Object(s.wf)(()=>{const n=null!=t.training&&t.training;if(3!==(e=e).length)throw new Ja("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));let a=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=_c({ones:()=>s.Le(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=_c({ones:()=>s.Le(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let c,l,u,d;0<this.dropout&&this.dropout<1&&(e=s.Fe(e,i[0]));let h=es(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=s.Fe(a,o[0])),h=s.sd(h,es(a,this.recurrentKernel.read())),this.useBias&&(h=rs(h,this.bias.read()));const[p,f,m,g]=s.kf(h,4,h.rank-1);c=this.recurrentActivation.apply(p),l=this.recurrentActivation.apply(f),u=s.sd(s.Fe(l,r),s.Fe(c,this.activation.apply(m))),d=this.recurrentActivation.apply(g);const b=s.Fe(d,this.activation.apply(u));return[b,b,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:zo(this.activation),recurrentActivation:zo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Os(this.kernelInitializer),recurrentInitializer:Os(this.recurrentInitializer),biasInitializer:Os(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Go(this.kernelRegularizer),recurrentRegularizer:Go(this.recurrentRegularizer),biasRegularizer:Go(this.biasRegularizer),activityRegularizer:Go(this.activityRegularizer),kernelConstraint:si(this.kernelConstraint),recurrentConstraint:si(this.recurrentConstraint),biasConstraint:si(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}}Oc.className="LSTMCell",s.Ze.registerClass(Oc);class Cc extends wc{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Oc(e),super(e)}call(e,t){return Object(s.wf)(()=>{null!=this.cell.dropoutMask&&(s.Wd(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(s.Wd(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}Cc.className="LSTM",s.Ze.registerClass(Cc);class Ec extends kc{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Object(s.wf)(()=>{let n=(e=e).slice(1);const a=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?a.push(n.splice(0,e.stateSize.length)):a.push(n.splice(0,1));a.reverse();const r=[];let s;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=a[i],s=0===i?[e[0]].concat(n):[s[0]].concat(n),s=o.call(s,t),r.push(s.slice(1))}n=[];for(const e of r.slice().reverse())n.push(...e);return[s[0]].concat(n)})}build(e){let t;Es(e)&&(e=e[0]),e=e,this.cells.forEach((n,a)=>{Dr("RNNCell_".concat(a),()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map(e=>({className:e.getClassName(),config:e.getConfig()}))};return Object.assign({},e,t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=[];for(const r of t.cells)a.push(vi(r,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Ms(e)}setWeights(e){const t=[];for(const n of this.cells){const a=n.weights.length,r=e.splice(a);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],r[e]])}js(t)}}function _c(e){const{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:i}=e,o=()=>null!=i?i(t(),n):ss(t(),n),c=()=>is(o,t,a);if(!r||r<=1)return s.oe(c().clone());return Array(r).fill(void 0).map(c).map(e=>s.oe(e.clone()))}Ec.className="StackedRNNCells",s.Ze.registerClass(Ec);var Ac=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var r=0;for(a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]])}return n};class Rc extends wc{constructor(e){if(e.unroll)throw new Qa("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Qa("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new zs({ndim:5})]}call(e,t){return s.wf(()=>{if(null!=this.cell.dropoutMask&&(s.Wd(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(s.Wd(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Ja("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return s.wf(()=>{const{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)],i=s.If(r);return Array.isArray(t)?Array(t.length).fill(i):[i]})}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];s.wf(()=>{if(!this.stateful)throw new Za("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(null==n[0])throw new Ja("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>s.If(r)):this.states_=[s.If(r)];else if(null==e)s.Wd(this.states_),null!=this.keptStates&&(s.Wd(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>s.If(r)):this.states_[0]=s.If(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Ja("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));t?this.keptStates.push(this.states_.slice()):s.Wd(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],a=r;if(!s.Df.arraysEqual(n.shape,a))throw new Ja("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(a,", received shape=").concat(n.shape));this.states_[t]=n}}this.states_=this.states_.map(e=>s.oe(e.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,c=e[o?3:2],l=e[o?4:3],u=ec(c,a[0],r,s[0],i[0]),d=ec(l,a[1],r,s[1],i[1]);return[...e.slice(0,2),...o?[n,u,d]:[u,d,n]]}}Rc.className="ConvRNN2D";class Dc extends Oc{constructor(e){const{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:s,dilationRate:i}=e;super(Object.assign({},e,{units:t})),this.filters=t,br(this.filters,"filters"),this.kernelSize=$o(n,2,"kernelSize"),this.kernelSize.forEach(e=>br(e,"kernelSize")),this.strides=$o(a||1,2,"strides"),this.strides.forEach(e=>br(e,"strides")),this.padding=r||"valid",_r(this.padding),this.dataFormat=s||"channelsLast",Er(this.dataFormat),this.dilationRate=$o(i||1,2,"dilationRate"),this.dilationRate.forEach(e=>br(e,"dilationRate"))}build(e){var t;e=Rs(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new Ja("The channel dimension of the input should be defined. "+"Found ".concat(e[n]));const a=e[n],r=this.kernelSize.concat([a,4*this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const i=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,a=this.filters;e=new((t=class extends ls{apply(e,t){return Yr([n.apply([a]),s.Ke([a]),n.apply([2*a])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return s.wf(()=>{if(3!==e.length)throw new Ja("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=t.training||!1,a=e[0],r=e[1],i=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=_c({ones:()=>s.Le(a),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,c=(e,t,n)=>t&&t[n]?s.Fe(t[n],e):e;let l=c(a,o,0),u=c(a,o,1),d=c(a,o,2),h=c(a,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=_c({ones:()=>s.Le(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const p=this.recurrentDropoutMask;let f=c(r,p,0),m=c(r,p,1),g=c(r,p,2),b=c(r,p,3);const[y,v,x,w]=s.kf(this.kernel.read(),4,3),[k,I,S,N]=this.useBias?s.kf(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,k,this.padding),u=this.inputConv(u,v,I,this.padding),d=this.inputConv(d,x,S,this.padding),h=this.inputConv(h,w,N,this.padding);const[T,O,C,E]=s.kf(this.recurrentKernel.read(),4,3);f=this.recurrentConv(f,T),m=this.recurrentConv(m,O),g=this.recurrentConv(g,C),b=this.recurrentConv(b,E);const _=this.recurrentActivation.apply(s.sd(l,f)),A=this.recurrentActivation.apply(s.sd(u,m)),R=s.sd(s.Fe(A,i),s.Fe(_,this.activation.apply(s.sd(d,g)))),D=s.Fe(this.recurrentActivation.apply(s.sd(h,b)),this.activation.apply(R));return[D,D,R]})}getConfig(){const e=super.getConfig(),{units:t}=e,n=Ac(e,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,a)}inputConv(e,t,n,a){const r=s.Qd(e,t,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?rs(r,n,this.dataFormat):r}recurrentConv(e,t){return s.Qd(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}Dc.className="ConvLSTM2DCell",s.Ze.registerClass(Dc);class Fc extends Rc{constructor(e){const t=new Dc(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}}Fc.className="ConvLSTM2D",s.Ze.registerClass(Fc);class Mc extends Us{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(null==this.noiseShape[a]?t[a]:this.noiseShape[a]);return n}call(e,t){return Object(s.wf)(()=>{this.invokeCallHook(e,t);const n=As(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,a=this.getNoiseShape(n);return is(()=>ss(n,this.rate,a,this.seed),()=>n,e)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}Mc.className="Dropout",s.Ze.registerClass(Mc);class jc extends Mc{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}jc.className="SpatialDropout1D",s.Ze.registerClass(jc);class zc extends Us{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,br(this.units,"units"),this.activation=Po(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Cs(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Cs(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=oi(e.kernelConstraint),this.biasConstraint=oi(e.biasConstraint),this.kernelRegularizer=qo(e.kernelRegularizer),this.biasRegularizer=qo(e.biasRegularizer),this.activityRegularizer=qo(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=Rs(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=Rs(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Object(s.wf)(()=>{this.invokeCallHook(e,t);const n=As(e),a=yr(this.activation.getClassName());let r;return null!=a?r=es(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=es(n,this.kernel.read()),null!=this.bias&&(r=rs(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r})}getConfig(){const e={units:this.units,activation:zo(this.activation),useBias:this.useBias,kernelInitializer:Os(this.kernelInitializer),biasInitializer:Os(this.biasInitializer),kernelRegularizer:Go(this.kernelRegularizer),biasRegularizer:Go(this.biasRegularizer),activityRegularizer:Go(this.activityRegularizer),kernelConstraint:si(this.kernelConstraint),biasConstraint:si(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}zc.className="Dense",s.Ze.registerClass(zc);class Lc extends Us{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Rs(e);for(const t of e.slice(1))if(null==t)throw new Ja('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(e.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[e[0],Lr(e,1)]}call(e,t){return Object(s.wf)(()=>{this.invokeCallHook(e,t);let n=As(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=Object(s.zf)(n,e)}return function(e){if(e.rank<=1)throw new Ja("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank,"."));const t=[e.shape[0],Lr(e.shape,1)];return s.Ue(e,t)}(n)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}Lc.className="Flatten",s.Ze.registerClass(Lc);class Pc extends Us{constructor(e){super(e),this.supportsMasking=!0,this.activation=Po(e.activation)}call(e,t){return Object(s.wf)(()=>{this.invokeCallHook(e,t);const n=As(e);return this.activation.apply(n)})}getConfig(){const e={activation:zo(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}Pc.className="Activation",s.Ze.registerClass(Pc);class Bc extends Us{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Object(s.wf)(()=>{return e=As(e),t=e,n=this.n,Object(s.wf)(()=>{if(2!==t.shape.length)throw new Ja("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(t.shape.length," tensor."));return Qr(Hr(t,1),[1,n,1])});var t,n})}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}Bc.className="RepeatVector",s.Ze.registerClass(Bc);class Wc extends Us{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",a=t.slice();let r=1,s=null;for(let o=0;o<a.length;++o){const e=a[o];if(this.isUnknown(e)){if(null!==s)throw new Ja("Can only specifiy one unknown dimension.");s=o}else r*=e}const i=Lr(e);if(null!==s){if(0===r||i%r!==0)throw new Ja(n);a[s]=i/r}else if(i!==r)throw new Ja(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Object(s.wf)(()=>{this.invokeCallHook(e,t);const n=As(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return Object(s.Ue)(n,r)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}Wc.className="Reshape",s.Ze.registerClass(Wc);class Uc extends Us{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(e.dims," instead."));const t=Wr(1,e.dims.length+1);if(!s.Df.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new zs({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=Rs(e)).slice();return this.dims.forEach((n,a)=>{t[a+1]=e[n]}),t}call(e,t){return Object(s.zf)(As(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}Uc.className="Permute",s.Ze.registerClass(Uc);class Vc extends Us{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=As(e);return Object(s.ud)(Object(s.Ie)(n,this.maskValue),-1)}call(e,t){return Object(s.wf)(()=>{this.invokeCallHook(e,t);const n=As(e),a=Object(s.ud)(Object(s.Ie)(n,this.maskValue),-1,!0);return Object(s.Fe)(n,Object(s.Hd)(a,n.dtype))})}}Vc.className="Masking",s.Ze.registerClass(Vc);class Gc extends Us{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(sr(e.inputLength))}this.inputDim=e.inputDim,br(this.inputDim,"inputDim"),this.outputDim=e.outputDim,br(this.outputDim,"outputDim"),this.embeddingsInitializer=Cs(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=qo(e.embeddingsRegularizer),this.activityRegularizer=qo(e.activityRegularizer),this.embeddingsConstraint=oi(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Object(s.wf)(()=>this.maskZero?(e=As(e),Object(s.Ie)(e,Object(s.Jf)(e))):null)}computeOutputShape(e){if(e=Rs(e),null==this.inputLength)return[...e,this.outputDim];const t=sr(this.inputLength);if(t.length!==e.length-1)throw new Ja('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));{let n=0;for(let a=0;a<t.length;++a){const r=t[a],s=e[a+1];if(null!=r&&null!=s&&r!==s)throw new Ja('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));null==r&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Object(s.wf)(()=>{this.invokeCallHook(e,t);let n=As(e);"int32"!==n.dtype&&(n=Gr(n,"int32"));const a=ts(this.embeddings.read(),Object(s.Ue)(n,[n.size]));return Object(s.Ue)(a,Rs(this.computeOutputShape(n.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Os(this.embeddingsInitializer),embeddingsRegularizer:Go(this.embeddingsRegularizer),activityRegularizer:Go(this.activityRegularizer),embeddingsConstraint:si(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}Gc.className="Embedding",s.Ze.registerClass(Gc);class Hc extends Us{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Qa}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){const r=e[e.length-t.length+a],s=t[a];if(null==r||null==s||r<0||s<0)n.push(null);else if(1===r)n.push(s);else if(1===s)n.push(r);else{if(r!==s)throw new Ja("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Rs(e)]),(e=e).length<2)throw new Ja("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(e.length," input(s)."));let t=[];for(const r of e)null!=r&&null!==r[0]&&t.push(r[0]);if(t=pr(t),t.length>1)throw new Ja("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(e),"."));let n=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const t=null==e[r]?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const a=e.map(e=>e.length);-1===e.indexOf(null)&&1===pr(a).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Object(s.wf)(()=>{if(e=e,this.reshapeRequired){const t=[],n=e.map(e=>e.rank);if(-1===n.indexOf(null)){const a=Br(n);for(let n of e){const e=n.rank;for(let t=0;t<a-e;++t)n=Hr(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const i of e){const e=i.rank;if(null==e){const e=i.shape,a=e[0],r=e.slice(1).concat([a]);let o=s.Ue(i,[a].concat(Lr(e.slice(1))));o=s.zf(o,[1,0]),o=s.Ue(o,r),t.push(o),n=!0}else if(e>1){const a=Wr(1,e).concat([0]);t.push(s.zf(i,a)),n=!0}else t.push(i)}let a=this.mergeFunction(t);const r=a.rank;if(n)if(null==r){const e=a.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));a=s.Ue(s.zf(s.Ue(a,[-1,t]),[1,0]),n)}else if(r>1){const e=[r-1].concat(Wr(0,r-1));a=s.zf(a,e)}return a}}return this.mergeFunction(e)})}computeOutputShape(e){let t;t=null==(e=e)[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const n=null==e[a]?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const a of e)null!=a&&null!==a[0]&&n.push(a[0]);return n=pr(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return s.wf(()=>{if(null==t)return null;if(!Array.isArray(t))throw new Ja("`mask` should be an Array");if(!Array.isArray(e))throw new Ja("`inputs` should be an Array");if(t.length!==e.length)throw new Ja("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(e.length," vs ").concat(t.length,")"));if(t.every(e=>null==e))return null;let n=(t=t.map(e=>null==e?e:s.ee(e,0)))[0];for(let e=1;e<t.length-1;++e)n=s.ve(n,t[e]);return n})}}class qc extends Hc{constructor(e){super(e)}mergeFunction(e){return Object(s.wf)(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=s.sd(t,e[n]);return t})}}qc.className="Add",s.Ze.registerClass(qc);class Kc extends Hc{constructor(e){super(e)}mergeFunction(e){return Object(s.wf)(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=s.Fe(t,e[n]);return t})}}Kc.className="Multiply",s.Ze.registerClass(Kc);class Xc extends Hc{constructor(e){super(e)}mergeFunction(e){return Object(s.wf)(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=s.sd(t,e[n]);return s.Fe(1/e.length,t)})}}Xc.className="Average",s.Ze.registerClass(Xc);class Zc extends Hc{constructor(e){super(e)}mergeFunction(e){return Object(s.wf)(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=s.Ae(t,e[n]);return t})}}Zc.className="Maximum",s.Ze.registerClass(Zc);class Yc extends Hc{constructor(e){super(e)}mergeFunction(e){return Object(s.wf)(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=s.De(t,e[n]);return t})}}Yc.className="Minimum",s.Ze.registerClass(Yc);class Jc extends Hc{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new Ja("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const a of e)if(null!=a){t=!1;break}if(t)return;const n=[];for(let a=0;a<e.length;++a){const t=e[a].slice();t.splice(this.axis,1);let r=!1;for(const e of n)if(s.Df.arraysEqual(e,t)){r=!0;break}r||n.push(t)}if(n.length>1)throw new Ja("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Object(s.wf)(()=>Yr(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Ja("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(const r of t.slice(1)){if(null==n[a]||null==r[a]){n[a]=null;break}n[a]+=r[a]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new Ja("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Ja("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Ja("Mismatch in the length of mask (".concat(t.length,") ")+"and the legnth of inputs (".concat(e.length,")"));return s.wf(()=>{let n=!0;if(t.forEach(e=>{null==e||(n=!1)}),n)return null;const a=[];for(let i=0;i<e.length;++i)null==t[i]?a.push(s.Hd(s.Le(e[i]),"bool")):t[i].rank<e[i].rank?a.push(s.ee(t[i],-1)):a.push(t[i]);const r=s.Kd(a,this.axis);return s.td(r,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function Qc(e,t){for(;e<0;)e+=t;return e}Jc.className="Concatenate",s.Ze.registerClass(Jc);class $c extends Hc{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){s.Df.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Qa("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new Ja("Dimension incompatibility: "+"".concat(t[a[0]]," !== ").concat(n[a[1]]))}mergeFunction(e){if(2!==e.length)throw new Ja("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(e.length," input(s)."));let t,n=e[0],a=e[1];return t=Array.isArray(this.axes)?this.axes.map((t,n)=>Qc(t,e[n].shape.length)):[Qc(this.axes,n.shape.length),Qc(this.axes,a.shape.length)],this.normalize&&(n=xi(n,t[0]),a=xi(a,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Qa("batchDot is not implemented for tensors of 4D or higher rank yet");if(s.Df.assert(e.shape.length>=2,()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(e.shape.length)),s.Df.assert(e.shape.length>=2,()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(t.shape.length)),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new Qa("batchDot is not implemented for complex64-type Tensors yet.");const a=e.shape.length,r=t.shape.length;null==n&&(n=[a-1,r-2]);const i=n;return s.wf(()=>{let n,o;if(a>r){n=a-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=s.Ue(t,t.shape.concat(e))}else if(r>a){n=r-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=s.Ue(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)o=i[0]===i[1]?s.pf(s.Fe(e,t),i[0]):s.pf(s.Fe(s.zf(e,[1,0]),t),i[1]);else{const n=i[0]!==e.shape.length-1,a=i[1]===t.shape.length-1;o=s.we(e,t,n,a)}if(n>0){let e;e=a>r?a+r-3:a-1;const t=[];for(let a=e;a<e+n;++a)t.push(a);o=s.mf(o,t)}return 1===o.shape.length&&(o=s.ee(o,1)),o})}(n,a,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[Qc(this.axes,e.length),Qc(this.axes,t.length)],n}computeOutputShape(e){s.Df.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Qa("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);const r=t.concat(n);return 1===r.length&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}$c.className="Dot",s.Ze.registerClass($c);class el extends Us{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Object(s.wf)(()=>{this.invokeCallHook(e,t);const n=As(e);return is(()=>Object(s.sd)($r(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}}el.className="GaussianNoise",s.Ze.registerClass(el);class tl extends Us{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Object(s.wf)(()=>{this.invokeCallHook(e,t);const n=As(e);if(this.rate>0&&this.rate<1){return is(()=>{const e=Math.sqrt(this.rate/(1-this.rate));return Object(s.Fe)(n,$r(n.shape,1,e))},()=>n,t.training||!1)}return n})}}tl.className="GaussianDropout",s.Ze.registerClass(tl);class nl extends Us{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||As(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Object(s.wf)(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e);return is(()=>{const t=As(e),a=-1.7580993408473766;let r=Object(s.le)(Object(s.Qe)(n),this.rate);r=Gr(r,"float32");const i=((1-this.rate)*(1+this.rate*a**2))**-.5,o=-i*a*this.rate,c=Object(s.sd)(Object(s.Fe)(t,r),Object(s.Fe)(Object(s.sd)(r,-1),a));return Object(s.sd)(Object(s.Fe)(c,i),o)},()=>As(e),t.training||!1)}return e})}}function al(e,t,n,a,r){let i,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)i=s.Ad(e,t,n,a,r,o);else if(3===e.rank)i=s.Bd(e,t,n,a,r,o);else{if(4!==e.rank)throw new Qa("batchNormalization is not implemented for array of rank ".concat(e.rank," ")+"yet");i=s.Cd(e,t,n,a,r,o)}return i}function rl(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Object(s.wf)(()=>{const i=s.Ee(e,a),o=i.mean,c=i.variance;return[al(e,o,c,n,t,r),o,c]})}function sl(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Object(s.wf)(()=>{const i=s.Ee(e,a),o=i.mean,c=i.variance,l=[];for(const t of Wr(0,e.rank))-1!==a.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=Object(s.Ue)(o,l),d=Object(s.Ue)(c,l),h=null==t?null:Object(s.Ue)(t,l),p=null==n?null:Object(s.Ue)(n,l);return[al(e,u,d,p,h,r),o,c]})}nl.className="AlphaDropout",s.Ze.registerClass(nl);class il extends Us{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Cs(e.betaInitializer||"zeros"),this.gammaInitializer=Cs(e.gammaInitializer||"ones"),this.movingMeanInitializer=Cs(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Cs(e.movingVarianceInitializer||"ones"),this.betaConstraint=oi(e.betaConstraint),this.gammaConstraint=oi(e.gammaConstraint),this.betaRegularizer=qo(e.betaRegularizer),this.gammaRegularizer=qo(e.gammaRegularizer)}build(e){e=Rs(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new Ja("Axis ".concat(t," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(e),"."));this.inputSpec=[new zs({ndim:e.length,axes:{[t]:n}})];const a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Object(s.wf)(()=>{const n=null!=t.training&&t.training,a=As(e),r=a.shape,i=r.length,o=Wr(0,i),c=this.axis>=0?this.axis:this.axis+i;o.splice(c,1);const l=tr(1,i);l[c]=r[c];const u=o.slice();u.sort();const d=!s.Df.arraysEqual(u,Wr(0,i).slice(0,i-1));if(!n)return(()=>{if(d){const e=Object(s.Ue)(this.movingMean.read(),l),t=Object(s.Ue)(this.movingVariance.read(),l),n=this.center?Object(s.Ue)(this.beta.read(),l):null,r=this.scale?Object(s.Ue)(this.gamma.read(),l):null;return al(a,e,t,n,r,this.epsilon)}return al(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,p,f]=function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return s.Df.arraysEqual(a.slice().sort(),Wr(0,e.rank-1))?rl(e,t,n,a,r):sl(e,t,n,a,r)}(a,this.gamma.read(),this.beta.read(),o,this.epsilon),m=(e,t,n)=>{s.wf(()=>{const a=1-n,r=e.read(),i=s.Fe(s.of(r,t),a);e.write(s.of(r,i))})};return(()=>{m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum)})(),h})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Os(this.betaInitializer),gammaInitializer:Os(this.gammaInitializer),movingMeanInitializer:Os(this.movingMeanInitializer),movingVarianceInitializer:Os(this.movingVarianceInitializer),betaRegularizer:Go(this.betaRegularizer),gammaRegularizer:Go(this.gammaRegularizer),betaConstraint:si(this.betaConstraint),gammaConstraint:si(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}il.className="BatchNormalization",s.Ze.registerClass(il);class ol extends Us{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const e of this.axis)if(!Number.isInteger(e))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Cs(e.betaInitializer||"zeros"),this.gammaInitializer=Cs(e.gammaInitializer||"ones"),this.betaRegularizer=qo(e.betaRegularizer),this.gammaRegularizer=qo(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=Rs(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(const a of this.axis)if(a<0||a>=t)throw new Error("Invalid axis: ".concat(a));if(this.axis.length!==pr(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map(t=>e[t]);this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(e,t){const n=As(e),a=n.shape,r=a.length;return Object(s.wf)(()=>{let{mean:e,variance:t}=Object(s.Ee)(n,this.axis,!0);const i=tr(1,r);for(const n of this.axis)i[n]=a[n];const o=e=>null!=e&&e.shape.length!==r?s.Ue(e,i):e;let c=this.scale?o(this.gamma.read()):null,l=this.center?o(this.beta.read()):null;const u=[],d=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(u.push(a[n]),d.push(1)):(u.push(1),d.push(a[n]));return e=s.xf(e,u),t=s.xf(t,u),null!=c&&(c=s.xf(c,d)),null!=l&&(l=s.xf(l,d)),al(n,e,t,l,c,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Os(this.betaInitializer),gammaInitializer:Os(this.gammaInitializer),betaRegularizer:Go(this.betaRegularizer),gammaRegularizer:Go(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}ol.className="LayerNormalization",s.Ze.registerClass(ol);class cl extends Us{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new Ja("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(e.padding.length," array."));let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new Ja("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(e.padding[0].length," array."));if(t=e.padding[0],2!==e.padding[1].length)throw new Ja("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(e.padding[1].length," array."));n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new zs({ndim:4})]}computeOutputShape(e){let t,n;return e=Rs(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Object(s.wf)(()=>{return t=As(e),n=this.padding,a=this.dataFormat,Object(s.wf)(()=>{if(4!==t.rank)throw new Ja("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(t.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new Ja("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==a&&(a="channelsLast"),"channelsLast"!==a&&"channelsFirst"!==a)throw new Ja("Unknown data format: ".concat(a,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let e;return e="channelsFirst"===a?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],s.Me(t,e)});var t,n,a})}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function ll(e,t,n,a,r,i){return Object(s.wf)(()=>{let o;Er(r),Ar(i),_r(a),null==n&&(n=[1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),e=nc(e,r);const c="same"===a?"same":"valid";return o="max"===i?s.ye(e,t,n,c):s.wd(e,t,n,c),"channelsFirst"===r&&(o=s.zf(o,[0,3,1,2])),o})}function ul(e,t,n,a,r,i){return Object(s.wf)(()=>{let o;Er(r),Ar(i),_r(a),null==n&&(n=[1,1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),e=ac(e,r);const c="same"===a?"same":"valid";return o="max"===i?s.ze(e,t,n,c):s.xd(e,t,n,c),"channelsFirst"===r&&(o=s.zf(o,[0,4,1,2,3])),o})}cl.className="ZeroPadding2D",s.Ze.registerClass(cl);class dl extends Us{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new Ja("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.poolSize)));this.poolSize=e.poolSize}if(br(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new Ja("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.strides)));this.strides=e.strides}br(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,_r(this.padding),this.inputSpec=[new zs({ndim:3})]}computeOutputShape(e){const t=ec((e=Rs(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Object(s.wf)(()=>{this.invokeCallHook(e,t),e=Hr(As(e),2);const n=this.poolingFunction(As(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return s.mf(n,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class hl extends dl{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Er(r),_r(a),ll(e,t,n,a,r,"max")}}hl.className="MaxPooling1D",s.Ze.registerClass(hl);class pl extends dl{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Er(r),_r(a),ll(e,t,n,a,r,"avg")}}pl.className="AveragePooling1D",s.Ze.registerClass(pl);class fl extends Us{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new Ja("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides];br(this.poolSize,"poolSize"),br(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Er(this.dataFormat),_r(this.padding),this.inputSpec=[new zs({ndim:4})]}computeOutputShape(e){e=Rs(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=ec(t,this.poolSize[0],this.padding,this.strides[0]),n=ec(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Object(s.wf)(()=>(this.invokeCallHook(e,t),this.poolingFunction(As(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class ml extends fl{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Er(r),_r(a),ll(e,t,n,a,r,"max")}}ml.className="MaxPooling2D",s.Ze.registerClass(ml);class gl extends fl{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Er(r),_r(a),ll(e,t,n,a,r,"avg")}}gl.className="AveragePooling2D",s.Ze.registerClass(gl);class bl extends Us{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new Ja("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];br(this.poolSize,"poolSize"),br(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Er(this.dataFormat),_r(this.padding),this.inputSpec=[new zs({ndim:5})]}computeOutputShape(e){e=Rs(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[4]:e[3];return t=ec(t,this.poolSize[0],this.padding,this.strides[0]),n=ec(n,this.poolSize[1],this.padding,this.strides[1]),a=ec(a,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return Object(s.wf)(()=>(this.invokeCallHook(e,t),this.poolingFunction(As(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class yl extends bl{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Er(r),_r(a),ul(e,t,n,a,r,"max")}}yl.className="MaxPooling3D",s.Ze.registerClass(yl);class vl extends bl{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Er(r),_r(a),ul(e,t,n,a,r,"avg")}}vl.className="AveragePooling3D",s.Ze.registerClass(vl);class xl extends Us{constructor(e){super(e),this.inputSpec=[new zs({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Qa}}class wl extends xl{constructor(e){super(e||{})}call(e,t){return Object(s.wf)(()=>{const t=As(e);return s.Be(t,1)})}}wl.className="GlobalAveragePooling1D",s.Ze.registerClass(wl);class kl extends xl{constructor(e){super(e||{})}call(e,t){return Object(s.wf)(()=>{const t=As(e);return s.xe(t,1)})}}kl.className="GlobalMaxPooling1D",s.Ze.registerClass(kl);class Il extends Us{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Er(this.dataFormat),this.inputSpec=[new zs({ndim:4})]}computeOutputShape(e){return e=e,"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Qa}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Sl extends Il{call(e,t){return Object(s.wf)(()=>{const t=As(e);return"channelsLast"===this.dataFormat?s.Be(t,[1,2]):s.Be(t,[2,3])})}}Sl.className="GlobalAveragePooling2D",s.Ze.registerClass(Sl);class Nl extends Il{call(e,t){return Object(s.wf)(()=>{const t=As(e);return"channelsLast"===this.dataFormat?s.xe(t,[1,2]):s.xe(t,[2,3])})}}Nl.className="GlobalMaxPooling2D",s.Ze.registerClass(Nl);class Tl extends Us{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=vi(t.layer,n);delete t.layer;const r={layer:a};return Object.assign(r,t),new e(r)}}class Ol extends Tl{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Rs(e)).length<3)throw new Ja("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(e)));this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=Rs(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return Object(s.wf)(()=>xc((e,n)=>[As(this.layer.call(e,t)),[]],e=As(e),[],!1,null,null,!1,!0)[1])}}Ol.className="TimeDistributed",s.Ze.registerClass(Ol);class Cl extends Tl{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=vi(n),t.goBackwards=!0!==t.goBackwards;const a={};var r;if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=vi(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,r=this.mergeMode,mr(Or,"BidirectionalMergeMode",r),e.weights)throw new Qa("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,a,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r,this.returnState?(a=r.slice(1),t=r[0]):t=r[0],t=t,"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(a).concat(a.slice()):[t].concat(a).concat(a.slice()):rr(n)}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=vc(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==a)return super.apply(e,t);const s=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new Ja("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);const a=n.map(e=>new zs({shape:e.shape}));this.forwardLayer.stateSpec=a.slice(0,e/2),this.backwardLayer.stateSpec=a.slice(e/2),i.push(...a)}if(null!=a)throw new Qa("Support for constants in Bidirectional layers is not implemented yet.");const o=s[0]instanceof Ls;for(const c of s)if(c instanceof Ls!==o)throw new Ja("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(s),a=this.inputSpec.concat(i),r=this.inputSpec;this.inputSpec=a;const o=super.apply(n,t);return this.inputSpec=r,o}return super.apply(e,t)}call(e,t){return Object(s.wf)(()=>{const n=t.initialState;let a,r,i,o;if(null==n)a=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const s=n.slice(0,n.length/2),i=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:s})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(a)&&(i=a.slice(1).concat(r.slice(1))),a=a[0],r=r[0]),this.returnSequences&&(r=s.Ve(r,1)),"concat"===this.mergeMode?o=Yr([a,r]):"sum"===this.mergeMode?o=s.sd(a,r):"ave"===this.mergeMode?o=s.Fe(.5,s.sd(a,r)):"mul"===this.mergeMode?o=s.Fe(a,r):null==this.mergeMode&&(o=[a,r]),this.returnState?null==this.mergeMode?o.concat(i):[o].concat(i):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Dr(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Dr(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map(e=>null);return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=vi(t.layer);if(delete t.layer,null!=t.numConstants)throw new Qa("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=t;return a.layer=n,new e(a)}}Cl.className="Bidirectional",s.Ze.registerClass(Cl);class El extends Us{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Object(s.wf)(()=>("float32"!==(e=As(e)).dtype&&(e=Gr(e,"float32")),Object(s.sd)(Object(s.Fe)(e,this.scale),this.offset)))}}El.className="Rescaling",s.Ze.registerClass(El);Object(s.be)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var _l=n(52),Al=n(1);class Rl{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return Object(Al.e)(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return Object(Al.e)(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return Object(_l.f)(this.node.rawAttrs,e,t);if(null!=n.s)return Object(_l.i)(this.node.rawAttrs,e,t);if(null!=n.b)return Object(_l.c)(this.node.rawAttrs,e,t);if(null!=n.shape)return Object(_l.k)(this.node.rawAttrs,e,t);if(null!=n.type)return Object(_l.e)(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return Object(_l.g)(this.node.rawAttrs,e,t);if(null!=n.list.s)return Object(_l.h)(this.node.rawAttrs,e,t);if(null!=n.list.shape)return Object(_l.j)(this.node.rawAttrs,e,t);if(null!=n.list.b)return Object(_l.b)(this.node.rawAttrs,e,t);if(null!=n.list.type)return Object(_l.d)(this.node.rawAttrs,e,t)}return t}}var Dl=n(95),Fl=n(20);const Ml=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"AddN":return[r.addN(Object(Al.d)("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"Mul":return[r.mul(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"RealDiv":case"Div":return[r.div(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"DivNoNan":return[r.divNoNan(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"FloorDiv":return[r.floorDiv(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"Sub":return[r.sub(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"Minimum":return[r.minimum(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"Maximum":return[r.maximum(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"Pow":return[r.pow(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},jl=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(Object(Al.d)("x",e,t,n))];case"Acos":return[r.acos(Object(Al.d)("x",e,t,n))];case"Acosh":return[r.acosh(Object(Al.d)("x",e,t,n))];case"Asin":return[r.asin(Object(Al.d)("x",e,t,n))];case"Asinh":return[r.asinh(Object(Al.d)("x",e,t,n))];case"Atan":return[r.atan(Object(Al.d)("x",e,t,n))];case"Atan2":return[r.atan2(Object(Al.d)("x",e,t,n),Object(Al.d)("y",e,t,n))];case"Atanh":return[r.atanh(Object(Al.d)("x",e,t,n))];case"Ceil":return[r.ceil(Object(Al.d)("x",e,t,n))];case"Complex":return[r.complex(Object(Al.d)("real",e,t,n),Object(Al.d)("imag",e,t,n))];case"Cos":return[r.cos(Object(Al.d)("x",e,t,n))];case"Cosh":return[r.cosh(Object(Al.d)("x",e,t,n))];case"Elu":return[r.elu(Object(Al.d)("x",e,t,n))];case"Erf":return[r.erf(Object(Al.d)("x",e,t,n))];case"Exp":return[r.exp(Object(Al.d)("x",e,t,n))];case"Expm1":return[r.expm1(Object(Al.d)("x",e,t,n))];case"Floor":return[r.floor(Object(Al.d)("x",e,t,n))];case"Log":return[r.log(Object(Al.d)("x",e,t,n))];case"Log1p":return[r.log1p(Object(Al.d)("x",e,t,n))];case"Imag":return[r.imag(Object(Al.d)("x",e,t,n))];case"Neg":return[r.neg(Object(Al.d)("x",e,t,n))];case"Reciprocal":return[r.reciprocal(Object(Al.d)("x",e,t,n))];case"Real":return[r.real(Object(Al.d)("x",e,t,n))];case"Relu":return[r.relu(Object(Al.d)("x",e,t,n))];case"Round":return[r.round(Object(Al.d)("x",e,t,n))];case"Selu":return[r.selu(Object(Al.d)("x",e,t,n))];case"Sigmoid":return[r.sigmoid(Object(Al.d)("x",e,t,n))];case"Sin":return[r.sin(Object(Al.d)("x",e,t,n))];case"Sign":return[r.sign(Object(Al.d)("x",e,t,n))];case"Sinh":return[r.sinh(Object(Al.d)("x",e,t,n))];case"Softplus":return[r.softplus(Object(Al.d)("x",e,t,n))];case"Sqrt":return[r.sqrt(Object(Al.d)("x",e,t,n))];case"Square":return[r.square(Object(Al.d)("x",e,t,n))];case"Tanh":return[r.tanh(Object(Al.d)("x",e,t,n))];case"Tan":return[r.tan(Object(Al.d)("x",e,t,n))];case"ClipByValue":return[r.clipByValue(Object(Al.d)("x",e,t,n),Object(Al.d)("clipValueMin",e,t,n),Object(Al.d)("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(Object(Al.d)("x",e,t,n))];case"Rsqrt":return[r.rsqrt(Object(Al.e)(e.inputNames[0],t,n))];case"Prod":return[r.prod(Object(Al.d)("x",e,t,n),Object(Al.d)("axes",e,t,n))];case"LeakyRelu":return[r.leakyRelu(Object(Al.d)("x",e,t,n),Object(Al.d)("alpha",e,t,n))];case"Prelu":return[r.prelu(Object(Al.d)("x",e,t,n),Object(Al.d)("alpha",e,t,n))];case"IsNan":return[r.isNaN(Object(Al.e)(e.inputNames[0],t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function zl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){s.Df.assert(e.length===t.length,()=>n+" Shapes ".concat(e," and ").concat(t," must match"));for(let a=0;a<e.length;a++){const r=e[a],i=t[a];s.Df.assert(r<0||i<0||r===i,()=>n+" Shapes ".concat(e," and ").concat(t," must match"))}}}function Ll(e){return"number"!==typeof e&&!e.some(e=>e<0)}function Pl(e,t,n){let a=Bl(e,n);const r=!Ll(a);if(r&&0===t.length)throw new Error("Tried to calculate elements of an empty list"+" with non-fully-defined elementShape: ".concat(a));if(r&&t.forEach(e=>{a=Bl(e.shape,a)}),!Ll(a))throw new Error("Non-fully-defined elementShape: ".concat(a));return a}function Bl(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error("Incompatible ranks during merge: ".concat(e," vs. ").concat(t));const n=[];for(let a=0;a<e.length;++a){const r=e[a],s=t[a];if(r>=0&&s>=0&&r!==s)throw new Error("Incompatible shape during merge: ".concat(e," vs. ").concat(t));n[a]=r>=0?r:s}return n}class Wl{constructor(e,t,n,a,r,i,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=i,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Object(s.We)(0),Object(s.oe)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||e>=this.size())throw new Error("Tried to read from index ".concat(e,", but array size is: ").concat(this.size()));const t=this.tensors[e];if(t.cleared)throw new Error("TensorArray ".concat(this.name,": Could not read index ").concat(e," twice because it was cleared after a previous read ")+"(perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error("Tried to write to index ".concat(e,", but array is not resizeable and size is: ").concat(this.maxSize));const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,",\n          because the value dtype is ").concat(t.dtype,", but TensorArray dtype is ").concat(this.dtype,"."));if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),zl(this.elementShape,t.shape,"TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,".")),n.read)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been read."));if(n.written)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been written."));n.tensor=t,Object(s.oe)(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error("TensorArray ".concat(this.name,": could not write multiple tensors,")+"because the index size: ".concat(e.length," is not the same as tensors size: ").concat(t.length,"."));e.forEach((e,n)=>this.write(e,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but gather requested dtype ").concat(t));if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Object(s.sf)([],[0].concat(this.elementShape));const n=this.readMany(e);return zl(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Object(s.nf)(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but concat requested dtype ").concat(e));if(0===this.size())return Object(s.sf)([],[0].concat(this.elementShape));const t=[];for(let a=0;a<this.size();a++)t.push(a);const n=this.readMany(t);return zl(this.elementShape,n[0].shape,"TensorArray shape mismatch: tensor array shape (".concat(this.elementShape,") vs first tensor shape (").concat(n[0].shape,")")),Object(s.Kd)(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));if(e.length!==t.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(e.length," vs. ").concat(t.shape[0]));const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error("Max index must be < array size (".concat(n,"  vs. ").concat(this.maxSize,")"));this.writeMany(e,Object(s.Bf)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));let n=0;const a=e.map(e=>(n+=e,n));if(n!==t.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(n,", and tensor's shape is: ").concat(t.shape));if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths (".concat(this.maxSize," vs. ").concat(e.length,"), ")+"and the TensorArray is not marked as dynamically resizeable");const r=0===n?0:t.size/n,i=[];Object(s.wf)(()=>{t=Object(s.Ue)(t,[1,n,r]);for(let n=0;n<e.length;++n){const o=[0,0===n?0:a[n-1],0],c=[1,e[n],r];i[n]=Object(s.Ue)(Object(s.cf)(t,o,c),this.elementShape)}return i});const o=[];for(let s=0;s<e.length;s++)o[s]=s;this.writeMany(o,i)}}class Ul{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach(e=>{if(n!==e.dtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(e.dtype));zl(t,e.shape,"TensorList shape mismatch: "),Object(s.oe)(e)}),this.idTensor=Object(s.We)(0),this.maxNumElements=a,Object(s.oe)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Ul([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(-1!==n&&this.tensors.length!==n)throw new Error("Operation expected a list with ".concat(n," elements but got a list with ").concat(this.tensors.length," elements."));zl(e,this.elementShape,"TensorList shape mismatch: ");const a=Pl(this.elementShape,this.tensors,e);return Object(s.wf)(()=>{const e=this.tensors.map(e=>Object(s.Ue)(e,a));return Object(s.nf)(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=Pl(this.elementShape,this.tensors,e),a=this.tensors.pop();return a.kept=!1,zl(a.shape,e,"TensorList shape mismatch: "),Object(s.Ue)(a,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(this.elementDtype));if(zl(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Object(s.oe)(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error("TensorListResize expects size to be non-negative. Got: ".concat(e));if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error("TensorListResize input size ".concat(e," is greater maxNumElement ").concat(this.maxNumElements,"."));const t=new Ul([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(this.elementDtype));if(e<0||e>this.tensors.length)throw new Error("Trying to access element ".concat(e," in a list with ").concat(this.tensors.length," elements."));if(null==this.tensors[e])throw new Error("element at index ".concat(e," is null."));zl(this.tensors[e].shape,t,"TensorList shape mismatch: ");const a=Pl(this.elementShape,this.tensors,t);return Object(s.Ue)(this.tensors[e],a)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t.dtype,", but list elements ").concat(this.elementDtype));if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error("Trying to set element ".concat(e," in a list with max ").concat(this.maxNumElements," elements."));zl(this.elementShape,t.shape,"TensorList shape mismatch: "),Object(s.oe)(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));zl(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const a=Pl(this.elementShape,this.tensors,n);return 0===e.length?Object(s.sf)([],[0].concat(a)):Object(s.wf)(()=>{const t=e.map(e=>Object(s.Ue)(this.tensors[e],a));return Object(s.nf)(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error("TensorList dtype is ".concat(this.elementDtype," but concat requested dtype ").concat(e));zl(this.elementShape,t,"TensorList shape mismatch: ");const n=Pl(this.elementShape,this.tensors,t);return 0===this.size()?Object(s.sf)([],[0].concat(n)):Object(s.wf)(()=>{const e=this.tensors.map(e=>Object(s.Ue)(e,n));return Object(s.Kd)(e,0)})}}const Vl=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const a=Object(Al.d)("thenBranch",e,t,n),r=Object(Al.d)("elseBranch",e,t,n),s=Object(Al.d)("cond",e,t,n),i=Object(Al.d)("args",e,t,n);return(await s.data())[0]?n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const a=Object(Al.d)("body",e,t,n),r=Object(Al.d)("cond",e,t,n),s=Object(Al.d)("args",e,t,n),i=await n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(e=>e.id);let c=await i[0].data();i.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()});let l=s;for(;c[0];){const e=l;l=await n.functionMap[a].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map(e=>e.id);e.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});const s=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);c=await s[0].data(),s.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return l}case"LoopCond":{const a=Object(Al.d)("pred",e,t,n);return[Object(Al.a)(a)]}case"Switch":{const a=Object(Al.d)("pred",e,t,n);let r=Object(Al.d)("data",e,t,n);return r.kept||(r=Object(Al.a)(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const a=e.inputNames.find(e=>void 0!==Object(Al.e)(e,t,n));if(a){const e=Object(Al.e)(a,t,n);return[Object(Al.a)(e)]}return}case"Enter":{const a=Object(Al.d)("frameName",e,t,n),r=Object(Al.d)("tensor",e,t,n);return n.enterFrame(a),[Object(Al.a)(r)]}case"Exit":{const a=Object(Al.d)("tensor",e,t,n);return n.exitFrame(),[Object(Al.a)(a)]}case"NextIteration":{const a=Object(Al.d)("tensor",e,t,n);return n.nextIteration(),[Object(Al.a)(a)]}case"TensorArrayV3":{const a=Object(Al.d)("size",e,t,n),r=Object(Al.d)("dtype",e,t,n),i=Object(Al.d)("elementShape",e,t,n),o=Object(Al.d)("dynamicSize",e,t,n),c=Object(Al.d)("clearAfterRead",e,t,n),l=Object(Al.d)("identicalElementShapes",e,t,n),u=Object(Al.d)("name",e,t,n),d=new Wl(u,r,a,i,l,o,c);return n.addTensorArray(d),[d.idTensor,Object(s.We)(1)]}case"TensorArrayWriteV3":{const a=Object(Al.d)("tensorArrayId",e,t,n),r=Object(Al.d)("index",e,t,n),s=Object(Al.d)("tensor",e,t,n),i=n.getTensorArray(a.id);return i.write(r,s),[i.idTensor]}case"TensorArrayReadV3":{const a=Object(Al.d)("tensorArrayId",e,t,n),r=Object(Al.d)("index",e,t,n);return[n.getTensorArray(a.id).read(r)]}case"TensorArrayGatherV3":{const a=Object(Al.d)("tensorArrayId",e,t,n),r=Object(Al.d)("indices",e,t,n),s=Object(Al.d)("dtype",e,t,n);return[n.getTensorArray(a.id).gather(r,s)]}case"TensorArrayScatterV3":{const a=Object(Al.d)("tensorArrayId",e,t,n),r=Object(Al.d)("indices",e,t,n),s=Object(Al.d)("tensor",e,t,n),i=n.getTensorArray(a.id);return i.scatter(r,s),[i.idTensor]}case"TensorArrayConcatV3":{const a=Object(Al.d)("tensorArrayId",e,t,n),r=n.getTensorArray(a.id),s=Object(Al.d)("dtype",e,t,n);return[r.concat(s)]}case"TensorArraySplitV3":{const a=Object(Al.d)("tensorArrayId",e,t,n),r=Object(Al.d)("tensor",e,t,n),s=Object(Al.d)("lengths",e,t,n),i=n.getTensorArray(a.id);return i.split(s,r),[i.idTensor]}case"TensorArraySizeV3":{const a=Object(Al.d)("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return[Object(s.We)(r.size(),"int32")]}case"TensorArrayCloseV3":{const a=Object(Al.d)("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const a=Object(Al.d)("tensorListId",e,t,n),r=Object(Al.d)("index",e,t,n),s=Object(Al.d)("tensor",e,t,n),i=n.getTensorList(a.id);return i.setItem(r,s),[i.idTensor]}case"TensorListGetItem":{const a=Object(Al.d)("tensorListId",e,t,n),r=Object(Al.d)("index",e,t,n),s=Object(Al.d)("elementShape",e,t,n),i=Object(Al.d)("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(r,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{const a=Object(Al.d)("indices",e,t,n),r=function(e,t,n,a){if(t.length!==e.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(t.length," vs. ").concat(e.shape[0]));const r=Math.max(...t);if(null!=a&&-1!==a&&r>=a)throw new Error("Max index must be < array size (".concat(r,"  vs. ").concat(a,")"));const i=new Ul([],n,e.dtype,a),o=Object(s.Bf)(e,0);return t.forEach((e,t)=>{i.setItem(e,o[t])}),i}(Object(Al.d)("tensor",e,t,n),a,Object(Al.d)("elementShape",e,t,n),Object(Al.d)("numElements",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const a=Object(Al.d)("elementShape",e,t,n),r=Object(Al.d)("elementDType",e,t,n);let s;s="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=Object(Al.d)(s,e,t,n),o=function(e,t,n,a){return new Ul([],e,t,a)}(a,r,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const a=Object(Al.d)("tensorListId",e,t,n),r=Object(Al.d)("indices",e,t,n),s=Object(Al.d)("elementShape",e,t,n),i=Object(Al.d)("elementDType",e,t,n);return[n.getTensorList(a.id).gather(r,i,s)]}case"TensorListStack":{const a=Object(Al.d)("tensorListId",e,t,n),r=Object(Al.d)("elementShape",e,t,n),s=Object(Al.d)("elementDType",e,t,n),i=Object(Al.d)("numElements",e,t,n);return[n.getTensorList(a.id).stack(r,s,i)]}case"TensorListFromTensor":{const a=function(e,t,n){const a=e.dtype;if(e.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: ".concat(e.shape));if(e.dtype!==n)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(n));zl(e.shape.slice(1),t,"TensorList shape mismatch: ");const r=Object(s.Bf)(e);return new Ul(r,t,a)}(Object(Al.d)("tensor",e,t,n),Object(Al.d)("elementShape",e,t,n),Object(Al.d)("elementDType",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const a=Object(Al.d)("tensorListId",e,t,n),r=n.getTensorList(a.id),s=Object(Al.d)("dtype",e,t,n),i=Object(Al.d)("elementShape",e,t,n);return[r.concat(s,i)]}case"TensorListPushBack":{const a=Object(Al.d)("tensorListId",e,t,n),r=Object(Al.d)("tensor",e,t,n),s=n.getTensorList(a.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{const a=Object(Al.d)("tensorListId",e,t,n),r=Object(Al.d)("elementShape",e,t,n),s=Object(Al.d)("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(r,s)]}case"TensorListSplit":{const a=Object(Al.d)("tensor",e,t,n),r=Object(Al.d)("elementShape",e,t,n),i=function(e,t,n){let a=0;const r=t.map(e=>(a+=e,a));if(a!==e.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(a,", and tensor's shape is: ").concat(e.shape));const i=Bl(e.shape.slice(1),n),o=0===a?0:e.size/a,c=Object(s.wf)(()=>{const n=[];e=Object(s.Ue)(e,[1,a,o]);for(let a=0;a<t.length;++a){const c=[0,0===a?0:r[a-1],0],l=[1,t[a],o];n[a]=Object(s.Ue)(Object(s.cf)(e,c,l),i)}return e.dispose(),n}),l=new Ul([],n,e.dtype,t.length);for(let s=0;s<c.length;s++)l.setItem(s,c[s]);return l}(a,Object(Al.d)("lengths",e,t,n),r);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{const a=Object(Al.d)("tensorListId",e,t,n),r=n.getTensorList(a.id);return[Object(s.We)(r.size(),"int32")]}case"TensorListResize":{const a=Object(Al.d)("tensorListId",e,t,n),r=Object(Al.d)("size",e,t,n),s=n.getTensorList(a.id).resize(r);return n.addTensorList(s),[s.idTensor]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function Gl(e,t,n){const[a,r]=Object(Al.d)("fusedOps",e,t,n),s="biasadd"===a,i=!s,o="prelu"===r,c="fusedbatchnorm"===a,l=Object(Al.d)("numArgs",e,t,n);if(s){if(o&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=Object(Al.d)("strides",e,t,n),d=Object(Al.c)(e,t,n),h=Object(Al.d)("dataFormat",e,t,n).toUpperCase(),p=Object(Al.d)("dilations",e,t,n);let[f,m]=Object(Al.d)("args",e,t,n);i&&(m=f,f=void 0);return{stride:u,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:Object(Al.d)("leakyreluAlpha",e,t,n)}}const Hl=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"Conv1D":{const a=Object(Al.d)("stride",e,t,n),s=Object(Al.d)("pad",e,t,n),i=Object(Al.d)("dataFormat",e,t,n).toUpperCase(),o=Object(Al.d)("dilation",e,t,n);return[r.conv1d(Object(Al.d)("x",e,t,n),Object(Al.d)("filter",e,t,n),a,s,i,o)]}case"Conv2D":{const a=Object(Al.d)("strides",e,t,n),s=Object(Al.c)(e,t,n),i=Object(Al.d)("dataFormat",e,t,n).toUpperCase(),o=Object(Al.d)("dilations",e,t,n);return[r.conv2d(Object(Al.d)("x",e,t,n),Object(Al.d)("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:d}=Gl(e,t,n);return[r.fused.conv2d({x:Object(Al.d)("x",e,t,n),filter:Object(Al.d)("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:d}=Gl(e,t,n);return[r.fused.depthwiseConv2d({x:Object(Al.d)("x",e,t,n),filter:Object(Al.d)("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const a=Object(Al.d)("outputShape",e,t,n),s=Object(Al.d)("strides",e,t,n),i=Object(Al.c)(e,t,n);return[r.conv2dTranspose(Object(Al.d)("x",e,t,n),Object(Al.d)("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const a=Object(Al.d)("strides",e,t,n),s=Object(Al.c)(e,t,n),i=Object(Al.d)("dilations",e,t,n),o=Object(Al.d)("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(Object(Al.d)("input",e,t,n),Object(Al.d)("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{const a=Object(Al.d)("strides",e,t,n),s=Object(Al.d)("pad",e,t,n),i=Object(Al.d)("dataFormat",e,t,n).toUpperCase(),o=Object(Al.d)("dilations",e,t,n);return[r.conv3d(Object(Al.d)("x",e,t,n),Object(Al.d)("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{const a=Object(Al.d)("strides",e,t,n),s=Object(Al.d)("pad",e,t,n),i=Object(Al.d)("kernelSize",e,t,n);return[r.avgPool(Object(Al.d)("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{const a=Object(Al.d)("strides",e,t,n),s=Object(Al.d)("pad",e,t,n),i=Object(Al.d)("kernelSize",e,t,n);return[r.maxPool(Object(Al.d)("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{const a=Object(Al.d)("strides",e,t,n),s=Object(Al.d)("pad",e,t,n),i=Object(Al.d)("kernelSize",e,t,n),o=Object(Al.d)("includeBatchInIndex",e,t,n),{result:c,indexes:l}=r.maxPoolWithArgmax(Object(Al.d)("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[c,l]}case"AvgPool3D":{const a=Object(Al.d)("strides",e,t,n),s=Object(Al.d)("pad",e,t,n),i=Object(Al.d)("kernelSize",e,t,n);return[r.avgPool3d(Object(Al.d)("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{const a=Object(Al.d)("strides",e,t,n),s=Object(Al.d)("pad",e,t,n),i=Object(Al.d)("kernelSize",e,t,n);return[r.maxPool3d(Object(Al.d)("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{const a=Object(Al.d)("strides",e,t,n),s=Object(Al.d)("pad",e,t,n),i=Object(Al.d)("dilations",e,t,n),o=a[1],c=a[2],l=i[1],u=i[2];return[r.dilation2d(Object(Al.d)("x",e,t,n),Object(Al.d)("filter",e,t,n),[o,c],s,[l,u],"NHWC")]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},ql=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"Fill":{const a=Object(Al.d)("shape",e,t,n),s=Object(Al.d)("dtype",e,t,n),i=Object(Al.d)("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{const a=Object(Al.d)("start",e,t,n),s=Object(Al.d)("stop",e,t,n),i=Object(Al.d)("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{const a=Object(Al.d)("logits",e,t,n),s=Object(Al.d)("numSamples",e,t,n),i=Object(Al.d)("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{const a=Object(Al.d)("indices",e,t,n),s=Object(Al.d)("depth",e,t,n),i=Object(Al.d)("onValue",e,t,n),o=Object(Al.d)("offValue",e,t,n),c=Object(Al.d)("dtype",e,t,n);return[r.oneHot(a,s,i,o,c)]}case"Ones":return[r.ones(Object(Al.d)("shape",e,t,n),Object(Al.d)("dtype",e,t,n))];case"OnesLike":return[r.onesLike(Object(Al.d)("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(Object(Al.d)("shape",e,t,n),Object(Al.d)("dtype",e,t,n),Object(Al.d)("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(Object(Al.d)("shape",e,t,n),Object(Al.d)("minval",e,t,n),Object(Al.d)("maxval",e,t,n),Object(Al.d)("dtype",e,t,n))];case"Range":{const a=Object(Al.d)("start",e,t,n),s=Object(Al.d)("stop",e,t,n),i=Object(Al.d)("step",e,t,n);return[r.range(a,s,i,Object(Al.d)("dtype",e,t,n))]}case"TruncatedNormal":{const a=Object(Al.d)("shape",e,t,n),s=Object(Al.d)("mean",e,t,n),i=Object(Al.d)("stdDev",e,t,n),o=Object(Al.d)("seed",e,t,n);return[r.truncatedNormal(a,s,i,Object(Al.d)("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(Object(Al.d)("shape",e,t,n),Object(Al.d)("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(Object(Al.d)("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function Kl(e,t,n){return{boxes:Object(Al.d)("boxes",e,t,n),scores:Object(Al.d)("scores",e,t,n),maxOutputSize:Object(Al.d)("maxOutputSize",e,t,n),iouThreshold:Object(Al.d)("iouThreshold",e,t,n),scoreThreshold:Object(Al.d)("scoreThreshold",e,t,n),softNmsSigma:Object(Al.d)("softNmsSigma",e,t,n)}}const Xl=async function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:a;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=Kl(e,t,n),u=await s.image.nonMaxSuppressionWithScoreAsync(a,r,i,o,c,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=Kl(e,t,n),l=Object(Al.d)("padToMaxOutputSize",e,t,n),u=await s.image.nonMaxSuppressionPaddedAsync(a,r,i,o,c,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=Kl(e,t,n);return[await s.image.nonMaxSuppressionAsync(a,r,i,o,c)]}case"Where":{const a=s.cast(Object(Al.d)("condition",e,t,n),"bool"),r=[await s.whereAsync(a)];return a.dispose(),r}case"ListDiff":return s.setdiff1dAsync(Object(Al.d)("x",e,t,n),Object(Al.d)("y",e,t,n));default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},Zl=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"LowerBound":{const a=Object(Al.d)("sortedSequence",e,t,n),s=Object(Al.d)("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{const a=Object(Al.d)("x",e,t,n),s=Object(Al.d)("k",e,t,n),i=Object(Al.d)("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{const a=Object(Al.d)("sortedSequence",e,t,n),s=Object(Al.d)("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{const a=Object(Al.d)("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{const a=Object(Al.d)("x",e,t,n),s=Object(Al.d)("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},Yl=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const a=Object(Al.d)("default",e,t,n);return[Object(Al.e)(e.name,t,n)||a];case"Placeholder":return[Object(Al.e)(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const a=Object(Al.d)("x",e,t,n);return[Object(Al.a)(a)]}case"IdentityN":return Object(Al.d)("x",e,t,n).map(e=>Object(Al.a)(e));case"Snapshot":const s=Object(Al.d)("x",e,t,n);return[Object(Al.a)(s)];case"Shape":return[r.tensor1d(Object(Al.d)("x",e,t,n).shape,"int32")];case"ShapeN":return Object(Al.d)("x",e,t,n).map(e=>r.tensor1d(e.shape));case"Size":return[r.scalar(Object(Al.d)("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(Object(Al.d)("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const i=Object(Al.d)("x",e,t,n),o=Object(Al.d)("data",e,t,n),c=Object(Al.d)("message",e,t,n),l=Object(Al.d)("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(c);for(let e=0;e<o.length;e++)console.log(Array.prototype.slice.call(o[e].dataSync()).slice(0,l));return[i];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};class Jl{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Object(s.We)(0),this.tensorMap=new Map,Object(s.oe)(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return p.a(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),Object(s.wf)(()=>{const e=Object(s.Bf)(t),a=n.length,r=e.length;s.Df.assert(a===r,()=>"The number of elements doesn't match, keys has "+"".concat(a," elements, the values has ").concat(r," ")+"elements.");for(let t=0;t<a;t++){const a=n[t],r=e[t];Object(s.oe)(r),this.tensorMap.set(a,r)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return Object(s.wf)(()=>{const e=[];for(let a=0;a<n.length;a++){const r=n[a],s=this.findWithDefault(r,t);e.push(s)}return Object(s.nf)(e)})}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error("Expect key dtype ".concat(this.keyDType,", but got ")+"".concat(e.dtype));if(t.dtype!==this.valueDType)throw new Error("Expect value dtype ".concat(this.valueDType,", but got ")+"".concat(t.dtype))}}const Ql=async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{const r=Object(Al.d)("keyDType",e,t,n),s=Object(Al.d)("valueDType",e,t,n),i=new Jl(r,s);return a.addHashTable(e.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{const r=Object(Al.d)("tableHandle",e,t,n,a),s=Object(Al.d)("keys",e,t,n),i=Object(Al.d)("values",e,t,n),o=a.getHashTableById(r.id);return[await o.import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{const r=Object(Al.d)("tableHandle",e,t,n,a),s=Object(Al.d)("keys",e,t,n),i=Object(Al.d)("defaultValue",e,t,n),o=a.getHashTableById(r.id);return[await o.find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=Object(Al.d)("tableHandle",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},$l=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"ResizeBilinear":{const a=Object(Al.d)("images",e,t,n),s=Object(Al.d)("size",e,t,n),i=Object(Al.d)("alignCorners",e,t,n),o=Object(Al.d)("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{const a=Object(Al.d)("images",e,t,n),s=Object(Al.d)("size",e,t,n),i=Object(Al.d)("alignCorners",e,t,n),o=Object(Al.d)("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{const a=Object(Al.d)("image",e,t,n),s=Object(Al.d)("boxes",e,t,n),i=Object(Al.d)("boxInd",e,t,n),o=Object(Al.d)("cropSize",e,t,n),c=Object(Al.d)("method",e,t,n),l=Object(Al.d)("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,c,l)]}case"ImageProjectiveTransformV3":{const a=Object(Al.d)("images",e,t,n),s=Object(Al.d)("transforms",e,t,n),i=Object(Al.d)("outputShape",e,t,n),o=Object(Al.d)("fillValue",e,t,n),c=Object(Al.d)("interpolation",e,t,n),l=Object(Al.d)("fillMode",e,t,n);return[r.image.transform(a,s,c.toLowerCase(),l.toLowerCase(),o,i)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},eu=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"Equal":return[r.equal(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"NotEqual":return[r.notEqual(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"Greater":return[r.greater(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"Less":return[r.less(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"LessEqual":return[r.lessEqual(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"LogicalNot":return[r.logicalNot(Object(Al.d)("a",e,t,n))];case"LogicalOr":return[r.logicalOr(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];case"Select":case"SelectV2":return[r.where(Object(Al.d)("condition",e,t,n),Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},tu=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(Object(Al.d)("a",e,t,n),Object(Al.d)("b",e,t,n),Object(Al.d)("transposeA",e,t,n),Object(Al.d)("transposeB",e,t,n))];case"Einsum":return[r.einsum(Object(Al.d)("equation",e,t,n),...Object(Al.d)("tensors",e,t,n))];case"Transpose":return[r.transpose(Object(Al.d)("x",e,t,n),Object(Al.d)("perm",e,t,n))];case"_FusedMatMul":const[a,s]=Object(Al.d)("fusedOps",e,t,n),i="biasadd"===a,o="prelu"===s,c=Object(Al.d)("numArgs",e,t,n),l=Object(Al.d)("leakyreluAlpha",e,t,n);if(i){if(o&&2!==c)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==c)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,d]=Object(Al.d)("args",e,t,n);return[r.fused.matMul({a:Object(Al.d)("a",e,t,n),b:Object(Al.d)("b",e,t,n),transposeA:Object(Al.d)("transposeA",e,t,n),transposeB:Object(Al.d)("transposeB",e,t,n),bias:u,activation:s,preluActivationWeights:d,leakyreluAlpha:l})];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},nu=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(Object(Al.d)("x",e,t,n),Object(Al.d)("axis",e,t,n),Object(Al.d)("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(Object(Al.d)("x",e,t,n),Object(Al.d)("mean",e,t,n),Object(Al.d)("variance",e,t,n),Object(Al.d)("offset",e,t,n),Object(Al.d)("scale",e,t,n),Object(Al.d)("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(Object(Al.d)("x",e,t,n),Object(Al.d)("radius",e,t,n),Object(Al.d)("bias",e,t,n),Object(Al.d)("alpha",e,t,n),Object(Al.d)("beta",e,t,n))];case"Softmax":return[r.softmax(Object(Al.d)("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(Object(Al.d)("x",e,t,n))];case"SparseToDense":return[r.sparseToDense(Object(Al.d)("sparseIndices",e,t,n),Object(Al.d)("outputShape",e,t,n),Object(Al.d)("sparseValues",e,t,n),Object(Al.d)("defaultValue",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},au=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"Max":{const a=Object(Al.d)("axis",e,t,n),s=Object(Al.d)("keepDims",e,t,n);return[r.max(Object(Al.d)("x",e,t,n),a,s)]}case"Mean":{const a=Object(Al.d)("axis",e,t,n),s=Object(Al.d)("keepDims",e,t,n);return[r.mean(Object(Al.d)("x",e,t,n),a,s)]}case"Min":{const a=Object(Al.d)("axis",e,t,n),s=Object(Al.d)("keepDims",e,t,n);return[r.min(Object(Al.d)("x",e,t,n),a,s)]}case"Sum":{const a=Object(Al.d)("axis",e,t,n),s=Object(Al.d)("keepDims",e,t,n);return[r.sum(Object(Al.d)("x",e,t,n),a,s)]}case"All":{const a=Object(Al.d)("axis",e,t,n),s=Object(Al.d)("keepDims",e,t,n);return[r.all(Object(Al.d)("x",e,t,n),a,s)]}case"Any":{const a=Object(Al.d)("axis",e,t,n),s=Object(Al.d)("keepDims",e,t,n);return[r.any(Object(Al.d)("x",e,t,n),a,s)]}case"ArgMax":{const a=Object(Al.d)("axis",e,t,n);return[r.argMax(Object(Al.d)("x",e,t,n),a)]}case"ArgMin":{const a=Object(Al.d)("axis",e,t,n);return[r.argMin(Object(Al.d)("x",e,t,n),a)]}case"Prod":{const a=Object(Al.d)("axis",e,t,n),s=Object(Al.d)("keepDims",e,t,n);return[r.prod(Object(Al.d)("x",e,t,n),a,s)]}case"Cumprod":{const a=Object(Al.d)("axis",e,t,n),s=Object(Al.d)("exclusive",e,t,n),i=Object(Al.d)("reverse",e,t,n);return[r.cumprod(Object(Al.d)("x",e,t,n),a,s,i)]}case"Cumsum":{const a=Object(Al.d)("axis",e,t,n),s=Object(Al.d)("exclusive",e,t,n),i=Object(Al.d)("reverse",e,t,n);return[r.cumsum(Object(Al.d)("x",e,t,n),a,s,i)]}case"Bincount":const a=Object(Al.d)("x",e,t,n),s=Object(Al.d)("weights",e,t,n),i=Object(Al.d)("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{const a=Object(Al.d)("x",e,t,n),s=Object(Al.d)("weights",e,t,n),i=Object(Al.d)("size",e,t,n),o=Object(Al.d)("binaryOutput",e,t,n);return[r.denseBincount(a,s,i,o)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},ru=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"ConcatV2":case"Concat":{const a=Object(Al.d)("n",e,t,n),s=Object(Al.d)("axis",e,t,n);let i=Object(Al.d)("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{const a=Object(Al.d)("x",e,t,n),s=Object(Al.d)("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{const a=Object(Al.d)("axis",e,t,n),s=Object(Al.d)("batchDims",e,t,n),i=Object(Al.d)("x",e,t,n),o=Object(Al.d)("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{const a=Object(Al.d)("dims",e,t,n),s=[];for(let e=0;e<a.length;e++)a[e]&&s.push(e);const i=Object(Al.d)("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{const a=Object(Al.d)("axis",e,t,n),s=Object(Al.d)("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{const a=Object(Al.d)("begin",e,t,n),s=Object(Al.d)("size",e,t,n);return[r.slice(Object(Al.d)("x",e,t,n),a,s)]}case"StridedSlice":{const a=Object(Al.d)("begin",e,t,n),s=Object(Al.d)("end",e,t,n),i=Object(Al.d)("strides",e,t,n),o=Object(Al.d)("beginMask",e,t,n),c=Object(Al.d)("endMask",e,t,n),l=Object(Al.d)("ellipsisMask",e,t,n),u=Object(Al.d)("newAxisMask",e,t,n),d=Object(Al.d)("shrinkAxisMask",e,t,n),h=Object(Al.d)("x",e,t,n);return[r.stridedSlice(h,a,s,i,o,c,l,u,d)]}case"Pack":return Object(s.wf)(()=>{const a=Object(Al.d)("axis",e,t,n),i=Object(Al.d)("tensors",e,t,n),o=i[0].shape,c=r.squeeze(i[0]).shape,l=i.map(e=>{const t=s.Df.arraysEqual(e.shape,o);if(!t&&!s.Df.arraysEqual(r.squeeze(e).shape,c))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,o)});return[r.stack(l,a)]});case"Unpack":{const a=Object(Al.d)("axis",e,t,n),s=Object(Al.d)("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{const a=Object(Al.d)("reps",e,t,n);return[r.tile(Object(Al.d)("x",e,t,n),a)]}case"Split":case"SplitV":{const a=Object(Al.d)("axis",e,t,n),s=Object(Al.d)("numOrSizeSplits",e,t,n),i=Object(Al.d)("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{const a=Object(Al.d)("indices",e,t,n),s=Object(Al.d)("values",e,t,n),i=Object(Al.d)("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{const a=Object(Al.d)("x",e,t,n),s=Object(Al.d)("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{const a=Object(Al.d)("sparseIndices",e,t,n),s=Object(Al.d)("outputShape",e,t,n),i=Object(Al.d)("sparseValues",e,t,n),o=Object(Al.d)("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},su=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(Object(Al.d)("indices",e,t,n),Object(Al.d)("values",e,t,n),Object(Al.d)("denseShape",e,t,n),Object(Al.d)("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{const{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(Object(Al.d)("inputIndices",e,t,n),Object(Al.d)("inputShape",e,t,n),Object(Al.d)("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(Object(Al.d)("data",e,t,n),Object(Al.d)("indices",e,t,n),Object(Al.d)("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(Object(Al.d)("data",e,t,n),Object(Al.d)("indices",e,t,n),Object(Al.d)("segmentIds",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},iu=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"FFT":return[r.fft(Object(Al.d)("x",e,t,n))];case"IFFT":return[r.ifft(Object(Al.d)("x",e,t,n))];case"RFFT":return[r.rfft(Object(Al.d)("x",e,t,n))];case"IRFFT":return[r.irfft(Object(Al.d)("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},ou=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"StringNGrams":{const{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(Object(Al.d)("data",e,t,n),Object(Al.d)("dataSplits",e,t,n),Object(Al.d)("separator",e,t,n),Object(Al.d)("nGramWidths",e,t,n),Object(Al.d)("leftPad",e,t,n),Object(Al.d)("rightPad",e,t,n),Object(Al.d)("padWidth",e,t,n),Object(Al.d)("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{const{indices:a,values:s,shape:i}=r.string.stringSplit(Object(Al.d)("input",e,t,n),Object(Al.d)("delimiter",e,t,n),Object(Al.d)("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(Object(Al.d)("input",e,t,n),Object(Al.d)("numBuckets",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},cu=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;switch(e.op){case"Cast":return[r.cast(Object(Al.d)("x",e,t,n),Object(Al.d)("dtype",e,t,n))];case"ExpandDims":{const a=Object(Al.d)("axis",e,t,n);return[r.expandDims(Object(Al.d)("x",e,t,n),a)]}case"Squeeze":{const a=Object(Al.d)("axis",e,t,n);return[r.squeeze(Object(Al.d)("x",e,t,n),a)]}case"Reshape":return[r.reshape(Object(Al.d)("x",e,t,n),Object(Al.d)("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(Object(Al.d)("x",e,t,n),Object(Al.d)("padding",e,t,n),Object(Al.d)("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(Object(Al.d)("x",e,t,n),Object(Al.d)("padding",e,t,n),Object(Al.d)("constantValue",e,t,n))];case"SpaceToBatchND":{const a=Object(Al.d)("blockShape",e,t,n),s=Object(Al.d)("paddings",e,t,n);return[r.spaceToBatchND(Object(Al.d)("x",e,t,n),a,s)]}case"BatchToSpaceND":{const a=Object(Al.d)("blockShape",e,t,n),s=Object(Al.d)("crops",e,t,n);return[r.batchToSpaceND(Object(Al.d)("x",e,t,n),a,s)]}case"DepthToSpace":{const a=Object(Al.d)("blockSize",e,t,n),s=Object(Al.d)("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(Object(Al.d)("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(Object(Al.d)("x",e,t,n),Object(Al.d)("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(Object(Al.d)("s0",e,t,n),Object(Al.d)("s1",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function lu(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:s.wf;const i=((e,t,n)=>{switch(e.category){case"arithmetic":return r(()=>Ml(e,t,n));case"basic_math":return r(()=>jl(e,t,n));case"control":return Vl(e,t,n);case"convolution":return r(()=>Hl(e,t,n));case"creation":return r(()=>ql(e,t,n));case"dynamic":return Xl(e,t,n);case"evaluation":return r(()=>Zl(e,t,n));case"image":return r(()=>$l(e,t,n));case"graph":return r(()=>Yl(e,t,n));case"logical":return r(()=>eu(e,t,n));case"matrices":return r(()=>tu(e,t,n));case"normalization":return r(()=>nu(e,t,n));case"reduction":return r(()=>au(e,t,n));case"slice_join":return r(()=>ru(e,t,n));case"sparse":return r(()=>su(e,t,n));case"spectral":return r(()=>iu(e,t,n));case"string":return r(()=>ou(e,t,n));case"transformation":return r(()=>cu(e,t,n));case"hash_table":return Ql(e,t,n,a);case"custom":const s=Object(Dl.a)(e.op);if(s&&s.customExecutor)return s.customExecutor(new Rl(e,t,n));throw TypeError("Custom op ".concat(e.op," is not registered."));default:throw TypeError("Unknown op '".concat(e.op,"'. File an issue at ")+"https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(e,t,n);return s.Df.isPromise(i)?i.then(e=>[].concat(e)):[].concat(i)}class uu{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":"".concat(e.frameName,"-").concat(e.iterationId)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function du(e,t,n,a){const r=new Set,s=[];let i=null,o=null;const c=new Set,l=Object.keys(e).map(e=>Object(Al.g)(e)[0]);let u=[];null!=a&&(u=a.map(e=>Object(Al.g)(e.name)[0]));const d=[...t];for(;d.length>0;){const e=d.pop();(mu(e)||gu(e)||bu(e))&&null==i&&(i=e,o=i.children.map(e=>e.name).filter(e=>r.has(e))),r.add(e.name),null==n[e.name]&&(-1===l.indexOf(e.name)&&-1===u.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach(e=>{c.has(e.name)||(c.add(e.name),d.push(e))}):s.push(e.name)))}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:i,syncInputs:o}}const hu=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],pu=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],fu=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function mu(e){return hu.indexOf(e.op)>=0}function gu(e){return pu.indexOf(e.op)>=0}function bu(e){return fu.indexOf(e.op)>=0}class yu{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new yu(e.functions[t],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?"".concat(t,":").concat(e.defaultOutput):t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const n=e.map(e=>e.name).sort(),a=t.map(e=>e.name).sort();return n.join(this.SEPERATOR)+"--"+a.join(this.SEPERATOR)}compile(e,t){const n=du(e,t,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:r,syncInputs:s}=n;if(null!=r)throw new Error("This execution contains the node '".concat(r.name,"', which has ")+"the dynamic op '".concat(r.op,"'. Please use ")+"model.executeAsync() instead. Alternatively, to avoid the "+"dynamic ops, specify the inputs [".concat(s,"]"));if(a.length>0){const n=t.map(e=>e.name),r=Object.keys(e);throw new Error("Cannot compute the outputs [".concat(n,"] from the provided inputs ")+"[".concat(r,"]. Missing the following inputs: [").concat(a,"]"))}return function(e,t,n){const{usedNodes:a,inputs:r}=n,s=[],i=Object.keys(r).map(e=>Object(Al.g)(e)[0]).map(t=>e.nodes[t]),o=e.initNodes;i.forEach(e=>{a.has(e.name)&&s.push(e)}),e.weights.forEach(e=>{a.has(e.name)&&s.push(e)}),null!=o&&o.forEach(e=>{a.has(e.name)&&s.push(e)});const c=new Set,l=[];for(;s.length>0;){const e=s.pop();c.add(e.name),t[e.name]||l.push(e),e.children.forEach(e=>{!c.has(e.name)&&a.has(e.name)&&e.inputs.every(e=>c.has(e.name))&&s.push(e)})}return l}(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const a=n.map(e=>this.graph.nodes[Object(Al.g)(e)[0]]),r=t.map(e=>Object(Al.g)(e)[0]);let i=r.map(e=>this.graph.nodes[e]);this.resetIntermediateTensors(),0===i.length&&(i=this._outputs);const o=this.getCompilationKey(a,i);let c=this.compiledMap.get(o);null==c&&(c=this.compile(e,i),this.compiledMap.set(o,c));const l={},u={};return Object(s.wf)(()=>{const n=new uu(this.weightMap,l,u,this.functionExecutorMap),a=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[n,r]=Object(Al.g)(t),s=[];s[r]=e[t],a[n]=s});const i=this.getFrozenTensorIds(a),o={};for(let e=0;e<c.length;e++){const t=c[e];if(!a[t.name]){const e=lu(t,a,n,this._resourceManager);if(s.Df.isPromise(e))throw new Error("The execution of the op '".concat(t.op,"' returned a promise. ")+"Please use model.executeAsync() instead.");a[t.name]=e,this.checkTensorForDisposal(t.name,t,a,n,i,r,o)}}return null==this.parent&&n.dispose(i),t.map(e=>Object(Al.e)(e,a,n))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,t,n,a,r,s,i){"control"!==t.category&&-1===s.indexOf(e)&&(n[e].forEach(e=>{null!=e&&(i[e.id]=(i[e.id]||0)+t.children.length)}),t.inputs.forEach(e=>{if("control"!==e.category){const s=Object(Al.f)(e.name,n,a);null!=s&&s.forEach(e=>{if(e&&!e.kept&&!r.has(e.id)){const n=i[e.id];if(1===n){if(this.keepTensorForDebug){const[n,r]=Object(Al.b)(t.name,a);this.intermediateTensors[n]||(this.intermediateTensors[n]=[]),this.intermediateTensors[n][r]=e}else e.dispose();delete i[e.id]}else null!=n&&i[e.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(e=>e.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(e=>{!e||e.kept||e.isDisposed||this.keepIds.has(e.id)||e.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(e=>e.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=Object(s.be)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(u){console.warn(u.message)}this.resetIntermediateTensors();const i=new uu(this.weightMap,a,r,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,i,t,n);const o=t.map(e=>Object(Al.e)(e,this.tensorsMap,i)),c=o.map(e=>e.id),l=Object.keys(e).map(t=>e[t].id);return this.keepIds=new Set([...c,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),null==this.parent&&i.dispose(this.keepIds),o}async executeFunctionAsync(e,t,n){const a=e.reduce((e,t,n)=>(e[this.inputs[n].name]=t,e),{});return this._executeAsync(a,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,a){const r=Object.keys(e),s=r.map(e=>this.graph.nodes[Object(Al.g)(e)[0]]),i=n.map(e=>Object(Al.g)(e)[0]);let o=i.map(e=>this.graph.nodes[e]);0===o.length&&(o=this._outputs);const{usedNodes:c,missingInputs:l,dynamicNode:u,syncInputs:d}=du(e,o,this.weightMap,this._initNodes),h=[...s,...this.graph.weights,...this._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),p=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[n,a]=Object(Al.g)(t),r=[];r[a]=e[t],p[n]=r});const f={},m=this.getFrozenTensorIds(p),g={};for(;h.length>0;){const e=this.processStack(s,h,t,p,g,m,i,f,c);await Promise.all(e)}null!=u||a||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=o.filter(e=>!mu(e)&&!Object(Al.e)(e.name,p,t)).map(e=>e.name);if(b.length>0){let e="";throw null!=u&&(e="Alternatively, to avoid the dynamic ops, use model.execute() "+"and specify the inputs [".concat(d,"]")),new Error("Cannot compute the outputs [".concat(b,"] from the provided ")+"inputs [".concat(r,"]. Consider providing the following inputs: ")+"[".concat(l,"]. ").concat(e))}return p}processStack(e,t,n,a,r,i,o,c,l){const u=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let d="";if("Enter"===e.node.op&&Object(Al.d)("isConstant",e.node,a,n)&&([d]=Object(Al.b)(e.node.name,n)),null==a[e.node.name]){const h=lu(e.node,a,n,this._resourceManager);d||([d]=Object(Al.b)(e.node.name,n));const p=n.currentContext;s.Df.isPromise(h)?u.push(h.then(s=>(a[d]=s,n.currentContext=p,this.checkTensorForDisposal(d,e.node,a,n,i,o,c),this.processChildNodes(e.node,t,n,a,r,l),s))):(a[d]=h,this.checkTensorForDisposal(d,e.node,a,n,i,o,c),this.processChildNodes(e.node,t,n,a,r,l))}else this.processChildNodes(e.node,t,n,a,r,l)}return u}processChildNodes(e,t,n,a,r,s){e.children.forEach(e=>{const[i]=Object(Al.b)(e.name,n);!r[i]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!Object(Al.e)(e,a,n))&&(r[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every(e=>!!Object(Al.e)(e,a,n))&&(r[i]=!0,t.push({contexts:n.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[a]=Object(Al.g)(t),r=this.graph.nodes[a];if(r.attrParams.shape&&r.attrParams.shape.value){const e=r.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every((t,n)=>-1===e[n]||e[n]===t);s.Df.assert(t,()=>"The shape of dict['".concat(r.name,"'] provided in ")+"model.execute(dict) must be [".concat(e,"], but was ")+"[".concat(n.shape,"]"))}r.attrParams.dtype&&r.attrParams.dtype.value&&s.Df.assert(n.dtype===r.attrParams.dtype.value,()=>"The dtype of dict['".concat(r.name,"'] provided in ")+"model.execute(dict) must be "+"".concat(r.attrParams.dtype.value,", but was ").concat(n.dtype))})}mapInputs(e){const t={};for(const n in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]){t[this._signature.inputs[n].name]=e[n]}else t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter(e=>{const[t]=Object(Al.g)(e);return null==this.graph.nodes[t]});if(t.length>0)throw new Error("The dict provided in model.execute(dict) has "+"keys: [".concat(t,"] that are not part of graph"))}mapOutputs(e){return e.map(e=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]){return this._signature.outputs[e].name}return e},{})}checkOutputs(e){e.forEach(e=>{const[t]=Object(Al.g)(e);if(!this.graph.nodes[t])throw new Error("The output '".concat(e,"' is not found in the graph"))})}}class vu{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class xu{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:s.ne;this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new vu}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error("Found more than one (".concat(t.length,") load handlers for ")+"URL '".concat([e],"'"));this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return s.Df.isPromise(e)?e.then(e=>this.loadSync(e)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(n=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}this.signature=n,this.version="".concat(t.versions.producer,".").concat(t.versions.minConsumer);const a=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new yu(_l.a.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(a),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=_l.a.Instance.transformGraph(e.modelInitializer);this.initializer=new yu(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new Error("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){const n=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const e=n instanceof s.gd?[n]:n,t={};return e.forEach((e,n)=>t[this.structuredOutputKeys[n]]=e),t}return n}normalizeInputs(e){if(!(e instanceof s.gd)&&!Array.isArray(e))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error("Input tensor count mismatch,"+"the graph model has ".concat(this.inputNodes.length," placeholders, ")+"while there are ".concat(e.length," input tensors."));return this.inputNodes.reduce((t,n,a)=>(t[n]=e[a],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function wu(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:s.ne;if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"===typeof e&&(e=ku(e));const a=new xu(e,t,n);return await a.load(),a}function ku(e){return e.endsWith("/")||(e+="/"),"".concat(e).concat("model.json").concat("?tfjs-format=file")}var Iu=n(78),Su=n(40),Nu=n(66);class Tu{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let a;return s.Df.assert(e>0,()=>"batchSize needs to be positive, but it is\n      ".concat(e)),a=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),Ou(async()=>(await n.iterator()).columnMajorBatch(e,t,Cu),a)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,Ou(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,Ou(async()=>(await t.iterator()).filter(t=>s.wf(()=>e(t))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return Ou(async()=>(await t.iterator()).map(t=>s.wf(()=>e(t))),this.size)}mapAsync(e){const t=this;return Ou(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return Ou(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,Ou(async()=>{const n=Object(Su.e)(async()=>({value:await t.iterator(),done:!1}));return Object(Su.d)(n.take(e))},n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,Ou(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const a=this,r=Iu.alea(t||s.Df.now().toString());return Ou(async()=>{let t=r.int32();return n&&(t+=r.int32()),(await a.iterator()).shuffle(e,t.toString())},this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,Ou(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function Ou(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends Tu{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function Cu(e){if(null===e)return null;const t=e[0];if(Object(Nu.a)(t)){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof s.gd?s.nf(e):s.sf(e)}(e),recurse:!1}}return{value:null,recurse:!0}}Tu.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");Su.a;Su.a;var Eu=n(223);Eu.a;function _u(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&s.Df.assert("complex64"!==e.dtype,()=>"".concat(t," does not support complex64 tensors in the CPU backend."))})}const Au=s.pe.whereImpl;class Ru extends s.yb{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new s.N(this,Object(s.ae)())}nextDataId(){return Ru.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,Object(s.be)().get("IS_NODE")&&s.zd.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:n,refCount:1}),a}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&s.Df.isString(n[0])){const r=n.map(e=>s.Df.encodeString(e));a=this.write(r,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,a,r){this.data.set(e,{values:t,dtype:a,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){const e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return s.zd.mergeRealAndImagArrays(e,t)}return this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>s.Df.decodeString(e));return Object(s.Gd)(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(s.Gd)(e.shape,e.dtype,t)}makeOutput(e,t,n){return Object(s.ae)().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=s.Df.now();e();return{kernelMs:s.Df.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){_u([e],"where");const t=this.readSync(e.dataId);return Au(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Ru.nextDataId=0;function Du(e,t,n){return a=>{let{inputs:r,attrs:i,backend:o}=a;const{x:c}=r;if(_u(c,e),"string"===c.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const l=o,u=l.data.get(c.dataId).values,d=s.Df.sizeFromShape(c.shape),h=n||c.dtype,p=s.Df.getArrayFromDType(h,d);for(let e=0;e<d;++e)p[e]=t(u[e],i);return l.makeTensorInfo(c.shape,h,p)}}function Fu(e,t,n){return a=>{let{inputs:r,attrs:s,backend:i}=a;const{x:o}=r;if(_u(o,e),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const c=i,l=c.data.get(o.dataId).values,u=n||o.dtype,d=t(l,u,s);return c.makeTensorInfo(o.shape,u,d)}}Object(s.Re)("cpu",()=>new Ru,1);const Mu=Du(s.Y,e=>e>=0?e:Math.exp(e)-1),ju={kernelName:s.Y,backendName:"cpu",kernelFunc:Mu};function zu(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const Lu={kernelName:s.tb,backendName:"cpu",kernelFunc:zu};function Pu(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:i}=a;_u([r],"leakyRelu");const o=s.Df.sizeFromShape(r.shape),c=n.data.get(r.dataId).values,l=s.Df.getTypedArrayFromDType("float32",o);for(let s=0;s<c.length;s++)l[s]=c[s]<0?i*c[s]:c[s];return n.makeTensorInfo(r.shape,"float32",l)}const Bu={kernelName:s.Bb,backendName:"cpu",kernelFunc:Pu};function Wu(e){return(t,n,a,r,i)=>{const o=s.zd.assertAndGetBroadcastShape(t,n),c=o.length,l=s.Df.computeStrides(o),u=s.Df.sizeFromShape(o),d=s.Df.getTypedArrayFromDType(i,u),h=t.length,p=n.length,f=s.Df.computeStrides(t),m=s.Df.computeStrides(n),g=s.zd.getBroadcastDims(t,o),b=s.zd.getBroadcastDims(n,o);if(g.length+b.length===0)for(let s=0;s<d.length;++s)d[s]=e(a[s%a.length],r[s%r.length]);else for(let y=0;y<d.length;++y){const t=s.Df.indexToLoc(y,c,l),n=t.slice(-h);g.forEach(e=>n[e]=0);const i=s.Df.locToIndex(n,h,f),o=t.slice(-p);b.forEach(e=>o[e]=0);const u=s.Df.locToIndex(o,p,m);d[y]=e(a[i],r[u])}return[d,o]}}const Uu=Wu((e,t)=>e<0?t*e:e);function Vu(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t;_u([a,r],"prelu");const s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,[o,c]=Uu(a.shape,r.shape,s,i,"float32");return n.makeTensorInfo(c,"float32",o)}const Gu={kernelName:s.jc,backendName:"cpu",kernelFunc:Vu},Hu=Du(s.rc,e=>Math.max(0,e)),qu={kernelName:s.rc,backendName:"cpu",kernelFunc:Hu},Ku=Du(s.sc,e=>Math.min(Math.max(0,e),6)),Xu={kernelName:s.sc,backendName:"cpu",kernelFunc:Ku};function Zu(e){return(t,n,a)=>{const r=s.Df.getTypedArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)r[s]=e(t[s],a);return r}}const Yu=Zu(e=>1/(1+Math.exp(-e))),Ju=Du(s.Gc,e=>1/(1+Math.exp(-e))),Qu={kernelName:s.Gc,backendName:"cpu",kernelFunc:Ju};function $u(e,t,n,a,r){if("linear"===n)return zu({inputs:{x:t},backend:e});if("relu"===n)return Hu({inputs:{x:t},backend:e});if("elu"===n)return Mu({inputs:{x:t},backend:e});if("relu6"===n)return Ku({inputs:{x:t},backend:e});if("prelu"===n)return Vu({inputs:{x:t,alpha:a},backend:e});if("leakyrelu"===n)return Pu({inputs:{x:t},backend:e,attrs:{alpha:r}});if("sigmoid"===n)return Ju({inputs:{x:t},backend:e});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function ed(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=n.makeTensorInfo(a.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",s),imag:n.makeTensorInfo(r.shape,"float32",i)},o}const td={kernelName:s.z,backendName:"cpu",kernelFunc:ed};function nd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return ed({inputs:{real:nd(e,t,"float32"),imag:nd(e,t,"float32")},backend:e})}const a=s.Df.makeZerosTypedArray(s.Df.sizeFromShape(t),n);return e.makeTensorInfo(t,n,a)}function ad(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const rd={kernelName:s.oc,backendName:"cpu",kernelFunc:ad};function sd(e,t,n,a){if("int32"===a){return[t,"int32",Int32Array.from(e)]}if("bool"===a){const a=s.Df.toTypedArray([0],n),[r,i]=Wu((e,t)=>e!==t?1:0)(t,[],e,a,"bool");return[i,"bool",r]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(a))}function id(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:i}=a;if("complex64"===i){if("complex64"===r.dtype)return zu({inputs:{x:r},backend:n});const e=nd(n,r.shape,r.dtype),t=id({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=ed({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===r.dtype){const e=ad({inputs:{input:r},backend:n}),t=id({inputs:{x:e},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(e),t}if(!s.Df.hasEncodingLoss(r.dtype,i)){const e=zu({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:i}}const o=n.data.get(r.dataId).values,[c,l,u]=sd(o,r.shape,r.dtype,i);return n.makeTensorInfo(c,l,u)}const od={kernelName:s.w,backendName:"cpu",kernelFunc:id};function cd(e,t,n,a){return null==n?n=>{let{inputs:r,backend:i}=n;const{a:o,b:c}=r,l=i;_u([o,c],e);const u=l.data.get(o.dataId).values,d=l.data.get(c.dataId).values,h="string"===o.dtype?s.zd.fromUint8ToStringArray(u):u,p="string"===o.dtype?s.zd.fromUint8ToStringArray(d):d,f=a||o.dtype,[m,g]=t(o.shape,c.shape,h,p,f);return l.makeTensorInfo(g,f,m)}:e=>{let{inputs:r,backend:s}=e;const{a:i,b:o}=r,c=s;if("complex64"===i.dtype||"complex64"===o.dtype){const e=id({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),t=c.data.get(e.dataId),a=t.complexTensorInfos.real,r=t.complexTensorInfos.imag,s=c.data.get(a.dataId).values,l=c.data.get(r.dataId).values,u=id({inputs:{x:o},backend:c,attrs:{dtype:"complex64"}}),d=c.data.get(u.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=c.data.get(h.dataId).values,m=c.data.get(p.dataId).values,[g,b,y]=n(i.shape,o.shape,s,l,f,m),v=c.makeTensorInfo(y,"float32",g),x=c.makeTensorInfo(y,"float32",b),w=ed({inputs:{real:v,imag:x},backend:c});return c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(v),c.disposeIntermediateTensorInfo(x),w}{const e=c.data.get(i.dataId).values,n=c.data.get(o.dataId).values,r=a||i.dtype,[s,l]=t(i.shape,o.shape,e,n,r);return c.makeTensorInfo(l,r,s)}}}function ld(e){return(t,n,a,r,i,o)=>{const c=s.zd.assertAndGetBroadcastShape(t,n),l=s.Df.sizeFromShape(c),u=c.length,d=s.Df.computeStrides(c),h=s.Df.getTypedArrayFromDType("float32",l),p=s.Df.getTypedArrayFromDType("float32",l),f=s.zd.getBroadcastDims(t,c),m=s.zd.getBroadcastDims(n,c),g=s.zd.mergeRealAndImagArrays(a,r),b=s.zd.mergeRealAndImagArrays(i,o),y=t.length,v=s.Df.computeStrides(t),x=n.length,w=s.Df.computeStrides(n);if(f.length+m.length===0)for(let s=0;s<h.length;s++){const t=s%g.length,n=s%b.length,a=e(g[2*t],g[2*t+1],b[2*n],b[2*n+1]);h[s]=a.real,p[s]=a.imag}else for(let k=0;k<h.length;k++){const t=s.Df.indexToLoc(k,u,d),n=t.slice(-y);f.forEach(e=>n[e]=0);const a=s.Df.locToIndex(n,y,v),r=t.slice(-x);m.forEach(e=>r[e]=0);const i=s.Df.locToIndex(r,x,w),o=e(g[2*a],g[2*a+1],b[2*i],b[2*i+1]);h[k]=o.real,p[k]=o.imag}return[h,p,c]}}const ud=Wu((e,t)=>e+t),dd=ld((e,t,n,a)=>({real:e+n,imag:t+a})),hd=cd(s.d,ud,dd),pd={kernelName:s.d,backendName:"cpu",kernelFunc:hd};function fd(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:i}=a,o=s.Df.sizeFromShape(r.shape),c=s.Df.inferFromImplicitShape(i,o),l=s.Df.sizeFromShape(c);s.Df.assert(o===l,()=>"The new shape (".concat(c,") has ").concat(l," elements and the old ")+"shape (".concat(r.shape,") has ").concat(o," elements. The new shape and old ")+"shape must have the same number of elements."),n.incRef(r.dataId);const u=n.data.get(r.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=c,t.shape=c}return{dataId:r.dataId,shape:c,dtype:r.dtype}}const md={kernelName:s.tc,backendName:"cpu",kernelFunc:fd};function gd(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:i}=t,{transposeA:o,transposeB:c}=a;_u([r,i],"matMul");const l=r.shape.length,u=i.shape.length,d=o?r.shape[l-2]:r.shape[l-1],h=c?i.shape[u-1]:i.shape[u-2],p=o?r.shape[l-1]:r.shape[l-2],f=c?i.shape[u-2]:i.shape[u-1],m=r.shape.slice(0,-2),g=i.shape.slice(0,-2),b=s.Df.sizeFromShape(m),y=s.Df.sizeFromShape(g),v=s.Ed.assertAndGetBroadcastShape(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([p,f]);s.Df.assert(d===h,()=>"Error in matMul: inner shapes (".concat(d,") and (")+"".concat(h,") of Tensors with shapes ").concat(r.shape," and ")+"".concat(i.shape," and transposeA=").concat(o)+" and transposeB=".concat(c," must match."));const x=c?[y,f,h]:[y,h,f],w=fd({inputs:{x:r},backend:n,attrs:{shape:o?[b,d,p]:[b,p,d]}}),k=fd({inputs:{x:i},backend:n,attrs:{shape:x}}),I=o?w.shape[1]:w.shape[2],S=o?w.shape[2]:w.shape[1],N=c?k.shape[1]:k.shape[2],T=Math.max(b,y),O=n.data.get(w.dataId).values,C=n.data.get(k.dataId).values,E=s.Df.computeStrides(w.shape),_=s.Df.computeStrides(k.shape),[A,R,D]=o?[E[0],1,E[1]]:[E[0],E[1],1],[F,M,j]=c?[1,_[1],_[0]]:[_[1],1,_[0]],z=S*N,L=Object(s.Gd)([T,S,N],w.dtype),P=L.values,B=n.blockSize;for(let s=0;s<T;s++)for(let e=0;e<S;e+=B)for(let t=0;t<N;t+=B)for(let n=0;n<I;n+=B){const a=Math.min(e+B,S),r=Math.min(t+B,N),i=Math.min(n+B,I);for(let o=e;o<a;o++)for(let e=t;e<r;e++){let t=0;for(let a=n;a<i;a++){const n=Math.min(s,b-1)*A,r=Math.min(s,y-1)*j;t+=O[n+o*R+a*D]*C[a*F+e*M+r]}P[s*z+(o*N+e)]+=t}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(k),n.makeTensorInfo(v,L.dtype,L.values)}const bd={kernelName:s.s,backendName:"cpu",kernelFunc:gd};const yd={kernelName:s.qd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=a;let h,p,f;const m=[];h=gd({inputs:{a:r,b:s},attrs:{transposeA:c,transposeB:l},backend:n}),i&&(p=hd({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),u&&(f=$u(n,h,u,o,d),m.push(h),h=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return h}};function vd(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const xd={kernelName:s.a,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;_u(t,"abs");let a=new Float32Array(s.Df.sizeFromShape(t.shape));return a=vd(n.data.get(t.dataId).values),n.makeOutput(a,t.shape,t.dtype)}},wd=Du(s.b,e=>Math.acos(e)),kd={kernelName:s.b,backendName:"cpu",kernelFunc:wd},Id=Du(s.c,e=>Math.acosh(e)),Sd={kernelName:s.c,backendName:"cpu",kernelFunc:Id};const Nd={kernelName:s.e,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;_u(t,"addN");const r=a.map(e=>n.data.get(e.dataId).values),i=Object(s.Gd)(a[0].shape,a[0].dtype),o=i.values;for(let s=0;s<a.length;s++){const e=r[s];for(let t=0;t<o.length;t++)o[t]+=e[t]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}};function Td(e,t,n,a,r){const i=t.length,o=s.Df.sizeFromShape(t),c=s.Df.computeStrides(t),l=s.Df.computeStrides(r),u=s.Df.getTypedArrayFromDType(n,s.Df.sizeFromShape(r));for(let d=0;d<o;++d){const t=s.Df.indexToLoc(d,i,c),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[a[e]];u[s.Df.locToIndex(n,i,l)]=e[d]}return u}function Od(e){const{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:s}=n;_u(r,"transpose");const i=r.shape.length,o=new Array(i);for(let l=0;l<o.length;l++)o[l]=r.shape[s[l]];const c=Td(a.data.get(r.dataId).values,r.shape,r.dtype,s,o);return{dataId:a.write(c,o,r.dtype),shape:o,dtype:r.dtype}}const Cd={kernelName:s.ld,backendName:"cpu",kernelFunc:Od};const Ed={kernelName:s.f,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:o}=a;_u(r,"all");const c=s.Df.parseAxisParam(i,r.shape);let l=c;const u=s.zd.getAxesPermutation(l,r.shape.length);let d=r;null!=u&&(d=Od({inputs:{x:r},backend:n,attrs:{perm:u}}),l=s.zd.getInnerMostAxes(l.length,r.shape.length)),s.zd.assertAxesAreInnerMostDims("all",l,d.shape.length);const[h,p]=s.zd.computeOutAndReduceShapes(d.shape,l),f=s.Df.sizeFromShape(p),m=s.Df.makeZerosTypedArray(s.Df.sizeFromShape(h),d.dtype),g=n.data.get(d.dataId).values;for(let s=0;s<m.length;++s){const e=s*f;let t=g[e];for(let n=0;n<f;++n){const a=g[e+n];t=t&&a}m[s]=t}null!=u&&n.disposeIntermediateTensorInfo(d);const b=n.makeTensorInfo(h,d.dtype,m);if(o){const e=fd({inputs:{x:b},backend:n,attrs:{shape:s.zd.expandShapeToKeepDim(h,c)}});return n.disposeIntermediateTensorInfo(b),e}return b}};const _d={kernelName:s.g,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:o}=a;_u(r,"any");const c=s.Df.parseAxisParam(i,r.shape);let l=c;const u=s.zd.getAxesPermutation(l,r.shape.length);let d=r;null!=u&&(d=Od({inputs:{x:r},backend:n,attrs:{perm:u}}),l=s.zd.getInnerMostAxes(l.length,r.shape.length)),s.zd.assertAxesAreInnerMostDims("any",l,d.shape.length);const[h,p]=s.zd.computeOutAndReduceShapes(d.shape,l),f=s.Df.sizeFromShape(p),m=s.Df.makeZerosTypedArray(s.Df.sizeFromShape(h),d.dtype),g=n.data.get(d.dataId).values;for(let s=0;s<m.length;++s){const e=s*f;let t=g[e];for(let n=0;n<f;++n){const a=g[e+n];t=t||a}m[s]=t}null!=u&&n.disposeIntermediateTensorInfo(d);const b=n.makeTensorInfo(h,d.dtype,m);if(o){const e=fd({inputs:{x:b},backend:n,attrs:{shape:s.zd.expandShapeToKeepDim(h,c)}});return n.disposeIntermediateTensorInfo(b),e}return b}};const Ad={kernelName:s.h,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i}=a;_u(r,"argMax");let o=s.Df.parseAxisParam(i,r.shape);const c=s.zd.getAxesPermutation(o,r.shape.length);let l=r;const u=[];null!=c&&(l=Od({inputs:{x:r},backend:n,attrs:{perm:c}}),u.push(l),o=s.zd.getInnerMostAxes(o.length,l.shape.length)),o=[o[0]],s.zd.assertAxesAreInnerMostDims("argMax",o,l.shape.length);const[d,h]=s.zd.computeOutAndReduceShapes(l.shape,o),p=s.Df.sizeFromShape(d),f=s.Df.makeZerosTypedArray(p,"int32"),m=s.Df.sizeFromShape(h),g=n.data.get(l.dataId).values;for(let s=0;s<f.length;++s){const e=s*m;let t=g[e],n=0;for(let a=0;a<m;++a){const r=g[e+a];r>t&&(t=r,n=a)}f[s]=n}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(d,"int32",f)}};const Rd={kernelName:s.i,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i}=a;_u(r,"argMin");let o=s.Df.parseAxisParam(i,r.shape);const c=s.zd.getAxesPermutation(o,r.shape.length);let l=r;const u=[];null!=c&&(l=Od({inputs:{x:r},backend:n,attrs:{perm:c}}),u.push(l),o=s.zd.getInnerMostAxes(o.length,l.shape.length)),o=[o[0]],s.zd.assertAxesAreInnerMostDims("argMin",o,l.shape.length);const[d,h]=s.zd.computeOutAndReduceShapes(l.shape,o),p=s.Df.sizeFromShape(d),f=s.Df.makeZerosTypedArray(p,"int32"),m=s.Df.sizeFromShape(h),g=n.data.get(l.dataId).values;for(let s=0;s<f.length;++s){const e=s*m;let t=g[e],n=0;for(let a=0;a<m;++a){const r=g[e+a];r<t&&(t=r,n=a)}f[s]=n}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(d,"int32",f)}},Dd=Du(s.j,e=>Math.asin(e)),Fd={kernelName:s.j,backendName:"cpu",kernelFunc:Dd},Md=Du(s.k,e=>Math.asinh(e)),jd={kernelName:s.k,backendName:"cpu",kernelFunc:Md},zd=Du(s.l,e=>Math.atan(e)),Ld={kernelName:s.l,backendName:"cpu",kernelFunc:zd},Pd=Wu((e,t)=>Math.atan2(e,t)),Bd=cd(s.m,Pd),Wd={kernelName:s.m,backendName:"cpu",kernelFunc:Bd},Ud=Du(s.n,e=>Math.atanh(e)),Vd={kernelName:s.n,backendName:"cpu",kernelFunc:Ud};function Gd(e,t,n,a,r,i){const o=r.strideHeight,c=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=Object(s.Gd)(r.outShape,n),b=g.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],v=r.outShape[2]*r.outShape[3],x=r.outShape[3];for(let s=0;s<r.batchSize;++s){const t=s*y,n=s*a[0];for(let s=0;s<r.inChannels;++s)for(let g=0;g<r.outHeight;++g){const y=g*o-p,w=Math.max(0,y),k=Math.min(r.inHeight,d+y),I=t+g*v;for(let t=0;t<r.outWidth;++t){const o=t*c-f,d=Math.max(0,o),p=Math.min(r.inWidth,h+o);let g=m,y=0,v=0;for(let t=w;t<k;t+=l){const r=n+t*a[1];for(let t=d;t<p;t+=u){const n=e[r+t*a[2]+s];"max"===i&&n>g?g=n:"avg"===i&&(y+=n,v++)}if(isNaN(g))break}b[I+t*x+s]="avg"===i?y/v:g}}}return g}function Hd(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=Object(s.Gd)(a.outShape,"int32"),c=a.strideHeight,l=a.strideWidth,u=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterHeight,p=a.effectiveFilterWidth,f=a.padInfo.top,m=a.padInfo.left,g=Object(s.Gd)(t,n,e);for(let s=0;s<a.batchSize;++s)for(let e=0;e<a.inChannels;++e)for(let t=0;t<a.outHeight;++t){const n=t*c-f;let b=n;for(;b<0;)b+=u;const y=Math.min(a.inHeight,h+n);for(let c=0;c<a.outWidth;++c){const h=c*l-m;let f=h;for(;f<0;)f+=d;const v=Math.min(a.inWidth,p+h);let x=Number.NEGATIVE_INFINITY,w=-1;for(let t=b;t<y;t+=u){const o=t-n;for(let n=f;n<v;n+=d){const c=n-h,l=g.get(s,t,n,e);l>x&&(x=l,w=r?i?((s*a.inHeight+t)*a.inWidth+n)*a.inChannels+e:(t*a.inWidth+n)*a.inChannels+e:o*p+c)}}o.set(w,s,t,c,e)}}return o}function qd(e,t,n,a,r,i){const o=r.strideDepth,c=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,d=r.dilationHeight,h=r.dilationWidth,p=r.effectiveFilterDepth,f=r.effectiveFilterHeight,m=r.effectiveFilterWidth,g=r.padInfo.front,b=r.padInfo.top,y=r.padInfo.left,v="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Object(s.Gd)(r.outShape,n),w=x.values,k=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],I=r.outShape[2]*r.outShape[3]*r.outShape[4],S=r.outShape[3]*r.outShape[4],N=r.outShape[4];for(let s=0;s<r.batchSize;++s){const t=s*k,n=s*a[0];for(let s=0;s<r.inChannels;++s)for(let x=0;x<r.outDepth;++x){const k=x*o-g;let T=k;for(;T<0;)T+=u;const O=Math.min(r.inDepth,p+k),C=t+x*I;for(let t=0;t<r.outHeight;++t){const o=t*c-b;let p=o;for(;p<0;)p+=d;const g=Math.min(r.inHeight,f+o),x=C+t*S;for(let t=0;t<r.outWidth;++t){const o=t*l-y;let c=o;for(;c<0;)c+=h;const f=Math.min(r.inWidth,m+o),b=x+t*N;let k=v,I=0,S=0;for(let t=T;t<O;t+=u){const r=n+t*a[1];for(let t=p;t<g;t+=d){const n=r+t*a[2];for(let t=c;t<f;t+=h){const r=e[n+t*a[3]+s];if("max"===i&&r>k?k=r:"avg"===i&&(I+=r,S++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}w[b+s]="avg"===i?I/S:k}}}}return x}const Kd={kernelName:s.o,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;_u(r,"avgPool");const{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=a;s.Df.assert(s.zd.eitherStridesOrDilationsAreOne(o,1),()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'"));const u=s.zd.computePool2DInfo(r.shape,i,o,1,c,l);let d;if(1===u.filterWidth&&1===u.filterHeight&&s.Df.arraysEqual(u.inShape,u.outShape))d=zu({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=s.Df.computeStrides(r.shape),a=Gd(e,r.shape,r.dtype,t,u,"avg");d=n.makeTensorInfo(u.outShape,r.dtype,a.values)}return d}};const Xd={kernelName:s.p,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:i,strides:o,pad:c,dimRoundingMode:l,dataFormat:u}=a;_u(r,"avgPool3d");const d=s.zd.computePool3DInfo(r.shape,i,o,1,c,l,u),h=qd(n.data.get(r.dataId).values,r.shape,r.dtype,s.Df.computeStrides(r.shape),d,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const Zd={kernelName:s.q,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=a;_u([r,i],"avgPool3DGrad");const d=s.zd.computePool3DInfo(i.shape,o,c,1,l,u),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,b=d.filterWidth,y=d.dilationDepth,v=d.dilationHeight,x=d.dilationWidth,w=d.effectiveFilterDepth,k=d.effectiveFilterHeight,I=d.effectiveFilterWidth,S=w-1-d.padInfo.front,N=I-1-d.padInfo.left,T=k-1-d.padInfo.top,O=Object(s.Gd)(i.shape,"float32"),C=1/(m*g*b),E=n.bufferSync(r);for(let s=0;s<d.batchSize;++s)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inDepth;++t)for(let n=0;n<d.inHeight;++n)for(let a=0;a<d.inWidth;++a){const r=t-S,i=n-T,o=a-N;let c=0;for(let t=0;t<w;t+=y){const n=(r+t)/h;if(!(n<0||n>=d.outDepth||Math.floor(n)!==n))for(let t=0;t<k;t+=v){const a=(i+t)/p;if(!(a<0||a>=d.outHeight||Math.floor(a)!==a))for(let t=0;t<I;t+=x){const r=(o+t)/f;if(r<0||r>=d.outWidth||Math.floor(r)!==r)continue;c+=E.get(s,n,a,r,e)}}}O.set(c*C,s,t,n,a,e)}return n.makeTensorInfo(O.shape,O.dtype,O.values)}};const Yd={kernelName:s.r,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,o=i;_u([r,i],"avgPoolGrad");const{filterSize:c,strides:l,pad:u}=a,d=s.zd.computePool2DInfo(o.shape,c,l,1,u),h=d.strideHeight,p=d.strideWidth,f=d.filterHeight,m=d.filterWidth,g=d.dilationHeight,b=d.dilationWidth,y=d.effectiveFilterHeight,v=d.effectiveFilterWidth,x=v-1-d.padInfo.left,w=y-1-d.padInfo.top,k=Object(s.Gd)(o.shape,"float32"),I=1/(f*m),S=n.data.get(r.dataId).values,N=Object(s.Gd)(r.shape,"float32",S);for(let s=0;s<d.batchSize;++s)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const a=t-w,r=n-x;let i=0;for(let t=0;t<y;t+=g){const n=(a+t)/h;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let t=0;t<v;t+=b){const a=(r+t)/p;if(a<0||a>=d.outWidth||Math.floor(a)!==a)continue;i+=N.get(s,n,a,e)}}k.set(i*I,s,t,n,e)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}};const Jd={kernelName:s.lb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,scale:i,offset:o,mean:c,variance:l}=t;s.Df.assert(c.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),s.Df.assert(null==o||c.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),s.Df.assert(null==i||c.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),_u([r,c,l,i,o],"batchNorm");let{varianceEpsilon:u}=a;null==u&&(u=.001);const d=n.data.get(r.dataId).values,h=n.data.get(c.dataId).values,p=n.data.get(l.dataId).values,f=i?n.data.get(i.dataId).values:new Float32Array([1]),m=o?n.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(d.length),b=m.length,y=f.length,v=p.length,x=h.length;let w=0,k=0,I=0,S=0;for(let s=0;s<d.length;++s)g[s]=m[w++]+(d[s]-h[k++])*f[I++]/Math.sqrt(p[S++]+u),w>=b&&(w=0),k>=x&&(k=0),I>=y&&(I=0),S>=v&&(S=0);return n.makeTensorInfo(r.shape,r.dtype,g)}};function Qd(e,t,n,a,r){const i=s.hf.isSliceContinous(a,t,n),o=s.Df.sizeFromShape(n),c=s.Df.computeStrides(a);if(i){const n=s.hf.computeFlatOffset(t,c);return"string"===r?e.slice(n,n+o):e.subarray(n,n+o)}const l="string"===r?s.zd.fromUint8ToStringArray(e):e,u=Object(s.Gd)(a,r,l),d=Object(s.Gd)(n,r);for(let s=0;s<d.size;++s){const e=d.indexToLoc(s),n=e.map((e,n)=>e+t[n]);d.set(u.get(...n),...e)}return"string"===r?s.zd.fromStringArrayToUint8(d.values):d.values}function $d(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:i,size:o}=a;_u(r,"slice");const[c,l]=s.hf.parseSliceParams(r,i,o);s.hf.assertParamsValid(r,c,l);const u=Qd(n.data.get(r.dataId).values,c,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,u)}const eh={kernelName:s.Kc,backendName:"cpu",kernelFunc:$d};const th={kernelName:s.t,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:i,crops:o}=a;_u([r],"batchToSpaceND");const c=i.reduce((e,t)=>e*t),l=s.zd.getReshaped(r.shape,i,c),u=s.zd.getPermuted(l.length,i.length),d=s.zd.getReshapedPermuted(r.shape,i,c),h=s.zd.getSliceBeginCoords(o,i.length),p=s.zd.getSliceSize(d,o,i.length),f=fd({inputs:{x:r},backend:n,attrs:{shape:l}}),m=Od({inputs:{x:f},backend:n,attrs:{perm:u}}),g=fd({inputs:{x:m},backend:n,attrs:{shape:d}}),b=$d({inputs:{x:g},backend:n,attrs:{begin:h,size:p}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),b}};function nh(e,t,n,a,r){const i=s.Df.sizeFromShape(a),o=s.Df.makeZerosTypedArray(r,n);for(let s=0;s<e.length;s++){const n=e[s];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(o[n]+=i>0?t[s]:1)}return o}function ah(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e.shape[0],i=e.shape[1],o=Object(s.Gd)([r,n],t.dtype);for(let s=0;s<r;s++)for(let r=0;r<i;r++){const i=e.get(s,r);if(i<0)throw new Error("Input x must be non-negative!");i>=n||(a?o.set(1,s,i):t.size>0?o.set(o.get(s,i)+t.get(s,r),s,i):o.set(o.get(s,i)+1,s,i))}return o}const rh={kernelName:s.u,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=nh(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,o)}};const sh={kernelName:s.v,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,c=s.zd.assertAndGetBroadcastShape(Array.from(i),Array.from(o));return n.makeTensorInfo([c.length],"int32",Int32Array.from(c))}},ih=Zu(e=>Math.ceil(e)),oh=Fu(s.x,ih),ch={kernelName:s.x,backendName:"cpu",kernelFunc:oh},lh=Du(s.y,(e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),uh={kernelName:s.y,backendName:"cpu",kernelFunc:lh},dh={kernelName:s.A,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,a=new Float32Array(s.Df.sizeFromShape(t.shape)),r=n.data.get(t.dataId),i=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,c=n.data.get(i.dataId).values,l=n.data.get(o.dataId).values;for(let s=0;s<c.length;s++){const e=c[s],t=l[s];a[s]=Math.hypot(e,t)}return n.makeOutput(a,t.shape,"float32")}};function hh(e,t,n,a){const r=s.Df.getArrayFromDType(n,s.Df.sizeFromShape(t));if(a&&"string"!==n){let t=0;e.forEach(e=>{const n=s.Df.sizeFromShape(e.shape);r.set(e.vals,t),t+=n})}else{let a=0;e.forEach(e=>{const i="string"===n?s.zd.fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const s=n*t[1]+a;for(let t=0;t<e.shape[1];++t)r[s+t]=i[o++]}a+=e.shape[1]})}return r}function ph(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const fh={kernelName:s.ub,backendName:"cpu",kernelFunc:ph};function mh(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,i=s.Df.parseAxisParam(r,t[0].shape)[0],o=t.map(e=>e.shape);s.zd.assertParamsConsistent(o,i);let c=s.zd.computeOutShape(t.map(e=>e.shape),i);if(0===s.Df.sizeFromShape(c))return n.makeTensorInfo(c,t[0].dtype,[]);const l=t.filter(e=>s.Df.sizeFromShape(e.shape)>0);if(1===l.length)return zu({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){const e=l.map(e=>ad({inputs:{input:e},backend:n})),t=l.map(e=>ph({inputs:{input:e},backend:n})),a=mh({inputs:e,backend:n,attrs:{axis:i}}),r=mh({inputs:t,backend:n,attrs:{axis:i}}),s=ed({inputs:{real:a,imag:r},backend:n});return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),t.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r),s}const u=l.map(e=>{const t=s.Df.sizeFromShape(e.shape.slice(i));return fd({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})}),d=u.map(e=>({vals:n.data.get(e.dataId).values,shape:e.shape}));c=s.zd.computeOutShape(u.map(e=>e.shape),1);const h=1===u[0].shape[0],p=hh(d,c,t[0].dtype,h),f=s.zd.computeOutShape(l.map(e=>e.shape),i),m=n.makeTensorInfo(f,t[0].dtype,p);return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),m}const gh={kernelName:s.B,backendName:"cpu",kernelFunc:mh};function bh(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:o,pad:c,dataFormat:l,dilations:u,dimRoundingMode:d}=a;_u([r,i],"conv2d");const h=s.zd.convertConv2DDataFormat(l),p=s.zd.computeConv2DInfo(r.shape,i.shape,o,u,c,d,!1,h),f=p.filterHeight,m=p.filterWidth,g=p.dilationHeight,b=p.dilationWidth,y=p.padInfo.left,v=p.padInfo.top,x="channelsLast"===p.dataFormat,w=new s.hd(p.outShape,r.dtype),k=s.Df.computeStrides(r.shape),I=s.Df.computeStrides(i.shape),S=k[0],N=x?k[1]:k[2],T=x?k[2]:1,O=x?1:k[1],C=w.strides[0],E=x?w.strides[1]:w.strides[2],_=x?w.strides[2]:1,A=x?1:w.strides[1],R=n.data.get(r.dataId).values,D=n.data.get(i.dataId).values,F=w.values;for(let s=0;s<p.batchSize;++s){const e=s*S,t=s*C;for(let n=0;n<p.outHeight;++n){const a=t+n*E,r=n*p.strideHeight-v;for(let t=0;t<f;++t){const n=r+t*g;if(n<0||n>=p.inHeight)continue;const s=t*I[0],i=e+n*N;for(let e=0;e<p.outWidth;++e){const t=a+e*_,n=e*p.strideWidth-y;for(let e=0;e<m;++e){const a=n+e*b;if(a<0||a>=p.inWidth)continue;const r=i+a*T;let o=s+e*I[1];for(let e=0;e<p.inChannels;++e){const n=R[r+e*O];for(let e=0;e<p.outChannels;++e)F[t+e*A]+=n*D[o+e];o+=p.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,F)}const yh={kernelName:s.C,backendName:"cpu",kernelFunc:bh};const vh={kernelName:s.D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:i}=t,{strides:o,pad:c,dataFormat:l,dimRoundingMode:u,filterShape:d}=a;_u([r,i],"conv2dBackpropFilter");const h=s.zd.convertConv2DDataFormat(l),p=s.zd.computeConv2DInfo(r.shape,d,o,1,c,u,!1,h),{strideHeight:f,strideWidth:m,filterHeight:g,filterWidth:b}=p,y="channelsLast"===p.dataFormat,v=new s.hd(p.filterShape,"float32"),x=p.padInfo.left,w=p.padInfo.top,k=n.data.get(r.dataId).values,I=n.data.get(i.dataId).values,S=new s.hd(r.shape,r.dtype,k),N=new s.hd(i.shape,i.dtype,I);for(let s=0;s<g;++s){const e=Math.max(0,Math.ceil((w-s)/f)),t=Math.min(p.outHeight,(p.inHeight+w-s)/f);for(let n=0;n<b;++n){const a=Math.max(0,Math.ceil((x-n)/m)),r=Math.min(p.outWidth,(p.inWidth+x-n)/m);for(let i=0;i<p.inChannels;++i)for(let o=0;o<p.outChannels;++o){let c=0;for(let l=0;l<p.batchSize;++l)for(let u=e;u<t;++u){const e=s+u*f-w;for(let t=a;t<r;++t){const a=n+t*m-x;c+=y?S.get(l,e,a,i)*N.get(l,u,t,o):S.get(l,i,e,a)*N.get(l,o,u,t)}}v.set(c,s,n,i,o)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};const xh={kernelName:s.E,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:i}=t,{inputShape:o,strides:c,pad:l,dataFormat:u,dimRoundingMode:d}=a;_u([r,i],"conv2dBackpropInput");const h=s.Df.computeStrides(i.shape),p=s.Df.computeStrides(r.shape);let f=s.zd.convertConv2DDataFormat(u);const m=s.zd.computeConv2DInfo(o,i.shape,c,1,l,d,!1,f),g=new s.hd(m.inShape,"float32"),b=g.values,y=n.data.get(r.dataId).values,v=n.data.get(i.dataId).values,[x,w,k]=h,{batchSize:I,filterHeight:S,filterWidth:N,inChannels:T,inHeight:O,inWidth:C,outChannels:E,outHeight:_,outWidth:A,strideHeight:R,strideWidth:D}=m;f=m.dataFormat;const F=S-1-m.padInfo.top,M=N-1-m.padInfo.left,j="channelsLast"===f,z=g.strides[0],L=j?g.strides[1]:g.strides[2],P=j?g.strides[2]:1,B=j?1:g.strides[1],W=p[0],U=j?p[1]:p[2],V=j?p[2]:1,G=j?1:p[1];for(let s=0;s<I;++s)for(let e=0;e<T;++e)for(let t=0;t<O;++t){const n=t-F,a=Math.max(0,Math.ceil(n/R)),r=Math.min(_,(S+n)/R);for(let i=0;i<C;++i){const o=i-M,c=Math.max(0,Math.ceil(o/D)),l=Math.min(A,(N+o)/D);let u=0;for(let t=a;t<r;++t){const a=t*R-n;for(let n=c;n<l;++n){const r=W*s+U*t+V*n,i=x*(S-1-a)+w*(N-1-(n*D-o))+k*e;for(let e=0;e<E;++e){u+=y[r+G*e]*v[i+e]}}}b[z*s+L*t+P*i+B*e]=u}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const wh={kernelName:s.F,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:o,pad:c,dilations:l}=a;_u([r,i],"conv3d");const u=s.zd.computeConv3DInfo(r.shape,i.shape,o,l,c),{filterDepth:d,filterHeight:h,filterWidth:p,dilationDepth:f,dilationHeight:m,dilationWidth:g,padInfo:b}=u,y=b.front,v=b.left,x=b.top,w=new s.hd(u.outShape,r.dtype),k=n.data.get(r.dataId).values,I=n.data.get(i.dataId).values,S=w.values,N=s.Df.computeStrides(r.shape),T=s.Df.computeStrides(i.shape);for(let s=0;s<u.batchSize;++s){const e=s*N[0],t=s*w.strides[0];for(let n=0;n<u.outDepth;++n){const a=t+n*w.strides[1],r=n*u.strideDepth-y;for(let t=0;t<d;++t){const n=r+t*f;if(n<0||n>=u.inDepth)continue;const s=t*T[0],i=e+n*N[1];for(let e=0;e<u.outHeight;++e){const t=a+e*w.strides[2],n=e*u.strideHeight-x;for(let e=0;e<h;++e){const a=n+e*m;if(a<0||a>=u.inHeight)continue;const r=s+e*T[1],o=i+a*N[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,a=e*u.strideWidth-v;for(let e=0;e<p;++e){const t=a+e*g;if(t<0||t>=u.inWidth)continue;const s=r+e*T[2],i=o+t*u.inChannels;let c=s;for(let e=0;e<u.inChannels;++e){const t=k[i+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*I[c+e];c+=u.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const kh={kernelName:s.G,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:i}=t,{strides:o,pad:c,filterShape:l}=a;_u([r,i],"conv3dBackpropFilterV2");const u=s.Df.computeStrides(r.shape),d=s.Df.computeStrides(i.shape),h=s.zd.computeConv3DInfo(r.shape,l,o,1,c),p=h.strideDepth,f=h.strideHeight,m=h.strideWidth,g=h.filterDepth,b=h.filterHeight,y=h.filterWidth,v=new s.hd(h.filterShape,"float32"),x=v.values,[w,k,I,S]=v.strides,N=n.data.get(i.dataId).values,[T,O,C,E]=d,_=n.data.get(r.dataId).values,[A,R,D,F]=u,M=h.padInfo.front,j=h.padInfo.left,z=h.padInfo.top;for(let s=0;s<g;++s){const e=Math.max(0,Math.ceil((M-s)/p)),t=Math.min(h.outDepth,(h.inDepth+M-s)/p),n=s*w;for(let a=0;a<b;++a){const r=Math.max(0,Math.ceil((z-a)/f)),i=Math.min(h.outHeight,(h.inHeight+z-a)/f),o=a*k+n;for(let n=0;n<y;++n){const c=Math.max(0,Math.ceil((j-n)/m)),l=Math.min(h.outWidth,(h.inWidth+j-n)/m),u=n*I+o;for(let o=0;o<h.inChannels;++o){const d=o*S+u;for(let u=0;u<h.outChannels;++u){let g=0;for(let d=0;d<h.batchSize;++d){const h=d*A,b=d*T;for(let d=e;d<t;++d){const e=(s+d*p-M)*R+h,t=d*O+b;for(let s=r;s<i;++s){const r=(a+s*f-z)*D+e,i=s*C+t;for(let e=c;e<l;++e){const t=e*E+i;g+=_[(n+e*m-j)*F+r+o]*N[t+u]}}}}x[d+u]=g}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};const Ih={kernelName:s.H,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:i}=t,{pad:o,strides:c,inputShape:l}=a;_u([r],"conv3dBackpropInputV2");const u=s.Df.computeStrides(r.shape),d=s.Df.computeStrides(i.shape),h=s.zd.computeConv3DInfo(l,i.shape,c,1,o),p=new s.hd(h.inShape,"float32"),f=p.values,[m,g,b,y]=p.strides,v=n.data.get(r.dataId).values,[x,w,k,I]=u,S=n.data.get(i.dataId).values,[N,T,O,C]=d,{batchSize:E,filterDepth:_,filterHeight:A,filterWidth:R,inChannels:D,inDepth:F,inHeight:M,inWidth:j,outChannels:z,outDepth:L,outHeight:P,outWidth:B,strideDepth:W,strideHeight:U,strideWidth:V}=h,G=_-1-h.padInfo.front,H=A-1-h.padInfo.top,q=R-1-h.padInfo.left;for(let s=0;s<E;++s)for(let e=0;e<D;++e)for(let t=0;t<F;++t){const n=t-G,a=Math.max(0,Math.ceil(n/W)),r=Math.min(L,(_+n)/W);for(let i=0;i<M;++i){const o=i-H,c=Math.max(0,Math.ceil(o/U)),l=Math.min(P,(A+o)/U);for(let u=0;u<j;++u){const d=u-q,h=Math.max(0,Math.ceil(d/V)),p=Math.min(B,(R+d)/V);let E=0;for(let t=a;t<r;++t){const a=t*W-n;for(let n=c;n<l;++n){const r=n*U-o;for(let i=h;i<p;++i){const o=x*s+w*t+k*n+I*i,c=N*(_-1-a)+T*(A-1-r)+O*(R-1-(i*V-d))+C*e;for(let e=0;e<z;++e){E+=v[o+e]*S[c+e]}}}}f[m*s+g*t+b*i+y*u+e]=E}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}},Sh=Du(s.I,e=>Math.cos(e)),Nh={kernelName:s.I,backendName:"cpu",kernelFunc:Sh},Th=Du(s.J,e=>Math.cosh(e)),Oh={kernelName:s.J,backendName:"cpu",kernelFunc:Th};const Ch={kernelName:s.K,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:i,boxInd:o}=t,{cropSize:c,method:l,extrapolationValue:u}=a,[d,h,p,f]=r.shape,m=i.shape[0],[g,b]=c,y=Object(s.Gd)([m,g,b,f],"float32"),v=n.data.get(i.dataId).values,x=n.data.get(o.dataId).values,w=n.data.get(r.dataId).values,k=s.Df.computeStrides(r.shape),I=s.Df.computeStrides(y.shape);for(let s=0;s<m;s++){const e=4*s,t=v[e],n=v[e+1],a=v[e+2],r=v[e+3],i=x[s];if(i>=d)continue;const o=g>1?(a-t)*(h-1)/(g-1):0,c=b>1?(r-n)*(p-1)/(b-1):0;for(let d=0;d<g;d++){const e=g>1?t*(h-1)+d*o:.5*(t+a)*(h-1);if(e<0||e>h-1)for(let t=0;t<b;t++)for(let e=0;e<f;e++){const n=e+t*I[2]+d*I[1]+s*I[0];y.values[n]=u}else if("bilinear"===l){const t=Math.floor(e),a=Math.ceil(e),o=e-t;for(let e=0;e<b;e++){const l=b>1?n*(p-1)+e*c:.5*(n+r)*(p-1);if(l<0||l>p-1){for(let t=0;t<f;t++){const n=t+e*I[2]+d*I[1]+s*I[0];y.values[n]=u}continue}const h=Math.floor(l),m=Math.ceil(l),g=l-h;for(let n=0;n<f;n++){let r=n+h*k[2]+t*k[1]+i*k[0];const c=w[r];r=n+m*k[2]+t*k[1]+i*k[0];const l=w[r];r=n+h*k[2]+a*k[1]+i*k[0];const u=w[r];r=n+m*k[2]+a*k[1]+i*k[0];const p=c+(l-c)*g,f=u+(w[r]-u)*g;r=n+e*I[2]+d*I[1]+s*I[0],y.values[r]=p+(f-p)*o}}}else for(let t=0;t<b;++t){const a=b>1?n*(p-1)+t*c:.5*(n+r)*(p-1);if(a<0||a>p-1){for(let e=0;e<f;e++){const n=e+t*I[2]+d*I[1]+s*I[0];y.values[n]=u}continue}const o=Math.round(a),l=Math.round(e);for(let e=0;e<f;e++){const n=e+o*k[2]+l*k[1]+i*k[0],a=e+t*I[2]+d*I[1]+s*I[0];y.values[a]=w[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const Eh={kernelName:s.L,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,exclusive:o,reverse:c}=a;_u(r,"cumprod");const l=s.zd.getAxesPermutation([i],r.shape.length);let u=r;null!=l&&(u=Od({inputs:{x:r},backend:n,attrs:{perm:l}}));const d=s.zd.getInnerMostAxes(1,r.shape.length)[0];if(d!==u.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(u.shape.length-1," but got axis=").concat(d));const h=Object(s.Cf)(u.dtype,"int32"),p=s.Df.makeOnesTypedArray(s.Df.sizeFromShape(u.shape),h),f=n.data.get(u.dataId).values,m=u.shape[u.shape.length-1],g=c?(e,t)=>e+m-t-1:(e,t)=>e+t;for(let s=0;s<f.length;s+=m)for(let e=0;e<m;e++){const t=g(s,e);if(0===e)p[t]=o?1:f[t];else{const n=g(s,e-1);p[t]=o?f[n]*p[n]:f[t]*p[n]}}const b=n.makeTensorInfo(u.shape,h,p);if(null!=l){const e=Od({inputs:{x:b},backend:n,attrs:{perm:s.zd.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(u),e}return b}};const _h={kernelName:s.M,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,exclusive:o,reverse:c}=a;_u(r,"cumsum");const l=s.zd.getAxesPermutation([i],r.shape.length);let u=r;null!=l&&(u=Od({inputs:{x:r},backend:n,attrs:{perm:l}}));const d=s.zd.getInnerMostAxes(1,r.shape.length)[0];if(d!==u.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(u.shape.length-1," but got axis=").concat(d));const h=Object(s.Cf)(u.dtype,"int32"),p=s.Df.makeZerosTypedArray(s.Df.sizeFromShape(u.shape),h),f=n.data.get(u.dataId).values,m=u.shape[u.shape.length-1],g=c?(e,t)=>e+m-t-1:(e,t)=>e+t;for(let s=0;s<f.length;s+=m)for(let e=0;e<m;e++){const t=g(s,e);if(0===e)p[t]=o?0:f[t];else{const n=g(s,e-1);p[t]=o?f[n]+p[n]:f[t]+p[n]}}const b=n.makeTensorInfo(u.shape,h,p);if(null!=l){const e=Od({inputs:{x:b},backend:n,attrs:{perm:s.zd.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(u),e}return b}};const Ah={kernelName:s.O,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(1===r.shape.length){const e=nh(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,e)}if(2===r.shape.length){const e=ah(n.bufferSync(r),n.bufferSync(s),i,o);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};const Rh={kernelName:s.P,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:i,dataFormat:o}=a;s.Df.assert("NHWC"===o,()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(o));const c=r.shape[0],l=r.shape[1],u=r.shape[2],d=r.shape[3],h=l*i,p=u*i,f=d/(i*i),m=n.data.get(r.dataId).values,g=new Float32Array(c*h*p*f);let b=0;for(let s=0;s<c;++s)for(let e=0;e<h;++e){const t=Math.floor(e/i),n=e%i;for(let e=0;e<p;++e){const a=Math.floor(e/i),r=(n*i+e%i)*f;for(let e=0;e<f;++e){const n=e+r+d*(a+u*(t+l*s));g[b++]=m[n]}}}return n.makeTensorInfo([c,h,p,f],r.dtype,g)}};function Dh(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:o,pad:c,dilations:l,dimRoundingMode:u}=a;_u([r,i],"depthwiseConv2DNative");const d=s.Df.computeStrides(r.shape),h=s.Df.computeStrides(i.shape);let p=l;null==p&&(p=[1,1]),s.Df.assert(s.zd.eitherStridesOrDilationsAreOne(o,p),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(o," and dilations '").concat(p,"'"));const f=s.zd.computeConv2DInfo(r.shape,i.shape,o,p,c,u,!0),{filterHeight:m,filterWidth:g,dilationHeight:b,dilationWidth:y,padInfo:v}=f,x=v.left,w=v.top,k=f.outChannels/f.inChannels,I=new s.hd(f.outShape,r.dtype),S=n.data.get(r.dataId).values,N=n.data.get(i.dataId).values,T=I.values;for(let s=0;s<f.batchSize;++s){const e=s*d[0],t=s*I.strides[0];for(let n=0;n<f.outHeight;++n){const a=t+n*I.strides[1],r=n*f.strideHeight-w;for(let t=0;t<m;++t){const n=r+t*b;if(n<0||n>=f.inHeight)continue;const s=t*h[0],i=e+n*d[1];for(let e=0;e<f.outWidth;++e){const t=a+e*I.strides[2],n=e*f.strideWidth-x;for(let e=0;e<g;++e){const a=n+e*y;if(a<0||a>=f.inWidth)continue;const r=s+e*h[1],o=i+a*f.inChannels;let c=t,l=r;for(let e=0;e<f.inChannels;++e){const t=S[o+e];for(let e=0;e<k;++e)T[c+e]+=t*N[l+e];c+=k,l+=k}}}}}}return n.makeTensorInfo(I.shape,I.dtype,I.values)}const Fh={kernelName:s.Q,backendName:"cpu",kernelFunc:Dh};const Mh={kernelName:s.R,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:i}=t,{strides:o,dilations:c,pad:l,dimRoundingMode:u,filterShape:d}=a;_u([r,i],"depthwiseConv2dNativeBackpropFilter");const h=s.zd.computeConv2DInfo(r.shape,d,o,c,l,u,!0),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,b=new s.hd(h.filterShape,"float32"),y=h.padInfo.left,v=h.padInfo.top,x=h.outChannels/h.inChannels,w=n.data.get(r.dataId).values,k=new s.hd(r.shape,r.dtype,w),I=n.data.get(i.dataId).values,S=new s.hd(i.shape,i.dtype,I);for(let s=0;s<m;++s){const e=Math.max(0,Math.ceil((v-s)/p)),t=Math.min(h.outHeight,(h.inHeight+v-s)/p);for(let n=0;n<g;++n){const a=Math.max(0,Math.ceil((y-n)/f)),r=Math.min(h.outWidth,(h.inWidth+y-n)/f);for(let i=0;i<h.outChannels;++i){const o=Math.trunc(i/x),c=i%x;let l=0;for(let u=0;u<h.batchSize;++u)for(let c=e;c<t;++c){const e=s+c*p-v;for(let t=a;t<r;++t){const a=n+t*f-y;l+=k.get(u,e,a,o)*S.get(u,c,t,i)}}b.set(l,s,n,o,c)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const jh={kernelName:s.S,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:i}=t,{strides:o,dilations:c,pad:l,dimRoundingMode:u,inputShape:d}=a;_u([r,i],"depthwiseConv2DNativeBackpropInput");const h=s.Df.computeStrides(r.shape),p=s.Df.computeStrides(i.shape),f=s.zd.computeConv2DInfo(d,i.shape,o,c,l,u,!0),m=new s.hd(f.inShape,"float32"),g=m.values,[b,y,v]=m.strides,x=n.data.get(r.dataId).values,[w,k,I]=h,S=n.data.get(i.dataId).values,[N,T,O]=p,{batchSize:C,filterHeight:E,filterWidth:_,inChannels:A,inHeight:R,inWidth:D,outChannels:F,outHeight:M,outWidth:j,strideHeight:z,strideWidth:L}=f,P=E-1-f.padInfo.top,B=_-1-f.padInfo.left,W=F/A;for(let s=0;s<C;++s)for(let e=0;e<A;++e)for(let t=0;t<R;++t){const n=t-P,a=Math.max(0,Math.ceil(n/z)),r=Math.min(M,(E+n)/z);for(let i=0;i<D;++i){const o=i-B,c=Math.max(0,Math.ceil(o/L)),l=Math.min(j,(_+o)/L);let u=0;for(let t=a;t<r;++t){const a=t*z-n;for(let n=c;n<l;++n){const r=w*s+k*t+I*n,i=N*(E-1-a)+T*(_-1-(n*L-o))+O*e;for(let t=0;t<W;++t){u+=x[r+(e*W+t)]*S[i+t]}}}g[b*s+y*t+v*i+e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const zh={kernelName:s.T,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=s.Df.sizeFromShape(a.shape),i=n.data.get(a.dataId).values,o=Object(s.Gd)([r,r],a.dtype),c=o.values;for(let s=0;s<i.length;s++)c[s*r+s]=i[s];const l=[...a.shape,...a.shape];return n.makeTensorInfo(l,o.dtype,o.values)}},Lh={kernelName:s.U,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:i}=t,{strides:o,pad:c,dilations:l}=a,u=n,d=u.data.get(r.dataId).values,h=r.shape.length,p=u.data.get(i.dataId).values,f=i.shape.length,{batchSize:m,inHeight:g,inWidth:b,inChannels:y,outHeight:v,outWidth:x,padInfo:w,strideHeight:k,strideWidth:I,filterHeight:S,filterWidth:N,dilationHeight:T,dilationWidth:O,outShape:C}=s.zd.computeDilation2DInfo(r.shape,i.shape,o,c,"NHWC",l),E=s.Df.sizeFromShape(C),_=C.length,A=s.Df.getArrayFromDType(r.dtype,E);for(let R=0;R<m;++R)for(let e=0;e<v;++e){const t=e*k-w.top;for(let n=0;n<x;++n){const a=n*I-w.left;for(let o=0;o<y;++o){let c=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*T;if(n>=0&&n<g)for(let t=0;t<N;++t){const l=a+t*O;if(l>=0&&l<b){const a=s.Df.locToIndex([R,n,l,o],h,s.Df.computeStrides(r.shape)),u=s.Df.locToIndex([e,t,o],f,s.Df.computeStrides(i.shape)),m=d[a]+p[u];m>c&&(c=m)}}}A[s.Df.locToIndex([R,e,n,o],_,s.Df.computeStrides(C))]=c}}}return{dataId:u.write(s.Df.toTypedArray(A,r.dtype),C,r.dtype),shape:C,dtype:r.dtype}}},Ph={kernelName:s.V,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:i,dy:o}=t,{strides:c,pad:l,dilations:u}=a,d=n,h=s.Df.toNestedArray(r.shape,d.data.get(r.dataId).values),p=s.Df.toNestedArray(i.shape,d.data.get(i.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:b,outHeight:y,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:I,filterWidth:S,dilationHeight:N,dilationWidth:T,outShape:O}=s.zd.computeDilation2DInfo(r.shape,i.shape,c,l,"NHWC",u);s.Df.assert(o.rank===O.length,()=>"Error in ".concat(s.V,", dy ")+"must have the same rank as output ".concat(O.length,", but got ")+"".concat(o.rank));const C=s.Df.toNestedArray(O,d.data.get(o.dataId).values),E=s.Df.makeZerosNestedTypedArray(i.shape,i.dtype);for(let s=0;s<f;++s)for(let e=0;e<y;++e){const t=e*w-x.top;for(let n=0;n<v;++n){const a=n*k-x.left;for(let r=0;r<b;++r){let i=Number.MIN_SAFE_INTEGER,o=0,c=0;for(let e=0;e<I;++e){const n=t+e*N;if(n>=0&&n<m)for(let t=0;t<S;++t){const l=a+t*T;if(l>=0&&l<g){const a=h[s][n][l][r]+p[e][t][r];a>i&&(i=a,o=e,c=t)}}}E[o][c][r]+=C[s][e][n][r]}}}return{dataId:d.write(s.Df.toTypedArray(E,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},Bh={kernelName:s.W,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:i,dy:o}=t,{strides:c,pad:l,dilations:u}=a,d=n,h=s.Df.toNestedArray(r.shape,d.data.get(r.dataId).values),p=s.Df.toNestedArray(i.shape,d.data.get(i.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:b,outHeight:y,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:I,filterWidth:S,dilationHeight:N,dilationWidth:T,outShape:O}=s.zd.computeDilation2DInfo(r.shape,i.shape,c,l,"NHWC",u);s.Df.assert(o.rank===O.length,()=>"Error in ".concat(s.W,", dy ")+"must have the same rank as output ".concat(O.length,", but got ")+"".concat(o.rank));const C=s.Df.toNestedArray(O,d.data.get(o.dataId).values),E=s.Df.makeZerosNestedTypedArray(r.shape,r.dtype);for(let s=0;s<f;++s)for(let e=0;e<y;++e){const t=e*w-x.top;for(let n=0;n<v;++n){const a=n*k-x.left;for(let r=0;r<b;++r){let i=Number.MIN_SAFE_INTEGER,o=t<0?0:t,c=a<0?0:a;for(let e=0;e<I;++e){const n=t+e*N;if(n>=0&&n<m)for(let t=0;t<S;++t){const l=a+t*T;if(l>=0&&l<g){const a=h[s][n][l][r]+p[e][t][r];a>i&&(i=a,o=n,c=l)}}}E[s][o][c][r]+=C[s][e][n][r]}}}return{dataId:d.write(s.Df.toTypedArray(E,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Wh=Wu((e,t)=>e*t),Uh=ld((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n})),Vh=cd(s.Xb,Wh,Uh),Gh={kernelName:s.Xb,backendName:"cpu",kernelFunc:Vh};function Hh(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:o}=a;let c;_u(r,"sum"),c="bool"===r.dtype?id({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):zu({inputs:{x:r},backend:n});const l=c.shape.length,u=s.Df.parseAxisParam(i,c.shape),d=s.zd.getAxesPermutation(u,l);let h=u,p=c;null!=d&&(p=Od({inputs:{x:c},backend:n,attrs:{perm:d}}),h=s.zd.getInnerMostAxes(h.length,l)),s.zd.assertAxesAreInnerMostDims("sum",h,p.shape.length);const[f,m]=s.zd.computeOutAndReduceShapes(p.shape,h);let g=nd(n,f,s.zd.upcastType(p.dtype,"int32"));const b=s.Df.sizeFromShape(m),y=n.data.get(g.dataId).values,v=n.data.get(p.dataId).values;for(let s=0;s<y.length;++s){const e=s*b;let t=0;for(let n=0;n<b;++n)t+=v[e+n];y[s]=t}if(o){const e=g;g=fd({inputs:{x:g},backend:n,attrs:{shape:s.zd.expandShapeToKeepDim(g.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(c),null!=d&&n.disposeIntermediateTensorInfo(p),g}const qh={kernelName:s.dd,backendName:"cpu",kernelFunc:Hh};const Kh={kernelName:s.X,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,i=t,{allDims:o,summedDims:c,idDims:l}=s.zd.decodeEinsumEquation(r,i.length);s.zd.checkEinsumDimSizes(o.length,l,i);const{path:u,steps:d}=s.zd.getEinsumComputePath(c,l),h=d.length;let p=null,f=o.length;const m=[];for(let g=0;g<h;++g){for(const e of d[g]){const{permutationIndices:t,expandDims:a}=s.zd.getEinsumPermutation(f,l[e]);let r;s.zd.isIdentityPermutation(t)?r=i[e]:(r=Od({inputs:{x:i[e]},backend:n,attrs:{perm:t}}),m.push(r));const o=r.shape.slice();for(let e=0;e<a.length;++e)o.splice(a[e],0,1);s.Df.arraysEqual(r.shape,o)||(r=fd({inputs:{x:r},backend:n,attrs:{shape:o}}),m.push(r)),null===p?p=r:(p=Vh({inputs:{a:r,b:p},backend:n}),m.push(p))}g<h-1&&(u[g]>=0&&(p=Hh({inputs:{x:p},backend:n,attrs:{axis:u[g]-(o.length-f),keepDims:!1}}),m.push(p)),f--)}for(const s of m)s!==p&&n.disposeIntermediateTensorInfo(s);return p}};const Xh={kernelName:s.Z,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:a,y:r}=t;_u([a,r],"eluGrad");const i=new Float32Array(s.Df.sizeFromShape(r.shape)),o=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values;for(let s=0;s<o.length;++s){const e=o[s];i[s]=e>=1?c[s]:c[s]*(e+1)}return n.makeTensorInfo(r.shape,"float32",i)}},Zh=Wu((e,t)=>e===t?1:0),Yh=cd(s.ab,Zh,null,"bool"),Jh={kernelName:s.ab,backendName:"cpu",kernelFunc:Yh},Qh=s.zd.ERF_P,$h=s.zd.ERF_A1,ep=s.zd.ERF_A2,tp=s.zd.ERF_A3,np=s.zd.ERF_A4,ap=s.zd.ERF_A5,rp=Du(s.bb,e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+Qh*n);return t*(1-((((ap*a+np)*a+tp)*a+ep)*a+$h)*a*Math.exp(-n*n))}),sp={kernelName:s.bb,backendName:"cpu",kernelFunc:rp},ip=Zu(e=>Math.exp(e)),op=Fu(s.cb,ip,"float32"),cp={kernelName:s.cb,backendName:"cpu",kernelFunc:op};function lp(e){const{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:i}=a,o=r.shape.length,c=r.shape.slice();let l=i;return i<0&&(s.Df.assert(-(o+1)<=i,()=>"Axis must be in the interval [".concat(-(o+1),", ").concat(o,"]")),l=o+i+1),c.splice(l,0,1),fd({inputs:{x:r},backend:n,attrs:{shape:c}})}const up={kernelName:s.db,backendName:"cpu",kernelFunc:lp},dp=Zu(e=>Math.expm1(e)),hp=Fu(s.eb,dp),pp={kernelName:s.eb,backendName:"cpu",kernelFunc:hp},fp=Wu((e,t)=>e/t),mp=cd(s.pc,fp),gp={kernelName:s.pc,backendName:"cpu",kernelFunc:mp},bp=Wu((e,t)=>e-t),yp=ld((e,t,n,a)=>({real:e-n,imag:t-a})),vp=cd(s.cd,bp,yp),xp={kernelName:s.cd,backendName:"cpu",kernelFunc:vp};function wp(e,t,n){const a=e.shape,r=a[0],i=a[1],o=n.data.get(e.dataId),c=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,u=[r,i],d=s.Df.sizeFromShape(u),h=s.Df.getTypedArrayFromDType("float32",d),p=s.Df.getTypedArrayFromDType("float32",d);for(let b=0;b<r;b++){const e=$d({inputs:{x:c},backend:n,attrs:{begin:[b,0],size:[1,i]}}),a=$d({inputs:{x:l},backend:n,attrs:{begin:[b,0],size:[1,i]}}),r=ed({inputs:{real:e,imag:a},backend:n}),{real:o,imag:u}=kp(r,t,n),d=s.zd.mergeRealAndImagArrays(o,u);for(let t=0;t<i;t++){const e=s.zd.getComplexWithIndex(d,t);h[b*i+t]=e.real,p[b*i+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r)}const f=n.makeTensorInfo(u,"float32",h),m=n.makeTensorInfo(u,"float32",p),g=ed({inputs:{real:f,imag:m},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}function kp(e,t,n){const a=s.Df.sizeFromShape(e.shape),r=n.data.get(e.dataId),i=n.data.get(r.complexTensorInfos.real.dataId).values,o=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0===((c=a)&c-1)){const r=function e(t,n,a,r,i){if(1===a)return{real:t,imag:n};const o=s.zd.mergeRealAndImagArrays(t,n),c=a/2,l=s.zd.complexWithEvenIndex(o),u=l.real,d=l.imag,h=[u.length],p=i.makeTensorInfo(h,"float32",u),f=i.makeTensorInfo(h,"float32",d),m=ed({inputs:{real:p,imag:f},backend:i}),g=s.zd.complexWithOddIndex(o),b=g.real,y=g.imag,v=[b.length],x=i.makeTensorInfo(v,"float32",b),w=i.makeTensorInfo(v,"float32",y),k=ed({inputs:{real:x,imag:w},backend:i}),I=e(u,d,c,r,i),S=I.real,N=I.imag,T=[S.length],O=i.makeTensorInfo(T,"float32",S),C=i.makeTensorInfo(T,"float32",N),E=ed({inputs:{real:O,imag:C},backend:i}),_=e(b,y,c,r,i),A=_.real,R=_.imag,D=[A.length],F=i.makeTensorInfo(D,"float32",A),M=i.makeTensorInfo(D,"float32",R),j=ed({inputs:{real:F,imag:M},backend:i}),z=s.zd.exponents(a,r),L=[z.real.length],P=i.makeTensorInfo(L,"float32",z.real),B=i.makeTensorInfo(L,"float32",z.imag),W=ed({inputs:{real:P,imag:B},backend:i}),U=Vh({inputs:{a:W,b:j},backend:i}),V=hd({inputs:{a:E,b:U},backend:i}),G=vp({inputs:{a:E,b:U},backend:i}),H=ad({inputs:{input:V},backend:i}),q=ad({inputs:{input:G},backend:i}),K=ph({inputs:{input:V},backend:i}),X=ph({inputs:{input:G},backend:i}),Z=mh({inputs:[H,q],backend:i,attrs:{axis:0}}),Y=mh({inputs:[K,X],backend:i,attrs:{axis:0}}),J=i.data.get(Z.dataId).values,Q=i.data.get(Y.dataId).values;return i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(m),i.disposeIntermediateTensorInfo(x),i.disposeIntermediateTensorInfo(w),i.disposeIntermediateTensorInfo(k),i.disposeIntermediateTensorInfo(O),i.disposeIntermediateTensorInfo(C),i.disposeIntermediateTensorInfo(E),i.disposeIntermediateTensorInfo(F),i.disposeIntermediateTensorInfo(M),i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(P),i.disposeIntermediateTensorInfo(B),i.disposeIntermediateTensorInfo(W),i.disposeIntermediateTensorInfo(U),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo(G),i.disposeIntermediateTensorInfo(H),i.disposeIntermediateTensorInfo(K),i.disposeIntermediateTensorInfo(q),i.disposeIntermediateTensorInfo(X),i.disposeIntermediateTensorInfo(Z),i.disposeIntermediateTensorInfo(Y),{real:J,imag:Q}}(i,o,a,t,n),c=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(c,"float32",r.real),t=n.makeTensorInfo(c,"float32",r.imag),i=n.makeTensorInfo([],"float32",s.Df.createScalarValue(a,"float32")),o=zu({inputs:{x:i},backend:n}),l=gp.kernelFunc({inputs:{a:e,b:i},backend:n}),u=gp.kernelFunc({inputs:{a:t,b:o},backend:n}),d=n.data.get(l.dataId).values,h=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:d,imag:h}}return r}{const e=function(e,t,n){const a=new Float32Array(2*t);for(let r=0;r<t;r++){let i=0,o=0;for(let a=0;a<t;a++){const c=s.zd.exponent(r*a,t,n),l=s.zd.getComplexWithIndex(e,a);i+=l.real*c.real-l.imag*c.imag,o+=l.real*c.imag+l.imag*c.real}n&&(i/=t,o/=t),s.zd.assignToTypedArray(a,i,o,r)}return a}(s.zd.mergeRealAndImagArrays(i,o),a,t);return s.zd.splitRealAndImagArrays(e)}var c}const Ip={kernelName:s.fb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=s.Df.sizeFromShape(a.shape),i=a.shape[a.shape.length-1],o=fd({inputs:{x:a},backend:n,attrs:{shape:[r/i,i]}}),c=wp(o,!1,n),l=fd({inputs:{x:c},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),l}};function Sp(e){const{backend:t,attrs:n}=e,{shape:a,value:r,dtype:i}=n,o=i||s.Df.inferDtype(r),c=s.Df.getArrayFromDType(o,s.Df.sizeFromShape(a));return function(e,t,n){e.fill(t)}(c,r),t.makeTensorInfo(a,o,c)}const Np={kernelName:s.gb,backendName:"cpu",kernelFunc:Sp};const Tp={kernelName:s.hb,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,i=a,o=s.Df.getTypedArrayFromDType(r.dtype,s.Df.sizeFromShape(r.shape)),[c,l,u,d]=r.shape,h=i.data.get(r.dataId).values;for(let s=0;s<c;s++){const e=s*u*l*d;for(let t=0;t<l;t++){const n=t*(u*d);for(let t=0;t<u;t++){const a=t*d;for(let r=0;r<d;r++){const s=Math.round(u-t-1),i=e+n+a+r;let c=h[i];if(s>=0&&s<u){c=h[e+n+s*d+r]}o[i]=c}}}}return{dataId:i.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Op=Zu(e=>Math.floor(e)),Cp=Fu(s.ib,Op),Ep={kernelName:s.ib,backendName:"cpu",kernelFunc:Cp},_p=Wu((e,t)=>Math.floor(e/t)),Ap=cd(s.jb,_p,null,"int32"),Rp={kernelName:s.jb,backendName:"cpu",kernelFunc:Ap};const Dp={kernelName:s.mb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a;let m=bh({inputs:{x:r,filter:s},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(i){const e=m;if("NCHW"===u&&1===i.shape.length&&1!==i.shape[0]){const e=fd({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=hd({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=hd({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===u&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=fd({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=$u(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=$u(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};const Fp={kernelName:s.nb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a;let m=Dh({inputs:{x:r,filter:s},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(i){const e=m;m=hd({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=$u(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function Mp(e,t,n,a,r,i,o,c,l){const u=Object(s.Gd)([a,i],n);for(let s=0;s<a;s++){const n=[];let a=0;for(let t=0;t<r;t++){const i=e[s*r+t];a+=i*o[t],n.push(i)}if(a<0||a>=l/i)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(c));for(let e=0;e<i;e++)u.values[s*i+e]=t.get(...t.indexToLoc(a*i+e))}return u}const jp={kernelName:s.ob,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,i=s.Df.sizeFromShape(a.shape),o=r.shape,c=o[o.length-1],[l,u,d,h]=s.zd.prepareAndValidate(a,r);if(0===u)return n.makeTensorInfo(l,a.dtype,[]);const p=Mp(n.data.get(r.dataId).values,n.bufferSync(a),a.dtype,u,c,d,h,a.shape,i);return n.makeTensorInfo(l,a.dtype,p.values)}};function zp(e,t,n){const a=Object(s.Gd)(n,e.dtype);for(let r=0;r<a.size;++r){const n=a.indexToLoc(r).slice(),s=n[0],i=n[2],o=t.locToIndex([s,i]);n[2]=t.values[o];const c=e.locToIndex(n);0<=c&&c<e.values.length&&(a.values[r]=e.values[c])}return a}const Lp={kernelName:s.pb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:i}=t,{axis:o,batchDims:c}=a;_u([r,i],"gatherV2");const l=s.Df.parseAxisParam(o,r.shape)[0],u=n.data.get(i.dataId).values,d=r.shape[l];for(let x=0;x<u.length;++x){const e=u[x];s.Df.assert(e<=d-1&&e>=0,()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(d-1,"]"))}let h=c;null==c&&(h=0);const p=s.Df.sizeFromShape(i.shape),f=s.zd.segment_util.collectGatherOpShapeInfo(r,i,l,h),m=fd({inputs:{x:r},backend:n,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),g=fd({inputs:{x:i},backend:n,attrs:{shape:[f.batchSize,p/f.batchSize]}}),b=[f.batchSize,f.outerSize,p/f.batchSize,f.sliceSize],y=n.bufferSync(g),v=zp(n.bufferSync(m),y,b);return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(f.outputShape,v.dtype,v.values)}},Pp=Wu((e,t)=>e>t?1:0),Bp=cd(s.qb,Pp,null,"bool"),Wp={kernelName:s.qb,backendName:"cpu",kernelFunc:Bp},Up=Wu((e,t)=>e>=t?1:0),Vp=cd(s.rb,Up,null,"bool"),Gp={kernelName:s.rb,backendName:"cpu",kernelFunc:Vp};const Hp={kernelName:s.sb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=s.Df.sizeFromShape(a.shape),i=a.shape[a.shape.length-1],o=fd({inputs:{x:a},backend:n,attrs:{shape:[r/i,i]}}),c=wp(o,!0,n),l=fd({inputs:{x:c},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),l}},qp=Du(s.vb,e=>Number.isFinite(e)?1:0,"bool"),Kp={kernelName:s.vb,backendName:"cpu",kernelFunc:qp},Xp=Du(s.wb,e=>Math.abs(e)===1/0?1:0,"bool"),Zp={kernelName:s.wb,backendName:"cpu",kernelFunc:Xp},Yp=Du(s.xb,e=>Number.isNaN(e)?1:0,"bool"),Jp={kernelName:s.xb,backendName:"cpu",kernelFunc:Yp},Qp=Wu((e,t)=>e<t?1:0),$p=cd(s.Cb,Qp,null,"bool"),ef={kernelName:s.Cb,backendName:"cpu",kernelFunc:$p},tf=Wu((e,t)=>e<=t?1:0),nf=cd(s.Db,tf,null,"bool"),af={kernelName:s.Db,backendName:"cpu",kernelFunc:nf};function rf(e,t,n){const a=(t-e)/(n-1),r=s.Df.makeZerosTypedArray(n,"float32");r[0]=e;for(let s=1;s<r.length;s++)r[s]=r[s-1]+a;return r}const sf={kernelName:s.Eb,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=rf(a,r,s);return t.makeTensorInfo([i.length],"float32",i)}},of=Zu(e=>Math.log(e)),cf=Fu(s.Fb,of),lf={kernelName:s.Fb,backendName:"cpu",kernelFunc:cf},uf=Du(s.Gb,e=>Math.log1p(e)),df={kernelName:s.Gb,backendName:"cpu",kernelFunc:uf},hf=Wu((e,t)=>e&&t),pf=cd(s.Hb,hf,null,"bool"),ff={kernelName:s.Hb,backendName:"cpu",kernelFunc:pf},mf=Du(s.Ib,e=>e?0:1,"bool"),gf={kernelName:s.Ib,backendName:"cpu",kernelFunc:mf},bf=Wu((e,t)=>e||t),yf=cd(s.Jb,bf,null,"bool"),vf={kernelName:s.Jb,backendName:"cpu",kernelFunc:yf};const xf={kernelName:s.zb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:i,bias:o,alpha:c,beta:l}=a;_u(r,"LRN");const u=r.shape[3],d=u-1,h=n.data.get(r.dataId).values,p=s.Df.sizeFromShape(r.shape),f=new Float32Array(p);function m(e){const t=e%u;let n=e-t+Math.max(0,t-i);const a=e-t+Math.min(t+i,d);let r=0;for(;n<=a;n++){const e=h[n];r+=e*e}return r}for(let s=0;s<p;s++){const e=m(s),t=h[s]*Math.pow(o+c*e,-l);f[s]=t}return n.makeTensorInfo(r.shape,r.dtype,f)}};const wf={kernelName:s.Ab,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,y:i,dy:o}=t,{depthRadius:c,bias:l,alpha:u,beta:d}=a;_u(o,"LRNGrad");const h=s.Df.sizeFromShape(o.shape),p=o.shape[3],f=n.data.get(o.dataId).values,m=n.data.get(r.dataId).values,g=n.data.get(i.dataId).values,b=new Float32Array(h),y=h;for(let s=0;s<y;s++){const e=s%p,t=s-e+Math.max(0,e-c),n=s-e+Math.min(p,e+c+1);let a=0;for(let r=t;r<n;r++)a+=Math.pow(m[r],2);a=u*a+l;for(let r=t;r<n;r++){let e=-2*u*d*m[r]*g[s]/a;s===r&&(e+=Math.pow(a,-d)),e*=f[s],b[r]+=e}}return n.makeTensorInfo(o.shape,r.dtype,b)}};function kf(e,t,n,a){const r=s.Df.getTypedArrayFromDType(a,s.Df.sizeFromShape(n));for(let s=0;s<r.length;++s){const n=s*t;let a=e[n];for(let r=0;r<t;++r){const t=e[n+r];(Number.isNaN(t)||t>a)&&(a=t)}r[s]=a}return r}function If(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:i,keepDims:o}=a,c=n;let l=r.shape;const u=l.length,d=s.Df.parseAxisParam(i,l);let h=d;const p=s.zd.getAxesPermutation(h,u);let f=c.data.get(r.dataId).values;if(null!=p){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[p[t]];f=Td(f,l,r.dtype,p,e),h=s.zd.getInnerMostAxes(h.length,u),l=e}_u(r,"max"),s.zd.assertAxesAreInnerMostDims("max",h,u);const[m,g]=s.zd.computeOutAndReduceShapes(l,h),b=kf(f,s.Df.sizeFromShape(g),m,r.dtype),y=c.write(b,m,r.dtype);let v=m;if(o){v=s.zd.expandShapeToKeepDim(m,d)}return{dataId:y,shape:v,dtype:r.dtype}}const Sf={kernelName:s.Kb,backendName:"cpu",kernelFunc:If},Nf=Wu((e,t)=>Math.max(e,t)),Tf=cd(s.Qb,Nf),Of={kernelName:s.Qb,backendName:"cpu",kernelFunc:Tf};const Cf={kernelName:s.Lb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;_u(r,"maxPool");const{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=a;s.Df.assert(s.zd.eitherStridesOrDilationsAreOne(o,1),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'"));const u=s.zd.computePool2DInfo(r.shape,i,o,1,c,l);let d;if(1===u.filterWidth&&1===u.filterHeight&&s.Df.arraysEqual(u.inShape,u.outShape))d=zu({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=s.Df.computeStrides(r.shape),a=Gd(e,r.shape,r.dtype,t,u,"max");d=n.makeTensorInfo(u.outShape,r.dtype,a.values)}return d}};const Ef={kernelName:s.Mb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:i,strides:o,pad:c,dimRoundingMode:l,dataFormat:u}=a;_u(r,"maxPool3d");const d=s.zd.computePool3DInfo(r.shape,i,o,1,c,l,u),h=qd(n.data.get(r.dataId).values,r.shape,r.dtype,s.Df.computeStrides(r.shape),d,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const _f={kernelName:s.Nb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=a;_u([r,i],"maxPool3DGrad");const d=s.zd.computePool3DInfo(i.shape,o,c,1,l,u),h=function(e,t){const n=Object(s.Gd)(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,c=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.front,f=t.padInfo.top,m=t.padInfo.left;for(let s=0;s<t.batchSize;++s)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){const y=b*a-p;let v=y;for(;v<0;)v+=o;const x=Math.min(t.inDepth,u+y);for(let a=0;a<t.outHeight;++a){const u=a*r-f;let p=u;for(;p<0;)p+=c;const w=Math.min(t.inHeight,d+u);for(let r=0;r<t.outWidth;++r){const f=r*i-m;let k=f;for(;k<0;)k+=l;const I=Math.min(t.inWidth,h+f);let S=Number.NEGATIVE_INFINITY,N=-1;for(let t=v;t<x;t+=o){const n=t-y;for(let a=p;a<w;a+=c){const r=a-u;for(let i=k;i<I;i+=l){const o=i-f,c=e.get(s,t,a,i,g);c>=S&&(S=c,N=n*d*h+r*d+o)}}}n.set(N,s,b,a,r,g)}}}return n}(n.bufferSync(i),d),p=d.strideDepth,f=d.strideHeight,m=d.strideWidth,g=d.dilationDepth,b=d.dilationHeight,y=d.dilationWidth,v=d.effectiveFilterDepth,x=d.effectiveFilterHeight,w=d.effectiveFilterWidth,k=v-1-d.padInfo.front,I=w-1-d.padInfo.left,S=x-1-d.padInfo.top,N=Object(s.Gd)(i.shape,"float32"),T=n.bufferSync(r);for(let s=0;s<d.batchSize;++s)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inDepth;++t)for(let n=0;n<d.inHeight;++n)for(let a=0;a<d.inWidth;++a){const r=t-k,i=n-S,o=a-I;let c=0;for(let t=0;t<v;t+=g){const n=(r+t)/p;if(!(n<0||n>=d.outDepth||Math.floor(n)!==n))for(let a=0;a<x;a+=b){const r=(i+a)/f;if(!(r<0||r>=d.outHeight||Math.floor(r)!==r))for(let i=0;i<w;i+=y){const l=(o+i)/m;if(l<0||l>=d.outWidth||Math.floor(l)!==l)continue;const u=v*x*w-1-h.get(s,n,r,l,e)===t*x*w+a*w+i?1:0;if(0===u)continue;c+=T.get(s,n,r,l,e)*u}}}N.set(c,s,t,n,a,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};const Af={kernelName:s.Ob,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i,output:o}=t,c=i;_u([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:d,dimRoundingMode:h}=a,p=s.zd.computePool2DInfo(c.shape,l,u,1,d,h),f=n.data.get(c.dataId).values,m=Object(s.Gd)(p.outShape,c.dtype,Hd(f,c.shape,c.dtype,p).values),g=p.strideHeight,b=p.strideWidth,y=p.dilationHeight,v=p.dilationWidth,x=p.effectiveFilterHeight,w=p.effectiveFilterWidth,k=w-1-p.padInfo.left,I=x-1-p.padInfo.top,S=Object(s.Gd)(c.shape,"float32"),N=n.data.get(r.dataId).values,T=Object(s.Gd)(r.shape,"float32",N);for(let s=0;s<p.batchSize;++s)for(let e=0;e<p.inChannels;++e)for(let t=0;t<p.inHeight;++t)for(let n=0;n<p.inWidth;++n){const a=t-I,r=n-k;let i=0;for(let t=0;t<x;t+=y){const n=(a+t)/g;if(!(n<0||n>=p.outHeight||Math.floor(n)!==n))for(let a=0;a<w;a+=v){const o=(r+a)/b;if(o<0||o>=p.outWidth||Math.floor(o)!==o)continue;const c=x*w-1-m.get(s,n,o,e)===t*w+a?1:0;if(0===c)continue;i+=T.get(s,n,o,e)*c}}S.set(i,s,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const Rf={kernelName:s.Pb,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:i,strides:o,pad:c,includeBatchInIndex:l}=n,u=a;_u(r,"MaxPoolWithArgmax");const d=u.data.get(r.dataId).values,h=s.zd.computePool2DInfo(r.shape,i,o,[1,1],c),[p,f]=function(e,t,n,a,r){const i=Gd(e,0,n,s.Df.computeStrides(t),r,"max"),o=Hd(e,t,n,r,!0,a);return[i.values,o.values]}(d,r.shape,r.dtype,l,h),m=u.write(p,h.outShape,r.dtype),g=u.write(f,h.outShape,r.dtype);return[{dataId:m,shape:h.outShape,dtype:r.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}};const Df={kernelName:s.Rb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:o}=a,c=s.Df.parseAxisParam(i,r.shape),l=s.zd.computeOutAndReduceShapes(r.shape,c)[1],u=s.Df.sizeFromShape(l),d=[],h=n.makeTensorInfo([],"float32",new Float32Array([u]));d.push(h);const p=id({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});d.push(p);const f=mp({inputs:{a:p,b:h},backend:n});d.push(f);const m=Hh({inputs:{x:f},backend:n,attrs:{axis:i,keepDims:o}});return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),m}};const Ff={kernelName:s.Sb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:o}=a;_u(r,"min");const c=s.Df.parseAxisParam(i,r.shape);let l=c;const u=s.zd.getAxesPermutation(l,r.shape.length);let d=r;null!=u&&(d=Od({inputs:{x:r},backend:n,attrs:{perm:u}}),l=s.zd.getInnerMostAxes(l.length,r.shape.length)),s.zd.assertAxesAreInnerMostDims("min",l,d.shape.length);const[h,p]=s.zd.computeOutAndReduceShapes(d.shape,l),f=s.Df.sizeFromShape(p),m=s.Df.makeZerosTypedArray(s.Df.sizeFromShape(h),d.dtype),g=n.data.get(d.dataId).values;for(let s=0;s<m.length;++s){const e=s*f;let t=g[e];for(let n=0;n<f;++n){const a=g[e+n];(Number.isNaN(a)||a<t)&&(t=a)}m[s]=t}null!=u&&n.disposeIntermediateTensorInfo(d);const b=n.makeTensorInfo(h,d.dtype,m);if(o){const e=fd({inputs:{x:b},backend:n,attrs:{shape:s.zd.expandShapeToKeepDim(h,c)}});return n.disposeIntermediateTensorInfo(b),e}return b}},Mf=Wu((e,t)=>Math.min(e,t)),jf=cd(s.Tb,Mf),zf={kernelName:s.Tb,backendName:"cpu",kernelFunc:jf};const Lf={kernelName:s.Ub,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:i,mode:o}=a;_u(r,"mirrorPad");const c=i.map((e,t)=>e[0]+r.shape[t]+e[1]),l=i.map(e=>e[0]),u=i.map((e,t)=>e[0]+r.shape[t]),d="reflect"===o?0:1,h=n.data.get(r.dataId).values,p=r.shape.length,f=s.Df.computeStrides(r.shape),m=s.Df.sizeFromShape(c),g=c.length,b=s.Df.computeStrides(c),y=s.Df.getTypedArrayFromDType(r.dtype,m);for(let v=0;v<m;v++){let e=s.Df.indexToLoc(v,g,b);for(let n=0;n<g;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-d:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+d);e=e.map((e,t)=>e-l[t]);const t=s.Df.locToIndex(e,p,f);y[v]=h[t]}return{dataId:n.write(y,c,r.dtype),shape:c,dtype:r.dtype}}},Pf=Wu((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),Bf=cd(s.Vb,Pf),Wf={kernelName:s.Vb,backendName:"cpu",kernelFunc:Bf};function Uf(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:i}=a,o=r.shape.length;let c=i;if(-1===c&&(c=o-1),c!==o-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(o," and dim was ").concat(c));const l=s.Df.parseAxisParam([c],r.shape),u=If({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),d=s.zd.expandShapeToKeepDim(u.shape,l),h=fd({inputs:{x:u},backend:n,attrs:{shape:d}}),p=vp({inputs:{a:r,b:h},backend:n}),f=op({inputs:{x:p},backend:n}),m=Hh({inputs:{x:f},backend:n,attrs:{axis:l,keepDims:!1}}),g=fd({inputs:{x:m},backend:n,attrs:{shape:d}}),b=mp({inputs:{a:f,b:g},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),b}const Vf={kernelName:s.Lc,backendName:"cpu",kernelFunc:Uf};const Gf={kernelName:s.Wb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:i,seed:o,normalized:c}=a;_u(r,"multinomial");const l=c?r:Uf({inputs:{logits:r},backend:n,attrs:{dim:-1}}),u=l.shape[0],d=l.shape[1],h=n.data.get(l.dataId).values,p=[u,i],f=s.Df.makeZerosTypedArray(s.Df.sizeFromShape(p),"int32");for(let s=0;s<u;++s){const e=s*d,t=new Float32Array(d-1);t[0]=h[e];for(let r=1;r<t.length;++r)t[r]=t[r-1]+h[e+r];const n=Iu.alea(o.toString()),a=s*i;for(let r=0;r<i;++r){const e=n();f[a+r]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){f[a+r]=n;break}}}return c||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(p,"int32",f)}};function Hf(e,t,n){const a=s.Df.createScalarValue(-1,n);return Wh([],t,a,e,n)}const qf={kernelName:s.Yb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;_u(a,"neg");const r=n.data.get(a.dataId).values,[s,i]=Hf(r,a.shape,a.dtype);return n.makeTensorInfo(i,a.dtype,s)}},Kf=s.pe.nonMaxSuppressionV3Impl;const Xf={kernelName:s.Zb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=a;_u(r,"NonMaxSuppression");const l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:d}=Kf(l,u,i,o,c);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Zf=s.pe.nonMaxSuppressionV4Impl;const Yf={kernelName:s.ac,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,padToMaxOutputSize:l}=a;_u(r,"NonMaxSuppressionPadded");const u=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:h,validOutputs:p}=Zf(u,d,i,o,c,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},Jf=s.pe.nonMaxSuppressionV5Impl;const Qf={kernelName:s.bc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=a;_u(r,"NonMaxSuppressionWithScore");const u=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,h=i,p=o,f=c,m=l,{selectedIndices:g,selectedScores:b}=Jf(u,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},$f=Wu((e,t)=>e!==t?1:0),em=cd(s.cc,$f,null,"bool"),tm={kernelName:s.cc,backendName:"cpu",kernelFunc:em};const nm={kernelName:s.dc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:i,depth:o,onValue:c,offValue:l}=a;_u(r,"oneHot");const u=s.Df.sizeFromShape(r.shape),d=new Float32Array(u*o);d.fill(l);const h=n.data.get(r.dataId).values;for(let s=0;s<u;++s)h[s]>=0&&h[s]<o&&(d[s*o+h[s]]=c);return n.makeTensorInfo([...r.shape,o],i,d)}};function am(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=ad({inputs:{input:a},backend:n}),t=am({inputs:{x:e},backend:n}),r=ph({inputs:{input:a},backend:n}),s=am({inputs:{x:r},backend:n}),i=ed({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}return Sp({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const rm={kernelName:s.pd,backendName:"cpu",kernelFunc:am};const sm={kernelName:s.ec,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const t=ad({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),s=ph({inputs:{input:r},backend:a}),i=am({inputs:{x:s},backend:a}),o=ed({inputs:{real:n,imag:i},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(i),o}return Sp({backend:a,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function im(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return lp({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(e=>{s.Df.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),s.Df.assert(o===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const c=[],l=mh({inputs:t.map(e=>{const t=lp({inputs:{input:e},backend:n,attrs:{dim:r}});return c.push(t),t}),backend:n,attrs:{axis:r}});return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}const om={kernelName:s.gc,backendName:"cpu",kernelFunc:im};const cm={kernelName:s.hc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:i,constantValue:o}=a;_u(r,"pad");const c=i.map((e,t)=>e[0]+r.shape[t]+e[1]),l=i.map(e=>e[0]),u=n.data.get(r.dataId).values,d=s.Df.sizeFromShape(r.shape),h=r.shape.length,p=s.Df.computeStrides(r.shape),f=s.Df.sizeFromShape(c),m=c.length,g=s.Df.computeStrides(c),b=s.Df.getTypedArrayFromDType(r.dtype,f);0!==o&&b.fill(o);for(let y=0;y<d;y++){const e=s.Df.indexToLoc(y,h,p).map((e,t)=>e+l[t]);b[s.Df.locToIndex(e,m,g)]=u[y]}return{dataId:n.write(b,c,r.dtype),shape:c,dtype:r.dtype}}},lm=Wu((e,t)=>Math.pow(e,t)),um=cd(s.ic,lm),dm={kernelName:s.ic,backendName:"cpu",kernelFunc:um};function hm(e,t,n,a){const[r,i]=s.zd.computeOutAndReduceShapes(e,a),o=Object(s.Cf)(t,"int32"),c=s.Df.makeZerosTypedArray(s.Df.sizeFromShape(r),o),l=s.Df.sizeFromShape(i);for(let s=0;s<c.length;++s){const e=s*l;let t=1;for(let a=0;a<l;++a)t*=n[e+a];c[s]=t}return{outVals:c,outShape:r,outDtype:o}}const pm={kernelName:s.kc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:o}=a;_u(r,"prod");const c=r.shape.length,l=s.Df.parseAxisParam(i,r.shape),u=s.zd.getAxesPermutation(l,c);let d=l,h=r;const p=[];null!=u&&(h=Od({inputs:{x:r},backend:n,attrs:{perm:u}}),p.push(h),d=s.zd.getInnerMostAxes(d.length,c));const f=n.data.get(h.dataId).values,{outVals:m,outShape:g,outDtype:b}=hm(h.shape,h.dtype,f,d);let y=g;return o&&(y=s.zd.expandShapeToKeepDim(g,l)),p.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(y,b,m)}};function fm(e,t,n,a){const r=[];let s=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);!function(e,t){for(let n=0;n<e.length;++n){const a=e[n],r=n===e.length-1?t:e[n+1].length;if(0===a.length)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let e=1;e<a.length;++e)if(a[e-1]>a[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,a);let c=1;for(let l=0;l<t.length-1;++l){c*=t[l];const e=t[l+1];for(let t=1;t<c+1;++t)o[l].push(t*e)}for(let l=0;l<e.length;++l){let a=e[l],i=e[l]+1;for(let e=0;e<n.length;++e){const r=n[e],s=e+t.length-1;if(s>=0){const e=o[s],t=e[e.length-1]-r[a];for(let n=a;n<i;++n)o[s].push(r[n+1]+t)}a=r[a],i=r[i]}i!==a&&(r.push([a,i]),s+=i-a)}return{outSplits:o,valueSlices:r,numValues:s}}function mm(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function gm(e,t,n,a,r){const i=t.slice();i[0]=r;const o=s.Df.getArrayFromDType(n,s.Df.sizeFromShape(i)),c=e.length;return function(e,t,n,a,r,s){const i=mm(t,2)[1],o=mm(s,2)[1];let c=0;for(const l of n)for(let t=l[0];t<l[1];++t){for(let n=0;n<a;++n)r[c*o+n]=e[t*i+n];++c}}(e,t,a,0===c?0:c/t[0],o,i),[o,i]}function bm(e,t,n,a,r,i,o,c){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach((e,a)=>{if(e<0||e>=n){const r=s.Df.indexToLoc(a,t.length,s.Df.computeStrides(t)).join(",");throw new Error("indices[".concat(r,"] = ").concat(e," is not in [0, ").concat(n,")"))}})}(i,o,t[0][0]-1),0===a.length)throw new Error("params.rank must be nonzero");const l=a[0],{outSplits:u,valueSlices:d,numValues:h}=fm(i,o,e,l),p=function(e){const t=[];for(let n=0;n<e.length;++n){const a=e[n].length,r=s.Df.getArrayFromDType("int32",a);t.push(r),e[n].forEach((e,t)=>r[t]=e)}return t}(u),f=gm(n,a,r,d,h);return[p,f[0],f[1]]}const ym={kernelName:s.lc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,c=r.map(e=>n.data.get(e.dataId).values),l=r.map(e=>e.shape),u=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=bm(c,l,u,s.shape,s.dtype,d,i.shape),m=h.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};var vm=s.zd.RowPartitionType;class xm{constructor(e,t,n,a,r,i,o,c,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=a,this.valuesDType=r,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=c,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=s.zd.getRowPartitionTypesHelper(u),this.raggedRank=s.zd.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===vm.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===vm.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case vm.VALUE_ROWIDS:return xm.getMaxWidthValueRowID(t);case vm.ROW_SPLITS:return xm.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type ".concat(vm[this.getRowPartitionTypeByDimension(e-1)]))}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let a=0;a<t-1;++a){const t=e[a+1]-e[a];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,a=e[0],r=0;for(let s=1;s<t;++s){const t=e[s];t!==a&&(a=t,r=Math.max(s-n,r),n=s)}return Math.max(t-n,r)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return km(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;s.zd.validateDefaultValueShape(n,t);const a=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=s.zd.combineRaggedTensorToTensorShapes(this.raggedRank,a,t);r[0]<0&&(r[0]=e);for(let s=1;s<=this.raggedRank;++s)r[s]<0&&(r[s]=this.getMaxWidth(s));return r}calculateFirstParentOutputIndex(e,t,n){const a=Math.min(e,n),r=[];let i=0;for(let s=0;s<a;++s,i+=t)r.push(i);for(let s=a;s<e;++s)r.push(-1);return s.Df.assert(r.length===e,()=>"Final length of result must be equal to firstDimension."),r}calculateOutputIndexRowSplit(e,t,n,a){const r=e.length,s=[];for(let i=0;i<r-1;++i){const r=e[i+1]-e[i];let o=Math.min(a,r),c=t[i];-1===c&&(o=0);for(let e=0;e<o;++e)s.push(c),c+=n;for(let e=0;e<r-o;++e)s.push(-1)}if(r>0&&s.length!==e[r-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,a){const r=e.length,s=[];if(0===r)return[];let i=0,o=e[0];if(o>=t.length)throw new Error("Got currentValueRowId=".concat(o,", which is not less than ").concat(t.length));let c=t[o];s.push(c);for(let l=1;l<r;++l){const r=e[l];if(r===o)c>=0&&(++i,i<a?c+=n:c=-1);else{if(i=0,o=r,r>=t.length)throw new Error("Got nextValueRowId=".concat(r," which is not less than ").concat(t.length));c=t[r]}s.push(c)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,a){const r=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case vm.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,n,a);case vm.ROW_SPLITS:if(r.length-1>t.length)throw new Error("Row partition size is greater than output size: ".concat(r.length-1," > ").concat(t.length));return this.calculateOutputIndexRowSplit(r,t,n,a);default:throw new Error("Unsupported partition type: ".concat(vm[s]))}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case vm.FIRST_DIM_SIZE:return e[0];case vm.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case vm.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(vm[t]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*t[s+1];const a=km(t,!1),r=s.Df.getArrayFromDType(this.valuesDType,s.Df.sizeFromShape(a));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){s=this.calculateOutputIndex(e-1,s,n[e],t[e])}this.setOutput(this.raggedRank,s,r,a)}return[a,r]}setOutput(e,t,n,a){if(0===n.length)return;const r=this.values,i=n;let o=a.slice();o=o.slice(e+1);const c=s.Df.sizeFromShape(o),l=t.length;let u=this.defaultValue;if(u.length!==c&&1!==u.length){const e=this.defaultValueShape;Object(s.wf)(()=>{const t=Object(s.Ue)(u,e),n=Object(s.Dd)(t,o);u=n.dataSync()})}let d=0,h=0,p=0;for(let s=0;s<=l;++s){let e=s<l?t[s]:-1;if(e!==p){if(h<p){const e=r.subarray(d*c);wm(i.subarray(h*c),e,(p-h)*c)}if(s>=l){const t=n.length;e=Math.floor(t/c)}if(e>p)if(1===this.defaultValue.length)i.subarray(p*c,e*c).fill(this.defaultValue[0]),p=e;else for(;e>p;){wm(i.slice(p*c),u,c),++p}e<0?(d=s+1,h=p):(d=s,h=p,p=h+1)}else++p}}}function wm(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function km(e,t){const n=[];for(let a of e){if(a<0){if(!t)throw new Error("Dimension ".concat(a," must be >= 0"));if(a<-1)throw new Error("Dimension ".concat(a," must be >= -1"));a=-1}n.push(a)}return n}function Im(e,t,n,a,r,s,i,o,c,l){return new xm(e,t,n,a,r,s,i,o,c,l).compute()}const Sm={kernelName:s.mc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:c}=a,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,h=o.map(e=>n.data.get(e.dataId).values),p=o.map(e=>e.shape),[f,m]=Im(l,r.shape,u,s.shape,s.dtype,d,i.shape,h,p,c);return n.makeTensorInfo(f,s.dtype,m)}};function Nm(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return s.Df.makeZerosTypedArray(0,a);const r=Math.abs(Math.ceil((t-e)/n)),i=s.Df.makeZerosTypedArray(r,a);t<e&&1===n&&(n=-1),i[0]=e;for(let s=1;s<i.length;s++)i[s]=i[s-1]+n;return i}const Tm={kernelName:s.nc,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,dtype:s,step:i}=n,o=Nm(a,r,i,s);return t.makeTensorInfo([o.length],s,o)}},Om=Du(s.qc,e=>1/e),Cm={kernelName:s.qc,backendName:"cpu",kernelFunc:Om};const Em={kernelName:s.uc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:c}=a;_u(r,"resizeBilinear");const l=s.Df.computeStrides(r.shape),[u,d]=c,[h,p,f,m]=r.shape,g=n.data.get(r.dataId).values,b=new Float32Array(s.Df.sizeFromShape([h,u,d,m])),y=[i&&u>1?p-1:p,i&&d>1?f-1:f],v=[i&&u>1?u-1:u,i&&d>1?d-1:d];let x=0;const w=y[0]/v[0],k=y[1]/v[1];for(let s=0;s<h;s++)for(let e=0;e<u;e++){let t;t=o?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),a=t-n,r=Math.min(p-1,Math.ceil(t)),i=s*l[0]+n*l[1],c=s*l[0]+r*l[1];for(let e=0;e<d;e++){let t;t=o?k*(e+.5)-.5:k*e;const n=Math.max(0,Math.floor(t)),r=t-n,s=Math.min(f-1,Math.ceil(t)),u=i+n*l[2],d=c+n*l[2],h=i+s*l[2],p=c+s*l[2];for(let e=0;e<m;e++){const t=g[u+e],n=g[d+e],s=t+(g[h+e]-t)*r,i=s+(n+(g[p+e]-n)*r-s)*a;b[x++]=i}}}return n.makeTensorInfo([h,u,d,m],"float32",b)}};const _m={kernelName:s.vc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:i}=t,{alignCorners:o}=a;_u([i,r],"resizeBilinearGrad");const c=s.Df.computeStrides(r.shape),[l,u,d,h]=r.shape,[,p,f]=i.shape,m=new Float32Array(l*u*d*h),g=[o&&p>1?u-1:u,o&&f>1?d-1:d],b=[o&&p>1?p-1:p,o&&f>1?f-1:f],y=g[0]/b[0],v=g[1]/b[1],x=n.data.get(i.dataId).values;let w=0;for(let s=0;s<l;s++){const e=s*c[0];for(let t=0;t<p;t++){const n=t*y,a=Math.floor(n),r=Math.min(Math.ceil(n),u-1),s=e+a*c[1],i=e+r*c[1],o=n-a,l=1-o;for(let e=0;e<f;e++){const t=e*v,n=Math.floor(t),a=Math.min(Math.ceil(t),d-1),r=t-n,u=1-r,p=s+n*c[2],f=s+a*c[2],g=i+n*c[2],b=i+a*c[2],y=l*u,k=l*r,I=o*u,S=o*r;for(let e=0;e<h;e++){const t=x[w++];m[p+e]+=t*y,m[f+e]+=t*k,m[g+e]+=t*I,m[b+e]+=t*S}}}}return n.makeTensorInfo([l,d,u,h],"float32",m)}};const Am={kernelName:s.wc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:c}=a;_u(r,"resizeNearestNeighbor");const l=s.Df.computeStrides(r.shape),[u,d]=c,[h,p,f,m]=r.shape,g=n.data.get(r.dataId).values,b=new Float32Array(h*u*d*m),y=[i&&u>1?p-1:p,i&&d>1?f-1:f],v=[i&&u>1?u-1:u,i&&d>1?d-1:d],x=y[0]/v[0],w=y[1]/v[1];let k=0;for(let s=0;s<h;s++){const e=s*l[0];for(let t=0;t<u;t++){const n=o?x*(t+.5):x*t;let a=Math.min(p-1,i?Math.round(n):Math.floor(n));o&&(a=Math.max(0,a));const r=e+a*l[1];for(let e=0;e<d;e++){const t=o?w*(e+.5):w*e;let n=Math.min(f-1,i?Math.round(t):Math.floor(t));o&&(n=Math.max(0,n));const a=r+n*l[2];for(let e=0;e<m;e++){const t=g[a+e];b[k++]=t}}}}return n.makeTensorInfo([h,u,d,m],r.dtype,b)}};const Rm={kernelName:s.xc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:i}=t,{alignCorners:o}=a;_u([i,r],"resizeNearestNeighborGrad");const c=s.Df.computeStrides(r.shape),l=s.Df.computeStrides(i.shape),[u,d,h,p]=r.shape,[,f,m]=i.shape,g=new Float32Array(u*d*h*p),b=n.data.get(i.dataId).values,y=[o&&f>1?d-1:d,o&&m>1?h-1:h],v=[o&&f>1?f-1:f,o&&m>1?m-1:m],x=y[0]/v[0],w=y[1]/v[1],k=1/x,I=1/w,S=2*Math.ceil(k)+2,N=2*Math.ceil(I)+2;for(let s=0;s<u;s++){const e=s*c[0];for(let t=0;t<d;t++){const n=e+t*c[1],a=Math.floor(t*k),r=Math.floor(a-S/2);for(let s=0;s<h;s++){const a=n+s*c[2],i=Math.floor(s*I),u=Math.floor(i-N/2);for(let n=0;n<p;n++){let i=0;for(let a=0;a<S;a++){const c=a+r;if(c<0||c>=f)continue;const p=e+c*l[1],g=c*x;if(t===Math.min(d-1,o?Math.round(g):Math.floor(g)))for(let e=0;e<N;e++){const t=e+u;if(t<0||t>=m)continue;const a=p+t*l[2],r=t*w;s===Math.min(h-1,o?Math.round(r):Math.floor(r))&&(i+=b[a+n])}}g[a+n]=i}}}}return n.makeTensorInfo(r.shape,r.dtype,g)}};const Dm={kernelName:s.yc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:i}=a;_u(r,"reverse");const o=r.shape.length,c=s.Df.parseAxisParam(i,r.shape);if(0===o)return zu({inputs:{x:r},backend:n});const l=new s.hd(r.shape,r.dtype),u=n.bufferSync(r);for(let s=0;s<l.size;s++){const e=l.indexToLoc(s),t=e.slice();c.forEach(e=>t[e]=r.shape[e]-1-t[e]),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},Fm={kernelName:s.zc,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:i,fillValue:o,center:c}=n,l=a,u=s.Df.getTypedArrayFromDType(r.dtype,s.Df.sizeFromShape(r.shape)),[d,h,p,f]=r.shape,[m,g]=s.zd.getImageCenter(c,h,p),b=Math.sin(i),y=Math.cos(i),v=l.data.get(r.dataId).values;for(let s=0;s<d;s++){const e=s*p*h*f;for(let t=0;t<h;t++){const n=t*(p*f);for(let a=0;a<p;a++){const r=a*f;for(let s=0;s<f;s++){const i=[d,t,a,s],c=i[2],l=i[1];let x=(c-m)*y-(l-g)*b,w=(c-m)*b+(l-g)*y;x=Math.round(x+m),w=Math.round(w+g);let k=o;if("number"!==typeof o&&(k=3===s?255:o[s]),x>=0&&x<p&&w>=0&&w<h){k=v[e+w*(p*f)+x*f+s]}u[e+n+r+s]=k}}}}return{dataId:l.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Mm=Du(s.Ac,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),jm={kernelName:s.Ac,backendName:"cpu",kernelFunc:Mm},zm=Zu(e=>1/Math.sqrt(e)),Lm=Fu(s.Bc,zm),Pm={kernelName:s.Bc,backendName:"cpu",kernelFunc:Lm};function Bm(e,t,n,a,r,i,o,c,l,u){const d=[a/r,r],h=e.values,p=t.values;if(0===a)return Object(s.Gd)(n,t.dtype);const f=Object(s.Gd)(d,t.dtype);"string"===typeof l||"number"===typeof l?f.values.fill(l):"boolean"===typeof l&&f.values.fill(+l);for(let s=0;s<i;s++){const e=[];let i=0;for(let t=0;t<o;t++){const n=h[s*o+t];e.push(n),i+=n*c[t]}if(i<0||i>=a/r)throw new Error("Invalid indices: ".concat(e," does not index into ").concat(n));for(let n=0;n<r;n++)u?f.values[i*r+n]+=p[s*r+n]:f.values[i*r+n]=0===t.rank?p[0]:p[s*r+n]}return f}const Wm={kernelName:s.Cc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:i}=t,{shape:o}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=s.zd.calculateShapes(i,r,o),p=Bm(n.bufferSync(r),n.bufferSync(i),o,h,u,l,c,d,0,!0);return n.makeTensorInfo(o,p.dtype,p.values)}};function Um(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function Vm(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}const Gm={kernelName:s.Dc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:i}=t,{side:o}=a,c=function(e,t,n,a,r,i){const o=s.Df.getArrayFromDType("int32",n*r);for(let s=0;s<n;++s){const n=e.slice(s*a,(s+1)*a),c=s*r;for(let e=0;e<r;++e)o[c+e]="left"===i?Um(n,t[e+c]):Vm(n,t[e+c])}return o}(n.data.get(r.dataId).values,n.data.get(i.dataId).values,r.shape[0],r.shape[1],i.shape[1],o);return n.makeTensorInfo(i.shape,"int32",c)}};const Hm={kernelName:s.Ec,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:i}=t;_u([a,r,i],"select");const o=a.shape.length,c=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,d=Object(s.Cf)(r.dtype,i.dtype),h=s.Df.makeZerosTypedArray(s.Df.sizeFromShape(r.shape),d);let p=0;const f=0===o||o>1||1===r.shape.length?1:s.Df.sizeFromShape(r.shape.slice(1));for(let s=0;s<c.length;s++)for(let e=0;e<f;e++)1===c[s]?h[p++]=l[s]:h[p++]=u[s];return n.makeTensorInfo(r.shape,d,h)}},qm=s.zd.SELU_SCALEALPHA,Km=s.zd.SELU_SCALE,Xm=Du(s.Fc,e=>e>=0?Km*e:qm*(Math.exp(e)-1)),Zm={kernelName:s.Fc,backendName:"cpu",kernelFunc:Xm},Ym=Du(s.Hc,e=>e<0?-1:e>0?1:0),Jm={kernelName:s.Hc,backendName:"cpu",kernelFunc:Ym},Qm=Du(s.Ic,e=>Math.sin(e)),$m={kernelName:s.Ic,backendName:"cpu",kernelFunc:Qm},eg=Du(s.Jc,e=>Math.sinh(e)),tg={kernelName:s.Jc,backendName:"cpu",kernelFunc:eg},ng=Math.log(1.1920928955078125e-7)+2,ag=Du(s.Mc,e=>{const t=e>-ng,n=e<ng,a=Math.exp(e);let r;return r=n?a:t?e:Math.log(1+a),r}),rg={kernelName:s.Mc,backendName:"cpu",kernelFunc:ag};const sg={kernelName:s.Nc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:i,paddings:o}=a;_u([r],"spaceToBatchND");const c=s.Df.sizeFromShape(i),l=[[0,0]];l.push(...o);for(let s=1+i.length;s<r.shape.length;++s)l.push([0,0]);const u=cm.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),d=s.zd.getReshaped(u.shape,i,c,!1),h=s.zd.getPermuted(d.length,i.length,!1),p=s.zd.getReshapedPermuted(u.shape,i,c,!1),f=fd({inputs:{x:u},backend:n,attrs:{shape:d}}),m=Od({inputs:{x:f},backend:n,attrs:{perm:h}}),g=fd({inputs:{x:m},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function ig(e,t,n,a,r,i,o){const c=t[0],l=i[0],u=new Array(l),d=new Array(c),h=t[1];if(0===l){if(0!==c)throw new Error(s.zd.getSparseFillEmptyRowsIndicesDenseShapeMismatch(c));return[s.Df.getArrayFromDType(n,0),[0,h],s.Df.getArrayFromDType(r,0),u,d]}let p=!0,f=0;const m=new Array(l).fill(0);for(let b=0;b<c;++b){const t=e[b*h];if(t<0)throw new Error(s.zd.getSparseFillEmptyRowsNegativeIndexErrorMessage(b,t));if(t>=l)throw new Error(s.zd.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(b,t,l));++m[t],p=p&&t>=f,f=t}let g=!0;for(let s=0;s<l;++s){const e=0===m[s];u[s]=e,g=g&&!e,m[s]=Math.max(m[s],1),s>0&&(m[s]+=m[s-1])}if(g&&p){const t=e,n=a;for(let e=0;e<c;++e)d[e]=e;return[t,[c,h],n,u,d]}{const t=m[l-1],i=s.Df.getArrayFromDType(n,t*h),p=s.Df.getArrayFromDType(r,t),f=new Array(l).fill(0);for(let n=0;n<c;++n){const t=e[n*h],r=f[t],s=(0===t?0:m[t-1])+r;f[t]++;for(let a=0;a<h;++a)i[s*h+a]=e[n*h+a];p[s]=a[n],d[n]=s}for(let e=0;e<l;++e){if(0===f[e]){const t=0===e?0:m[e-1];i[t*h+0]=e;for(let e=1;e<h;++e)i[t*h+e]=0;p[t]=o}}return[i,[t,h],p,u,d]}}const og={kernelName:s.Oc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(s.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(r.shape));if(0!==i.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));const o=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values[0],[d,h,p,f,m]=ig(o,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(h,a.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};function cg(e,t,n,a,r){const i=s.Df.sizeFromShape(a),o=t[0],c=r.length,l=[];let u=1,d=-1;for(let g=0;g<c;++g){const e=r[g];if(-1===e){if(-1!==d)throw new Error(s.zd.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(d,g));d=g,l.push(1)}else{if(e<0)throw new Error(s.zd.getSparseReshapeNegativeOutputDimErrorMessage(g,e));u*=e,l.push(e)}}if(-1!==d){if(u<=0)throw new Error(s.zd.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(i/u);if(u*e!==i)throw new Error(s.zd.getSparseReshapeInputOutputMultipleErrorMessage(a,l));l[d]=e}if(s.Df.sizeFromShape(l)!==i)throw new Error(s.zd.getSparseReshapeInputOutputMismatchErrorMessage(a,l));const h=a.length,p=[];if(h>0){p[h-1]=1;for(let e=h-2;e>=0;--e)p[e]=p[e+1]*a[e+1]}const f=[];if(c>0){f[c-1]=1;for(let e=c-2;e>=0;--e)f[e]=f[e+1]*l[e+1]}const m=s.Df.getArrayFromDType(n,o*c);for(let s=0;s<o;++s){let t=0;for(let n=0;n<h;++n)t+=e[s*h+n]*p[n];for(let e=0;e<c;++e)m[s*c+e]=Math.trunc(t/f[e]),t%=f[e]}return[m,[o,c],l]}const lg={kernelName:s.Pc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(r.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));const i=Array.from(n.data.get(r.dataId).values),o=n.data.get(a.dataId).values,c=Array.from(n.data.get(s.dataId).values),[l,u,d]=cg(o,a.shape,a.dtype,i,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};function ug(e,t,n,a,r){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const c=a.length,l=[t[0],e.length/t[0]],u=l[1],d=c>0?r[c-1]+1:0,h=d;if(h<0)throw new Error(s.zd.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const p=t.slice();p[0]=h;const f=p.reduce((e,t)=>e*t,1),m=s.Df.getArrayFromDType(n,f);if(0===c)return h>0&&m.fill(o),[m,p];if(h<=0)throw new Error(s.zd.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let g=0,b=1,y=0,v=r[g];for(;;){let t=0;if(b<c){if(t=r[b],v===t){++b;continue}if(v>=t)throw new Error(s.zd.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(v<0||v>=h)throw new Error(s.zd.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v,h));v>y&&m.fill(o,y*u,v*u);for(let n=g;n<b;++n){const t=a[n];if(t<0||t>=l[0])throw new Error(s.zd.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,a[n],l[0]));for(let n=0;n<u;n++)m[v*u+n]+=e[t*u+n]}if(i)for(let e=0;e<u;e++)m[v*u+e]/=b-g;if(g=b,++b,y=v+1,v=t,b>c)break}return y<h&&m.fill(o,y*u,h*u),[m,p]}const dg={kernelName:s.Qc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(s.shape));if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,[l,u]=ug(i,a.shape,a.dtype,o,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const hg={kernelName:s.Rc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(s.shape));if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,[l,u]=ug(i,a.shape,a.dtype,o,c);return n.makeTensorInfo(u,a.dtype,l)}};const pg={kernelName:s.Sc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:c}=a,{sliceRank:l,numUpdates:u,sliceSize:d,strides:h,outputSize:p}=s.zd.calculateShapes(i,r,c),f=n.bufferSync(r);let m;switch(i.dtype){case"bool":m=Bm(f,n.bufferSync(i),c,p,d,u,l,h,Boolean(n.data.get(o.dataId).values[0]),!1);break;case"float32":m=Bm(f,n.bufferSync(i),c,p,d,u,l,h,n.data.get(o.dataId).values[0],!1);break;case"int32":m=Bm(f,n.bufferSync(i),c,p,d,u,l,h,n.data.get(o.dataId).values[0],!1);break;case"string":m=Bm(f,n.bufferSync(i),c,p,d,u,l,h,s.Df.decodeString(n.data.get(o.dataId).values[0]),!1);break;default:throw new Error("Unsupported type ".concat(i.dtype))}return n.makeTensorInfo(c,m.dtype,m.values)}};const fg={kernelName:s.Tc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:i,axis:o}=a,c=s.Df.parseAxisParam(o,r.shape)[0],l=s.zd.prepareSplitSize(r,i,c),u=new Array(r.shape.length).fill(0),d=r.shape.slice();return l.map(e=>{const t=[...d];t[c]=e;const a=$d({inputs:{x:r},backend:n,attrs:{begin:u,size:t}});return u[c]+=e,a})}},mg=Zu(e=>Math.sqrt(e)),gg=Du(s.Uc,e=>Math.sqrt(e)),bg={kernelName:s.Uc,backendName:"cpu",kernelFunc:gg},yg={kernelName:s.Vc,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:a}=t,r=n;_u(a,"square");const s=r.data.get(a.dataId).values,i=new Float32Array(s.length);for(let o=0;o<s.length;++o){const e=s[o];i[o]=e*e}return{dataId:r.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},vg=Wu((e,t)=>{const n=e-t;return n*n}),xg=cd(s.Wc,vg),wg={kernelName:s.Wc,backendName:"cpu",kernelFunc:xg},kg=Du(s.Xc,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),Ig={kernelName:s.Xc,backendName:"cpu",kernelFunc:kg};function Sg(e,t,n,a){const r=Object(s.Gd)(e,t.dtype);for(let s=0;s<r.size;s++){const e=r.indexToLoc(s),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+a[t];r.set(t.get(...i),...e)}return r}const Ng={kernelName:s.Yc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:i,end:o,strides:c,beginMask:l,endMask:u,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=a;_u(r,"stridedSlice");const{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:y,begin:v,end:x,strides:w}=s.hf.sliceInfo(r.shape,i,o,c,l,u,d,h,p);let k;if(g)k=fd({inputs:{x:r},backend:n,attrs:{shape:m}});else if(b||y){s.Df.assert(r.shape.length>=1,()=>"Input must have rank at least 1, got: ".concat(r.shape.length));const e=s.hf.computeOutShape(v,x,w),t=$d({inputs:{x:r},backend:n,attrs:{begin:v,size:e}});k=fd({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{const e=Sg(f,n.bufferSync(r),w,v);k=n.makeTensorInfo(m,e.dtype,e.values)}return k}};class Tg{constructor(e,t,n,a,r,i){this.separator=s.Df.encodeString(e),this.nGramWidths=t,this.leftPad=s.Df.encodeString(n),this.rightPad=s.Df.encodeString(a),this.padWidth=r,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,s){for(let i=0;i<r;++i){const o=this.getPadWidth(s),c=Math.max(0,o-i),l=Math.max(0,o-(r-(i+1))),u=s-(c+l),d=t+(c>0?0:i-o);let h=0;h+=c*this.leftPad.length;for(let t=0;t<u;++t)h+=e[d+t].length;h+=l*this.rightPad.length;h+=(c+l+u-1)*this.separator.length,n[a+i]=new Uint8Array(h);const p=n[a+i];let f=0;const m=e=>e.forEach(e=>p[f++]=e);for(let e=0;e<c;++e)m(this.leftPad),m(this.separator);for(let t=0;t<u-1;++t)m(e[d+t]),m(this.separator);if(u>0){m(e[d+u-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got ".concat(e));for(let r=1;r<a;++r){let a=t[r]>=e;if(a=a&&t[r]<=n,!a)throw new Error("Invalid split value ".concat(t[r],", must be in [").concat(e,", ").concat(n,"]"));e=t[r]}if(e!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(e))}const r=a-1,i=s.Df.getArrayFromDType("int32",a);if(0===n||0===a){const e=new Array(n);for(let t=0;t<=r;++t)i[t]=0;return[e,i]}i[0]=0;for(let s=1;s<=r;++s){const e=t[s]-t[s-1];let n=0;this.nGramWidths.forEach(t=>{n+=this.getNumNGrams(e,t)}),this.preserveShort&&e>0&&0===n&&(n=1),i[s]=i[s-1]+n}const o=new Array(i[r]);for(let s=0;s<r;++s){const n=t[s];let a=i[s];if(this.nGramWidths.forEach(r=>{const i=t[s+1]-t[s],c=this.getNumNGrams(i,r);this.createNGrams(e,n,o,a,c,r),a+=c}),this.preserveShort&&a===i[s]){const r=t[s+1]-t[s];if(0===r)continue;const i=r+2*this.padWidth,c=1;this.createNGrams(e,n,o,a,c,i)}}return[o,i]}}function Og(e,t,n,a,r,s,i,o){return new Tg(n,a,r,s,i,o).compute(e,t)}const Cg={kernelName:s.Zc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,h=n.data.get(u.dataId).values,p=n.data.get(d.dataId).values,[f,m]=Og(h,p,r,s,i,o,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};function Eg(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const r=t[0];let s=e.indexOf(r);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||a.push(t),s=(e=e.subarray(s+1)).indexOf(r)}return void(n&&0===e.length||a.push(e))}let r=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(r,s);n&&0===t.length||a.push(t),r=s+1}}function _g(e,t,n){const a=e.length,r=[];let i=0,o=0;const c=new Array(a);for(let s=0;s<a;++s){const a=r.length;Eg(e[s],t,n,r);const l=r.length-a;c[s]=l,i+=l,o=Math.max(o,l)}const l=s.Df.getArrayFromDType("int32",2*i),u=new Array(i),d=[a,o];let h=0;for(let s=0;s<a;++s)for(let e=0;e<c[s];++e)l[2*h]=s,l[2*h+1]=e,u[h]=r[h],++h;return[l,u,d]}const Ag={kernelName:s.ad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));const o=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values[0],[l,u,d]=_g(o,c,r),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};function Rg(e,t){const n=s.Df.getArrayFromDType("int32",e.length);for(let a=0;a<e.length;++a)n[a]=s.Df.fingerPrint64(e[a]).modulo(t).getLowBitsUnsigned();return n}const Dg={kernelName:s.bd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=Rg(n.data.get(s.dataId).values,r);return n.makeTensorInfo(s.shape,"int32",i)}},Fg=Du(s.ed,e=>Math.tan(e)),Mg={kernelName:s.ed,backendName:"cpu",kernelFunc:Fg},jg=Du(s.fd,e=>Math.tanh(e)),zg={kernelName:s.fd,backendName:"cpu",kernelFunc:jg};function Lg(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const a=Object(s.Gd)(n,e.dtype);for(let r=0;r<a.values.length;++r){const t=a.indexToLoc(r),n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=t[a]%e.shape[a];const s=e.locToIndex(n);a.values[r]=e.values[s]}return a}const Pg={kernelName:s.id,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;_u(r,"tile");const i=Lg(n.bufferSync(r),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},Bg=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function Wg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;a>n;){if(a-n>600){const r=a-n+1,s=t-n+1,i=Math.log(r),o=.5*Math.exp(2*i/3),c=.5*Math.sqrt(i*o*(r-o)/r)*Math.sign(s-r/2);Wg(e,t,Math.max(n,Math.floor(t-s*o/r+c)),Math.min(a,Math.floor(t+(r-s)*o/r+c)))}const r=e[t];let i=n,o=a;for(s.Df.swap(e,n,t),Bg(e[a],r)>0&&s.Df.swap(e,n,a);i<o;){for(s.Df.swap(e,i,o),i++,o--;Bg(e[i],r)<0;)i+=1;for(;Bg(e[o],r)>0;)o-=1}0===Bg(e[n],r)?s.Df.swap(e,n,o):(o+=1,s.Df.swap(e,o,a)),o<=t&&(n=o+1),t<=o&&(a=o-1)}}function Ug(e,t,n,a,r){const i=t[t.length-1],[o,c]=[e.length/i,i],l=s.Df.getTypedArrayFromDType(n,o*a),u=s.Df.getTypedArrayFromDType("int32",o*a);for(let s=0;s<o;s++){const t=s*c,n=e.subarray(t,t+c);let i=new Array(n.length);n.forEach((e,t)=>i[t]={value:e,index:t}),a<i.length&&(Wg(i,a),i=i.slice(0,a)),r&&i.sort(Bg);const o=s*a,d=l.subarray(o,o+a),h=u.subarray(o,o+a);for(let e=0;e<a;e++)d[e]=i[e].value,h[e]=i[e].index}const d=t.slice();return d[d.length-1]=a,[Object(s.Gd)(d,n,l),Object(s.Gd)(d,"int32",u)]}const Vg={kernelName:s.jd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a;_u(r,"topk");const o=n.data.get(r.dataId).values,[c,l]=Ug(o,r.shape,r.dtype,s,i);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};const Gg={kernelName:s.kd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:i}=t,{interpolation:o,fillMode:c,fillValue:l,outputShape:u}=n,[d,h,p,f]=r.shape,[m,g]=null!=u?u:[h,p],b=[d,m,g,f],y=s.Df.computeStrides(r.shape),v=y[0],x=y[1],w=y[2],k=s.Df.computeStrides(b),I=k[0],S=k[1],N=k[2],T=s.Df.getTypedArrayFromDType(r.dtype,s.Df.sizeFromShape(b));T.fill(l);const O=a.data.get(r.dataId).values,C=a.data.get(i.dataId).values;for(let s=0;s<d;++s){const e=1===i.shape[0]?C:C.subarray(8*s,8*s+8);for(let t=0;t<m;++t)for(let n=0;n<g;++n)for(let a=0;a<f;++a){let r;const i=e[6]*n+e[7]*t+1;if(0===i)continue;const u=(e[0]*n+e[1]*t+e[2])/i,d=(e[3]*n+e[4]*t+e[5])/i,f=Hg(u,p,c),m=Hg(d,h,c);switch(o){case"nearest":r=Kg(O,h,p,v,x,w,s,m,f,a,l);break;case"bilinear":r=Xg(O,h,p,v,x,w,s,m,f,a,l);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(o))}T[s*I+t*S+n*N+a]=r}return a.makeTensorInfo(b,r.dtype,T)}return{dataId:a.write(T,b,r.dtype),shape:r.shape,dtype:r.dtype}}};function Hg(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return s.Df.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return s.Df.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return s.Df.clamp(0,e,t-1)}(e,t);case"constant":default:return function(e,t){return e}(e)}}function qg(e,t,n,a,r,s,i,o,c,l,u){return 0<=o&&o<t&&0<=c&&c<n?e[i*a+o*r+c*s+l]:u}function Kg(e,t,n,a,r,s,i,o,c,l,u){return qg(e,t,n,a,r,s,i,Math.round(o),Math.round(c),l,u)}function Xg(e,t,n,a,r,s,i,o,c,l,u){const d=Math.floor(o),h=Math.floor(c),p=d+1,f=h+1;return(p-o)*((f-c)*qg(e,t,n,a,r,s,i,d,h,l,u)+(c-h)*qg(e,t,n,a,r,s,i,d,f,l,u))+(o-d)*((f-c)*qg(e,t,n,a,r,s,i,p,h,l,u)+(c-h)*qg(e,t,n,a,r,s,i,p,f,l,u))}function Zg(e,t,n,a){const r=s.Df.parseAxisParam(t,n)[0],i=[1,n[0],1];for(let s=0;s<r;s++)i[0]*=n[s];i[1]=n[r];for(let s=r+1;s<n.length;s++)i[2]*=n[s];const o={},c=new Int32Array(n[r]),l=new s.hd(i,a,e),u=[],d=1===i[0]&&1===i[2];for(let s=0;s<n[r];s++){let t;if(d)t=e[s].toString();else{const e=[];for(let t=0;t<i[0];t++)for(let n=0;n<i[2];n++)e.push(l.get(t,s,n));t=e.join(",")}if(void 0!==o[t])c[s]=o[t];else{const e=Object.keys(o).length;o[t]=e,c[s]=e,u.push(s)}}const h=i.slice();h[1]=Object.keys(o).length;const p=new s.hd(h,a);u.forEach((e,t)=>{for(let n=0;n<i[0];n++)for(let a=0;a<i[2];a++)p.set(l.get(n,e,a),n,t,a)});const f=n.slice();return f[r]=h[1],{outputValues:p.values,outputShape:f,indices:c}}const Yg={kernelName:s.md,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;_u(s,"unique");const i=a.data.get(s.dataId).values,{outputValues:o,outputShape:c,indices:l}=Zg(i,r,s.shape,s.dtype);return[a.makeTensorInfo(c,s.dtype,o),a.makeTensorInfo([l.length],"int32",l)]}};const Jg={kernelName:s.nd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const i=r.shape.length,o=r.shape[s],c=new Array(i-1);let l=0;for(let p=0;p<i;p++)p!==s&&(c[l++]=r.shape[p]);const u=new Array(i).fill(0),d=r.shape.slice();d[s]=1;const h=new Array(o);for(let p=0;p<h.length;p++){u[s]=p;const e=$d({inputs:{x:r},backend:n,attrs:{begin:u,size:d}});h[p]=fd({inputs:{x:e},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(e)}return h}};const Qg={kernelName:s.od,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:i}=t,{numSegments:o}=a;_u(r,"unsortedSegmentSum");const c=[],l=[],u=r.shape.length-i.shape.length;let d=i;for(let s=0;s<u;++s){const e=lp({inputs:{input:d},backend:n,attrs:{dim:s+1}});d=e,l.push(e)}for(let p=0;p<o;++p){const e=s.Df.createScalarValue(p,"int32"),t=n.makeTensorInfo([],"int32",e),a=Yh({inputs:{a:t,b:d},backend:n}),i=id({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),o=Vh({inputs:{a:i,b:r},backend:n}),u=Hh({inputs:{x:o},backend:n,attrs:{axis:0,keepDims:!1}});c.push(u),l.push(t),l.push(a),l.push(i),l.push(o),l.push(u)}const h=im({inputs:c,backend:n,attrs:{axis:0}});return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),h}},$g=[yd,xd,kd,Sd,pd,Nd,Ed,_d,Ad,Rd,Fd,jd,Ld,Wd,Vd,Kd,Xd,Zd,Yd,bd,Jd,th,rh,sh,od,ch,uh,td,dh,gh,yh,vh,xh,wh,kh,Ih,Nh,Oh,Ch,Eh,_h,Ah,Rh,Fh,Mh,jh,zh,Lh,Ph,Bh,Kh,ju,Xh,Jh,sp,cp,up,pp,Ip,Np,Tp,Ep,Rp,Dp,Fp,jp,Lp,Wp,Gp,Lu,Hp,fh,Kp,Zp,Jp,Bu,ef,af,sf,lf,df,ff,gf,vf,xf,wf,Sf,Of,Cf,Ef,_f,Af,Rf,Df,Ff,zf,Lf,Wf,Gf,Gh,qf,Xf,Yf,Qf,tm,nm,sm,om,cm,dm,Gu,pm,ym,Sm,Tm,rd,gp,Cm,qu,Xu,md,Em,_m,Am,Rm,Dm,Fm,jm,Pm,Wm,Gm,Hm,Zm,Qu,Jm,$m,tg,eh,Vf,rg,sg,og,lg,dg,hg,pg,fg,bg,yg,wg,Ig,Ng,Cg,Ag,Dg,xp,qh,Mg,zg,Pg,Vg,Gg,Cd,Yg,Jg,Qg,rm];for(const NT of $g)Object(s.Se)(NT);const eb={},tb={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function nb(e,t){if(!(e in eb)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if("undefined"!==typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;n.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete eb[e]},!1),Object(s.be)().getBool("SOFTWARE_WEBGL_ENABLED")&&(tb.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",tb)||n.getContext("experimental-webgl",tb);return n.getContext("webgl2",tb)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;eb[e]=n}const n=eb[e];return null==n||n.isContextLost()?(delete eb[e],nb(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),eb[e])}var ab,rb,sb;function ib(e,t){return[t,e]}function ob(e){const t=s.Df.sizeFromShape(e),n=Math.ceil(t/4);return s.Df.sizeToSquarishShape(n)}function cb(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function lb(e,t){const n=e;let a,r,i,o,c,l,u,d,h,p;return 2===Object(s.be)().getNumber("WEBGL_VERSION")?(a=n.R32F,r=n.R16F,i=n.RGBA16F,o=n.RGBA32F,c=n.RED,u=4,d=1,h=n.HALF_FLOAT,p=n.FLOAT,l=n.RGBA8):(a=e.RGBA,r=e.RGBA,i=e.RGBA,o=n.RGBA,c=e.RGBA,u=4,d=4,h=null!=t?t.HALF_FLOAT_OES:null,p=e.FLOAT,l=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:c,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:d,textureTypeHalfFloat:h,textureTypeFloat:p}}function ub(e,t){const n=t();return Object(s.be)().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(t)}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(ab||(ab={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(rb||(rb={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(sb||(sb={}));function db(e){return!!(Object(s.be)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function hb(e,t){return wb(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const pb=/ERROR: [0-9]+:([0-9]+):/g;function fb(e,t){const n=pb.exec(t);if(null==n)return console.log("Couldn't parse line number in error: ".concat(t)),void console.log(e);const a=+n[1],r=e.split("\n"),i=r.length.toString().length+2,o=r.map((e,t)=>s.Df.rightPad((t+1).toString(),i)+e);let c=0;for(let s=0;s<o.length;s++)c=Math.max(o[s].length,c);const l=o.slice(0,a-1),u=o.slice(a-1,a),d=o.slice(a);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log("%c ".concat(s.Df.rightPad(u[0],c)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function mb(e,t){if(ub(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function gb(e,t,n,a,r,s,i){const o=e.getAttribLocation(t,n);return-1!==o&&(ub(e,()=>e.bindBuffer(e.ARRAY_BUFFER,a)),ub(e,()=>e.vertexAttribPointer(o,r,e.FLOAT,!1,s,i)),ub(e,()=>e.enableVertexAttribArray(o)),!0)}function bb(e,t,n,a){ub(e,()=>function(e,t,n){kb(e,n),ub(e,()=>e.activeTexture(e.TEXTURE0+n)),ub(e,()=>e.bindTexture(e.TEXTURE_2D,t))}(e,t,a)),ub(e,()=>e.uniform1i(n,a))}function yb(e,t,n){ub(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),ub(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function vb(e,t){ub(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),ub(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function xb(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(t)}}(e,t))}function wb(e,t,n){const a=ub(e,()=>t());if(null==a)throw new Error(n);return a}function kb(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){const e="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(e,"."))}}function Ib(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return s.Df.sizeFromShape(e.slice(0,e.length-t))}function Sb(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Nb(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[Ib(e),...Sb(e)]),t}function Tb(e){return e%2===0}function Ob(e,t){if(e=e.slice(-2),t=t.slice(-2),s.Df.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],a=t.slice(-1)[0];if(n===a)return!0;if(Tb(n)&&Tb(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&Tb(e[0])&&Tb(t[0])}let Cb,Eb;function _b(e,t){return null!=e.getExtension(t)}function Ab(e){try{if(null!=nb(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Rb(e){if(0===e)return!1;const t=nb(e);if(1!==e){if(_b(t,"EXT_color_buffer_float"))return Db(t);const e="EXT_color_buffer_half_float";if(_b(t,e)){const n=t.getExtension(e);return function(e,t){const n=lb(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(r),s}(t,n)}return!1}if(!_b(t,"OES_texture_float"))return!1;if(!_b(t,"WEBGL_color_buffer_float"))return!1;return Db(t)}function Db(e){const t=lb(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function Fb(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&s.Df.assert("complex64"!==e.dtype,()=>"".concat(t," does not support complex64 tensors ")+"in the WebGL backend.")})}const Mb=Object(s.be)();function jb(){let e,t,n,a,r,i,o,c,l,u;return 2===Object(s.be)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",r="texture",i="outputColor",o="out vec4 outputColor;",c=Object(s.be)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",r="texture2D",i="gl_FragColor",o="",c="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:c,defineSpecialInf:l,defineRound:u}}function zb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=s.Df.computeStrides(t);return a.map((t,r)=>{const s="int ".concat(e[r]," = ").concat(n," / ").concat(t),i=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * ").concat(t):"index -= ".concat(e[r]," * ").concat(t);return"".concat(s,"; ").concat(i,";")}).join("")}function Lb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=s.Df.computeStrides(t);return a.map((t,r)=>{const s="int ".concat(e[r]," = ").concat(n," / outShapeStrides[").concat(r,"]"),i=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * outShapeStrides[").concat(r,"]"):"index -= ".concat(e[r]," * outShapeStrides[").concat(r,"]");return"".concat(s,"; ").concat(i,";")}).join("")}function Pb(e,t){const n=e.length,a=e.map(e=>"".concat(t,"[").concat(e,"]")),r=new Array(n-1);r[n-2]=a[n-1];for(let s=n-3;s>=0;--s)r[s]="(".concat(r[s+1]," * ").concat(a[s+1],")");return r}function Bb(e){const t=s.Df.computeStrides(e).map(e=>e.toString());return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0]," + coords.y * ").concat(t[1]," + coords.z;\n  }\n")}Mb.registerFlag("HAS_WEBGL",()=>Mb.getNumber("WEBGL_VERSION")>0),Mb.registerFlag("WEBGL_VERSION",()=>Ab(2)?2:Ab(1)?1:0),Mb.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Mb.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Mb.get("WEBGL_VERSION")),Mb.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Mb.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Mb.registerFlag("WEBGL_PACK",()=>Mb.getBool("HAS_WEBGL")),Mb.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Mb.getBool("WEBGL_PACK")),Mb.registerFlag("WEBGL_PACK_CLIP",()=>Mb.getBool("WEBGL_PACK")),Mb.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Mb.getBool("WEBGL_PACK")),Mb.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Mb.getBool("WEBGL_PACK")),Mb.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Mb.getBool("WEBGL_PACK")),Mb.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Mb.getBool("WEBGL_PACK")),Mb.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Mb.getBool("WEBGL_PACK")),Mb.registerFlag("WEBGL_PACK_REDUCE",()=>Mb.getBool("WEBGL_PACK")),Mb.registerFlag("WEBGL_LAZILY_UNPACK",()=>Mb.getBool("WEBGL_PACK")),Mb.registerFlag("WEBGL_CONV_IM2COL",()=>Mb.getBool("WEBGL_PACK")),Mb.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(e){if(null==Cb){const t=nb(e);Cb=t.getParameter(t.MAX_TEXTURE_SIZE)}return Cb}(Mb.getNumber("WEBGL_VERSION"))),Mb.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(e){if(null==Eb){const t=nb(e);Eb=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Eb)}(Mb.getNumber("WEBGL_VERSION"))),Mb.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=Mb.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=nb(e);return t=_b(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:_b(n,"EXT_disjoint_timer_query")?1:0,t}(e)}),Mb.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Mb.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!s.Vd.isMobile()),Mb.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(e){if(0===e)return!1;const t=nb(e);if(1===e){if(!_b(t,"OES_texture_float"))return!1}else if(!_b(t,"EXT_color_buffer_float"))return!1;return Db(t)}(Mb.getNumber("WEBGL_VERSION"))),Mb.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Mb.getBool("WEBGL_FORCE_F16_TEXTURES")&&Mb.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Mb.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Rb(Mb.getNumber("WEBGL_VERSION"))),Mb.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(e=Mb.getNumber("WEBGL_VERSION"))&&null!=nb(e).fenceSync;var e}),Mb.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Mb.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Mb.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))}),Mb.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>s.Vd.isMobile()?1:-1,e=>{if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(e,"."))}),Mb.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Mb.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Mb.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Mb.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Mb.registerFlag("WEBGL_EXP_CONV",()=>!1),Mb.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Mb.getBool("IS_TEST")),Mb.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Mb.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Mb.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);const Wb="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:Ub}=s.zd;function Vb(e,t,n){const a=[];if(e.forEach(e=>{const t=s.Df.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push("uniform float ".concat(e.name).concat(t>1?"[".concat(t,"]"):"",";")):(a.push("uniform sampler2D ".concat(e.name,";")),a.push("uniform int offset".concat(e.name,";"))),n.enableShapeUniforms){const{uniformShape:t}=cy(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:a.push("uniform int ".concat(e.name,"Shape;"));break;case 2:a.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:a.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:a.push("uniform ivec4 ".concat(e.name,"Shape;"))}a.push("uniform ivec2 ".concat(e.name,"TexShape;"))}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(e=>{a.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))});const r=a.join("\n"),i=e.map(e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0,r="";r+=n?Hb(e,a):Gb(e,a);const s=e.shapeInfo.logicalShape,i=t.logicalShape;s.length<=i.length&&(r+=n?sy(e,t):iy(e,t));return r}(e,t,n.packedInputs,n.enableShapeUniforms)).join("\n"),o=t.texShape,c=jb(),l=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(c);let u,d,h=function(e){return"".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(qb,"\n    ").concat(Kb,"\n    ").concat(Xb,"\n  ")}(c);t.isPacked?(u=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===a[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(a[1],".0);\n      }\n    ");if(1===a[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(a[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      return 2 * (resTexRC.x * ").concat(a[1]," + resTexRC.y);\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(s.Df.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(a[0],", ").concat(a[1],"));\n      }\n    ");const r=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2);let i=s,o="",c="b, r, c";for(let l=2;l<e.length-1;l++)i*=e[e.length-l-1],o="\n      int b".concat(l," = index / ").concat(i,";\n      index -= b").concat(l," * ").concat(i,";\n    ")+o,c="b".concat(l,", ")+c;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      ").concat(o,"\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec").concat(e.length,"(").concat(c,");\n    }\n  ")}(e,t,n)}}(t.logicalShape,o,n.enableShapeUniforms),d=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(c)):(u=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1],".0);\n      }\n    ");if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return resTexRC.x * ").concat(t[1]," + resTexRC.y;\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){if(s.Df.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    ");if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n){const t=Lb(["r","c","d"],e);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(t,"\n    return ivec3(r, c, d);\n  }\n")}const a=zb(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,t,n);case 4:return function(e,t,n){if(n){const t=Lb(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(t,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const a=zb(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,t,n);case 5:return function(e,t){const n=zb(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0],",\n                             ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,t);case 6:return function(e,t){const n=zb(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,t);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(t.logicalShape,o,n.enableShapeUniforms),d=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(c)),n.packedInputs&&(h+=Zb);return[h,l,d,r,u,i,n.userCode].join("\n")}function Gb(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return Jb(e,t);case 1:return Qb(e,t);case 2:return $b(e,t);case 3:return ey(e,t);case 4:return ty(e,t);case 5:return ny(e);case 6:return ay(e);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function Hb(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=jb();return"\n    vec4 ".concat(n,"() {\n      return ").concat(a.texture2D,"(").concat(t,", halfCR);\n    }\n  ")}(e);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,s=jb();if(t)return"\n    vec4 ".concat(a,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ");const i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return"\n    vec4 ".concat(a,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(i[0],", ").concat(i[1],", index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=e.shapeInfo.texShape,o=i[0],c=i[1],l=jb();if(null!=i&&s.Df.arraysEqual(n,i))return t?"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n\n        return ").concat(l.texture2D,"(").concat(a,", uv);\n      }\n    "):"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(c,".0, ").concat(o,".0);\n\n        return ").concat(l.texture2D,"(").concat(a,", uv);\n      }\n    ");if(t)return"\n    vec4 ".concat(r,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(l.texture2D,"(").concat(a,", uv);\n    }\n  ");const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],d=Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(d,", ").concat(u[0],", ").concat(u[1],", row, col);\n      return ").concat(l.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const a=n.slice(1),s=[1,2],i=ly(e,a),o=["b","row","col"];return"\n        ".concat(Hb(i,t),"\n        vec4 ").concat(r,"(int b, int row, int col) {\n          return ").concat(r,"(").concat(uy(o,s),");\n        }\n      ")}const o=jb();if(t)return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(o.texture2D,"(").concat(a,", uv);\n    }\n  ");const c=i[0],l=i[1],u=Math.ceil(n[2]/2),d=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(c,", ").concat(l,", ").concat(d,", ").concat(u,", b, row, col);\n      return ").concat(o.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);default:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=jb();if(t)return"\n    vec4 ".concat(a,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ");const s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=c[0],u=c[1],d=Math.ceil(s[i-1]/2);let h=d*Math.ceil(s[i-2]/2),p="int b, int row, int col",f="b * ".concat(h," + (row / 2) * ").concat(d," + (col / 2)");for(let m=2;m<i-1;m++)p="int b".concat(m,", ")+p,h*=s[i-m-1],f="b".concat(m," * ").concat(h," + ")+f;return"\n    vec4 ".concat(a,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(l,");\n      return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t)}}const qb="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Kb="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Xb="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Zb="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Yb(e){return"offset".concat(e)}function Jb(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(a,"() {return ").concat(n,";}");const[r,s]=e.shapeInfo.texShape;if(1===r&&1===s)return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=Yb(n);if(t)return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[o,c]=e.shapeInfo.texShape;return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(o,", ").concat(c,", ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}function Qb(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int index) {\n        ").concat(ry(e),"\n      }\n    ");const r=e.shapeInfo.texShape,s=r[0],i=r[1];if(1===i&&1===s)return"\n      float ".concat(a,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const o=Yb(n);return 1===i?t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o,") + 0.5) / ").concat(s,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):1===s?t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(o,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(o,") + 0.5) / ").concat(i,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):t?"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  "):"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(s,", ").concat(i,", index + ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}function $b(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=e.shapeInfo.texShape;if(null!=i&&s.Df.arraysEqual(n,i)){if(t)return"\n      float ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const e=i[0],n=i[1];return"\n    float ".concat(r,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(e,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}const{newShape:o,keptDims:c}=s.Df.squeezeShape(n),l=o;if(l.length<n.length){const n=ly(e,l),a=["row","col"];return"\n      ".concat(Gb(n,t),"\n      float ").concat(r,"(int row, int col) {\n        return ").concat(r,"(").concat(uy(a,c),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(ry(e),"\n      }\n    ");const u=i[0],d=i[1],h=Yb(a);return 1===d?t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(a,"TexShape[0]));\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(u,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  "):1===u?t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(a,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(d,".0, 0.5);\n      return sampleTexture(").concat(a,", uv);\n    }\n  "):t?"\n      float ".concat(r,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a,"Shape[1] + col + ").concat(h,";\n        vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n  float ".concat(r,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(h,";\n    vec2 uv = uvFromFlat(").concat(u,", ").concat(d,", index);\n    return sampleTexture(").concat(a,", uv);\n  }\n")}function ey(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=n[1]*n[2],o=n[2],{newShape:c,keptDims:l}=s.Df.squeezeShape(n),u=c;if(u.length<n.length){const n=ly(e,u),a=["row","col","depth"];return"\n        ".concat(Gb(n,t),"\n        float ").concat(r,"(int row, int col, int depth) {\n          return ").concat(r,"(").concat(uy(a,l),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(i,", ").concat(o,", 1)));\n        ").concat(ry(e),"\n      }\n    ");const d=e.shapeInfo.texShape,h=d[0],p=d[1],f=e.shapeInfo.flatOffset;if(p===i&&null==f)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        int stride1 = ").concat(a,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n        float ".concat(r,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(o,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(p,".0, ").concat(h,".0);\n          return sampleTexture(").concat(a,", uv);\n        }\n      ");if(p===o&&null==f)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(a,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(p,".0, ").concat(h,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");const m=Yb(a);return t?"\n    float ".concat(r,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(a,"Shape[1] * ").concat(a,"Shape[2];\n      int stride1 = ").concat(a,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n      return sampleTexture(").concat(a,", uv);\n    }\n    "):"\n      float ".concat(r,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(i," + col * ").concat(o," + depth + ").concat(m,";\n        vec2 uv = uvFromFlat(").concat(h,", ").concat(p,", index);\n        return sampleTexture(").concat(a,", uv);\n      }\n  ")}function ty(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=n[3],o=n[2]*i,c=n[1]*o,{newShape:l,keptDims:u}=s.Df.squeezeShape(n);if(l.length<n.length){const n=ly(e,l),a=["row","col","depth","depth2"];return"\n      ".concat(Gb(n,t),"\n      float ").concat(r,"(int row, int col, int depth, int depth2) {\n        return ").concat(r,"(").concat(uy(a,u),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(c,", ").concat(o,", ").concat(i,", 1)));\n        ").concat(ry(e),"\n      }\n    ");const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1],m="int stride2 = ".concat(a,"Shape[3];"),g="int stride1 = ".concat(a,"Shape[2] * stride2;"),b="int stride0 = ".concat(a,"Shape[1] * stride1;");if(f===c&&null==d)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        ").concat(m,"\n        ").concat(g,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(o,", ").concat(i,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");if(f===i&&null==d)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(a,"Shape[1] * ").concat(a,"Shape[2], ").concat(a,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const y=Yb(a);return t?"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(m,"\n      ").concat(g,"\n      ").concat(b,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index + ").concat(y,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  "):"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(c," + col * ").concat(o," +\n          depth * ").concat(i," + depth2;\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index + ").concat(y,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}function ny(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],i=t[3]*r,o=t[2]*i,c=t[1]*o,{newShape:l,keptDims:u}=s.Df.squeezeShape(t);if(l.length<t.length){const t=ly(e,l),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(Gb(t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(uy(n,u),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(c,", ").concat(o,", ").concat(i,", ").concat(r,")) +\n          depth3;\n        ").concat(ry(e),"\n      }\n    ");const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(o,", ").concat(i,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===r&&null==d)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const m=Yb(n);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(c," + col * ").concat(o," + depth * ").concat(i," +\n          depth2 * ").concat(r," + depth3 + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}function ay(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:i}=s.Df.squeezeShape(t);if(r.length<t.length){const t=ly(e,r),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(Gb(t),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(uy(n,i),");\n      }\n    ")}const o=t[5],c=t[4]*o,l=t[3]*c,u=t[2]*l,d=t[1]*u;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(d,", ").concat(u,", ").concat(l,", ").concat(c,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(o,", 1)));\n        ").concat(ry(e),"\n      }\n    ");const h=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,f=p[0],m=p[1];if(m===d&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(u,", ").concat(l,", ").concat(c,", ").concat(o,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(m,".0, ").concat(f,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(m===o&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(m,".0, ").concat(f,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const g=Yb(n);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(d," + col * ").concat(u," + depth * ").concat(l," +\n          depth2 * ").concat(c," + depth3 * ").concat(o," + depth4 + ").concat(g,";\n      vec2 uv = uvFromFlat(").concat(f,", ").concat(m,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}function ry(e){const t=e.name,n=s.Df.sizeFromShape(e.shapeInfo.logicalShape);return n<2?"return ".concat(t,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(t,"[i];\n      }\n    }\n  ")}function sy(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",i=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,c=Ub(e.shapeInfo.logicalShape,t.logicalShape),l=oy(o),u=o-i;let d;const h=["x","y","z","w","u","v"];d=0===i?"":o<2&&c.length>=1?"coords = 0;":c.map(e=>"coords.".concat(h[e+u]," = 0;")).join("\n");let p="";p=o<2&&i>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>"coords.".concat(h[t+u])).join(", ");let f="return outputValue;";const m=1===s.Df.sizeFromShape(e.shapeInfo.logicalShape),g=1===s.Df.sizeFromShape(t.logicalShape);if(1!==i||m||g){if(m&&!g)f=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(c.length){const e=i-2,t=i-1;c.indexOf(e)>-1&&c.indexOf(t)>-1?f="return vec4(outputValue.x);":c.indexOf(e)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":c.indexOf(t)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(r,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(d,"\n      vec4 outputValue = get").concat(a,"(").concat(p,");\n      ").concat(f,"\n    }\n  ")}function iy(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",i=t.texShape,o=e.shapeInfo.texShape,c=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&c===l&&null==e.shapeInfo.flatOffset&&s.Df.arraysEqual(o,i))return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const u=oy(l),d=Ub(e.shapeInfo.logicalShape,t.logicalShape),h=l-c;let p;const f=["x","y","z","w","u","v"];p=0===c?"":l<2&&d.length>=1?"coords = 0;":d.map(e=>"coords.".concat(f[e+h]," = 0;")).join("\n");let m="";return m=l<2&&c>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>"coords.".concat(f[t+h])).join(", "),"\n    float ".concat(r,"() {\n      ").concat(u," coords = getOutputCoords();\n      ").concat(p,"\n      return get").concat(a,"(").concat(m,");\n    }\n  ")}function oy(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function cy(e,t,n){const{newShape:a,keptDims:r}=s.Df.squeezeShape(t),i=t.length,o=e&&3===i&&1===t[0],c=o?t.slice(1):a,l=!e&&i>1&&!s.Df.arraysEqual(t,n)&&a.length<i||o;return{useSqueezeShape:l,uniformShape:l?c:t,keptDims:r}}function ly(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function uy(e,t){return t.map(t=>e[t]).join(", ")}function dy(e,t,n,a){const r=n.map((e,n)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}}),i=r.map(e=>e.shapeInfo),o={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},c=Vb(r,o,t),l=function(e,t){const n=wb(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ub(e,()=>e.shaderSource(n,t)),ub(e,()=>e.compileShader(n)),Object(s.be)().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw fb(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,c),u=e.createProgram(l);return Object(s.be)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:c,webGLProgram:u,inShapeInfos:i,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:c,webGLProgram:u,inShapeInfos:i,outShapeInfo:o},hy(e,t,u))}function hy(e,t,n){const a={},r={},i={},o=[];let c,l,u,d=null,h=null;h=e.getUniformLocation(n,"NAN",!1),1===Object(s.be)().getNumber("WEBGL_VERSION")&&(d=e.getUniformLocation(n,"INFINITY",!1));for(let s=0;s<t.variableNames.length;s++){const o=t.variableNames[s];a[o]=e.getUniformLocation(n,o,!1),a["offset".concat(o)]=e.getUniformLocation(n,"offset".concat(o),!1),t.enableShapeUniforms&&(r["".concat(o,"Shape")]=e.getUniformLocation(n,"".concat(o,"Shape"),!1),i["".concat(o,"TexShape")]=e.getUniformLocation(n,"".concat(o,"TexShape"),!1))}return t.enableShapeUniforms&&(c=e.getUniformLocation(n,"outShape",!1),u=e.getUniformLocation(n,"outShapeStrides",!1),l=e.getUniformLocation(n,"outTexShape",!1)),t.customUniforms&&t.customUniforms.forEach((t,a)=>{o[a]=e.getUniformLocation(n,t.name,!1)}),{uniformLocations:a,customUniformLocations:o,infLoc:d,nanLoc:h,inShapesLocations:r,inTexShapesLocations:i,outShapeLocation:c,outShapeStridesLocation:u,outTexShapeLocation:l}}function py(e,t){if(e.length!==t.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(t.length," inputs"));e.forEach((e,n)=>{const a=e.logicalShape,r=t[n],i=r.shape;if(!s.Df.arraysEqual(a,i))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(a," and ").concat(i," must match"));if(e.isUniform&&r.isUniform)return;const o=e.texShape,c=r.isUniform?null:r.texData.texShape;if(!s.Df.arraysEqual(o,c))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(o," and ").concat(c," must match"))})}function fy(e){return Object(s.be)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class my{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ab.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=jb();this.outputShape=e,this.enableShapeUniforms=fy(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?Lb(["r","c","d"],e):zb(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class gy{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ab.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=jb();this.outputShape=e,this.enableShapeUniforms=fy(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?Lb(["r","c","d"],e):zb(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class by{constructor(e){this.variableNames=["A"],this.outTexUsage=rb.DOWNLOAD;const t=jb();this.outputShape=e,this.userCode="\n      ".concat(Wb,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class yy{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=rb.DOWNLOAD;const t=jb();this.outputShape=e,this.userCode="\n      ".concat(Wb,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class vy{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=jb();this.outputShape=e,this.enableShapeUniforms=fy(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)"),this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Bb(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ").concat(n.texture2D,"(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ").concat(n.output," = vec4(").concat(a,", 0., 0., 0.);\n      }\n    ")}}class xy{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=jb();this.outputShape=e,this.enableShapeUniforms=fy(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){const r=2*s+t;a+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(t," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(t,";\n          if (localCoords[1] + ").concat(s," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(s,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(r,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(r,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(r,"] = values[2];\n            } else {\n              result[").concat(r,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Bb(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a,"\n\n          ").concat(n.output," = ").concat(r,";\n        }\n    ")}}function wy(e){const t=jb();return function(e,t){const n=wb(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ub(e,()=>e.shaderSource(n,t)),ub(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,"".concat(t.version,"\n    precision highp float;\n    ").concat(t.attribute," vec3 clipSpacePos;\n    ").concat(t.attribute," vec2 uv;\n    ").concat(t.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function ky(e){return function(e,t){const n=wb(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ub(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),ub(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function Iy(e){return function(e,t){const n=wb(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ub(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),ub(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Uint16Array([0,1,2,2,1,3]))}function Sy(e,t,n,a,r,i){!function(e,t){const n=Object(s.be)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n="[".concat(e,"x").concat(t,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const a="[".concat(e,"x").concat(t,"]"),r="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}(t,n);const o=function(e){return wb(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}(e),c=e.TEXTURE_2D;return ub(e,()=>e.bindTexture(c,o)),ub(e,()=>e.texParameteri(c,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),ub(e,()=>e.texParameteri(c,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),ub(e,()=>e.texParameteri(c,e.TEXTURE_MIN_FILTER,e.NEAREST)),ub(e,()=>e.texParameteri(c,e.TEXTURE_MAG_FILTER,e.NEAREST)),1===Object(s.be)().getNumber("WEBGL_VERSION")?ub(e,()=>e.texImage2D(c,0,a,t,n,0,r,i,null)):ub(e,()=>e.texStorage2D(c,1,a,t,n)),ub(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:o,texShape:[n,t]}}function Ny(e){return e.internalFormatFloat}function Ty(e){return e.internalFormatHalfFloat}function Oy(e){return e.downloadTextureFormat}function Cy(e){return e.internalFormatPackedFloat}function Ey(e){return e.internalFormatPackedHalfFloat}function _y(e,t,n,a,r,s,i,o){const c=e,l=new Float32Array(function(e,t){const[n,a]=cb(e,t);return n*a*4}(s,i));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}class Ay{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=Object(s.be)().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){eb[e]=t}(t,e)):this.gl=nb(t);let n="WEBGL_color_buffer_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Object(s.be)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=hb(this.gl,e),_b(this.gl,t))this.textureHalfFloatExtension=hb(this.gl,t);else if(Object(s.be)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),_b(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=hb(this.gl,"EXT_color_buffer_half_float");else if(Object(s.be)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",_b(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!_b(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=ky(this.gl),this.indexBuffer=Iy(this.gl),this.framebuffer=function(e){return wb(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=lb(this.gl,this.textureHalfFloatExtension)}get debug(){return Object(s.be)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;ub(e,()=>e.finish()),ub(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ub(e,()=>e.deleteFramebuffer(this.framebuffer)),ub(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ub(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ub(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=ib(t,n);return Sy(e,r,s,Ny(a),a.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=ib(t,n);return Sy(e,r,s,Ty(a),a.textureFormatFloat,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=ib(t,n);return Sy(e,r,s,Oy(a),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){ub(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?2===Object(s.be)().getNumber("WEBGL_VERSION")?ub(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):ub(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):2===Object(s.be)().getNumber("WEBGL_VERSION")?ub(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):ub(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),ub(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),function(e,t,n,a,r,i){let o,c,l;ub(e,()=>e.bindTexture(e.TEXTURE_2D,t)),r instanceof Uint8Array?(o=new Uint8Array(n*a*4),c=e.UNSIGNED_BYTE,l=e.RGBA):(o=new Float32Array(n*a*4),c=e.FLOAT,l=i.internalFormatPackedFloat),o.set(r),2===Object(s.be)().getNumber("WEBGL_VERSION")?ub(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,c,o)):ub(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,a,0,e.RGBA,c,o)),ub(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=cb(t,n);return Sy(e,r,s,Ey(a),e.RGBA,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=cb(t,n);return Sy(e,r,s,Cy(a),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(vb(this.gl,this.framebuffer),this.outputTexture=null),ub(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n,a){const[r,s]=ib(t,n),i=new Uint8Array(t*n*4);return ub(e,()=>e.readPixels(0,0,r,s,a.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,a,r,s){return _y(this.gl,e,0,0,0,r,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=function(e,t,n,a){const r=e.createBuffer();ub(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));const s=16*t*n;return ub(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),ub(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),ub(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Object(s.be)().getBool("WEBGL_FENCE_API_ENABLED")){const a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=a.clientWaitSync(r,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=r}else Object(s.be)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Object(s.be)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n){const a=new Float32Array(t*n*4);return ub(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a)),a}(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=wy(t));const n=function(e){return wb(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}(t);return ub(t,()=>t.attachShader(n,this.vertexShader)),ub(t,()=>t.attachShader(n,e)),function(e,t){if(ub(e,()=>e.linkProgram(t)),!Object(s.be)().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n),this.debug&&mb(t,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=function(e,t,n){return ub(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),gb(e,t,"clipSpacePos",n,3,20,0)&&gb(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&ub(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&mb(this.gl,this.program),ub(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return wb(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),ub(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),bb(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,r]=cb(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&mb(this.gl,this.program),xb(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),ub(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ub(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=hb(this.gl,2===Object(s.be)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Object(s.be)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Object(s.be)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await s.Df.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,Object(s.be)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Object(s.be)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n=void 0;"setTimeoutCustom"in Object(s.be)().platform&&(n=Object(s.be)().platform.setTimeoutCustom.bind(Object(s.be)().platform)),s.Df.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),yb(this.gl,e,this.framebuffer),this.debug&&xb(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(yb(this.gl,this.outputTexture,this.framebuffer),this.debug&&xb(this.gl)):vb(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;yb(a,e,this.framebuffer),this.debug&&xb(a),this.outputTexture=e,ub(a,()=>a.viewport(0,0,t,n)),ub(a,()=>a.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),ub(this.gl,()=>this.gl.scissor(e,t,n,a))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:Ry,bincountImpl:Dy,bincountReduceImpl:Fy,castImpl:My,ceilImpl:jy,concatImpl:zy,equalImpl:Ly,expImpl:Py,expm1Impl:By,floorImpl:Wy,gatherNdImpl:Uy,gatherV2Impl:Vy,greaterImpl:Gy,greaterEqualImpl:Hy,lessImpl:qy,lessEqualImpl:Ky,linSpaceImpl:Xy,logImpl:Zy,maxImpl:Yy,maximumImpl:Jy,minimumImpl:Qy,multiplyImpl:$y,negImpl:ev,notEqualImpl:tv,prodImpl:nv,raggedGatherImpl:av,raggedTensorToTensorImpl:rv,rangeImpl:sv,rsqrtImpl:iv,scatterImpl:ov,sigmoidImpl:cv,simpleAbsImpl:lv,sliceImpl:uv,sparseFillEmptyRowsImpl:dv,sparseReshapeImpl:hv,sparseSegmentReductionImpl:pv,sqrtImpl:fv,stridedSliceImpl:mv,stringNGramsImpl:gv,stringSplitImpl:bv,stringToHashBucketFastImpl:yv,subImpl:vv,tileImpl:xv,topKImpl:wv,transposeImpl:kv,uniqueImpl:Iv}=r;function Sv(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>"".concat(e,".").concat(t))}function Nv(e,t){return 1===t?[e]:Sv(e,t)}class Tv{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=fy(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Nv("rc",this.rank),t=oy(this.rank),n=this.getOutOfBoundsCondition(e),a=this.getSetup(e),r=this.getOutput(e);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(a,"\n\n            setOutput(vec4(").concat(r,"));\n          }\n        }\n      ")}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r="".concat(0===n?"r":"rp1",", ").concat(0===a?"c":"cp1");for(let t=2;t<this.rank;t++)r="".concat(e[e.length-1-t],",")+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+="".concat(e[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],a=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(t[0],";\n      int c = ").concat(t[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(a,";\n    ")}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(e," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(t[0],"),\n            cEdge ? 0. : getA(").concat(t[1],"),\n            rEdge ? 0. : getA(").concat(t[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(t[3],")")}}class Ov{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=fy(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+="\n        ".concat(e,"\n        ").concat(a>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(a,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(a>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e,t){const n=t?function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=e.map((e,t)=>t),r=Pb(a,t);return r.map((t,a)=>{const s="int ".concat(e[a]," = ").concat(n," / ").concat(r[a]),i=a===r.length-1?"int ".concat(e[a+1]," = ").concat(n," - ").concat(e[a]," * ").concat(r[a]):"index -= ".concat(e[a]," * ").concat(r[a]);return"".concat(s,"; ").concat(i,";")}).join("")}(["r","c","d"],"inputShape"):zb(["r","c","d"],e);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Bb(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class Cv{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const a=_v(t,n),r=Av(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const s=Ev(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const e=this.freeTextures[r].shift();return this.usedTextures[r].push(e),e}let i;return a===sb.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===sb.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===sb.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===sb.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===sb.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const r=_v(n,a),i=Av(t,r,a);i in this.freeTextures||(this.freeTextures[i]=[]);const o=Ev(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),c=Object(s.be)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==c&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[i],u=l.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*t),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Ev(e,t,n,a,r){const s=function(e,t){switch(e){case sb.PACKED_2X2_FLOAT32:return Cy(t);case sb.PACKED_2X2_FLOAT16:return Ey(t);case sb.UNPACKED_FLOAT32:return Ny(t);case sb.UNPACKED_FLOAT16:return Ty(t);case sb.PACKED_4X1_UNSIGNED_BYTE:return Oy(t);default:throw new Error("Unknown physical texture type ".concat(e))}}(t,a);let i;if(r){const[t,n]=cb(e[0],e[1]);i=t*n}else{const[t,n]=ib(e[0],e[1]);i=t*n}return i*function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(t))}(n,s)}function _v(e,t){if(e===rb.UPLOAD)return sb.PACKED_2X2_FLOAT32;if(e===rb.RENDER||null==e)return function(e){return Object(s.be)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?sb.PACKED_2X2_FLOAT32:sb.UNPACKED_FLOAT32:e?sb.PACKED_2X2_FLOAT16:sb.UNPACKED_FLOAT16}(t);if(e===rb.DOWNLOAD||e===rb.PIXELS)return sb.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function Av(e,t,n){return"".concat(e[0],"_").concat(e[1],"_").concat(t,"_").concat(n)}class Rv{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=fy(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const Dv="if (isnan(x)) return x;",Fv="return abs(x);";const Mv=Dv+"\n  return (x < 0.0) ? 0.0 : x;\n",jv=Dv+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",zv="return x;",Lv="return 1.0 / (1.0 + exp(-1.0 * x));",Pv="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Bv="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Wv="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";class Uv{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=fy(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class Vv{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=fy(this.outputShape.length);const t=e.length,n=Nv("rc",t),a=oy(t),r=function(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),i=t<=1?"rc":"vec2(".concat(s.join(","),")");this.userCode="\n      void main() {\n        ".concat(a," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(r,");\n\n        setOutput(getChannel(packedInput, ").concat(i,"));\n      }\n    ")}}const Gv=s.pe.whereImpl,Hv={};const qv=Object(s.be)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class Kv extends s.yb{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Object(s.be)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof Ay)t=e;else{const n=nb(Object(s.be)().getNumber("WEBGL_VERSION"),e);t=new Ay(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=nb(Object(s.be)().getNumber("WEBGL_VERSION"));t=new Ay(e),this.binaryCache=((n=Object(s.be)().getNumber("WEBGL_VERSION"))in Hv||(Hv[n]={}),Hv[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Cv(this.gpgpu),this.numMBBeforeWarning=null==Object(s.be)().global.screen?1024:Object(s.be)().global.screen.height*Object(s.be)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new s.N(this,Object(s.ae)())}nextDataId(){return Kv.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((Object(s.be)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Object(s.be)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:rb.UPLOAD,refCount:1}),a}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,a,r){if(Object(s.be)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:rb.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:a,complexTensorInfos:r,slice:i,shape:o,isPacked:c}=t;if(null!=i){let t;t=c?new Uv(o,zv):new Rv(o,zv);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:a}],a),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;const l=null!=this.activeTimers;let u,d;if(l&&(u=s.Df.now()),"complex64"===a){const e=this.readSync(r.real.dataId),t=this.readSync(r.imag.dataId);d=s.zd.mergeRealAndImagArrays(e,t)}else d=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=s.Df.now()-u),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}const t=this.texData.get(e),{values:n,shape:a,slice:r,dtype:i,complexTensorInfos:o,isPacked:c}=t;if(null!=r){let t;t=c?new Uv(a,zv):new Rv(a,zv);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:i}],i),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if(Object(s.be)().getBool("DEBUG")&&!Object(s.be)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Object(s.be)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,d=null;if("complex64"!==i&&Object(s.be)().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);d=this.gpgpu.createBufferFromTexture(t.texture.texture,...ob(a))}if(this.pendingRead.set(e,[]),"complex64"!==i&&await this.gpgpu.createAndWaitForFence(),"complex64"===i){const e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),t=e[0],n=e[1];u=s.zd.mergeRealAndImagArrays(t,n)}else if(null==d)u=this.getValuesFromTexture(e);else{const e=s.Df.sizeFromShape(a);u=this.gpgpu.downloadFloat32MatrixFromBuffer(d,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=d){const e=this.gpgpu.gl;ub(e,()=>e.deleteBuffer(d))}const h=this.convertAndCacheOnCPU(e,u),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(e=>e(h)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Object(s.ae)().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:a,shape:r,slice:i,dtype:o,isPacked:c,texture:l}=n;if("complex64"===o)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=i){let n;n=c?new Uv(r,zv):new Rv(r,zv);const a=this.runWebGLProgram(n,[{dataId:e,shape:r,dtype:o}],o),s=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),s}if(null==l)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),d=Object(s.ae)().makeTensorFromTensorInfo(u),h=this.texData.get(u.dataId);return Object.assign({tensorRef:d},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>s.Df.decodeString(e));return Object(s.Gd)(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(s.Gd)(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!db(n)){if(Object(s.be)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:a}=this.texData.get(e),r=s.Df.sizeFromShape(t);if(Object(s.be)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...ob(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),s}const i=Object(s.be)().getBool("WEBGL_PACK")&&!0===a,o=i?Nb(t):t,c=i?new yy(o):new by(o),l=this.runWebGLProgram(c,[{shape:o,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(l),d}timerAvailable(){return Object(s.be)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=s.Df.flatten(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),i=s.Df.flatten(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,a&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Object(s.be)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(r);o.kernelMs=s.Df.sum(e),o.getExtraProfileInfo=()=>e.map((e,t)=>({name:i[t],ms:e})).map(e=>"".concat(e.name,": ").concat(e.ms)).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Object(s.be)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:s.Df.now(),endMs:null}}endTimer(e){return Object(s.be)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=s.Df.now(),e)}async getQueryTime(e){if(Object(s.be)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:r,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,c=this.dataRefCount.get(o);c>1?this.dataRefCount.set(o,c-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,r,s)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:qv;return Object(s.be)().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&s.Df.sizeFromShape(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){s.zd.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return Gv(e.shape,t)}packedUnaryOp(e,t,n){const a=new Uv(e.shape,t),r=this.compileAndRun(a,[e],n);return Object(s.ae)().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=lv(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Object(s.be)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Fv,e.dtype);const t=new Rv(e.shape,Fv),n=this.compileAndRun(t,[e]);return Object(s.ae)().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&s.Df.isString(n[0])){const r=n.map(e=>s.Df.encodeString(e));a=this.write(r,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){return Object(s.ae)().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new Vv(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new Tv(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[Ib(e.shape),...Sb(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},r=[Ib(t),...Sb(t)],s=new Ov(r,n),i=[n],o=this.runWebGLProgram(s,[a],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:a,shape:r,dtype:i}=n;if(null!=t){const e=s.Df.sizeFromShape(r),n=t[0]*t[1]*4;s.Df.assert(e<=n,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=Nb(r);let c;c=a?new gy(o):new my(o);const l=[null!=t?t:ob(o)];return{dtype:i,shape:r,dataId:this.runWebGLProgram(c,[{shape:o,dtype:i,dataId:e}],i,l,!0,t).dataId}}runWebGLProgram(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=arguments.length>5?arguments[5]:void 0;const o=this.makeTensorInfo(e.outputShape,n),c=this.texData.get(o.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===ab.DENSE){const t=null!=i?i:ob(e.outputShape);c.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===s.Df.sizeFromShape(o.shape))return c.values=s.Df.getTypedArrayFromDType(o.dtype,0),o;const l=[],u=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&s.Df.sizeFromShape(t.shape)<=Object(s.be)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!Ob(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),l.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(o.dataId);const d={shape:o.shape,texData:c,isUniform:!1},h=function(e,t,n){let a="";t.concat(n).forEach(t=>{const r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const i=t.texData.texShape,{useSqueezeShape:o,uniformShape:c,keptDims:l}=cy(e.packedInputs,t.shape,i);let u="",d="",h="";if(1===c.length&&e.packedInputs){const e=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];u="".concat(e[0]>1,"_").concat(e[1]>1)}else if(2!==c.length||e.packedInputs){if(c.length>2&&!e.packedInputs){const e=s.Df.computeStrides(c);h="".concat(e[0]===i[1],"_").concat(e[e.length-1]===i[1])}}else d="".concat(c[0]>1,"_").concat(c[1]>1);const p=t.shape.length,f=2===c.length&&s.Df.arraysEqual(t.shape,i),m=1===s.Df.sizeFromShape(t.shape),g=s.zd.getBroadcastDims(t.shape,n.shape),b=!e.packedInputs&&p===n.shape.length&&s.Df.arraysEqual(i,n.texData.texShape),y=e.packedInputs||c.length>2?"":"".concat(i[0]>1,"_").concat(i[1]>1);a+="".concat(p,"_").concat(b,"_").concat(o?l:"","_").concat(c.length,"_").concat(m,"_").concat(g,"_").concat(f,"_").concat(u,"_").concat(d,"_").concat(h,"_").concat(y,"_").concat(r)}else{const e=t.isUniform?"uniform":t.texData.texShape;a+="".concat(t.shape,"_").concat(e,"_").concat(r)}});const r=e.userCode;let i=e.constructor.name;return i+="_"+a+"_"+r+"".concat(Object(s.be)().getNumber("WEBGL_VERSION")),i}(e,u,d),p=this.getAndSaveBinary(h,()=>dy(this.gpgpu,e,u,d)),f=null!=this.activeTimers;let m;f&&(m=this.startTimer()),Object(s.be)().get("ENGINE_COMPILE_ONLY")||function(e,t,n,a,r){t.program.enableShapeUniforms||(py(t.inShapeInfos,n),py([t.outShapeInfo],[a]));const i=a.texData.texture,o=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):e.setOutputMatrixTexture(i.texture,o[0],o[1]),e.setProgram(t.webGLProgram),1===Object(s.be)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((n,a)=>{const r=t.program.variableNames[a],i=t.uniformLocations[r],o=t.uniformLocations["offset".concat(r)],c=t.inShapesLocations["".concat(r,"Shape")],l=t.inTexShapesLocations["".concat(r,"TexShape")];if(c){const{uniformShape:a}=cy(t.program.packedInputs,n.shape,n.texData.texShape);switch(a.length){case 1:e.gl.uniform1iv(c,new Int32Array(a));break;case 2:e.gl.uniform2iv(c,new Int32Array(a));break;case 3:e.gl.uniform3iv(c,new Int32Array(a));break;case 4:e.gl.uniform4iv(c,new Int32Array(a))}}if(l&&e.gl.uniform2i(l,n.texData.texShape[0],n.texData.texShape[1]),null!=i)if(n.isUniform)if(s.Df.sizeFromShape(n.shape)<2)e.gl.uniform1f(i,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(i,t)}else null!=n.texData.slice&&null!=o&&e.gl.uniform1i(o,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture.texture,i,a)});const c=t.outShapeLocation;if(c)switch(a.shape.length){case 1:e.gl.uniform1iv(c,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(c,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(c,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(c,new Int32Array(a.shape))}if(t.outShapeStridesLocation){const n=s.Df.computeStrides(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r&&t.program.customUniforms.forEach((n,a)=>{const s=t.customUniformLocations[a],i=r[a];if("float"===n.type)e.gl.uniform1fv(s,i);else if("vec2"===n.type)e.gl.uniform2fv(s,i);else if("vec3"===n.type)e.gl.uniform3fv(s,i);else if("vec4"===n.type)e.gl.uniform4fv(s,i);else if("int"===n.type)e.gl.uniform1iv(s,i);else if("ivec2"===n.type)e.gl.uniform2iv(s,i);else if("ivec3"===n.type)e.gl.uniform3iv(s,i);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));e.gl.uniform4iv(s,i)}}),e.executeProgram()}(this.gpgpu,p,u,d,a),l.forEach(e=>this.disposeIntermediateTensorInfo(e)),f&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const g=Object(s.be)().get("WEBGL_FLUSH_THRESHOLD");if(g>0){const e=s.Df.now();e-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Object(s.be)().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===r){const e=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),e}return o}compileAndRun(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,a,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Object(s.be)().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Object(s.wf)(()=>{if(!Object(s.be)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Object(s.be)().getBool("DEBUG");Object(s.be)().set("DEBUG",!1);const t=this.abs(Object(s.We)(1e-8)).dataSync()[0];if(Object(s.be)().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:a,values:r,texture:i,usage:o,isPacked:c}=t;if(null!=i)return;const l=null!=this.activeTimers;let u;l&&(u=s.Df.now());let d=t.texShape;if(null==d&&(d=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=Object(s.be)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=Object(s.be)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(a===1/0&&Object(s.be)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n*=2,a*=2,1===(e=e.map((t,n)=>n>=e.length-2?s.Df.nearestLargerEven(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length){const t=s.Df.squeezeShape(e);e=t.newShape}let r=s.Df.sizeFromShape(e),i=null;e.length<=1&&r<=n?i=[1,r]:2===e.length&&e[0]<=n&&e[1]<=n?i=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?i=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?i=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?i=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(i=[e[0],e[1]*e[2]*e[3]]);const o=null!=i&&Math.max(...i)>a&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(null==i||o)if(t){const t=Ib(e);let n=2,a=2;e.length&&([n,a]=Sb(e)),r=t*(n/2)*(a/2),i=s.Df.sizeToSquarishShape(r).map(e=>2*e)}else i=s.Df.sizeToSquarishShape(r);return i}(n,c),t.texShape=d),null!=r){const e=Nb(n);let i,o=d[1],h=d[0];const p=r instanceof Uint8Array||r instanceof Uint8ClampedArray;!c&&p||([o,h]=cb(d[0],d[1])),i=c?new xy(e,p):new vy(e,p);const f=p?[h,o]:d,m=this.makeTensorInfo(f,a),g=this.texData.get(m.dataId);g.usage=p?rb.PIXELS:rb.UPLOAD,g.texShape=f,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(m.dataId),o,h,r);const b=[[h,o]],y=!0,v=this.runWebGLProgram(i,[m],a,b,y),x=this.texData.get(v.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,Object(s.be)().get("ENGINE_COMPILE_ONLY")?this.disposeData(v.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(v.dataId)),this.disposeIntermediateTensorInfo(m),l&&(this.uploadWaitMs+=s.Df.now()-u)}else{const e=this.acquireTexture(d,o,a,c);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype ".concat(t))}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(e," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*s.Df.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise(e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}});e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Object(s.He)(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw fb(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:n,infLoc:a,nanLoc:r,inShapesLocations:s,inTexShapesLocations:i,outShapeLocation:o,outShapeStridesLocation:c,outTexShapeLocation:l}=hy(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=r,e.inShapesLocations=s,e.inTexShapesLocations=i,e.outShapeLocation=o,e.outShapeStridesLocation=c,e.outTexShapeLocation=l}}}Kv.nextDataId=0;s.Vd.isBrowser()&&Object(s.Re)("webgl",()=>new Kv,2);class Xv{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=s.zd.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=fy(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}class Zv{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s.zd.assertAndGetBroadcastShape(t,n);const r=this.outputShape.length;this.enableShapeUniforms=fy(r);let i="";if(a)if(0===r||1===s.Df.sizeFromShape(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=oy(r);if(i="\n          ".concat(e," coords = getOutputCoords();\n        "),1===r)this.enableShapeUniforms?i+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":i+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const e=Nv("coords",r);this.enableShapeUniforms?i+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= outShape[").concat(r," - 2];\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= outShape[").concat(r," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):i+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= ").concat(this.outputShape[r-2],";\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= ").concat(this.outputShape[r-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(i,"\n\n        setOutput(result);\n      }\n    ")}}function Yv(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const Jv={kernelName:s.tb,backendName:"webgl",kernelFunc:Yv};function Qv(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.makeTensorInfo(a.shape,"complex64"),i=n.texData.get(s.dataId),o=Yv({inputs:{x:a},backend:n}),c=Yv({inputs:{x:r},backend:n});return i.complexTensorInfos={real:o,imag:c},s}const $v={kernelName:s.z,backendName:"webgl",kernelFunc:Qv},ex="return (a < 0.) ? b * a : a;",tx="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const nx={kernelName:s.Bb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:i}=a,o=n.makeTensorInfo([],"float32",s.Df.createScalarValue(i,"float32")),c=Object(s.be)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zv(tx,r.shape,o.shape):new Xv(ex,r.shape,o.shape),l=n.runWebGLProgram(c,[r,o],"float32");return n.disposeIntermediateTensorInfo(o),l}},ax="return (a < 0.) ? b * a : a;",rx="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const sx={kernelName:s.jc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,i=Object(s.be)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zv(rx,a.shape,r.shape):new Xv(ax,a.shape,r.shape);return n.runWebGLProgram(i,[a,r],"float32")}};function ix(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:a,dtype:r}=e;return e=>{let{inputs:i,backend:o}=e;const{x:c}=i,l=o,u=r||c.dtype;if(l.shouldExecuteOnCPU([c])&&null!=a){const e=l.texData.get(c.dataId),t=a(e.values,u);return l.makeTensorInfo(c.shape,u,t)}let d;return d=Object(s.be)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new Uv(c.shape,n):new Rv(c.shape,t),l.runWebGLProgram(d,[c],u)}}function ox(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:a=!1,supportsComplex:r=!1,cpuKernelImpl:i,dtype:o}=e;return e=>{let{inputs:c,backend:l}=e;const{a:u,b:d}=c,h=l;if(r&&"complex64"===u.dtype){const e=h.texData.get(u.dataId),n=h.texData.get(d.dataId),[a,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(e=>{const[n,a]=e,r={dataId:n.dataId,dtype:n.dtype,shape:u.shape},i={dataId:a.dataId,dtype:a.dtype,shape:d.shape},o=new Xv(t,u.shape,d.shape);return h.runWebGLProgram(o,[r,i],Object(s.Cf)(n.dtype,a.dtype))}),i=Qv({inputs:{real:a,imag:r},backend:h});return h.disposeIntermediateTensorInfo(a),h.disposeIntermediateTensorInfo(r),i}const p=o||Object(s.Cf)(u.dtype,d.dtype);if(("string"===u.dtype||"string"===d.dtype||h.shouldExecuteOnCPU([u,d]))&&null!=i){const e=h.texData.get(u.dataId).values,t=h.texData.get(d.dataId).values,n="string"===u.dtype?s.zd.fromUint8ToStringArray(e):e,a="string"===u.dtype?s.zd.fromUint8ToStringArray(t):t,[r,o]=i(u.shape,d.shape,n,a,p),c=h.makeTensorInfo(o,p);return h.texData.get(c.dataId).values=r,c}let f;return f=Object(s.be)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new Zv(n,u.shape,d.shape,a):new Xv(t,u.shape,d.shape),h.runWebGLProgram(f,[u,d],p)}}function cx(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return"return x;";if("relu"===e)return t?Bv:Mv;if("elu"===e)return t?Pv:"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?Wv:jv;if("prelu"===e)return t?rx:ax;if("leakyrelu"===e)return t?tx:ex;if("sigmoid"===e)return t?"return 1.0 / (1.0 + exp(-1.0 * x));":Lv;throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}class lx{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=fy(this.outputShape.length);const l=a?e[1]:e[2],u=Math.ceil(l/2),d=a?"i * 2, rc.y":"rc.y, i * 2",h=r?"rc.z, i * 2":"i * 2, rc.z",p=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(i,"\n        }"):c?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(i,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(i,"\n        }"),g="result = activation(result);");const b=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let y="rc.x",v="rc.x";e[0]<t[0]?y="int(min(float(rc.x), ".concat(e[0]-1,".))"):t[0]<e[0]&&(v="int(min(float(rc.x), ".concat(t[0]-1,".))")),this.userCode="\n      ".concat(m,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ").concat(u,"; i++) {\n          int batchA = ").concat(y,";\n          int batchB = ").concat(v,";\n          vec4 a = getMatrixA(batchA, ").concat(d,");\n          vec4 b = getMatrixB(batchB, ").concat(h,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(b,"\n\n        ").concat(g,"\n\n        setOutput(result);\n      }\n    ")}}const ux="return areal * breal - aimag * bimag;",dx="return areal * bimag + aimag * breal;";class hx{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=s.zd.assertAndGetBroadcastShape(t,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const px="return a * b;";function fx(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,i=s.zd.upcastType(a.dtype,r.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),s=new hx(ux,a.shape,r.shape),i=new hx(dx,a.shape,r.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape}],c=n.runWebGLProgram(s,o,"float32"),l=n.runWebGLProgram(i,o,"float32"),u=Qv({inputs:{real:c,imag:l},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),u}if(n.shouldExecuteOnCPU([a,r])){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),[s,o]=$y(a.shape,r.shape,e.values,t.values,i),c=n.makeTensorInfo(o,i);return n.texData.get(c.dataId).values=s,c}let o;return o=Object(s.be)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zv(px,a.shape,r.shape):new Xv(px,a.shape,r.shape),n.runWebGLProgram(o,[a,r],i)}const mx={kernelName:s.Xb,backendName:"webgl",kernelFunc:fx};function gx(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:i}=a,o=n,c=s.Df.sizeFromShape(r.shape),l=s.Df.inferFromImplicitShape(i,c),u=s.Df.sizeFromShape(l);s.Df.assert(c===u,()=>"The new shape (".concat(l,") has ").concat(u," elements and the old ")+"shape (".concat(r.shape,") has ").concat(c," elements. The new shape and old ")+"shape must have the same number of elements.");const d=o.texData.get(r.dataId);return!d.isPacked||Ob(r.shape,l)||null!==d.texture&&Ob(d.shape,l)?(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype}):function(e,t,n){const a=[Ib(e.shape),...Sb(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},s=[Ib(t),...Sb(t)],i=new Ov(s,a),o=[a],c=n.runWebGLProgram(i,[r],e.dtype,o,!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(r,l,o)}const bx={kernelName:s.tc,backendName:"webgl",kernelFunc:gx};class yx{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:i}=e;this.outputShape=[a,i];const o=4*Math.floor(n/4),c=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l="sumValue += dot(values * ".concat(s.Df.isInt(e)?e.toPrecision(2):e,", ones);")}let u="";r%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(o,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(o,";\n        if (").concat(1===c,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(l,"\n        } else if (").concat(2===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(l,"\n        } else if (").concat(3===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(l,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class vx{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let c="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");const l=4*Math.floor(n/4),u=n%4;let d="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(o,"(values, minMaxValue);\n        if (").concat("min"===t," || ").concat("max"===t,") {\n          minMaxValue = ").concat(o,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";r%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(i,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(i,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(l,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(d,"\n        }\n\n        int inIdx = inOffset + ").concat(l,";\n        if (").concat(1===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(2===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(3===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(d,"\n        }\n        setOutput(").concat(c,");\n      }\n    ")}}function xx(e,t,n,a){const r=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],a=s.zd.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}(e.shape);let i=e;for(let s=0;s<r.length;s++){const{inSize:o,windowSize:c,outSize:l}=r[s];let u,d;u="mean"===n?0===s?new yx({windowSize:c,inSize:o,batchSize:e.shape[0],outSize:l},o):new yx({windowSize:c,inSize:o,batchSize:e.shape[0],outSize:l}):new vx({windowSize:c,inSize:o,batchSize:e.shape[0],outSize:l},n),d=i,i=a.runWebGLProgram(u,[i],t),d.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(d)}return i}class wx{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;const a=oy(this.rank),r=function(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}(t);this.userCode="\n    void main() {\n      ".concat(a," resRC = getOutputCoords();\n      setOutput(getA(").concat(r,"));\n    }\n    ")}}class kx{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const a=oy(this.rank),r=Sv("rc",this.rank),s=new Array(this.rank);for(let l=0;l<t.length;l++)s[t[l]]=r[l];const i="vec2(".concat(s.slice(-2).join(),")"),o="++".concat(r[this.rank-1]," < ").concat(n[this.rank-1]),c="getChannel(getA(".concat(s.join(),"), ").concat(i,")");this.userCode="\n    void main() {\n      ".concat(a," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(c,";\n      if(").concat(o,") {\n        result[1] = ").concat(c,";\n      }\n      --").concat(r[this.rank-1],";\n      if(++").concat(r[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(c,";\n        if(").concat(o,") {\n          result[3] = ").concat(c,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function Ix(e,t,n){const a=Object(s.be)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kx(e.shape,t):new wx(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function Sx(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:o}=a;return function(e,t,n,a){const r=t,i=e.shape.length,o=s.Df.parseAxisParam(r,e.shape);let c=o;const l=s.zd.getAxesPermutation(c,i),u=null!=l;let d=e;u&&(d=Ix(e,l,a),c=s.zd.getInnerMostAxes(c.length,i)),s.zd.assertAxesAreInnerMostDims("sum",c,i);const[h,p]=s.zd.computeOutAndReduceShapes(d.shape,c);let f=h;n&&(f=s.zd.expandShapeToKeepDim(h,o));const m=s.Df.sizeFromShape(p),g=gx({inputs:{x:d},attrs:{shape:[s.Df.sizeFromShape(e.shape)/m,m]},backend:a}),b=xx(g,Object(s.qf)(e.dtype),"sum",a),y=gx({inputs:{x:b},attrs:{shape:f},backend:a});return a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(b),u&&a.disposeIntermediateTensorInfo(d),y}(r,i,o,n)}const Nx={kernelName:s.dd,backendName:"webgl",kernelFunc:Sx};function Tx(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:s}=a,i=n,o=r.shape.length,c=new Array(o);for(let u=0;u<c.length;u++)c[u]=r.shape[s[u]];let l;if(i.shouldExecuteOnCPU([r])){const e=i.texData.get(r.dataId).values,t=kv(e,r.shape,r.dtype,s,c);l=i.makeTensorInfo(c,r.dtype);i.texData.get(l.dataId).values=t}else l=Ix(r,s,i);return l}const Ox={kernelName:s.ld,backendName:"webgl",kernelFunc:Tx};function Cx(e){let{a:t,b:n,transposeA:a,transposeB:r,backend:i,bias:o=null,preluActivationWeights:c=null,leakyreluAlpha:l=0,activation:u=null}=e;const d=t.shape.length,h=n.shape.length,p=a?t.shape[d-2]:t.shape[d-1],f=r?n.shape[h-1]:n.shape[h-2],m=a?t.shape[d-1]:t.shape[d-2],g=r?n.shape[h-2]:n.shape[h-1],b=t.shape.slice(0,-2),y=n.shape.slice(0,-2),v=s.Df.sizeFromShape(b),x=s.Df.sizeFromShape(y),w=s.Ed.assertAndGetBroadcastShape(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([m,g]);s.Df.assert(p===f,()=>"Error in matMul: inner shapes (".concat(p,") and (")+"".concat(f,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match."));const k=a?[v,p,m]:[v,m,p],I=r?[x,g,f]:[x,f,g],S=gx({inputs:{x:t},backend:i,attrs:{shape:k}}),N=gx({inputs:{x:n},backend:i,attrs:{shape:I}}),T=[S,N],O=Math.max(v,x),C=a?S.shape[1]:S.shape[2],E=null!=o,_=null!=c,A="leakyrelu"===u,R=null!=u?cx(u,!0):null;let D;if((1===m||1===g)&&C>1e3&&!1===(E||_||A||null!=R)){let e=S,t=N;a&&(e=Tx({inputs:{x:S},backend:i,attrs:{perm:[0,2,1]}}),T.push(e)),r&&(t=Tx({inputs:{x:N},backend:i,attrs:{perm:[0,2,1]}}),T.push(t));const n=1===g;let s=e;1!==g&&(s=gx({inputs:{x:e},backend:i,attrs:{shape:[O,C,1]}}),T.push(s));const o=1===g?2:1;let c=t;n&&(c=gx({inputs:{x:t},backend:i,attrs:{shape:[O,1,C]}}),T.push(c));const l=fx({inputs:{a:s,b:c},backend:i});D=Sx({inputs:{x:l},backend:i,attrs:{axis:o,keepDims:!0}}),T.push(l)}else{const e=Object(s.Cf)(t.dtype,n.dtype),u=new lx(k,I,[O,m,g],a,r,E,R,_,A),d=[S,N];if(null!=o&&d.push(o),_&&d.push(c),A){const e=i.makeTensorInfo([],"float32",s.Df.createScalarValue(l,"float32"));d.push(e),T.push(e)}D=i.runWebGLProgram(u,d,e)}const F=gx({inputs:{x:D},backend:i,attrs:{shape:w}});T.push(D);for(const s of T)i.disposeIntermediateTensorInfo(s);return F}const Ex={kernelName:s.qd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=a;return Cx({a:r,b:s,transposeA:c,transposeB:l,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:u})}};const _x={kernelName:s.a,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){const e=n.texData.get(a.dataId),t=lv(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}let r;return r=Object(s.be)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Uv(a.shape,"return abs(x);"):new Rv(a.shape,"return abs(x);"),n.runWebGLProgram(r,[a],a.dtype)}},Ax=ix({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Rx={kernelName:s.b,backendName:"webgl",kernelFunc:Ax},Dx=ix({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Fx={kernelName:s.c,backendName:"webgl",kernelFunc:Dx},Mx="return a + b;",jx=ox({opSnippet:Mx,packedOpSnippet:Mx,supportsComplex:!0,cpuKernelImpl:Ry}),zx={kernelName:s.d,backendName:"webgl",kernelFunc:jx};class Lx{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>"T".concat(t));const n=[];this.variableNames.forEach(e=>{n.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))});const a=this.variableNames.map(e=>"v".concat(e)).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}class Px{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>"T".concat(t));const n=[];this.variableNames.forEach(e=>{n.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))});const a=this.variableNames.map(e=>"v".concat(e)).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}const Bx={kernelName:s.e,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,r=n;if(1===r.length)return Yv({inputs:{x:r[0]},backend:a});if(r.length>Object(s.be)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(r.length/2),n=e({inputs:r.slice(0,t),backend:a}),s=e({inputs:r.slice(t),backend:a});return e({inputs:[n,s],backend:a})}const i=r.map(e=>e.dtype).reduce((e,t)=>Object(s.Cf)(e,t)),o=r.map(e=>e.shape),c=Object(s.be)().getBool("WEBGL_PACK")?new Px(r[0].shape,o):new Lx(r[0].shape,o);return a.runWebGLProgram(c,r,i)}};const Wx={kernelName:s.f,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:o}=a,c=r.shape.length,l=s.Df.parseAxisParam(i,r.shape);let u=l;const d=s.zd.getAxesPermutation(u,c);let h=r;null!=d&&(h=Tx({inputs:{x:r},backend:n,attrs:{perm:d}}),u=s.zd.getInnerMostAxes(u.length,c)),s.zd.assertAxesAreInnerMostDims("all",u,c);const[p,f]=s.zd.computeOutAndReduceShapes(h.shape,u),m=gx({inputs:{x:h},backend:n,attrs:{shape:[-1,s.Df.sizeFromShape(f)]}}),g=xx(m,m.dtype,"all",n);let b;if(o){b=gx({inputs:{x:g},backend:n,attrs:{shape:s.zd.expandShapeToKeepDim(p,l)}})}else b=gx({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(h),b}};const Ux={kernelName:s.g,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:o}=a,c=r.shape.length,l=s.Df.parseAxisParam(i,r.shape);let u=l;const d=s.zd.getAxesPermutation(u,c);let h=r;null!=d&&(h=Tx({inputs:{x:r},backend:n,attrs:{perm:d}}),u=s.zd.getInnerMostAxes(u.length,c)),s.zd.assertAxesAreInnerMostDims("any",u,c);const[p,f]=s.zd.computeOutAndReduceShapes(h.shape,u),m=gx({inputs:{x:h},backend:n,attrs:{shape:[-1,s.Df.sizeFromShape(f)]}}),g=xx(m,m.dtype,"any",n);let b;if(o){b=gx({inputs:{x:g},backend:n,attrs:{shape:s.zd.expandShapeToKeepDim(p,l)}})}else b=gx({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(h),b}};class Vx{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:r,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,s];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          int inIdx = ").concat(o,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(i," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class Gx{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,s.Df.assert(e.length>2,()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2."));const r=e[e.length-1],i=Math.ceil(r/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),a||this.variableNames.push("bestIndicesA");const o=this.outputShape,c=o.length,l=oy(c),u=Nv("coords",c);let d,h;if(1===i){h=c+1;const e=oy(h);d="\n        ".concat(e," sourceLocR = ").concat(e,"(").concat(u.join(),", 0);\n        ++").concat(u[c-1],";\n        ").concat(e," sourceLocG = ").concat(e,"(").concat(u.join(),", 0);\n        ++").concat(u[c-2],";\n        ").concat(e," sourceLocA = ").concat(e,"(").concat(u.join(),", 0);\n        --").concat(u[c-1],";\n        ").concat(e," sourceLocB = ").concat(e,"(").concat(u.join(),", 0);\n        --").concat(u[c-2],";")}else h=c,d="\n        ".concat(l," sourceLocR = coords;\n        ++").concat(u[c-1],";\n        ").concat(l," sourceLocG = coords;\n        ++").concat(u[c-2],";\n        ").concat(l," sourceLocA = coords;\n        --").concat(u[c-1],";\n        ").concat(l," sourceLocB = coords;\n        --").concat(u[c-2],";");const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],m=p.map(e=>"int "+e),g=Nv("sourceLocR",h-1).concat("inIdx.r"),b=Nv("sourceLocG",h-1).concat("inIdx.g"),y=Nv("sourceLocB",h-1).concat("inIdx.b"),v=Nv("sourceLocA",h-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",w=a?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),"),\n                             getBestIndicesAChannel(").concat(v.join(),")));"),k="vec4(\n            getAChannel(".concat(g.join(),"),\n            hasNextCol ? getAChannel(").concat(b.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(y.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(v.join(),") : 0.)"),I=a?"":"\n      float getBestIndicesAChannel(".concat(m.join(),") {\n        return getChannel(getBestIndicesA(").concat(p.join(),"),\n                                          vec2(").concat(p.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(m.join(),") {\n        return getChannel(getA(").concat(p.join(),"),\n                               vec2(").concat(p.slice(-2).join(),"));\n      }\n      ").concat(I,"\n      void main() {\n        ").concat(l," coords = getOutputCoords();\n        bool hasNextCol = ").concat(u[c-1]," < ").concat(o[c-1]-1,";\n        bool hasNextRow = ").concat(u[c-2]," < ").concat(o[c-2]-1,";\n        ").concat(d,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(f,", sourceLocG").concat(f,",\n          sourceLocB").concat(f,", sourceLocA").concat(f,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(k,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(w,"\n          vec4 candidate = ").concat(k,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(x,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function Hx(e,t,n,a){const r=[n];if(s.zd.assertAxesAreInnerMostDims("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!Object(s.be)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],i=e.texData.get(t.dataId);let o=t;null!==i&&i.isPacked&&(o=e.unpackTensor(t),n.push(o));const[c,l]=s.zd.computeOutAndReduceShapes(o.shape,r),u=s.Df.sizeFromShape(l),d=gx({inputs:{x:o},backend:e,attrs:{shape:[-1,u]}});n.push(d);const h=function e(t,n,a){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,i=n.shape[0],o=n.shape[1];null!=r&&(i=r.shape[0],o=r.shape[1]);const c=s.zd.computeOptimalWindowSize(o),l={windowSize:c,inSize:o,batchSize:i,outSize:Math.ceil(o/c)},u=new Vx(l,a,null==r),d=[n];null!=r&&d.push(r);const h=t.runWebGLProgram(u,d,"int32");if(1===h.shape[1])return h;const p=e(t,n,a,h);return t.disposeIntermediateTensorInfo(h),p}(e,d,a);n.push(h);const p=gx({inputs:{x:h},backend:e,attrs:{shape:c}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),p}return function e(t,n,a){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const i=null!=r?r.shape:n.shape,o=i[i.length-1],c=s.zd.computeOptimalWindowSize(o),l=new Gx(i,c,a,null==r),u=null==r?[n]:[n,r],d=t.runWebGLProgram(l,u,"int32");if(d.shape.length===n.shape.length){const r=e(t,n,a,d);return t.disposeIntermediateTensorInfo(d),r}return d}(e,t,a)}const qx={kernelName:s.h,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i}=a;let o=s.Df.parseAxisParam(i,r.shape);const c=s.zd.getAxesPermutation(o,r.shape.length);let l=r;const u=[];null!=c&&(l=Tx({inputs:{x:r},backend:n,attrs:{perm:c}}),u.push(l),o=s.zd.getInnerMostAxes(o.length,l.shape.length)),s.zd.assertAxesAreInnerMostDims("argMax",[o[0]],l.shape.length);const d=Hx(n,l,o[0],"max");return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}};const Kx={kernelName:s.i,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i}=a;let o=s.Df.parseAxisParam(i,r.shape);const c=s.zd.getAxesPermutation(o,r.shape.length);let l=r;const u=[];null!=c&&(l=Tx({inputs:{x:r},backend:n,attrs:{perm:c}}),u.push(l),o=s.zd.getInnerMostAxes(o.length,l.shape.length)),s.zd.assertAxesAreInnerMostDims("argMin",[o[0]],l.shape.length);const d=Hx(n,l,o[0],"min");return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}},Xx=ix({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Zx={kernelName:s.j,backendName:"webgl",kernelFunc:Xx},Yx=ix({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),Jx={kernelName:s.k,backendName:"webgl",kernelFunc:Yx},Qx=ix({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),$x={kernelName:s.l,backendName:"webgl",kernelFunc:Qx},ew=ox({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),tw={kernelName:s.m,backendName:"webgl",kernelFunc:ew},nw=ix({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),aw={kernelName:s.n,backendName:"webgl",kernelFunc:nw};class rw{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),g="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d");let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(i,", ").concat(o,");\n        const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(c,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(l,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(t," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a?r?m:g:"wR * ".concat(d," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let y="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(y="avgValue / count");const v=4*Math.floor(s/4),x=s%4,w="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(i,", ").concat(o,");\n      const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n      const float initializationValue = ").concat(b,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(b,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(c,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(v,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              getValue(batch, xR, xC + 3 * ").concat(l,", d)\n            );\n\n            ").concat(w,"\n          }\n\n          int xC = xCCorner + ").concat(v,";\n          if (").concat(1===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(2===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(3===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              initializationValue\n            );\n\n            ").concat(w,"\n          }\n        }\n        setOutput(").concat(y,");\n      }\n    ")}}class sw{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let v="0.0";if(y||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(i,", ").concat(o,", ").concat(c,");\n        const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(b,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(h,";\n              wD += ").concat(l,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(d,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(t," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a?r?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let x="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(x="avgValue / count");const w=4*Math.floor(s/4),k=s%4,I="\n      if (".concat(y,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(i,", ").concat(o,", ").concat(c,");\n      const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(b,");\n      const float initializationValue = ").concat(v,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(v,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(h,";\n            wD += ").concat(l,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(d,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(d,", ch)\n              );\n\n              ").concat(I,"\n            }\n\n            int xC = xCCorner + ").concat(w,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                initializationValue\n              );\n\n              ").concat(I,"\n            }\n          }\n          setOutput(").concat(x,");\n        }\n      }\n    ")}}const iw={kernelName:s.o,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;Fb(r,"avgPool");const{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=a;s.Df.assert(s.zd.eitherStridesOrDilationsAreOne(o,1),()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'"));const u=s.zd.computePool2DInfo(r.shape,i,o,1,c,l);if(1===u.filterWidth&&1===u.filterHeight&&s.Df.arraysEqual(u.inShape,u.outShape))return Yv({inputs:{x:r},backend:n});const d=new rw(u,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}};const ow={kernelName:s.p,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:i,strides:o,pad:c,dimRoundingMode:l,dataFormat:u}=a,d=s.zd.computePool3DInfo(r.shape,i,o,[1,1,1],c,l,u),h=new sw(d,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}};class cw{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=o-1-e.padInfo.top,u=c-1-e.padInfo.left,d=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(l,", ").concat(u,");\n      const float avgMultiplier = float(").concat(d,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(o,";\n            wR += ").concat(s,") {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(c,";\n            wC+= ").concat(i,") {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class lw{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*a);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(m,");\n      const float avgMultiplier = float(").concat(g,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(o,") {\n          float dyD = float(dyDCorner + wD) / ").concat(r,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(d,";\n              wR += ").concat(c,") {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(l,") {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const uw={kernelName:s.q,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,o=i,{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=a,h=s.zd.computePool3DInfo(o.shape,c,l,[1,1,1],u,d),p=new lw(h);return n.runWebGLProgram(p,[r],o.dtype)}};const dw={kernelName:s.r,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,o=i;Fb([r,i],"avgPoolGrad");const{filterSize:c,strides:l,pad:u}=a,d=s.zd.computePool2DInfo(o.shape,c,l,1,u),h=new cw(d);return n.runWebGLProgram(h,[r],o.dtype)}};const hw={kernelName:s.s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;return Cx({a:r,b:s,transposeA:i,transposeB:o,backend:n})}};class pw{constructor(e,t,n,a,r,i){this.outputShape=[],this.variableNames=["x","mean","variance"],s.zd.assertAndGetBroadcastShape(e,t),s.zd.assertAndGetBroadcastShape(e,n);let o="0.0";null!=a&&(s.zd.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let c="1.0";null!=r&&(s.zd.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(o,";\n        float scale = ").concat(c,";\n        float inv = scale * inversesqrt(variance + float(").concat(i,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class fw{constructor(e,t,n,a,r,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],s.zd.assertAndGetBroadcastShape(e,t),s.zd.assertAndGetBroadcastShape(e,n);let o="vec4(0.0)";null!=a&&(s.zd.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let c="vec4(1.0)";null!=r&&(s.zd.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(o,";\n        vec4 scale = ").concat(c,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(i,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const mw={kernelName:s.lb,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,mean:i,variance:o,offset:c,scale:l}=t;s.Df.assert(i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),s.Df.assert(null==c||i.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),s.Df.assert(null==l||i.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=a;null==u&&(u=.001);const d=[r,i,o];let h=null;null!=c&&(h=c.shape,d.push(c));let p=null;null!=l&&(p=l.shape,d.push(l));const f=Object(s.be)().getBool("WEBGL_PACK_NORMALIZATION")?new fw(r.shape,i.shape,o.shape,h,p,u):new pw(r.shape,i.shape,o.shape,h,p,u);return n.runWebGLProgram(f,d,d[0].dtype)}};class gw{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=oy(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return bw.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let a;const r=e.map((e,t)=>"sourceLoc.".concat(bw[t]," = start[").concat(t,"] + coords.").concat(bw[t],";"));a="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(r.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(a,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const bw=["x","y","z","w","u","v"];class yw{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=oy(this.rank),n=Nv("coords",this.rank),a=Nv("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":"vec2(".concat(a.slice(-2).join(),")"),s="getChannel(getSource(".concat(a.join(),"), ").concat(r,")"),i="\n      result.x = ".concat(s,";\n      if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(a[this.rank-1],";\n        result.y = ").concat(s,";\n        --").concat(a[this.rank-1],";\n      }\n    "),o=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(a[this.rank-2],";\n        result.z = ").concat(s,";\n        if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(a[this.rank-1],";\n          result.w = ").concat(s,";\n        }\n      }\n    "),c=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(e.map((e,t)=>"start[".concat(t,"]")).join(),");"):e.map((e,t)=>"".concat(a[t]," = ").concat(n[t]," + start[").concat(t,"];")).join("\n");this.userCode="\n      void main() {\n        ".concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(c,"\n        vec4 result = vec4(0.);\n        ").concat(i,"\n        ").concat(o,"\n        setOutput(result);\n      }\n    ")}}function vw(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:i,size:o}=a,[c,l]=s.hf.parseSliceParams(r,i,o);if(s.hf.assertParamsValid(r,c,l),0===s.Df.sizeFromShape(l))return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.texData.get(r.dataId),t=uv(e.values,c,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,t)}const{isPacked:u}=n.texData.get(r.dataId),d=s.hf.isSliceContinous(r.shape,c,l);if(u||!d){const e=Object(s.be)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new yw(l):new gw(l),t=[c];return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),function(e,t,n,a){const r=a.texData.get(e.dataId),i=a.makeTensorInfo(n,e.dtype),o=a.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=n,o.dtype=e.dtype;let c=s.hf.computeFlatOffset(t,s.Df.computeStrides(e.shape));r.slice&&(c+=r.slice.flatOffset),o.slice={flatOffset:c,origDataId:r.slice&&r.slice.origDataId||e.dataId};const l=a.dataRefCount.get(o.slice.origDataId)||1;return a.dataRefCount.set(o.slice.origDataId,l+1),i}(r,c,l,n)}const xw={kernelName:s.Kc,backendName:"webgl",kernelFunc:vw},ww={kernelName:s.t,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:i,crops:o}=a;s.Df.assert(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const c=i.reduce((e,t)=>e*t),l=s.zd.getReshaped(r.shape,i,c),u=s.zd.getPermuted(l.length,i.length),d=s.zd.getReshapedPermuted(r.shape,i,c),h=s.zd.getSliceBeginCoords(o,i.length),p=s.zd.getSliceSize(d,o,i.length),f=[],m=gx({inputs:{x:r},backend:n,attrs:{shape:l}}),g=Tx({inputs:{x:m},backend:n,attrs:{perm:u}}),b=gx({inputs:{x:g},backend:n,attrs:{shape:d}}),y=vw({inputs:{x:b},backend:n,attrs:{begin:h,size:p}});return f.push(m),f.push(g),f.push(b),f.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}};const kw={kernelName:s.u,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.readSync(r.dataId),c=n.readSync(s.dataId),l=Dy(o,c,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,l)}};const Iw={kernelName:s.v,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,i=n.readSync(a.dataId),o=n.readSync(r.dataId),c=s.zd.assertAndGetBroadcastShape(Array.from(i),Array.from(o));return n.makeTensorInfo([c.length],"int32",Int32Array.from(c))}},Sw=ox({opSnippet:"return float(a != b);",cpuKernelImpl:tv,dtype:"bool"}),Nw={kernelName:s.cc,backendName:"webgl",kernelFunc:Sw};function Tw(e){const{inputs:t,backend:n}=e,{input:a}=t;return Yv({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}const Ow={kernelName:s.oc,backendName:"webgl",kernelFunc:Tw};const Cw={kernelName:s.w,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:r}=t,{x:i}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===i.dtype)return Yv({inputs:{x:i},backend:a});const t=s.If(i.shape),n=e({inputs:{x:i},backend:a,attrs:{dtype:"float32"}}),r=Qv({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeIntermediateTensorInfo(n),r}if("complex64"===i.dtype){const t=Tw({inputs:{input:i},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:o}});return a.disposeIntermediateTensorInfo(t),n}if(!s.Df.hasEncodingLoss(i.dtype,o)){const e=Yv({inputs:{x:i},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:o}}if(a.shouldExecuteOnCPU([i])){const e=a.texData.get(i.dataId).values,[t,n,r]=My(e,i.shape,i.dtype,o);return a.makeTensorInfo(t,n,r)}if("int32"===o)return function(e,t){const n=new Rv(e.shape,"return float(int(x));"),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(i,a);if("bool"===o){const e=a.makeTensorInfo([],"bool",s.Df.getTypedArrayFromDType("bool",1)),t=Sw({inputs:{a:i,b:e},backend:a});return a.disposeIntermediateTensorInfo(e),t}throw new Error("Error in Cast: failed to cast ".concat(i.dtype," to ").concat(o))}},Ew="return ceil(x);",_w=ix({opSnippet:Ew,packedOpSnippet:Ew,cpuKernelImpl:jy}),Aw={kernelName:s.x,backendName:"webgl",kernelFunc:_w};class Rw{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class Dw{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const Fw={kernelName:s.y,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:i,clipValueMax:o}=a;let c;c=Object(s.be)().getBool("WEBGL_PACK_CLIP")?new Dw(r.shape):new Rw(r.shape);const l=[[i],[o]];return n.runWebGLProgram(c,[r],r.dtype,l)}};class Mw{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function jw(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const zw={kernelName:s.A,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),s=new Mw(a.shape),i=[jw(a,r.complexTensorInfos.real),jw(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}};class Lw{constructor(e){this.outputShape=[],this.outputShape=s.zd.computeOutShape(e,1),this.variableNames=e.map((e,t)=>"T".concat(t));const t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];const n=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")];for(let s=1;s<t.length;s++){const e=t[s-1];n.push("else if (yC < ".concat(t[s],") ")+"setOutput(getT".concat(s,"(yR, yC-").concat(e,"));"))}const a=t.length,r=t[t.length-1];n.push("else setOutput(getT".concat(a,"(yR, yC-").concat(r,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class Pw{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=s.zd.computeOutShape(e,t);const n=this.outputShape,a=n.length,r=oy(a),i=Nv("coords",a),o=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map((e,t)=>"T".concat(t));const c=new Array(e.length-1);c[0]=e[0][t];for(let s=1;s<c.length;s++)c[s]=c[s-1]+e[s][t];const l=o[t],u=o.slice(-2),d=o.join();let h="if (".concat(l," < ").concat(c[0],") {\n        return getChannel(\n            getT0(").concat(d,"), vec2(").concat(u.join(),"));\n        }");for(let s=1;s<c.length;s++){const e=c[s-1];h+="\n        if (".concat(l," < ").concat(c[s],"  && ").concat(l," >= ").concat(c[s-1],") {\n          return getChannel(\n            getT").concat(s,"(").concat(Bw(o,l,e),"),\n            vec2(").concat(Bw(u,l,e),"));\n        }")}const p=c.length,f=c[c.length-1];h+="\n        return getChannel(\n          getT".concat(p,"(").concat(Bw(o,l,f),"),\n          vec2(").concat(Bw(u,l,f),"));"),this.userCode="\n      float getValue(".concat(o.map(e=>"int "+e),") {\n        ").concat(h,"\n      }\n\n      void main() {\n        ").concat(r," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(i,"), 0., 0., 0.);\n\n        ").concat(i[a-1]," = ").concat(i[a-1]," + 1;\n        if (").concat(i[a-1]," < ").concat(n[a-1],") {\n          result.g = getValue(").concat(i,");\n        }\n\n        ").concat(i[a-2]," = ").concat(i[a-2]," + 1;\n        if (").concat(i[a-2]," < ").concat(n[a-2],") {\n          result.a = getValue(").concat(i,");\n        }\n\n        ").concat(i[a-1]," = ").concat(i[a-1]," - 1;\n        if (").concat(i[a-2]," < ").concat(n[a-2]," &&\n            ").concat(i[a-1]," < ").concat(n[a-1],") {\n          result.b = getValue(").concat(i,");\n        }\n        setOutput(result);\n      }\n    ")}}function Bw(e,t,n){const a=e.indexOf(t);return e.map((e,t)=>t===a?"".concat(e," - ").concat(n):e).join()}function Ww(e){const{inputs:t,backend:n}=e,{input:a}=t;return Yv({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}const Uw={kernelName:s.ub,backendName:"webgl",kernelFunc:Ww};function Vw(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map(e=>Tw({inputs:{input:e},backend:n})),r=e.map(e=>Ww({inputs:{input:e},backend:n})),s=Vw(a,t,n),i=Vw(r,t,n),o=Qv({inputs:{real:s,imag:i},backend:n});return a.forEach(e=>n.disposeIntermediateTensorInfo(e)),r.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}let r=n.shouldExecuteOnCPU(e);if("string"===a&&(r=!0),r){const r=e.map(e=>{const a=s.Df.sizeFromShape(e.shape.slice(t));return gx({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})}),i=r.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),o=s.zd.computeOutShape(r.map(e=>e.shape),1),c=1===r[0].shape[0],l=zy(i,o,a,c),u=s.zd.computeOutShape(e.map(e=>e.shape),t),d=n.makeTensorInfo(u,a,l);return r.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}const i=Object(s.be)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(e.length>i){const a=[];for(let s=0;s<e.length;s+=i){const r=e.slice(s,s+i);a.push(Vw(r,t,n))}const r=Vw(a,t,n);for(const e of a)n.disposeIntermediateTensorInfo(e);return r}if(Object(s.be)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const r=new Pw(e.map(e=>e.shape),t);return n.runWebGLProgram(r,e,a)}const{tensors2D:o,outShape:c}=function(e,t,n){const a=s.zd.computeOutShape(e.map(e=>e.shape),t);return{tensors2D:e.map(e=>gx({inputs:{x:e},attrs:{shape:[-1,s.Df.sizeFromShape(e.shape.slice(t))]},backend:n})),outShape:a}}(e,t,n),l=new Lw(o.map(e=>e.shape)),u=n.runWebGLProgram(l,o,a);o.forEach(e=>n.disposeIntermediateTensorInfo(e));const d=gx({inputs:{x:u},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(u),d}function Gw(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,i=s.Df.parseAxisParam(r,t[0].shape)[0],o=t.map(e=>e.shape);s.zd.assertParamsConsistent(o,i);const c=s.zd.computeOutShape(t.map(e=>e.shape),i);if(0===s.Df.sizeFromShape(c))return n.makeTensorInfo(c,t[0].dtype,[]);const l=t.filter(e=>s.Df.sizeFromShape(e.shape)>0);return 1===l.length?Yv({inputs:{x:l[0]},backend:n}):Vw(l,i,n)}const Hw={kernelName:s.B,backendName:"webgl",kernelFunc:Gw};class qw{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,b=m?2:3,y=m?3:1;let v="",x="";n&&(v=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(v,"\n\n      const ivec2 strides = ivec2(").concat(o,", ").concat(c,");\n      const ivec2 pads = ivec2(").concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(y,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(g,"], coords[").concat(b,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(d,"; wR++) {\n          int xR = xRCorner + wR * ").concat(l,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(h,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(m,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(m,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(m,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(m,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w,"\n        ").concat(x,"\n        setOutput(result);\n      }\n    ")}}class Kw{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(r,", ").concat(s,", ").concat(i,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(n,", ").concat(a,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(o,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(d,"; wR++) {\n            int xR = xRCorner + wR * ").concat(c,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,"; wC++) {\n              int xC = xCCorner + wC * ").concat(l,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Xw{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=fy(this.outputShape.length);const i=e.padInfo.left,o=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,d=u;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let s=0;s<u;s++)h+="\n           vec4 xTexelC".concat(2*s,";\n           int xTexelC").concat(2*s,"Ready;\n           vec4 xTexelC").concat(2*s+1,";\n           int xTexelC").concat(2*s+1,"Ready;\n           vec4 xC").concat(s,";");h+="\n     for (int r = 0; r < ".concat(l,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(let s=0;s<u;s++)h+="\n           xTexelC".concat(2*s," = vec4(0.0);\n           xTexelC").concat(2*s,"Ready = 0;\n           xTexelC").concat(2*s+1," = vec4(0.0);\n           xTexelC").concat(2*s+1,"Ready = 0;\n           xC").concat(s," = vec4(0.0);");h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(d+1)/2;g++){const t=2*g;if(h+="\n           xC = xCCorner + ".concat(t*c,";\n           "),1===o){if(t<u&&(i%2===1?(h+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n               "),h+=1===c&&t>0?"\n                 xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                   } else {\n                     xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                   }\n                   ")):h+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xC").concat(t," = xTexelC").concat(t,";\n                 "),t+1<u)){const e=i%2===0?s.Df.nearestLargerEven(c):c;c%2===0&&i%2===1||c%2!==0&&i%2!==1?(h+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                     xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(t+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(t+1,"Ready = 1;\n                   }\n                   "),h+=c>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                     } else {\n                      xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                     }\n                     "):"\n                     xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                     ")):h+=1===e?"\n                     xC".concat(t+1," = xTexelC").concat(t,";\n                     "):"\n                     xCOffset = xC + ".concat(e,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                       xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(t+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(t+1,"Ready = 1;\n                     }\n\n                     xC").concat(t+1," = xTexelC").concat(t+1,";\n                     ")}}else t<u&&(i%2===1?(h+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n               "),t+1<u&&(h+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                 "))):(h+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(\n                   xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n               "),t+1<u&&(h+="\n                   xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                 "))));t<u&&(h+="\n             wTexel = getW(r, ".concat(t,", d1, d2);\n             dotProd += xC").concat(t,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(t,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),t+1<u&&(h+="\n               wTexel = getW(r, ".concat(t+1,", d1, d2);\n               dotProd += xC").concat(t+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(t+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let p="",f="";n&&(p=a?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):r?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(p,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(h,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(m,"\n         ").concat(f,"\n         setOutput(result);\n       }\n     ")}}class Zw{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=fy(this.outputShape.length);const{dataFormat:n}=t,a=jb(),r="channelsLast"===n,s=r?1:2,i=r?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {");let c="";for(let l=0;l<=1;l++)for(let e=0;e<=1;e++)c+="\n          blockIndex = rc.z + ".concat(e,";\n          pos = rc.y + ").concat(l,";\n\n          ").concat(o,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(s,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(i,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(r,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(c,"\n\n        ").concat(a.output," = result;\n      }\n    ")}}function Yw(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Jw(e){let{x:t,filter:n,convInfo:a,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:c=0,activation:l=null}=e;const u=t.shape,d=r.texData.get(t.dataId),h=a.inChannels,p=u[0]*u[1]*u[2],f=a.outChannels,m="channelsLast"===a.dataFormat;let g;const b=[];if(null!=o){const e=Yw(o.shape,m);null!=e&&(o=gx({inputs:{x:o},backend:r,attrs:{shape:e}}),b.push(o))}if(null!=i){const e=Yw(i.shape,m);null!=e&&(i=gx({inputs:{x:i},backend:r,attrs:{shape:e}}),b.push(i))}if(!((1===p||1===f)&&h>1e3)&&d.isPacked&&m&&null!=d.texture&&u[2]%2!==0&&s.Df.arraysEqual(d.shape.slice(-3),u.slice(-3))){const e=u[0]*u[1]*(u[2]+1),h={dataId:t.dataId,shape:[1,e,a.inChannels],dtype:t.dtype},p=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,s.Df.assert(Ob(d.shape,h.shape),()=>"packed reshape ".concat(d.shape," to ").concat(h.shape," isn't free"));const f=gx({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}});b.push(f);const m=Cx({a:h,b:f,backend:r,transposeA:!1,transposeB:!1,bias:i,activation:l,preluActivationWeights:o,leakyreluAlpha:c}),y=r.texData.get(m.dataId);s.Df.assert(y.isPacked,()=>"batchMatMul result is expected to be packed"),d.shape=p,y.shape=a.outShape,g=Yv({inputs:{x:m},backend:r}),g.shape=a.outShape,b.push(m)}else{const e=a.outHeight*a.outWidth,s=gx({inputs:{x:t},backend:r,attrs:{shape:m?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),u=gx({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}}),d=Cx({a:m?s:u,b:m?u:s,transposeA:!m,transposeB:!1,backend:r,bias:i,activation:l,preluActivationWeights:o,leakyreluAlpha:c});g=gx({inputs:{x:d},backend:r,attrs:{shape:a.outShape}}),b.push(s),b.push(u),b.push(d)}for(const s of b)r.disposeIntermediateTensorInfo(s);return g}function Qw(e){let{x:t,filter:n,convInfo:a,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:c=0,activation:l=null}=e;const{filterWidth:u,filterHeight:d,inChannels:h,outWidth:p,outHeight:f,dataFormat:m}=a,g="channelsLast"===m,b=u*d*h,y=f*p,v=[a.batchSize,b,y],x=[];if(null!=o){const e=Yw(o.shape,g);null!=e&&(o=gx({inputs:{x:o},backend:r,attrs:{shape:e}}),x.push(o))}if(null!=i){const e=Yw(i.shape,g);null!=e&&(i=gx({inputs:{x:i},backend:r,attrs:{shape:e}}),x.push(i))}const w=gx({inputs:{x:n},backend:r,attrs:{shape:[1,b,s.Df.sizeFromShape(n.shape)/b]}});x.push(w);const k=new Zw(v,a),I=[t.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],S=r.runWebGLProgram(k,[t],"float32",I),N=gx({inputs:{x:S},backend:r,attrs:{shape:v}});x.push(S),x.push(N);const T=null!=i,O=null!=o,C="leakyrelu"===l,E=l?cx(l,!0):null,_=new lx(g?N.shape:w.shape,g?w.shape:N.shape,g?[a.batchSize,y,a.outChannels]:[a.batchSize,a.outChannels,y],!0,!1,T,E,O,C),A=g?[N,w]:[w,N];if(i&&A.push(i),O&&A.push(o),C){const e=r.makeTensorInfo([],"float32",s.Df.createScalarValue(c,"float32"));A.push(e),x.push(e)}const R=r.runWebGLProgram(_,A,"float32"),D=gx({inputs:{x:R},backend:r,attrs:{shape:a.outShape}});x.push(R);for(const s of x)r.disposeIntermediateTensorInfo(s);return D}const $w={kernelName:s.C,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:o,pad:c,dataFormat:l,dilations:u,dimRoundingMode:d}=a,h=s.zd.convertConv2DDataFormat(l),p=s.zd.computeConv2DInfo(r.shape,i.shape,o,u,c,d,!1,h);let f;if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(p.strideWidth<=2&&"channelsLast"===h&&Object(s.be)().getBool("WEBGL_EXP_CONV")){const e=new Xw(p),t=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];f=n.runWebGLProgram(e,[r,i],"float32",t)}else if(Object(s.be)().getBool("WEBGL_CONV_IM2COL"))f=Qw({x:r,filter:i,convInfo:p,backend:n});else{const e=new qw(p);f=n.runWebGLProgram(e,[r,i],"float32")}else f=Jw({x:r,filter:i,convInfo:p,backend:n});const m=gx({inputs:{x:f},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(f),m}};class ek{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              if (").concat(s,") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class tk{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,c=s?1:2,l=s?2:3,u=s?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(c,"], coords[").concat(l,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(s,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class nk{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(r,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(s,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(a," - ").concat(i,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class ak{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,c=n-1-e.padInfo.top,l=a-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(o,", ").concat(c,", ").concat(l,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(r,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const rk={kernelName:s.D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:i}=t,{strides:o,pad:c,dataFormat:l,dimRoundingMode:u,filterShape:d}=a,h=s.zd.convertConv2DDataFormat(l),p=s.zd.computeConv2DInfo(r.shape,d,o,1,c,u,!1,h),f=new ek(p);return n.runWebGLProgram(f,[r,i],"float32")}};const sk={kernelName:s.E,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:i}=t,{inputShape:o,strides:c,pad:l,dataFormat:u,dimRoundingMode:d}=a,h=s.zd.convertConv2DDataFormat(u),p=s.zd.computeConv2DInfo(o,i.shape,c,1,l,d,!1,h),f=new tk(p);return n.runWebGLProgram(f,[r,i],"float32")}};const ik={kernelName:s.F,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:o,pad:c,dilations:l}=a,u=s.zd.computeConv3DInfo(r.shape,i.shape,o,l,c),d=new Kw(u);return n.runWebGLProgram(d,[r,i],"float32")}};const ok={kernelName:s.G,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:i}=t,{strides:o,pad:c,filterShape:l}=a,u=s.zd.computeConv3DInfo(r.shape,l,o,1,c),d=new nk(u);return n.runWebGLProgram(d,[r,i],"float32")}};const ck={kernelName:s.H,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:i}=t,{pad:o,strides:c,inputShape:l}=a,u=s.zd.computeConv3DInfo(l,i.shape,c,1,o),d=new ak(u);return n.runWebGLProgram(d,[r,i],"float32")}},lk=ix({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),uk={kernelName:s.I,backendName:"webgl",kernelFunc:lk},dk=ix({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),hk={kernelName:s.J,backendName:"webgl",kernelFunc:dk};class pk{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,i,o,c]=e,[l]=t,[u,d]=n;this.outputShape=[l,u,d,c];const h="bilinear"===a?1:0,[p,f]=["".concat(i-1,".0"),"".concat(o-1,".0")],[m,g,b]=u>1?["".concat((i-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[y,v,x]=d>1?["".concat((o-1)/(d-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(m,");\n      const float width_ratio = float(").concat(y,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(s,") {\n          return;\n        }\n\n        float height_scale = ").concat(g,";\n        float width_scale = ").concat(v,";\n\n        float in_y = ").concat(b,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n        float in_x = ").concat(x,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(h," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const fk={kernelName:s.K,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:c,extrapolationValue:l}=a,u=new pk(r.shape,s.shape,o,c,l);return n.runWebGLProgram(u,[r,s,i],"float32")}};var mk;!function(e){e.Prod="*",e.Sum="+"}(mk||(mk={}));class gk{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,s=this.op===mk.Prod?"1.0":"0.0",i=n?s:"getX(".concat(bk(r,"coords",this.op),")"),o=this.outputShape[this.outputShape.length-1];let c="",l="";n?(c=a?"end != ".concat(o-1):"end != 0",l=a?"end + 1":"end - 1"):(c=a?"end + pow2 < ".concat(o):"end >= pow2",l=a?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(oy(r)," coords = getOutputCoords();\n        int end = ").concat(yk(r,"coords",this.op),";\n        float val = ").concat(i,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c,") {\n          int idx = ").concat(l,";\n          ").concat(yk(r,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(bk(r,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function bk(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function yk(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function vk(e,t,n,a,r,i){const o=t.shape.length,c=s.zd.getAxesPermutation([a],o);let l=t;null!=c&&(l=Tx({inputs:{x:t},backend:n,attrs:{perm:c}}));const u=s.zd.getInnerMostAxes(1,o)[0];if(u!==o-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(a));const d=l.shape[u];let h=Yv({inputs:{x:l},backend:n});for(let s=0;s<=Math.ceil(Math.log2(d))-1;s++){const t=new gk(e,l.shape,!1,i),a=[[s]],r=h;h=n.runWebGLProgram(t,[h],h.dtype,a),n.disposeIntermediateTensorInfo(r)}if(r){const t=new gk(e,l.shape,r,i),a=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(a)}if(null!=c){const e=Tx({inputs:{x:h},backend:n,attrs:{perm:s.zd.getUndoAxesPermutation(c)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),e}return h}const xk={kernelName:s.L,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return vk(mk.Prod,r,n,s,i,o)}};const wk={kernelName:s.M,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return vk(mk.Sum,r,n,s,i,o)}};const kk={kernelName:s.O,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(s.dataId),a=Dy(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,a)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(s),a=Fy(e,t,i,o);return n.makeTensorInfo(a.shape,s.dtype,a.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};class Ik{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Sk={kernelName:s.P,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a,o=r.shape[0],c=("NHWC"===i?r.shape[1]:r.shape[2])*s,l=("NHWC"===i?r.shape[2]:r.shape[3])*s,u=("NHWC"===i?r.shape[3]:r.shape[1])/(s*s),d=new Ik("NHWC"===i?[o,c,l,u]:[o,u,c,l],s,i);return n.runWebGLProgram(d,[r],r.dtype)}};class Nk{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=fy(this.outputShape.length);const s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let c="",l="";n&&(c=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),l="result = activation(result);");const u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(c,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o,";\n        int q = d2 - d1 * ").concat(o,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(s,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(i,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(l,"\n        setOutput(result);\n      }\n    ")}}class Tk{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=fy(this.outputShape.length);const i=e.outChannels/e.inChannels,o=e.padInfo.left,c=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,d=e.filterWidth,h=d;let p="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let s=0;s<d;s++)p+="\n          vec4 xTexelC".concat(2*s,";\n          int xTexelC").concat(2*s,"Ready;\n          vec4 xTexelC").concat(2*s+1,";\n          int xTexelC").concat(2*s+1,"Ready;\n          vec4 xC").concat(s,";");p+="\n    for (int r = 0; r < ".concat(u,"; r++) {\n      ");for(let s=0;s<d;s++)p+="\n          xTexelC".concat(2*s," = vec4(0.0);\n          xTexelC").concat(2*s,"Ready = 0;\n          xTexelC").concat(2*s+1," = vec4(0.0);\n          xTexelC").concat(2*s+1,"Ready = 0;\n          xC").concat(s," = vec4(0.0);");p+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let b=0;b<(h+1)/2;b++){const e=2*b;if(p+="\n          xC = xCCorner + ".concat(e*l,";\n          "),1===c){if(e<d&&(o%2===1?(p+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n              "),p+=1===l&&e>0?"\n                xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                  } else {\n                    xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                  }\n                  ")):p+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xC").concat(e," = xTexelC").concat(e,";\n                "),e+1<d)){const t=o%2===0?s.Df.nearestLargerEven(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(p+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                    xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(e+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(e+1,"Ready = 1;\n                  }\n                  "),p+=l>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                    } else {\n                     xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                    }\n                    "):"\n                    xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                    ")):p+=1===t?"\n                    xC".concat(e+1," = xTexelC").concat(e,";\n                    "):"\n                    xCOffset = xC + ".concat(t,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                      xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(e+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(e+1,"Ready = 1;\n                    }\n\n                    xC").concat(e+1," = xTexelC").concat(e+1,";\n                    ")}}else e<d&&(o%2===1?(p+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n              "),e+1<d&&(p+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                "))):(p+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(\n                  xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n              "),e+1<d&&(p+="\n                  xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                "))));e<d&&(p+="\n            wTexel = getW(r, ".concat(e,", d1, q);\n            dotProd += xC").concat(e," * vec4(wTexel.xz, wTexel.xz);\n          "),e+1<d&&(p+="\n              wTexel = getW(r, ".concat(e+1,", d1, q);\n              dotProd += xC").concat(e+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}p+="\n    }\n  ",p+="\n      }\n    ";let f="",m="";n&&(f=a?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(f,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(i,";\n        int q = d2 - d1 * ").concat(i,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(p,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(g,"\n        ").concat(m,"\n        setOutput(result);\n      }\n    ")}}const Ok={kernelName:s.Q,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:o,pad:c,dilations:l,dimRoundingMode:u}=a;let d=l;null==d&&(d=[1,1]),s.Df.assert(s.zd.eitherStridesOrDilationsAreOne(o,d),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(o," and dilations '").concat(d,"'"));const h=s.zd.computeConv2DInfo(r.shape,i.shape,o,d,c,u,!0);let p;p=Object(s.be)().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new Tk(h):new Nk(h);const f=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(p,[r,i],"float32",f)}};class Ck{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(s," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class Ek{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(o,"; dm++) {\n              int d2 = d1 * ").concat(o," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const _k={kernelName:s.R,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:i}=t,{strides:o,dilations:c,pad:l,dimRoundingMode:u,filterShape:d}=a,h=s.zd.computeConv2DInfo(r.shape,d,o,c,l,u,!0),p=new Ck(h);return n.runWebGLProgram(p,[r,i],"float32")}};const Ak={kernelName:s.S,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:i}=t,{strides:o,dilations:c,pad:l,dimRoundingMode:u,inputShape:d}=a,h=s.zd.computeConv2DInfo(d,i.shape,o,c,l,u,!0),p=new Ek(h);return n.runWebGLProgram(p,[r,i],"float32")}};class Rk{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Dk={kernelName:s.T,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],i=s.Df.sizeFromShape(a.shape),o=gx({inputs:{x:a},backend:n,attrs:{shape:[i]}}),c=new Rk(i),l=n.runWebGLProgram(c,[o],o.dtype),u=gx({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}};class Fk{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:c,dilationWidth:l}=e,{top:u,left:d}=a;this.userCode="\n      const ivec2 strides = ivec2(".concat(r,", ").concat(s,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(d,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(i,"; h++) {\n          int hIn = hBeg + h * ").concat(c,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(o,"; w++) {\n              int wIn = wBeg + w * ").concat(l,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const Mk={kernelName:s.U,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i}=t,{strides:o,pad:c,dilations:l}=a,u=s.zd.computeDilation2DInfo(r.shape,i.shape,o,c,"NHWC",l);let d;const h=new Fk(u);d=n.runWebGLProgram(h,[r,i],"float32");const p=gx({inputs:{x:d},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(d),p}};const jk={kernelName:s.X,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,i=t,{allDims:o,summedDims:c,idDims:l}=s.zd.decodeEinsumEquation(r,i.length);s.zd.checkEinsumDimSizes(o.length,l,i);const{path:u,steps:d}=s.zd.getEinsumComputePath(c,l),h=d.length;let p=null,f=o.length;const m=[];for(let g=0;g<h;++g){for(const e of d[g]){const{permutationIndices:t,expandDims:a}=s.zd.getEinsumPermutation(f,l[e]);let r;s.zd.isIdentityPermutation(t)?r=i[e]:(r=Tx({inputs:{x:i[e]},backend:n,attrs:{perm:t}}),m.push(r));const o=r.shape.slice();for(let e=0;e<a.length;++e)o.splice(a[e],0,1);s.Df.arraysEqual(r.shape,o)||(r=gx({inputs:{x:r},backend:n,attrs:{shape:o}}),m.push(r)),null===p?p=r:(p=fx({inputs:{a:r,b:p},backend:n}),m.push(p))}g<h-1&&(u[g]>=0&&(p=Sx({inputs:{x:p},backend:n,attrs:{axis:u[g]-(o.length-f),keepDims:!1}}),m.push(p)),f--)}for(const s of m)s!==p&&n.disposeIntermediateTensorInfo(s);return p}},zk=ix({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Lk={kernelName:s.Y,backendName:"webgl",kernelFunc:zk},Pk={kernelName:s.Z,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:r}=t,i=Object(s.be)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zv("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,r.shape):new Xv("return (b >= 1.0) ? a : a * (b + 1.0);",a.shape,r.shape);return n.runWebGLProgram(i,[a,r],a.dtype)}},Bk=ox({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Ly}),Wk={kernelName:s.ab,backendName:"webgl",kernelFunc:Bk},Uk=ix({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(s.zd.ERF_P,";\n  float a1 = ").concat(s.zd.ERF_A1,";\n  float a2 = ").concat(s.zd.ERF_A2,";\n  float a3 = ").concat(s.zd.ERF_A3,";\n  float a4 = ").concat(s.zd.ERF_A4,";\n  float a5 = ").concat(s.zd.ERF_A5,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),Vk={kernelName:s.bb,backendName:"webgl",kernelFunc:Uk},Gk=ix({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Py,dtype:"float32"}),Hk={kernelName:s.cb,backendName:"webgl",kernelFunc:Gk};function qk(e){const{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:i}=t,o=i.shape.length,c=i.shape.slice();let l=r;return r<0&&(s.Df.assert(-(o+1)<=r,()=>"Axis must be in the interval [".concat(-(o+1),", ").concat(o,"]")),l=o+r+1),c.splice(l,0,1),gx({inputs:{x:i},backend:a,attrs:{shape:c}})}const Kk={kernelName:s.db,backendName:"webgl",kernelFunc:qk},Xk="return exp(x) - 1.0;",Zk=ix({opSnippet:Xk,packedOpSnippet:Xk,cpuKernelImpl:By}),Yk={kernelName:s.eb,backendName:"webgl",kernelFunc:Zk};class Jk{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const r=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),s=n?"".concat(a,".0"):"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '.concat(e,"."));i="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(r,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(i,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(a,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(s,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function Qk(e,t,n){const a=n.texData.get(e.dataId),r=s.Df.sizeFromShape(e.shape),i=e.shape[e.shape.length-1],o=gx({inputs:{x:e},backend:n,attrs:{shape:[r/i,i]}}),c=o.shape,l=new Jk("real",c,t),u=new Jk("imag",c,t),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:c},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:c}],h=n.runWebGLProgram(l,d,"float32"),p=n.runWebGLProgram(u,d,"float32"),f=Qv({inputs:{real:h,imag:p},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p);const m=gx({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}const $k={kernelName:s.fb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Qk(a,!1,n)}};class eI{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function tI(e){const{backend:t,attrs:n}=e,{shape:a,value:r}=n;let{dtype:i}=n;if(i=i||s.Df.inferDtype(r),"string"===i){const e=s.Df.getArrayFromDType(i,s.Df.sizeFromShape(a));return e.fill(r),t.makeTensorInfo(a,i,e)}{const e=new eI(a,r),n=[[r]];return t.runWebGLProgram(e,[],i,n)}}const nI={kernelName:s.gb,backendName:"webgl",kernelFunc:tI};class aI{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const rI={kernelName:s.hb,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:a}=t,r=n,s=new aI(a.shape);return r.runWebGLProgram(s,[a],a.dtype)}},sI="return floor(x);",iI=ix({opSnippet:sI,packedOpSnippet:sI,cpuKernelImpl:Wy}),oI={kernelName:s.ib,backendName:"webgl",kernelFunc:iI},cI=ox({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),lI={kernelName:s.jb,backendName:"webgl",kernelFunc:cI};class uI{constructor(e){this.variableNames=["A"];const t=jb(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(a,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class dI{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=jb(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(a,".0, ").concat(n,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}const hI={kernelName:s.kb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:r}=t;const{numChannels:i}=a,o="undefined"!==typeof HTMLVideoElement&&r instanceof HTMLVideoElement,c="undefined"!==typeof HTMLImageElement&&r instanceof HTMLImageElement,[l,u]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[u,l],h=[u,l,i];if(c||o){const e=Object(s.be)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=pI&&e===fI||(fI=e,pI=document.createElement("canvas").getContext("2d",{willReadFrequently:fI})),pI.canvas.width=l,pI.canvas.height=u,pI.drawImage(r,0,0,l,u),r=pI.canvas}const p=n.makeTensorInfo(d,"int32");n.texData.get(p.dataId).usage=rb.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),r);const f=Object(s.be)().getBool("WEBGL_PACK")?new dI(h):new uI(h),m=n.runWebGLProgram(f,[p],"int32");return n.disposeData(p.dataId),m}};let pI,fI=Object(s.be)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const mI={kernelName:s.mb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i,bias:o,preluActivationWeights:c}=t,{strides:l,pad:u,dataFormat:d,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=a,g=s.zd.convertConv2DDataFormat(d),b=s.zd.computeConv2DInfo(r.shape,i.shape,l,h,u,p,!1,g);let y;const v=[],x=null!=o,w=null!=c,k="leakyrelu"===f,I=()=>{const e=[r,i],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=gx({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return v.push(t),t}return e};if(x&&e.push(t(o,d)),w&&e.push(t(c,d)),k){const t=n.makeTensorInfo([],"float32",s.Df.createScalarValue(m,"float32"));e.push(t),v.push(t)}return e};if(1!==b.filterHeight||1!==b.filterWidth||1!==b.dilationHeight||1!==b.dilationWidth||1!==b.strideHeight||1!==b.strideWidth||"SAME"!==b.padInfo.type&&"VALID"!==b.padInfo.type)if(b.strideWidth<=2&&"channelsLast"===g&&Object(s.be)().getBool("WEBGL_EXP_CONV")){const e=f?cx(f,!0):null,t=new Xw(b,x,e,w,k),a=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],r=I();y=n.runWebGLProgram(t,r,"float32",a)}else if(Object(s.be)().getBool("WEBGL_CONV_IM2COL"))y=Qw({x:r,filter:i,convInfo:b,backend:n,bias:o,activation:f,preluActivationWeights:c,leakyreluAlpha:m});else{const e=f?cx(f,!1):null,t=new qw(b,x,e,w,k),a=I();y=n.runWebGLProgram(t,a,"float32")}else y=Jw({x:r,filter:i,convInfo:b,backend:n,bias:o,activation:f,preluActivationWeights:c,leakyreluAlpha:m});const S=gx({inputs:{x:y},backend:n,attrs:{shape:b.outShape}});return v.push(y),v.forEach(e=>n.disposeIntermediateTensorInfo(e)),S}};const gI={kernelName:s.nb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:i,bias:o,preluActivationWeights:c}=t,{strides:l,pad:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a,m=[];let g=d;null==g&&(g=[1,1]),s.Df.assert(s.zd.eitherStridesOrDilationsAreOne(l,g),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(l," and dilations '").concat(g,"'"));const b=s.zd.computeConv2DInfo(r.shape,i.shape,l,g,u,h,!0),y=Object(s.be)().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels===1,v=p?cx(p,y):null,x=[r,i],w=null!=o,k=null!=c,I="leakyrelu"===p;if(w&&x.push(o),k&&x.push(c),I){const e=n.makeTensorInfo([],"float32",s.Df.createScalarValue(f,"float32"));x.push(e),m.push(e)}let S;S=y?new Tk(b,w,v,k,I):new Nk(b,w,v,k,I);const N=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],T=n.runWebGLProgram(S,x,"float32",N);return m.forEach(e=>n.disposeIntermediateTensorInfo(e)),T}};class bI{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;const r=oy(n.length);let s="\n    int index;";for(let i=0;i<this.sliceDim;i++)s+="\n          index = round(getIndices(coords[0], ".concat(i,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[i],";\n          flattenIndex += index * ").concat(this.strides[i],";");this.userCode="\n         void main() {\n          ".concat(r," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(s,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const yI={kernelName:s.ob,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,i=r.shape,o=i[i.length-1],c=s.Df.sizeFromShape(a.shape),[l,u,d,h]=s.zd.prepareAndValidate(a,r),p=gx({inputs:{x:r},backend:n,attrs:{shape:[u,o]}}),f=gx({inputs:{x:a},backend:n,attrs:{shape:[s.Df.sizeFromShape(a.shape)/d,d]}});if(n.shouldExecuteOnCPU([a,r])||"string"===a.dtype){const e=n.readSync(r.dataId),t=n.bufferSync(a),s=Uy(e,t,a.dtype,u,o,d,h,a.shape,c);return n.makeTensorInfo(l,a.dtype,s.values)}const m=new bI(o,h,[u,d],a.shape),g=n.runWebGLProgram(m,[f,p],f.dtype),b=gx({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),b}};class vI{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=oy(this.rank),a=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)2===r?a.push("index"):a.push("".concat(n[r]));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a,"));\n      }\n    ")}}function xI(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:i}=t,{axis:o,batchDims:c}=a,l=s.Df.parseAxisParam(o,r.shape)[0];if(Object(s.be)().get("DEBUG")){const e=n.readSync(i.dataId),t=r.shape[l];for(let n=0;n<e.length;++n){const a=e[n];s.Df.assert(a<=t-1&&a>=0,()=>"GatherV2: the index value ".concat(a," is not in [0, ").concat(t-1,"]"))}}const u=s.zd.segment_util.collectGatherOpShapeInfo(r,i,l,c),d=s.Df.sizeFromShape(i.shape),h=[],p=gx({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=gx({inputs:{x:i},backend:n,attrs:{shape:[u.batchSize,d/u.batchSize]}});h.push(p),h.push(f);const m=[u.batchSize,u.outerSize,d/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,i])||"string"===r.dtype){const e=n.bufferSync(f),t=n.bufferSync(p),a=Vy(t,e,m);return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u.outputShape,a.dtype,a.values)}const g=new vI(p.shape,m),b=n.runWebGLProgram(g,[p,f],p.dtype);h.push(b);const y=gx({inputs:{x:b},backend:n,attrs:{shape:u.outputShape}});return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}const wI={kernelName:s.pb,backendName:"webgl",kernelFunc:xI},kI=ox({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Gy,dtype:"bool"}),II={kernelName:s.qb,backendName:"webgl",kernelFunc:kI},SI=ox({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Hy}),NI={kernelName:s.rb,backendName:"webgl",kernelFunc:SI};const TI={kernelName:s.sb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Qk(a,!0,n)}},OI=ix({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),CI={kernelName:s.vb,backendName:"webgl",kernelFunc:OI},EI=ix({opSnippet:"return float(isinf(x));",dtype:"bool"}),_I={kernelName:s.wb,backendName:"webgl",kernelFunc:EI},AI=ix({opSnippet:"return float(isnan(x));",dtype:"bool"}),RI={kernelName:s.xb,backendName:"webgl",kernelFunc:AI},DI=ox({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:qy,dtype:"bool"}),FI={kernelName:s.Cb,backendName:"webgl",kernelFunc:DI},MI=ox({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Ky,dtype:"bool"}),jI={kernelName:s.Db,backendName:"webgl",kernelFunc:MI};const zI={kernelName:s.Eb,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=Xy(a,r,s);return t.makeTensorInfo([i.length],"float32",i)}},LI=ix({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:Zy}),PI={kernelName:s.Fb,backendName:"webgl",kernelFunc:LI},BI=ix({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),WI={kernelName:s.Gb,backendName:"webgl",kernelFunc:BI},UI=ox({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),VI={kernelName:s.Hb,backendName:"webgl",kernelFunc:UI},GI=ix({opSnippet:"return float(!(x >= 1.0));"}),HI={kernelName:s.Ib,backendName:"webgl",kernelFunc:GI},qI=ox({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),KI={kernelName:s.Jb,backendName:"webgl",kernelFunc:qI};class XI{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];const s=t,i=e[3]-1;let o;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");o=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(s,"; j <= ").concat(s,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(i,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(o,";\n        setOutput(val);\n      }\n    ")}}class ZI{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=t,i=e[3]-1;let o;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");o=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(s,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(s,"; j <= ").concat(s,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(i,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(o,";\n        setOutput(result);\n      }\n    ")}}const YI={kernelName:s.zb,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:i,bias:o,alpha:c,beta:l}=a,u=Object(s.be)().getBool("WEBGL_PACK_NORMALIZATION")?new ZI(r.shape,i,o,c,l):new XI(r.shape,i,o,c,l);return n.runWebGLProgram(u,[r],r.dtype)}};class JI{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a,")\n                * float(").concat(r,")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(r,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const QI={kernelName:s.Ab,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:c,alpha:l,beta:u}=a,d=new JI(r.shape,o,c,l,u);return n.runWebGLProgram(d,[r,s,i],r.dtype)}};function $I(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:i,keepDims:o}=a,c=r.shape.length,l=s.Df.parseAxisParam(i,r.shape);let u=l;const d=s.zd.getAxesPermutation(u,c),h=null!=d,p=n.shouldExecuteOnCPU([r]);let f=r;if(h){if(p){const e=n.texData.get(f.dataId).values,t=new Array(c);for(let n=0;n<t.length;n++)t[n]=r.shape[d[n]];const a=kv(e,r.shape,r.dtype,d,t);f=n.makeTensorInfo(t,r.dtype);n.texData.get(f.dataId).values=a}else f=Ix(r,d,n);u=s.zd.getInnerMostAxes(u.length,c)}s.zd.assertAxesAreInnerMostDims("max",u,c);const[m,g]=s.zd.computeOutAndReduceShapes(f.shape,u);let b,y=m;if(o&&(y=s.zd.expandShapeToKeepDim(m,l)),p){const e=n.texData.get(f.dataId).values,t=Yy(e,s.Df.sizeFromShape(g),y,r.dtype);b=n.makeTensorInfo(y,r.dtype);n.texData.get(b.dataId).values=t}else b=function(e,t,n,a){const r=s.Df.sizeFromShape(t),i=gx({inputs:{x:e},attrs:{shape:[s.Df.sizeFromShape(e.shape)/r,r]},backend:a}),o=xx(i,e.dtype,"max",a),c=gx({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),c}(f,g,y,n);return h&&n.disposeIntermediateTensorInfo(f),b}const eS={kernelName:s.Kb,backendName:"webgl",kernelFunc:$I},tS=ox({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Jy}),nS={kernelName:s.Qb,backendName:"webgl",kernelFunc:tS};const aS={kernelName:s.Lb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;Fb(r,"maxPool");const{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=a;s.Df.assert(s.zd.eitherStridesOrDilationsAreOne(o,1),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'"));const u=s.zd.computePool2DInfo(r.shape,i,o,1,c,l);if(1===u.filterWidth&&1===u.filterHeight&&s.Df.arraysEqual(u.inShape,u.outShape))return Yv({inputs:{x:r},backend:n});const d=new rw(u,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}};const rS={kernelName:s.Mb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:i,strides:o,pad:c,dataFormat:l,dimRoundingMode:u}=a,d=s.zd.computePool3DInfo(r.shape,i,o,[1,1,1],c,u,l),h=new sw(d,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}};class sS{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=r-1-e.padInfo.top,o=s-1-e.padInfo.left,c=r*s-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(r,";\n          wR += ").concat(a,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(s,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(c," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(s," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class iS{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.front,d=c-1-e.padInfo.top,h=l-1-e.padInfo.left,p=o*c*l-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(d,", ").concat(h,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(o,";\n           wD += ").concat(r,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(c,";\n              wR += ").concat(s,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(l,";\n                wC += ").concat(i,") {\n              float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(c," * ").concat(l," +\n                  wR * ").concat(l," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const oS={kernelName:s.Nb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i}=t,o=i,{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=a,h=s.zd.computePool3DInfo(o.shape,c,l,[1,1,1],u,d),p=new sw(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new iS(h),g=n.runWebGLProgram(m,[r,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};const cS={kernelName:s.Ob,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:i,output:o}=t,c=i;Fb([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:d,dimRoundingMode:h}=a,p=s.zd.computePool2DInfo(c.shape,l,u,1,d,h),f=new rw(p,"max",!0),m=n.runWebGLProgram(f,[c],c.dtype),g=new sS(p),b=n.runWebGLProgram(g,[r,m],c.dtype);return n.disposeIntermediateTensorInfo(m),b}};const lS={kernelName:s.Pb,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:i,strides:o,pad:c,includeBatchInIndex:l}=n,u=a;s.Df.assert(4===r.shape.length,()=>"Error in maxPool: input must be rank 4 but got rank ".concat(r.shape.length,"."));const d=[1,1];s.Df.assert(s.zd.eitherStridesOrDilationsAreOne(o,d),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(d,"'"));const h=s.zd.computePool2DInfo(r.shape,i,o,d,c),[p,f]=function(e,t,n,a){let r=new rw(n,"max",!1);const s=a.runWebGLProgram(r,[e],"float32");return r=new rw(n,"max",!0,!0,t),[s,a.runWebGLProgram(r,[e],"float32")]}(r,l,h,u);return[p,f]}};const uS={kernelName:s.Rb,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{keepDims:i,axis:o}=n,c=a,l=r.shape.length,u=s.Df.parseAxisParam(o,r.shape);let d=u;const h=s.zd.getAxesPermutation(d,l),p=null!=h,f=c.shouldExecuteOnCPU([r]),m=[];let g=r;if(p){if(f){const e=c.texData.get(g.dataId).values,t=new Array(l);for(let a=0;a<t.length;a++)t[a]=r.shape[h[a]];const n=kv(e,r.shape,r.dtype,h,t);g=c.makeTensorInfo(t,r.dtype);c.texData.get(g.dataId).values=n}else g=Ix(r,h,c);m.push(g),d=s.zd.getInnerMostAxes(d.length,l)}s.zd.assertAxesAreInnerMostDims("sum",d,l);const[b,y]=s.zd.computeOutAndReduceShapes(g.shape,d);let v=b;i&&(v=s.zd.expandShapeToKeepDim(b,u));const x=function(e,t,n,a){const r=s.Df.sizeFromShape(t),i=gx({inputs:{x:e},attrs:{shape:[s.Df.sizeFromShape(e.shape)/r,r]},backend:a}),o=xx(i,"float32","mean",a),c=gx({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),c}(g,y,v,c);for(const s of m)c.disposeIntermediateTensorInfo(s);return x}};const dS={kernelName:s.Sb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:o}=a,c=r.shape.length,l=s.Df.parseAxisParam(i,r.shape);let u=l;const d=s.zd.getAxesPermutation(u,c);let h=r;null!=d&&(h=Tx({inputs:{x:r},backend:n,attrs:{perm:d}}),u=s.zd.getInnerMostAxes(u.length,r.shape.length)),s.zd.assertAxesAreInnerMostDims("min",u,c);const[p,f]=s.zd.computeOutAndReduceShapes(h.shape,u),m=gx({inputs:{x:h},backend:n,attrs:{shape:[-1,s.Df.sizeFromShape(f)]}}),g=xx(m,m.dtype,"min",n);let b;if(o){b=gx({inputs:{x:g},backend:n,attrs:{shape:s.zd.expandShapeToKeepDim(p,l)}})}else b=gx({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(h),b}},hS=ox({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Qy}),pS={kernelName:s.Tb,backendName:"webgl",kernelFunc:hS};class fS{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const a=e.length,r=oy(a),s=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),c="reflect"===n?0:1;this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(s,");\n      ").concat(r," end = ").concat(r,"(").concat(i,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(c,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(c,";\n          }\n        }\n        ").concat(r," coords = outC - start;\n        setOutput(getX(").concat(o,"));\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(c,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(c,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class mS{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const a=e.length,r=oy(a),s=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=Nv("rc",a),c=Nv("source",a),l="".concat(o[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),d="reflect"===n?0:1;let h="";if(1===a){const e="\n        ".concat(r," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(d,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(d,";\n        }\n        source -= start;\n      ");h="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(o[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ")}else{const e="\n        ".concat(r," source = rc;\n        ").concat(r," lt = ").concat(r,"(lessThan(source, start));\n        ").concat(r," gte = ").concat(r,"(greaterThanEqual(source, end));\n        ").concat(r," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(d,") +\n                gte * ((end - 1) * 2 - source + ").concat(d,");\n        source -= start;\n      ");h="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(o[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(o[a-2]," += 1;\n        if(").concat(o[a-2]," < ").concat(this.outputShape[a-2],") {\n          ").concat(e,"\n          result[2] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          ").concat(o[a-1]," += 1;\n          if(").concat(l,") {\n            ").concat(e,"\n            result[3] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(s,");\n      const ").concat(r," end = ").concat(r,"(").concat(i,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(h,"\n        setOutput(result);\n      }\n    ")}}const gS={kernelName:s.Ub,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r}=t,{paddings:i,mode:o}=a,c=Object(s.be)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mS(r.shape,i,o):new fS(r.shape,i,o);return n.runWebGLProgram(c,[r],r.dtype)}},bS=ox({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),yS={kernelName:s.Vb,backendName:"webgl",kernelFunc:bS};class vS{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}}const xS=ox({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),wS={kernelName:s.pc,backendName:"webgl",kernelFunc:xS},kS="return a - b;",IS=ox({opSnippet:kS,packedOpSnippet:kS,supportsComplex:!0,cpuKernelImpl:vv}),SS={kernelName:s.cd,backendName:"webgl",kernelFunc:IS};function NS(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:i}=a,o=s.Df.parseAxisParam([i],r.shape),c=$I({inputs:{x:r},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=s.zd.expandShapeToKeepDim(c.shape,o),u=gx({inputs:{x:c},backend:n,attrs:{shape:l}}),d=IS({inputs:{a:r,b:u},backend:n}),h=Gk({inputs:{x:d},backend:n}),p=Sx({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:!1}}),f=gx({inputs:{x:p},backend:n,attrs:{shape:l}}),m=xS({inputs:{a:h,b:f},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}const TS={kernelName:s.Lc,backendName:"webgl",kernelFunc:NS};const OS={kernelName:s.Wb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a,c=o?r:NS({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=c.shape[0],u=c.shape[1],d=new vS(l,u,s),h=[[i]],p=n.runWebGLProgram(d,[c],"int32",h);return o||n.disposeIntermediateTensorInfo(c),p}};const CS={kernelName:s.Yb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.texData.get(a.dataId),[t,r]=ev(e.values,a.shape,a.dtype);return n.makeTensorInfo(r,a.dtype,t)}let r;return r=Object(s.be)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Uv(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Rv(a.shape,"if (isnan(x)) return x;\n  return -x;\n"),n.runWebGLProgram(r,[a],a.dtype)}},ES=s.pe.nonMaxSuppressionV3Impl;const _S={kernelName:s.Zb,backendName:"webgl",kernelFunc:function(e){s.zd.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:c,scoreThreshold:l}=a,u=n.readSync(r.dataId),d=n.readSync(i.dataId),{selectedIndices:h}=ES(u,d,o,c,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},AS=s.pe.nonMaxSuppressionV4Impl;const RS={kernelName:s.ac,backendName:"webgl",kernelFunc:function(e){s.zd.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:c,scoreThreshold:l,padToMaxOutputSize:u}=a,d=n.readSync(r.dataId),h=n.readSync(i.dataId),{selectedIndices:p,validOutputs:f}=AS(d,h,o,c,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}},DS=s.pe.nonMaxSuppressionV5Impl;const FS={kernelName:s.bc,backendName:"webgl",kernelFunc:function(e){s.zd.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:c,scoreThreshold:l,softNmsSigma:u}=a,d=n.readSync(r.dataId),h=n.readSync(i.dataId),p=o,f=c,m=l,g=u,{selectedIndices:b,selectedScores:y}=DS(d,h,p,f,m,g);return[n.makeTensorInfo([b.length],"int32",new Int32Array(b)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class MS{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const jS={kernelName:s.dc,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:i,depth:o,onValue:c,offValue:l}=a,u=s.Df.sizeFromShape(r.shape),d=new MS(u,o,c,l),h=gx({inputs:{x:r},backend:n,attrs:{shape:[u]}}),p=n.runWebGLProgram(d,[h],i);n.disposeIntermediateTensorInfo(h);const f=gx({inputs:{x:p},backend:n,attrs:{shape:[...r.shape,o]}});return n.disposeIntermediateTensorInfo(p),f}};function zS(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=Tw({inputs:{input:a},backend:n}),t=zS({inputs:{x:e},backend:n}),r=Ww({inputs:{input:a},backend:n}),s=zS({inputs:{x:r},backend:n}),i=Qv({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}return tI({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const LS={kernelName:s.pd,backendName:"webgl",kernelFunc:zS};const PS={kernelName:s.ec,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const t=Tw({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),s=Ww({inputs:{input:r},backend:a}),i=zS({inputs:{x:s},backend:a}),o=Qv({inputs:{real:n,imag:i},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(i),o}return tI({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}};const BS={kernelName:s.gc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return qk({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(e=>{s.Df.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),s.Df.assert(o===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const c=[],l=Gw({inputs:t.map(e=>{const t=qk({inputs:{input:e},backend:n,attrs:{dim:r}});return c.push(t),t}),backend:n,attrs:{axis:r}});return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}};class WS{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const a=e.length,r=oy(a),s=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(s,");\n      ").concat(r," end = ").concat(r,"(").concat(i,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(r," coords = outC - start;\n          setOutput(getX(").concat(o,"));\n        }\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class US{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const a=e.length,r=oy(a),s=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=Nv("rc",a),c=Nv("source",a),l="".concat(o[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),d=["".concat(r," rc = outputLoc;"),"".concat(o[a-1]," += 1;\n       if(").concat(l,") {\n      "),1===a?"":"}\n       rc = outputLoc;\n       ".concat(o[a-2]," += 1;\n       if(").concat(o[a-2]," < ").concat(this.outputShape[a-2],") {"),1===a?"":"  ".concat(o[a-1]," += 1;\n         if(").concat(l,") {")],h=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===a?2:4;f<m;f++)p+="\n        ".concat(d[f],"\n        if (").concat(h,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(r," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ");p+=1===a?"} ":"}}",this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(s,");\n      const ").concat(r," end = ").concat(r,"(").concat(i,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const VS=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:i,constantValue:o}=a;if(0===s.Df.sizeFromShape(r.shape)){return tI({backend:n,attrs:{shape:i.map((e,t)=>e[0]+r.shape[t]+e[1]),value:o,dtype:r.dtype}})}const c=Object(s.be)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new US(r.shape,i,o):new WS(r.shape,i,o),l=[[o]];return n.runWebGLProgram(c,[r],r.dtype,l)},GS={kernelName:s.hc,backendName:"webgl",kernelFunc:VS},HS=ox({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),qS={kernelName:s.ic,backendName:"webgl",kernelFunc:HS};const KS={kernelName:s.kc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:i,keepDims:o}=a,c=r.shape.length,l=[],u=s.Df.parseAxisParam(i,r.shape);let d=u;const h=s.zd.getAxesPermutation(d,c);let p,f=r;if(null!=h&&(f=Tx({inputs:{x:r},backend:n,attrs:{perm:h}}),d=s.zd.getInnerMostAxes(d.length,c),l.push(f)),s.zd.assertAxesAreInnerMostDims("prod",d,c),n.shouldExecuteOnCPU([f])){const e=n.texData.get(f.dataId).values,{outVals:t,outShape:a,outDtype:r}=nv(f.shape,f.dtype,e,d);p=n.makeTensorInfo(a,r,t)}else{const[e,t]=s.zd.computeOutAndReduceShapes(f.shape,d),a=s.Df.sizeFromShape(t),i=gx({inputs:{x:f},backend:n,attrs:{shape:[-1,a]}}),o=xx(i,Object(s.qf)(r.dtype),"prod",n);p=gx({inputs:{x:o},backend:n,attrs:{shape:e}}),l.push(i),l.push(o)}if(o){l.push(p);const e=s.zd.expandShapeToKeepDim(p.shape,u);p=gx({inputs:{x:p},backend:n,attrs:{shape:e}})}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}};const XS={kernelName:s.lc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,c=r.map(e=>n.readSync(e.dataId)),l=r.map(e=>e.shape),u=n.readSync(s.dataId),d=n.readSync(i.dataId),[h,p,f]=av(c,l,u,s.shape,s.dtype,d,i.shape,o),m=h.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};const ZS={kernelName:s.mc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:c}=a,l=n.readSync(r.dataId),u=n.readSync(s.dataId),d=n.readSync(i.dataId),h=o.map(e=>n.readSync(e.dataId)),p=o.map(e=>e.shape),[f,m]=rv(l,r.shape,u,s.shape,s.dtype,d,i.shape,h,p,c);return n.makeTensorInfo(f,s.dtype,m)}},YS=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=sv(a,r,s,i);return t.makeTensorInfo([o.length],i,o)},JS={kernelName:s.nc,backendName:"webgl",kernelFunc:YS},QS=ix({opSnippet:"return 1.0 / x;"}),$S={kernelName:s.qc,backendName:"webgl",kernelFunc:QS},eN=ix({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),tN={kernelName:s.rc,backendName:"webgl",kernelFunc:eN},nN=ix({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),aN={kernelName:s.sc,backendName:"webgl",kernelFunc:nN};class rN{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[s,i,o,c]=e;this.outputShape=[s,t,n,c];const l=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(i,".0, ").concat(o,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class sN{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,c]=e;this.outputShape=[s,t,n,c];const l=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(i,".0, ").concat(o,".0,\n                                     ").concat(o,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const iN={kernelName:s.uc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:c}=a,[l,u]=c,d=Object(s.be)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new sN(r.shape,l,u,i,o):new rN(r.shape,l,u,i,o);return n.runWebGLProgram(d,[r],"float32")}};class oN{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],c=[n&&s>1?s-1:s,n&&i>1?i-1:i],l=o[0]/c[0],u=o[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(a-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(r-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const cN={kernelName:s.vc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new oN(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}};class lN{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[s,i,o,c]=e;this.outputShape=[s,t,n,c];const l=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let h;h=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(i,".0, ").concat(o,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(d,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class uN{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,c]=e;this.outputShape=[s,t,n,c];const l=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let h;h=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(i,".0, ").concat(o,".0,\n                                     ").concat(o,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(d,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const dN={kernelName:s.wc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:c}=a,[l,u]=c,d=Object(s.be)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new uN(r.shape,l,u,i,o):new lN(r.shape,l,u,i,o);return n.runWebGLProgram(d,[r],r.dtype)}};class hN{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],c=[n&&s>1?s-1:s,n&&i>1?i-1:i],l=o[0]/c[0],u=o[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(o[0],") *\n                (float(dyR) / float(").concat(c[0],"));\n\n            float sourceFracCol =\n                float(").concat(o[1],") *\n                  (float(dyC) / float(").concat(c[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const pN={kernelName:s.xc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new hN(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}};class fN{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=e,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      "));const a=e.map((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(a)).join(","),r=oy(n);this.userCode="\n      void main() {\n        ".concat(r," coords = getOutputCoords();\n        setOutput(getX(").concat(a,"));\n      }\n    ")}}class mN{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=e;const a=Nv("rc",n),r="".concat(a[n-1]," + 1 < ").concat(this.outputShape[n-1]),s="".concat(a[n-2]," + 1 < ").concat(this.outputShape[n-2]),i=oy(n);function o(n){const a=e.map((a,r)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - ").concat(a[n]," - 1"):"".concat(a[n])}(r,n)),r=a.join(","),s=a.slice(-2).join(",");return"getChannel(getX(".concat(r,"), vec2(").concat(s,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(r,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(i," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e){return o(e)}(a.slice()),";\n          if(").concat(r,"){\n            result.g = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(a.slice()),";\n          }\n          if(").concat(s,") {\n            result.b = ").concat(function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(a.slice()),";\n            if(").concat(r,") {\n              result.a = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(a.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const gN={kernelName:s.yc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:i}=a,o=r.shape.length,c=s.Df.parseAxisParam(i,r.shape);if(0===o)return Yv({inputs:{x:r},backend:n});const l=Object(s.be)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mN(r.shape,c):new fN(r.shape,c);return n.runWebGLProgram(l,[r],r.dtype)}};class bN{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],a=e[2];this.outputShape=e;let r="";r="number"===typeof t?"float outputValue = ".concat(t.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(t.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(r,"\n          if(coordX >= 0 && coordX < ").concat(a," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const yN={kernelName:s.zc,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:i,fillValue:o,center:c}=n,l=a,u=new bN(r.shape,o),[d,h]=s.zd.getImageCenter(c,r.shape[1],r.shape[2]),p=[[d,h,Math.sin(i),Math.cos(i)]];return l.runWebGLProgram(u,[r],r.dtype,p)}},vN=ix({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),xN={kernelName:s.Ac,backendName:"webgl",kernelFunc:vN},wN=ix({opSnippet:"return inversesqrt(x);",cpuKernelImpl:iv}),kN={kernelName:s.Bc,backendName:"webgl",kernelFunc:wN};class IN{constructor(e,t,n,a,r,s){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const i=oy(r.length),o=oy(s.length);let c="";1===n?c="i":2===n&&(c="i, j");const l="getIndices(".concat(c,")");let u="";1===a?u="i":2===a&&(u="i, coords[1]");const d="getUpdates(".concat(u,")"),h=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(r,");\n\n        void main() {\n          ").concat(o," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(l,");\n              flattenedIndex += index * ").concat(h,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(d,";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ")}}const SN={kernelName:s.Cc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:i}=t,{shape:o}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=s.zd.calculateShapes(i,r,o),p=[h/u,u];if(0===h)return n.makeTensorInfo(o,r.dtype);const f=gx({inputs:{x:r},backend:n,attrs:{shape:[l,c]}}),m=gx({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0])),b=new IN(l,c,f.shape.length,m.shape.length,d,p),y=n.runWebGLProgram(b,[m,f,g],m.dtype),v=gx({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(g),v}};class NN{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const r="for (int i = 0; i < ".concat(Math.ceil(Math.log2(t+1)),"; ++i) { if (left >= right) break;"),i=2===Object(s.be)().getNumber("WEBGL_VERSION")?"while (left < right) {":r,o="left"===a?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(i,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(o," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const TN={kernelName:s.Dc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=new NN(r.shape[0],r.shape[1],s.shape[1],i),c=[[r.shape[1]]];return n.runWebGLProgram(o,[r,s],"int32",c)}};class ON{constructor(e,t,n){let a,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)r="resRC",a="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let a=0;a<t.length;a++)i.push("".concat(n[a])),a<e&&s.push("".concat(n[a]));a=s.join(),r=i.join()}const s=oy(n);this.userCode="\n      void main() {\n        ".concat(s," resRC = getOutputCoords();\n        float cVal = getC(").concat(a,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(r,"));\n        } else {\n          setOutput(getB(").concat(r,"));\n        }\n      }\n    ")}}const CN={kernelName:s.Ec,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:i}=t,o=new ON(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(o,[a,r,i],Object(s.Cf)(r.dtype,i.dtype))}},EN=ix({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(s.zd.SELU_SCALEALPHA,";\n  float scale = ").concat(s.zd.SELU_SCALE,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),_N={kernelName:s.Fc,backendName:"webgl",kernelFunc:EN},AN=ix({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:cv}),RN={kernelName:s.Gc,backendName:"webgl",kernelFunc:AN},DN=ix({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),FN={kernelName:s.Hc,backendName:"webgl",kernelFunc:DN},MN=ix({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),jN={kernelName:s.Ic,backendName:"webgl",kernelFunc:MN},zN=ix({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),LN={kernelName:s.Jc,backendName:"webgl",kernelFunc:zN},PN=ix({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),BN={kernelName:s.Mc,backendName:"webgl",kernelFunc:PN},WN={kernelName:s.Nc,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:i,paddings:o}=a;s.Df.assert(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const c=i.reduce((e,t)=>e*t),l=[[0,0]];l.push(...o);for(let s=1+i.length;s<r.shape.length;++s)l.push([0,0]);const u=[],d=VS({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),h=s.zd.getReshaped(d.shape,i,c,!1),p=s.zd.getPermuted(h.length,i.length,!1),f=s.zd.getReshapedPermuted(d.shape,i,c,!1),m=gx({inputs:{x:d},backend:n,attrs:{shape:h}}),g=Tx({inputs:{x:m},backend:n,attrs:{perm:p}}),b=gx({inputs:{x:g},backend:n,attrs:{shape:f}});return u.push(d),u.push(m),u.push(g),u.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}};const UN={kernelName:s.Oc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(s.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(r.shape));if(0!==i.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));const o=n.readSync(a.dataId),c=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(i.dataId)[0],[d,h,p,f,m]=dv(o,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(h,a.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};const VN={kernelName:s.Pc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(r.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));const i=Array.from(n.readSync(r.dataId)),o=n.readSync(a.dataId),c=Array.from(n.readSync(s.dataId)),[l,u,d]=hv(o,a.shape,a.dtype,i,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};const GN={kernelName:s.Qc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(s.shape));const i=n.readSync(a.dataId),o=n.readSync(r.dataId),c=n.readSync(s.dataId),[l,u]=pv(i,a.shape,a.dtype,o,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const HN={kernelName:s.Rc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(s.shape));const i=n.readSync(a.dataId),o=n.readSync(r.dataId),c=n.readSync(s.dataId),[l,u]=pv(i,a.shape,a.dtype,o,c);return n.makeTensorInfo(u,a.dtype,l)}};const qN={kernelName:s.Sc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:c}=a,{sliceRank:l,numUpdates:u,sliceSize:d,strides:h,outputSize:p}=s.zd.calculateShapes(i,r,c);if("string"===i.dtype){const e=n.bufferSync(r),t=n.bufferSync(i),a=s.Df.decodeString(n.readSync(o.dataId)[0]),f=ov(e,t,c,p,d,u,l,h,a,!1);return n.makeTensorInfo(c,f.dtype,f.values)}const f=new IN(u,l,r.shape.length,i.shape.length,h,[p,1],!1),m=n.runWebGLProgram(f,[i,r,o],i.dtype),g=gx({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(m),g}};const KN={kernelName:s.Tc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:i,axis:o}=a,c=s.Df.parseAxisParam(o,r.shape)[0],l=s.zd.prepareSplitSize(r,i,c),u=r.shape.length,d=new Array(u).fill(0),h=r.shape.slice();return l.map(e=>{const t=[...h];t[c]=e;const a=vw({inputs:{x:r},backend:n,attrs:{begin:d,size:t}});return d[c]+=e,a})}},XN="return sqrt(x);",ZN=ix({opSnippet:XN,packedOpSnippet:XN,cpuKernelImpl:fv}),YN={kernelName:s.Uc,backendName:"webgl",kernelFunc:ZN},JN=ix({opSnippet:"return x * x;"}),QN={kernelName:s.Vc,backendName:"webgl",kernelFunc:JN},$N=ox({opSnippet:"return (a - b) * (a - b);",packedOpSnippet:"return (a - b) * (a - b);"}),eT={kernelName:s.Wc,backendName:"webgl",kernelFunc:$N};const tT={kernelName:s.Xc,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,s=Dv+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),i=new Rv(r.shape,s);return a.runWebGLProgram(i,[r],r.dtype)}};class nT{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const a=n.length,r=oy(n.length),s=oy(n.length);let i="";if(1===a)i="coords * strides + begin";else{let e=0;i=n.map((t,a)=>(e++,1===n.length?"coords * strides[".concat(a,"] + begin[").concat(a,"]"):"coords[".concat(e-1,"] * strides[").concat(a,"] + begin[").concat(a,"]"))).join(",")}this.userCode="\n      ".concat(r," begin = ").concat(r,"(").concat(e,");\n      ").concat(r," strides = ").concat(r,"(").concat(t,");\n\n      void main() {\n        ").concat(s," coords = getOutputCoords();\n        setOutput(getX(").concat(i,"));\n      }\n    ")}}const aT={kernelName:s.Yc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:i,end:o,strides:c,beginMask:l,endMask:u,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:y,begin:v,end:x,strides:w}=s.hf.sliceInfo(r.shape,i,o,c,l,u,d,h,p);let k;if(g)k=gx({inputs:{x:r},backend:n,attrs:{shape:m}});else if(b||y){s.Df.assert(r.shape.length>=1,()=>"Input must have rank at least 1, got: ".concat(r.shape.length));const e=s.hf.computeOutShape(v,x,w),t=vw({inputs:{x:r},backend:n,attrs:{begin:v,size:e}});k=gx({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),t=Object(s.Gd)(r.shape,r.dtype,e),a=mv(f,t,w,v);k=n.makeTensorInfo(m,r.dtype,a.values)}else{const e=new nT(v,w,f);k=n.runWebGLProgram(e,[r],r.dtype)}}const I=gx({inputs:{x:k},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(k),I}};const rT={kernelName:s.Zc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,h=n.readSync(u.dataId),p=n.readSync(d.dataId),[f,m]=gv(h,p,r,s,i,o,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};const sT={kernelName:s.ad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));const o=n.readSync(s.dataId),c=n.readSync(i.dataId)[0],[l,u,d]=bv(o,c,r),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};const iT={kernelName:s.bd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(s.dataId),o=yv(i,r);return n.makeTensorInfo(s.shape,"int32",o)}},oT=ix({opSnippet:"return tan(x);"}),cT={kernelName:s.ed,backendName:"webgl",kernelFunc:oT},lT=ix({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),uT={kernelName:s.fd,backendName:"webgl",kernelFunc:lT};class dT{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;const a=oy(this.rank),r=function(e){const t=e.length;if(t>5)throw Error("Tile for rank ".concat(t," is not yet supported"));if(1===t)return"imod(resRC, ".concat(e[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push("imod(".concat(n[r],", ").concat(e[r],")"));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(a," resRC = getOutputCoords();\n        setOutput(getA(").concat(r,"));\n      }\n    ")}}function hT(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:i}=a;if("string"===r.dtype||r.shape.length>5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map(e=>s.Df.decodeString(e)):e,a=Object(s.Gd)(r.shape,r.dtype,t),o=xv(a,i);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new dT(r.shape,i);return n.runWebGLProgram(o,[r],r.dtype)}const pT={kernelName:s.id,backendName:"webgl",kernelFunc:hT};class fT{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class mT{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function gT(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function bT(e){let t=1;for(;t<e;)t*=2;return t}const yT={kernelName:s.jd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:i,sorted:o}=a,c=Object(s.be)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Object(s.be)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,d=u[u.length-1];if(n.shouldExecuteOnCPU([r])||d<c||i>l){const e=n.readSync(r.dataId),[t,a]=wv(e,u,r.dtype,i,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===i)return u[u.length-1]=0,[n.makeTensorInfo(u,r.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===d)return[r,tI({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=n.texData.get(r.dataId),p=null!==h&&h.isPacked,f=p?n.unpackTensor(r):r,m=s.Df.sizeFromShape(u)/d,g=gx({inputs:{x:f},attrs:{shape:[m,d]},backend:n});p&&gT(n,f);const b=bT(i),y=bT(d);let v=null;const x=()=>null===v?[g,g]:[g,v],w=(e,t,a)=>{const r=x(),s=new fT(a),i=[[d],[null===v?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=v;v=n.runWebGLProgram(s,r,"int32",i),gT(n,o)};for(let s=1;s<b;s*=2){const e=2*s;for(let t=s;t>=1;t/=2)w(e,t,[m,y])}for(let s=y;s>b;s/=2){const e=x(),t=new mT([m,s/2]),a=[[d],[null===v?1:0],[b]],r=v;v=n.runWebGLProgram(t,e,"int32",a),gT(n,r);const i=b/2,o=2*i;for(let n=i;n>=1;n/=2)w(o,n,v.shape)}let k=v;v=vw({inputs:{x:v},backend:n,attrs:{begin:0,size:[m,i]}}),gT(n,k);let I=xI({inputs:{x:g,indices:v},backend:n,attrs:{axis:1,batchDims:1}});gT(n,g);const S=u.slice(0,-1);S.push(i),k=v,v=gx({inputs:{x:v},attrs:{shape:S},backend:n}),gT(n,k);const N=I;return I=gx({inputs:{x:I},attrs:{shape:S},backend:n}),gT(n,N),[I,v]}};class vT{constructor(e,t,n,a,r,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const i="nearest"===n?1:2;let o;switch(a){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(o," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(o," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(o," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(t,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(r,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(r,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat(i," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const xT={kernelName:s.kd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:c,outputShape:l}=a,[u,d,h,p]=r.shape,[f,m]=null!=l?l:[d,h],g=new vT(d,h,i,o,c,[u,f,m,p]);return n.runWebGLProgram(g,[r,s],"float32")}};const wT={kernelName:s.md,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;Fb(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=a.readSync(s.dataId),{outputValues:o,outputShape:c,indices:l}=Iv(i,r,s.shape,s.dtype);return[a.makeTensorInfo(c,s.dtype,o),a.makeTensorInfo([l.length],"int32",l)]}};const kT={kernelName:s.nd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const i=r,o=i.shape.length,c=r.shape[s],l=new Array(o-1);let u=0;for(let m=0;m<o;m++)m!==s&&(l[u++]=i.shape[m]);const d=[],h=new Array(o).fill(0),p=i.shape.slice();p[s]=1;const f=new Array(c);for(let m=0;m<f.length;m++){h[s]=m;const e=vw({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),t=gx({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,d.push(e)}return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}};class IT{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,a=e.batchSize,r=e.inSize,s=e.numSegments,i=s*Math.ceil(r/n);this.outputShape=[a,i];const o=4*Math.floor(n/4),c=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let u="";r%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      "));let d="";r%n>0&&(d="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(d,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(s,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(s,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(o,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(o,";\n        if (").concat(1===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(l,"\n        } else if (").concat(2===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(l,"\n        } else if (").concat(3===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(l,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const ST=[Ex,_x,Rx,Fx,zx,Bx,Wx,Ux,qx,Kx,Zx,Jx,$x,tw,aw,iw,ow,uw,dw,hw,mw,ww,kw,Iw,Cw,Aw,Fw,$v,zw,Hw,$w,rk,sk,ik,ok,ck,uk,hk,fk,xk,wk,kk,Sk,Ok,_k,Ak,Dk,Mk,jk,Lk,Pk,Wk,Vk,Hk,Kk,Yk,$k,nI,rI,oI,lI,hI,mI,gI,yI,wI,II,NI,Jv,TI,Uw,CI,_I,RI,nx,FI,jI,zI,PI,WI,VI,HI,KI,YI,QI,eS,nS,aS,rS,oS,cS,lS,uS,dS,pS,gS,yS,OS,mx,CS,_S,RS,FS,Nw,jS,PS,BS,GS,qS,sx,KS,XS,ZS,JS,Ow,wS,$S,tN,aN,bx,iN,cN,dN,pN,gN,yN,xN,kN,SN,TN,CN,_N,RN,FN,jN,LN,xw,TS,BN,WN,UN,VN,GN,HN,qN,KN,YN,QN,eT,tT,aT,rT,sT,iT,SS,Nx,cT,uT,pT,yT,xT,Ox,wT,kT,{kernelName:s.od,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:i}=t,{numSegments:o}=a,c=r.shape.length,l=[];let u=0;const d=s.zd.getAxesPermutation([u],c);let h=r;null!=d&&(h=Tx({inputs:{x:r},backend:n,attrs:{perm:d}}),l.push(h),u=s.zd.getInnerMostAxes(1,c)[0]);const p=s.zd.segment_util.computeOutShape(h.shape,u,o),f=s.Df.sizeFromShape([h.shape[u]]),m=gx({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}});l.push(m);const g=Object(s.qf)(r.dtype),b=(e,t,a,r,i)=>{const o=e.shape[0],c=e.shape[1],u=s.zd.segment_util.segOpComputeOptimalWindowSize(c,i),d=new IT({windowSize:u,inSize:c,batchSize:o,numSegments:i},t),h=n.compileAndRun(d,[e,a],r);if(l.push(h),h.shape[1]===i)return h;const p=YS({backend:n,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),f=hT({inputs:{x:p},backend:n,attrs:{reps:[c/u]}});l.push(p),l.push(f);return b(h,t,f,r,i)},y=gx({inputs:{x:b(m,"unsortedSegmentSum",i,g,o)},backend:n,attrs:{shape:p}});let v=y;if(null!=d){l.push(y);const e=s.zd.getUndoAxesPermutation(d);v=Tx({inputs:{x:v},backend:n,attrs:{perm:e}})}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),v}},LS];for(const NT of ST)Object(s.Se)(NT);s.Gf},function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var a=n(6),r=n(9);function s(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",r.c(e),new a.b(e,t,n)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({reverse_:function(e,t){const n={x:Object(s.a)(e,"x","reverse")},i={dims:t};return a.a.runKernel(r.xc,n,i)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return p}));var a=n(5),r=n(24),s=n(3),i=n(2),o=n(9),c=n(47),l=n(89),u=n(27),d=n(4),h=n(81);const p=Object(d.b)({transpose_:function(e,t,n){const d=Object(i.a)(e,"x","transpose");if(null==t&&(t=d.shape.map((e,t)=>t).reverse()),o.b(d.rank===t.length,()=>"Error in transpose: rank of input ".concat(d.rank," ")+"must match length of perm ".concat(t,".")),t.forEach(e=>{o.b(e>=0&&e<d.rank,()=>"All entries in 'perm' must be between 0 and ".concat(d.rank-1)+" but got ".concat(t))}),d.rank<=1)return d.clone();const p={x:d},f={perm:t};return"complex64"===d.dtype?Object(r.h)(()=>{let e=Object(h.a)(d),t=Object(l.a)(d);return e=a.a.runKernel(s.id,{x:e},f),t=a.a.runKernel(s.id,{x:t},f),n&&(t=Object(u.a)(t)),Object(c.a)(e,t)}):a.a.runKernel(s.id,p,f)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var a=n(5),r=n(9),s=n(10);function i(e,t,n,i){if(null==i&&(i=Object(r.r)(e)),"complex64"===i)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Object(r.A)(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Object(r.c)(t);const e=Object(r.O)(t),a=Object(r.O)(n);Object(r.b)(e===a,()=>"Based on the provided shape, [".concat(t,"], the tensor should have ")+"".concat(e," values but has ").concat(a));for(let s=0;s<n.length;++s){const e=n[s],a=s!==n.length-1||e!==Object(r.O)(t.slice(s));Object(r.b)(n[s]===t[s]||!a,()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(t,"). "))}}return Object(r.A)(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==i?Object(s.toTypedArray)(e,i):Object(r.m)(e,[],!0),a.a.makeTensor(e,t,i)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4);const c=Object(o.b)({complex_:function(e,t){const n=Object(s.a)(e,"real","complex"),o=Object(s.a)(t,"imag","complex");i.e(n.shape,o.shape,"real and imag shapes, ".concat(n.shape," and ").concat(o.shape,", ")+"must match in call to tf.complex().");const c={real:n,imag:o};return a.a.runKernel(r.A,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(4);const c=Object(o.b)({pow_:function(e,t){let n=Object(i.a)(e,"base","pow"),o=Object(i.a)(t,"exp","pow");[n,o]=Object(s.makeTypesMatch)(n,o);const c={a:n,b:o};return a.a.runKernel(r.hc,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(9),s=n(47),i=n(72);function o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if("complex64"===t){const t=o(e,"float32"),n=Object(i.a)(e,"float32");return Object(s.a)(t,n)}const n=Object(r.D)(Object(r.O)(e),t);return a.a.makeTensor(n,e,t)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(15),c=n(4);const l=Object(c.b)({lessEqual_:function(e,t){let n=Object(i.a)(e,"a","lessEqual","string_or_numeric"),c=Object(i.a)(t,"b","lessEqual","string_or_numeric");[n,c]=Object(s.makeTypesMatch)(n,c),Object(o.assertAndGetBroadcastShape)(n.shape,c.shape);const l={a:n,b:c};return a.a.runKernel(r.Cb,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const i=Object(s.a)(e,"x","pad");if(0===i.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const o={paddings:t,constantValue:n},c={x:i};return a.a.runKernel(r.gc,c,o)}})},function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return T})),n.d(t,"i",(function(){return C})),n.d(t,"c",(function(){return E})),n.d(t,"f",(function(){return _})),n.d(t,"e",(function(){return D})),n.d(t,"d",(function(){return F})),n.d(t,"k",(function(){return j})),n.d(t,"g",(function(){return z})),n.d(t,"h",(function(){return L})),n.d(t,"j",(function(){return P})),n.d(t,"b",(function(){return B}));var a=n(0),r=n(69),s=n(95),i=n(1),o=n(204),c=n(205),l=n(206),u=n(207),d=n(208),h=n(209),p=n(210),f=n(211),m=n(212),g=n(213),b=n(214),y=n(215),v=n(216),x=n(217),w=n(218),k=n(219),I=n(220),S=n(221),N=n(222);class T{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[o,c,l,u,d,h,p,f,m,g,b,y,v,x,w,k,I,S,N].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,a=[],r=[],s=[],o=n.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?a.push(e[t.name]):"Const"===t.op?r.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e),{});let c=[];const l=[];let u={},d={};null!=t&&(u=this.mapSignatureEntries(t.inputs),d=this.mapSignatureEntries(t.outputs));const h=Object.keys(o);h.forEach(e=>{const t=o[e];t.inputNames.forEach((e,n)=>{const[a,,r]=Object(i.b)(e),s=o[a];if(null!=s.outputs){const e=s.outputs.indexOf(r);if(-1!==e){const r="".concat(a,":").concat(e);t.inputNames[n]=r}}t.inputs.push(s),s.children.push(t)})}),0===Object.keys(d).length?h.forEach(e=>{const t=o[e];0===t.children.length&&l.push(t)}):Object.keys(d).forEach(e=>{const[t]=Object(i.b)(e),n=o[t];null!=n&&(n.signatureKey=d[e],l.push(n))}),Object.keys(u).length>0?Object.keys(u).forEach(e=>{const[t]=Object(i.b)(e),n=o[t];n&&(n.signatureKey=u[e],c.push(n))}):c=a;let p={};null!=e.library&&null!=e.library.function&&(p=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));const f={nodes:o,inputs:c,outputs:l,weights:r,placeholders:a,signature:t,functions:p};return s.length>0&&(f.initNodes=s),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=Object(s.a)(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.slice(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce((t,n)=>{const a=n.type;let r=void 0;switch(n.type){case"string":r=C(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=C(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=L(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=L(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=_(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=z(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=z(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=E(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=E(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=B(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=B(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=j(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=j(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=P(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=P(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=D(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=D(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=F(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=F(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=R(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=R(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: ".concat(n.type," for op: ").concat(e.op))}return t[n.name]={value:r,type:a},t},{})),n}mapFunction(e){const t=e.nodeDef,n=[];let a={};null!=t&&(a=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e),{}));const r=[],s=[];e.signature.inputArg.forEach(e=>{const[t]=Object(i.b)(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:A(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,r.push(n),a[t]=n});Object.keys(a).forEach(e=>{const t=a[e];t.inputNames.forEach((e,n)=>{const[r,,s]=Object(i.b)(e),o=a[r];if(null!=o.outputs){const e=o.outputs.indexOf(s);if(-1!==e){const a="".concat(r,":").concat(e);t.inputNames[n]=a}}t.inputs.push(o),o.children.push(t)})});const o=e.ret;e.signature.outputArg.forEach(e=>{const[t,n]=Object(i.b)(o[e.name]),r=a[t];null!=r&&(r.defaultOutput=n,s.push(r))});const c=this.mapArgsToSignature(e);return{nodes:a,inputs:r,outputs:s,weights:n,placeholders:[],signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function O(t,n){const r=Array.isArray(t)?String.fromCharCode.apply(null,t):function(t){const n=Object(a.be)().global;if("undefined"!==typeof n.atob)return n.atob(t);if("undefined"!==typeof e)return new e(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(t);return n?r:r.toLowerCase()}function C(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e[t];return null!=r?O(r.s,a):n}function E(e,t,n){const a=e[t];return a?a.b:n}function _(e,t,n){const a=e[t]||{},r=null!=a.i?a.i:null!=a.f?a.f:n;return"number"===typeof r?r:parseInt(r,10)}function A(e){switch("string"===typeof e&&(e=r.a[e]),e){case r.a.DT_FLOAT:case r.a.DT_HALF:return"float32";case r.a.DT_INT32:case r.a.DT_INT64:case r.a.DT_INT8:case r.a.DT_UINT8:return"int32";case r.a.DT_BOOL:return"bool";case r.a.DT_DOUBLE:return"float32";case r.a.DT_STRING:return"string";default:return null}}function R(e,t,n){const a=e[t];return a&&a.func?a.func.name:n}function D(e,t,n){const a=e[t];return a&&a.type?A(a.type):n}function F(e,t,n){const a=e[t];return a&&a.list&&a.list.type?a.list.type.map(e=>A(e)):n}function M(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"===typeof e.size?e.size:parseInt(e.size,10)):[]}function j(e,t,n){const a=e[t];return a&&a.shape?M(a.shape):n}function z(e,t,n){const a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map(e=>"number"===typeof e?e:parseInt(e,10)):n}function L(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e[t];return r&&r.list&&r.list.s?r.list.s.map(e=>O(e,a)):n}function P(e,t,n){const a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map(e=>M(e)):n}function B(e,t,n){const a=e[t];return a&&a.list&&a.list.b?a.list.b:n}}).call(this,n(128).Buffer)},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(15),o=n(4);const c=Object(o.b)({logicalAnd_:function(e,t){const n=Object(s.a)(e,"a","logicalAnd","bool"),o=Object(s.a)(t,"b","logicalAnd","bool");Object(i.assertAndGetBroadcastShape)(n.shape,o.shape);const c={a:n,b:o};return a.a.runKernel(r.Hb,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const i=Object(s.a)(e,"x","split"),o={x:i},c={numOrSizeSplits:t,axis:n};return a.a.runKernel(r.Sc,o,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4);const c=Object(o.b)({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Object(s.b)(e,"tensors","stack","string_or_numeric");i.b(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&i.b(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const o=n,c={axis:t};return a.a.runKernel(r.fc,o,c)}})},function(e,t,n){"use strict";n.d(t,"b",(function(){return c})),n.d(t,"a",(function(){return l})),n.d(t,"c",(function(){return u})),n.d(t,"e",(function(){return d})),n.d(t,"d",(function(){return h}));var a=n(19),r=n(99),s=n(68);const i=Object(r.a)("kernelRegistry",()=>new Map),o=Object(r.a)("gradRegistry",()=>new Map);function c(e,t){const n=p(e,t);return i.get(n)}function l(e){return o.get(e)}function u(e){const t=i.entries(),n=[];for(;;){const{done:a,value:r}=t.next();if(a)break;const[s,i]=r,[o]=s.split("_");o===e&&n.push(i)}return n}function d(e){const{kernelName:t,backendName:n}=e,a=p(t,n);i.has(a)&&s.b("The kernel '".concat(t,"' for backend ")+"'".concat(n,"' is already registered")),i.set(a,e)}function h(e){const{kernelName:t}=e;o.has(t)&&Object(a.b)().getBool("DEBUG")&&s.b("Overriding the gradient for '".concat(t,"'")),o.set(t,e)}function p(e,t){return"".concat(t,"_").concat(e)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4);const c=Object(o.b)({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Object(s.a)(e,"x","expandDims","string_or_numeric");i.b(t<=n.rank,()=>"Axis must be <= rank of the tensor");const o={input:n},c={dim:t};return a.a.runKernel(r.db,o,c)}})},function(e,t,n){"use strict";(function(e,a,r,s,i,o){n.d(t,"a",(function(){return TQ})),n.d(t,"b",(function(){return JZ})),n.d(t,"c",(function(){return xY})),n.d(t,"d",(function(){return NQ})),n.d(t,"e",(function(){return SQ})),n.d(t,"f",(function(){return wZ})),n.d(t,"g",(function(){return OY})),n.d(t,"h",(function(){return _Y})),n.d(t,"i",(function(){return rQ})),n.d(t,"j",(function(){return OQ}));var c=Object.defineProperty,l=n(202),u=(e,t)=>{for(var n in t)c(e,n,{get:t[n],enumerable:!0})};u({},{Abs:()=>Ke,Acos:()=>Xe,Acosh:()=>Ze,AdadeltaOptimizer:()=>Rp,AdagradOptimizer:()=>Dp,AdamOptimizer:()=>Fp,AdamaxOptimizer:()=>Mp,Add:()=>Ye,AddN:()=>Je,All:()=>Qe,Any:()=>$e,ArgMax:()=>et,ArgMin:()=>tt,Asin:()=>nt,Asinh:()=>at,Atan:()=>rt,Atan2:()=>it,Atanh:()=>st,AvgPool:()=>ot,AvgPool3D:()=>lt,AvgPool3DGrad:()=>ut,AvgPoolGrad:()=>ct,BackendWasm:()=>rZ,BatchMatMul:()=>dt,BatchToSpaceND:()=>ht,Bincount:()=>pt,BitwiseAnd:()=>ft,BroadcastArgs:()=>gt,BroadcastTo:()=>mt,Callback:()=>dN,CallbackList:()=>Xv,Cast:()=>bt,Ceil:()=>yt,ClipByValue:()=>vt,Complex:()=>xt,ComplexAbs:()=>wt,Concat:()=>kt,Conv2D:()=>It,Conv2DBackpropFilter:()=>St,Conv2DBackpropInput:()=>Nt,Conv3D:()=>Tt,Conv3DBackpropFilterV2:()=>Ot,Conv3DBackpropInputV2:()=>Ct,Cos:()=>Et,Cosh:()=>_t,CropAndResize:()=>Dt,Cumprod:()=>At,Cumsum:()=>Rt,CustomCallback:()=>Jv,DataStorage:()=>W,DenseBincount:()=>Ft,DepthToSpace:()=>Mt,DepthwiseConv2dNative:()=>jt,DepthwiseConv2dNativeBackpropFilter:()=>zt,DepthwiseConv2dNativeBackpropInput:()=>Lt,Diag:()=>Pt,Dilation2D:()=>Bt,Dilation2DBackpropFilter:()=>Ut,Dilation2DBackpropInput:()=>Wt,Draw:()=>Vt,ENV:()=>Ge,EarlyStopping:()=>fN,Einsum:()=>Ht,Elu:()=>qt,EluGrad:()=>Kt,Environment:()=>Pe,Equal:()=>Zt,Erf:()=>Xt,Exp:()=>Yt,ExpandDims:()=>Jt,Expm1:()=>Qt,FFT:()=>$t,Fill:()=>en,FlipLeftRight:()=>tn,Floor:()=>nn,FloorDiv:()=>an,FromPixels:()=>or,FusedBatchNorm:()=>rn,FusedConv2D:()=>ur,FusedDepthwiseConv2D:()=>dr,GPGPUContext:()=>yz,GatherNd:()=>on,GatherV2:()=>sn,GraphModel:()=>gO,Greater:()=>cn,GreaterEqual:()=>ln,History:()=>Yv,IFFT:()=>dn,Identity:()=>un,Imag:()=>hn,InputSpec:()=>Jy,IsFinite:()=>pn,IsInf:()=>fn,IsNan:()=>mn,KernelBackend:()=>U,LRN:()=>Cn,LRNGrad:()=>En,LayerVariable:()=>Xy,LayersModel:()=>Qx,LeakyRelu:()=>gn,Less:()=>bn,LessEqual:()=>yn,LinSpace:()=>vn,Log:()=>xn,Log1p:()=>wn,LogSoftmax:()=>Tn,LogicalAnd:()=>kn,LogicalNot:()=>In,LogicalOr:()=>Sn,LogicalXor:()=>Nn,LowerBound:()=>On,MathBackendCPU:()=>FC,MathBackendWebGL:()=>LL,MatrixBandPart:()=>_n,Max:()=>An,MaxPool:()=>Dn,MaxPool3D:()=>Mn,MaxPool3DGrad:()=>jn,MaxPoolGrad:()=>Fn,MaxPoolWithArgmax:()=>zn,Maximum:()=>Rn,Mean:()=>Ln,Min:()=>Pn,Minimum:()=>Bn,MirrorPad:()=>Wn,Mod:()=>Un,MomentumOptimizer:()=>zp,Multinomial:()=>Vn,Multiply:()=>Gn,Neg:()=>Hn,NonMaxSuppressionV3:()=>Kn,NonMaxSuppressionV4:()=>Xn,NonMaxSuppressionV5:()=>Zn,NotEqual:()=>qn,OP_SCOPE_SUFFIX:()=>Us,OneHot:()=>Jn,OnesLike:()=>Yn,Optimizer:()=>Ap,OptimizerConstructors:()=>Bf,Pack:()=>Qn,PadV2:()=>$n,Pool:()=>ea,Pow:()=>ta,Prelu:()=>na,Prod:()=>aa,RMSPropOptimizer:()=>Lp,RNN:()=>rk,RaggedGather:()=>ra,RaggedRange:()=>sa,RaggedTensorToTensor:()=>ia,Range:()=>oa,Rank:()=>us,Real:()=>ca,RealDiv:()=>Gt,Reciprocal:()=>la,Reduction:()=>$h,Relu:()=>ua,Relu6:()=>ga,Reshape:()=>da,ResizeBilinear:()=>fa,ResizeBilinearGrad:()=>ma,ResizeNearestNeighbor:()=>ha,ResizeNearestNeighborGrad:()=>pa,Reverse:()=>ba,RotateWithOffset:()=>cr,Round:()=>ya,Rsqrt:()=>va,SGDOptimizer:()=>jp,ScatterNd:()=>xa,SearchSorted:()=>ka,Select:()=>Ia,Selu:()=>Sa,Sequential:()=>nw,Sigmoid:()=>Ea,Sign:()=>Ca,Sin:()=>Ta,Sinh:()=>Oa,Slice:()=>Na,Softmax:()=>Ma,Softplus:()=>_a,SpaceToBatchND:()=>Da,SparseFillEmptyRows:()=>ja,SparseReshape:()=>za,SparseSegmentMean:()=>La,SparseSegmentSum:()=>Pa,SparseToDense:()=>Ba,SplitV:()=>Fa,Sqrt:()=>Aa,Square:()=>Ua,SquaredDifference:()=>Wa,StaticRegexReplace:()=>Va,Step:()=>ir,StridedSlice:()=>Ga,StringNGrams:()=>Ha,StringSplit:()=>qa,StringToHashBucketFast:()=>Ka,Sub:()=>Xa,Sum:()=>Ra,SymbolicTensor:()=>Qy,Tan:()=>Za,Tanh:()=>Ya,Tensor:()=>os,TensorBuffer:()=>rs,TensorScatterUpdate:()=>wa,Tile:()=>Ja,TopK:()=>Qa,Transform:()=>$a,Transpose:()=>er,Unique:()=>tr,Unpack:()=>nr,UnsortedSegmentSum:()=>ar,UpperBound:()=>rr,Variable:()=>ls,ZerosLike:()=>sr,_FusedMatMul:()=>lr,abs:()=>yo,acos:()=>vo,acosh:()=>xo,add:()=>fo,addN:()=>wo,all:()=>ko,any:()=>Io,argMax:()=>So,argMin:()=>No,asin:()=>To,asinh:()=>Oo,atan:()=>Co,atan2:()=>Eo,atanh:()=>_o,avgPool:()=>Zo,avgPool3d:()=>Yo,backend:()=>ho,backend_util:()=>Hf,basicLSTMCell:()=>nc,batchNorm:()=>sc,batchNorm2d:()=>ic,batchNorm3d:()=>oc,batchNorm4d:()=>cc,batchToSpaceND:()=>ac,bincount:()=>lc,bitwiseAnd:()=>uc,booleanMaskAsync:()=>$d,broadcastArgs:()=>dc,broadcastTo:()=>hc,broadcast_util:()=>jc,browser:()=>lf,buffer:()=>Ui,callbacks:()=>bN,cast:()=>Vi,ceil:()=>pc,clipByValue:()=>mc,clone:()=>Gi,complex:()=>Gs,concat:()=>Jo,concat1d:()=>gc,concat2d:()=>bc,concat3d:()=>yc,concat4d:()=>vc,constraints:()=>hv,conv1d:()=>wc,conv2d:()=>xc,conv2dTranspose:()=>Ic,conv3d:()=>Sc,conv3dTranspose:()=>Tc,copyRegisteredKernels:()=>Ir,cos:()=>Oc,cosh:()=>Cc,cosineWindow:()=>ch,cumprod:()=>Ec,cumsum:()=>_c,customGrad:()=>Ll,data:()=>wO,denseBincount:()=>Ac,deprecationWarn:()=>Zi,depthToSpace:()=>Rc,depthwiseConv2d:()=>Dc,deregisterOp:()=>wN,device_util:()=>Ds,diag:()=>Fc,dilation2d:()=>Mc,disableDeprecationWarnings:()=>Xi,dispose:()=>to,disposeVariables:()=>Yi,div:()=>go,divNoNan:()=>Vc,dot:()=>Gc,dropout:()=>ih,einsum:()=>Hc,elu:()=>qc,enableDebugMode:()=>Ki,enableProdMode:()=>qi,enclosingPowerOfTwo:()=>oh,engine:()=>Ji,ensureShape:()=>Kc,env:()=>Ue,equal:()=>Bc,erf:()=>Xc,euclideanNorm:()=>hl,exp:()=>pl,expandDims:()=>fl,expm1:()=>ml,eye:()=>bl,fft:()=>kd,fill:()=>fc,findBackend:()=>co,findBackendFactory:()=>lo,floor:()=>yl,floorDiv:()=>mo,forceHalfFloat:()=>BL,fused:()=>uh,gather:()=>vl,gatherND:()=>sh,gather_util:()=>vf,getBackend:()=>io,getGradient:()=>br,getKernel:()=>gr,getKernelsForBackend:()=>yr,getThreadsCount:()=>yZ,gpgpu_util:()=>Zj,grad:()=>Dl,grads:()=>Fl,greater:()=>xl,greaterEqual:()=>wl,ifft:()=>Id,imag:()=>kl,image:()=>kp,inTopKAsync:()=>lh,initializers:()=>Ov,input:()=>sw,io:()=>Bp,irfft:()=>Sd,isFinite:()=>Il,isInf:()=>Sl,isNaN:()=>Nl,keep:()=>no,kernel_impls:()=>Xm,layers:()=>Gv,leakyRelu:()=>Tl,less:()=>Ol,lessEqual:()=>Cl,linalg:()=>Ip,linspace:()=>El,loadGraphModel:()=>bO,loadGraphModelSync:()=>yO,loadLayersModel:()=>tw,localResponseNormalization:()=>_l,log:()=>Al,log1p:()=>Rl,logSigmoid:()=>Ul,logSoftmax:()=>Gl,logSumExp:()=>Hl,logicalAnd:()=>ql,logicalNot:()=>Kl,logicalOr:()=>Xl,logicalXor:()=>Zl,losses:()=>Sp,lowerBound:()=>Ql,matMul:()=>Qo,math:()=>of,max:()=>al,maxPool:()=>$l,maxPool3d:()=>eu,maxPoolWithArgmax:()=>tu,maximum:()=>nu,mean:()=>au,memory:()=>Qi,meshgrid:()=>iu,metrics:()=>GS,min:()=>rl,minimum:()=>ou,mirrorPad:()=>cu,mod:()=>lu,model:()=>aw,models:()=>iN,moments:()=>uu,movingAverage:()=>th,mul:()=>bo,multiRNNCell:()=>du,multinomial:()=>hu,neg:()=>Bl,nextFrame:()=>Vf,norm:()=>dl,notEqual:()=>pu,oneHot:()=>fu,ones:()=>su,onesLike:()=>mu,op:()=>Vs,outerProduct:()=>gu,pad:()=>bu,pad1d:()=>yu,pad2d:()=>vu,pad3d:()=>xu,pad4d:()=>wu,pool:()=>Iu,pow:()=>sl,prelu:()=>Su,print:()=>Hi,prod:()=>Nu,profile:()=>$i,raggedGather:()=>Tu,raggedRange:()=>Ou,raggedTensorToTensor:()=>Cu,rand:()=>Eu,randomGamma:()=>Xu,randomNormal:()=>Zu,randomStandardNormal:()=>Yu,randomUniform:()=>Ju,randomUniformInt:()=>Qu,range:()=>$u,ready:()=>so,real:()=>ed,reciprocal:()=>td,registerBackend:()=>uo,registerCallbackConstructor:()=>iw,registerGradient:()=>xr,registerKernel:()=>vr,registerOp:()=>vN,regularizers:()=>oN,relu:()=>nd,relu6:()=>ad,removeBackend:()=>oo,reshape:()=>Xo,reverse:()=>rd,reverse1d:()=>sd,reverse2d:()=>id,reverse3d:()=>od,reverse4d:()=>cd,rfft:()=>Td,round:()=>ld,rsqrt:()=>ud,scalar:()=>il,scatterND:()=>nh,scatter_util:()=>Pd,searchSorted:()=>Jl,selu:()=>dd,separableConv2d:()=>hd,sequential:()=>rw,serialization:()=>Op,setBackend:()=>ro,setPlatform:()=>po,setThreadsCount:()=>bZ,setWasmPath:()=>pZ,setWasmPaths:()=>fZ,setWebGLContext:()=>hM,setdiff1dAsync:()=>pd,shared:()=>MC,sigmoid:()=>$o,sign:()=>fd,signal:()=>wp,sin:()=>md,sinh:()=>gd,slice:()=>ec,slice1d:()=>bd,slice2d:()=>yd,slice3d:()=>vd,slice4d:()=>xd,slice_util:()=>wf,softmax:()=>wd,softplus:()=>Wl,spaceToBatchND:()=>ku,sparse:()=>Np,sparseToDense:()=>rh,spectral:()=>xp,split:()=>Nd,sqrt:()=>ol,square:()=>cl,squaredDifference:()=>Od,squeeze:()=>Cd,stack:()=>Ed,step:()=>_d,stridedSlice:()=>Ad,string:()=>Tp,sub:()=>Vl,sum:()=>ll,sumOutType:()=>vs,tan:()=>Rd,tanh:()=>tc,tensor:()=>qs,tensor1d:()=>Dd,tensor2d:()=>Fd,tensor3d:()=>Md,tensor4d:()=>jd,tensor5d:()=>zd,tensor6d:()=>Ld,tensorScatterUpdate:()=>Vd,tensor_util:()=>gs,test_util:()=>Au,tidy:()=>eo,tile:()=>gl,time:()=>ao,topk:()=>Gd,train:()=>Wf,transpose:()=>eh,truncatedNormal:()=>Hd,unique:()=>qd,unregisterGradient:()=>kr,unregisterKernel:()=>wr,unsortedSegmentSum:()=>Kd,unstack:()=>Xd,upcastType:()=>ys,upperBound:()=>Zd,util:()=>Nr,valueAndGrad:()=>Ml,valueAndGrads:()=>jl,variable:()=>Yd,variableGrads:()=>zl,version:()=>xZ,version_converter:()=>xO,version_core:()=>Pf,version_cpu:()=>oA,version_layers:()=>Dx,version_wasm:()=>vZ,version_webgl:()=>PL,webgl:()=>WL,webgl_util:()=>iM,where:()=>Wc,whereAsync:()=>Qd,zeros:()=>ru,zerosLike:()=>Uc});var d=Object.create,h=Object.defineProperty,p=Object.getOwnPropertyDescriptor,f=Object.getOwnPropertyNames,m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty,b=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),y=(e,t)=>{for(var n in t)h(e,n,{get:t[n],enumerable:!0})},v=(e,t,n)=>(n=null!=e?d(m(e)):{},((e,t,n,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let r of f(t))!g.call(e,r)&&r!==n&&h(e,r,{get:()=>t[r],enumerable:!(a=p(t,r))||a.enumerable});return e})(!t&&e&&e.__esModule?n:h(n,"default",{value:e,enumerable:!0}),e)),x=b((e,t)=>{t.exports=a;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(T){}function a(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}a.prototype.__isLong__,Object.defineProperty(a.prototype,"__isLong__",{value:!0}),a.isLong=r;var s={},i={};function o(e,t){var n,a,r;return t?(r=0<=(e>>>=0)&&e<256)&&(a=i[e])?a:(n=l(e,(0|e)<0?-1:0,!0),r&&(i[e]=n),n):(r=-128<=(e|=0)&&e<128)&&(a=s[e])?a:(n=l(e,e<0?-1:0,!1),r&&(s[e]=n),n)}function c(e,t){if(isNaN(e))return t?y:b;if(t){if(e<0)return y;if(e>=f)return I}else{if(e<=-m)return S;if(e+1>=m)return k}return e<0?c(-e,t).neg():l(e%p|0,e/p|0,t)}function l(e,t,n){return new a(e,t,n)}a.fromInt=o,a.fromNumber=c,a.fromBits=l;var u=Math.pow;function d(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return b;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var a;if((a=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===a)return d(e.substring(1),t,n).neg();for(var r=c(u(n,8)),s=b,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),l=parseInt(e.substring(i,i+o),n);if(o<8){var h=c(u(n,o));s=s.mul(h).add(c(l))}else s=(s=s.mul(r)).add(c(l))}return s.unsigned=t,s}function h(e,t){return"number"==typeof e?c(e,t):"string"==typeof e?d(e,t):l(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}a.fromString=d,a.fromValue=h;var p=4294967296,f=p*p,m=f/2,g=o(1<<24),b=o(0);a.ZERO=b;var y=o(0,!0);a.UZERO=y;var v=o(1);a.ONE=v;var x=o(1,!0);a.UONE=x;var w=o(-1);a.NEG_ONE=w;var k=l(-1,2147483647,!1);a.MAX_VALUE=k;var I=l(-1,-1,!0);a.MAX_UNSIGNED_VALUE=I;var S=l(0,-2147483648,!1);a.MIN_VALUE=S;var N=a.prototype;N.toInt=function(){return this.unsigned?this.low>>>0:this.low},N.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},N.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=c(e),n=this.div(t),a=n.mul(t).sub(this);return n.toString(e)+a.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var r=c(u(e,6),this.unsigned),s=this,i="";;){var o=s.div(r),l=(s.sub(o.mul(r)).toInt()>>>0).toString(e);if((s=o).isZero())return l+i;for(;l.length<6;)l="0"+l;i=""+l+i}},N.getHighBits=function(){return this.high},N.getHighBitsUnsigned=function(){return this.high>>>0},N.getLowBits=function(){return this.low},N.getLowBitsUnsigned=function(){return this.low>>>0},N.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},N.isZero=function(){return 0===this.high&&0===this.low},N.eqz=N.isZero,N.isNegative=function(){return!this.unsigned&&this.high<0},N.isPositive=function(){return this.unsigned||this.high>=0},N.isOdd=function(){return 1===(1&this.low)},N.isEven=function(){return 0===(1&this.low)},N.equals=function(e){return r(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},N.eq=N.equals,N.notEquals=function(e){return!this.eq(e)},N.neq=N.notEquals,N.ne=N.notEquals,N.lessThan=function(e){return this.comp(e)<0},N.lt=N.lessThan,N.lessThanOrEqual=function(e){return this.comp(e)<=0},N.lte=N.lessThanOrEqual,N.le=N.lessThanOrEqual,N.greaterThan=function(e){return this.comp(e)>0},N.gt=N.greaterThan,N.greaterThanOrEqual=function(e){return this.comp(e)>=0},N.gte=N.greaterThanOrEqual,N.ge=N.greaterThanOrEqual,N.compare=function(e){if(r(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},N.comp=N.compare,N.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(v)},N.neg=N.negate,N.add=function(e){r(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,a=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,c=e.low>>>16,u=0,d=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,d+=(p+=a+c)>>>16,u+=(d+=n+o)>>>16,u+=t+i,l((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(d&=65535),this.unsigned)},N.subtract=function(e){return r(e)||(e=h(e)),this.add(e.neg())},N.sub=N.subtract,N.multiply=function(e){if(this.isZero())return b;if(r(e)||(e=h(e)),n)return l(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return b;if(this.eq(S))return e.isOdd()?S:b;if(e.eq(S))return this.isOdd()?S:b;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return c(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,a=65535&this.high,s=this.low>>>16,i=65535&this.low,o=e.high>>>16,u=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,m=0,y=0,v=0;return y+=(v+=i*p)>>>16,m+=(y+=s*p)>>>16,y&=65535,m+=(y+=i*d)>>>16,f+=(m+=a*p)>>>16,m&=65535,f+=(m+=s*d)>>>16,m&=65535,f+=(m+=i*u)>>>16,f+=t*p+a*d+s*u+i*o,l((y&=65535)<<16|(v&=65535),(f&=65535)<<16|(m&=65535),this.unsigned)},N.mul=N.multiply,N.divide=function(e){if(r(e)||(e=h(e)),e.isZero())throw Error("division by zero");var t,a,s;if(n)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:b;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return x;s=y}else{if(this.eq(S))return e.eq(v)||e.eq(w)?S:e.eq(S)?v:(t=this.shr(1).div(e).shl(1)).eq(b)?e.isNegative()?v:w:(a=this.sub(e.mul(t)),s=t.add(a.div(e)));if(e.eq(S))return this.unsigned?y:b;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=b}for(a=this;a.gte(e);){t=Math.max(1,Math.floor(a.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(t)/Math.LN2),o=i<=48?1:u(2,i-48),d=c(t),p=d.mul(e);p.isNegative()||p.gt(a);)p=(d=c(t-=o,this.unsigned)).mul(e);d.isZero()&&(d=v),s=s.add(d),a=a.sub(p)}return s},N.div=N.divide,N.modulo=function(e){return r(e)||(e=h(e)),n?l((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},N.mod=N.modulo,N.rem=N.modulo,N.not=function(){return l(~this.low,~this.high,this.unsigned)},N.and=function(e){return r(e)||(e=h(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},N.or=function(e){return r(e)||(e=h(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},N.xor=function(e){return r(e)||(e=h(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},N.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},N.shl=N.shiftLeft,N.shiftRight=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},N.shr=N.shiftRight,N.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},N.shru=N.shiftRightUnsigned,N.shr_u=N.shiftRightUnsigned,N.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},N.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},N.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},N.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},N.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},a.fromBytes=function(e,t,n){return n?a.fromBytesLE(e,t):a.fromBytesBE(e,t)},a.fromBytesLE=function(e,t){return new a(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},a.fromBytesBE=function(e,t){return new a(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}}),w=b(()=>{}),k=b(()=>{}),I=b((e,t)=>{!function(e,t,n){function a(e){var t=this,n=function(){var e=4022871197;return function(t){t=String(t);for(var n=0;n<t.length;n++){var a=.02519603282416938*(e+=t.charCodeAt(n));a-=e=a>>>0,e=(a*=e)>>>0,e+=4294967296*(a-=e)}return 2.3283064365386963e-10*(e>>>0)}}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function r(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new a(e),s=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,s&&("object"==typeof s&&r(s,n),i.state=function(){return r(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.alea=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}),S=b((e,t)=>{!function(e,t,n){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),t.next()}function r(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new a(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&r(s,n),i.state=function(){return r(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor128=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}),N=b((e,t)=>{!function(e,t,n){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),a==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function r(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new a(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&r(s,n),i.state=function(){return r(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorwow=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}),T=b((e,t)=>{!function(e,t,n){function a(e){var t=this;t.next=function(){var e,n,a=t.x,r=t.i;return e=a[r],n=(e^=e>>>7)^e<<24,n^=(e=a[r+1&7])^e>>>10,n^=(e=a[r+3&7])^e>>>3,n^=(e=a[r+4&7])^e<<7,e=a[r+7&7],n^=(e^=e<<13)^e<<9,a[r]=n,t.i=r+1&7,n},function(e,t){var n,a=[];if(t===(0|t))a[0]=t;else for(t=""+t,n=0;n<t.length;++n)a[7&n]=a[7&n]<<15^t.charCodeAt(n)+a[n+1&7]<<13;for(;a.length<8;)a.push(0);for(n=0;n<8&&0===a[n];++n);for(8==n?a[7]=-1:a[n],e.x=a,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function r(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&(s.x&&r(s,n),i.state=function(){return r(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorshift7=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}),O=b((e,t)=>{!function(e,t,n){function a(e){var t=this;t.next=function(){var e,n,a=t.w,r=t.X,s=t.i;return t.w=a=a+1640531527|0,n=r[s+34&127],e=r[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=r[s]=n^e,t.i=s,n+(a^a>>>16)|0},function(e,t){var n,a,r,s,i,o=[],c=128;for(t===(0|t)?(a=t,t=null):(t+="\0",a=0,c=Math.max(c,t.length)),r=0,s=-32;s<c;++s)t&&(a^=t.charCodeAt((s+32)%t.length)),0===s&&(i=a),a^=a<<10,a^=a>>>15,a^=a<<4,a^=a>>>13,s>=0&&(i=i+1640531527|0,r=0==(n=o[127&s]^=a+i)?r+1:0);for(r>=128&&(o[127&(t&&t.length||0)]=-1),r=127,s=512;s>0;--s)a=o[r+34&127],n=o[r=r+1&127],a^=a<<13,n^=n<<17,a^=a>>>15,n^=n>>>12,o[r]=a^n;e.w=i,e.X=o,e.i=r}(t,e)}function r(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&(s.X&&r(s,n),i.state=function(){return r(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor4096=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}),C=b((e,t)=>{!function(e,t,n){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,a=t.d,r=t.a;return e=e<<25^e>>>7^n,n=n-a|0,a=a<<24^a>>>8^r,r=r-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-a|0,t.d=a<<16^n>>>16^r,t.a=r-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var a=0;a<n.length+20;a++)t.b^=0|n.charCodeAt(a),t.next()}function r(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new a(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&r(s,n),i.state=function(){return r(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.tychei=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}),E=b(()=>{}),_=b((e,t)=>{!function(e,a,r){var s,i=256,o="random",c=r.pow(i,6),l=r.pow(2,52),u=2*l,d=255;function h(t,n,d){var h=[],b=m(function e(t,n){var a,r=[],s=typeof t;if(n&&"object"==s)for(a in t)try{r.push(e(t[a],n-1))}catch(y){}return r.length?r:"string"==s?t:t+"\0"}((n=1==n?{entropy:!0}:n||{}).entropy?[t,g(a)]:null==t?function(){try{var t;return s&&(t=s.randomBytes)?t=t(i):(t=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(t)),g(t)}catch(h){var n=e.navigator,r=n&&n.plugins;return[+new Date,e,r,e.screen,g(a)]}}():t,3),h),y=new p(h),v=function(){for(var e=y.g(6),t=c,n=0;e<l;)e=(e+n)*i,t*=i,n=y.g(1);for(;e>=u;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|y.g(4)},v.quick=function(){return y.g(4)/4294967296},v.double=v,m(g(y.S),a),(n.pass||d||function(e,t,n,a){return a&&(a.S&&f(a,y),e.state=function(){return f(y,{})}),n?(r[o]=e,t):e})(v,b,"global"in n?n.global:this==r,n.state)}function p(e){var t,n=e.length,a=this,r=0,s=a.i=a.j=0,o=a.S=[];for(n||(e=[n++]);r<i;)o[r]=r++;for(r=0;r<i;r++)o[r]=o[s=d&s+e[r%n]+(t=o[r])],o[s]=t;(a.g=function(e){for(var t,n=0,r=a.i,s=a.j,o=a.S;e--;)t=o[r=d&r+1],n=n*i+o[d&(o[r]=o[s=d&s+t])+(o[s]=t)];return a.i=r,a.j=s,n})(i)}function f(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function m(e,t){for(var n,a=e+"",r=0;r<a.length;)t[d&r]=d&(n^=19*t[d&r])+a.charCodeAt(r++);return g(t)}function g(e){return String.fromCharCode.apply(0,e)}if(m(r.random(),a),"object"==typeof t&&t.exports){t.exports=h;try{s=E()}catch(b){}}else"function"==typeof define&&n(79)?define((function(){return h})):r.seedrandom=h}("undefined"!=typeof self?self:e,[],Math)}),A=b((e,t)=>{var n=I(),a=S(),r=N(),s=T(),i=O(),o=C(),c=_();c.alea=n,c.xor128=a,c.xorwow=r,c.xorshift7=s,c.xor4096=i,c.tychei=o,t.exports=c}),R=b(()=>{}),D=b(()=>{}),F=b(()=>{}),M=b(()=>{}),j=b(()=>{}),z=b(()=>{}),L=b((t,i)=>{var o=(()=>{var t="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return t=t||e,function(e){function n(){return L.buffer!=U&&J(L.buffer),G}function i(){return L.buffer!=U&&J(L.buffer),H}function o(){return L.buffer!=U&&J(L.buffer),q}function c(){return L.buffer!=U&&J(L.buffer),K}var l,u,d,h="undefined"!=typeof(e=e||{})?e:{};h.ready=new Promise((function(e,t){l=e,u=t})),"undefined"!=typeof a&&a.listeners&&(d={uncaughtException:a.listeners("uncaughtException"),unhandledRejection:a.listeners("unhandledRejection")});var p,f,m,g=Object.assign({},h),b=[],y=(e,t)=>{throw t},v="object"==typeof window,x="function"==typeof importScripts,w="object"==typeof a&&"object"==typeof a.versions&&"string"==typeof a.versions.node,k=h.ENVIRONMENT_IS_PTHREAD||!1,I="";function S(e){return h.locateFile?h.locateFile(e,I):I+e}if(w){var N=D(),T=F();let e;I=x?T.dirname(I)+"/":r+"/",p=(e,t)=>(e=de(e)?new URL(e):T.normalize(e),N.readFileSync(e,t?void 0:"utf8")),m=e=>{var t=p(e,!0);return t.buffer||(t=new Uint8Array(t)),t},f=(e,t,n)=>{e=de(e)?new URL(e):T.normalize(e),N.readFile(e,(function(e,a){e?n(e):t(a.buffer)}))},a.argv.length>1&&a.argv[1].replace(/\\/g,"/"),b=a.argv.slice(2),a.on("uncaughtException",(function(e){if(!(e instanceof fe))throw e})),a.on("unhandledRejection",(function(e){throw e})),y=(e,t)=>{if(ae())throw a.exitCode=e,t;(function(e){e instanceof fe||_("exiting due to exception: "+e)})(t),a.exit(e)},h.inspect=function(){return"[Emscripten Module object]"};try{e=M()}catch(nt){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),nt}s.Worker=e.Worker}else(v||x)&&(x?I=self.location.href:"undefined"!=typeof document&&document.currentScript&&(I=document.currentScript.src),"undefined"!=typeof t&&t&&(I=t),I=0!==I.indexOf("blob:")?I.substr(0,I.replace(/[?#].*/,"").lastIndexOf("/")+1):"",w||(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},x&&(m=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var a=new XMLHttpRequest;a.open("GET",e,!0),a.responseType="arraybuffer",a.onload=()=>{200==a.status||0==a.status&&a.response?t(a.response):n()},a.onerror=n,a.send(null)}),e=>document.title=e);w&&"undefined"==typeof performance&&(s.performance=j().performance);var O=console.log.bind(console),C=console.warn.bind(console);w&&(O=e=>N.writeSync(1,e+"\n"),C=e=>N.writeSync(2,e+"\n"));var E=h.print||O,_=h.printErr||C;Object.assign(h,g),g=null,h.arguments&&(b=h.arguments),h.thisProgram&&h.thisProgram,h.quit&&(y=h.quit);var A;Atomics.load,Atomics.store,Atomics.compareExchange;h.wasmBinary&&(A=h.wasmBinary);var R=h.noExitRuntime||!0;"object"!=typeof WebAssembly&&ce("no native wasm support detected");var L,P,B,W=!1;var U,V,G,H,q,K,X="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function Z(e,t,n){for(var a=(t>>>=0)+n,r=t;e[r]&&!(r>=a);)++r;if(r-t>16&&e.buffer&&X)return X.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(var s="";t<r;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var c=63&e[t++];if((i=224==(240&i)?(15&i)<<12|o<<6|c:(7&i)<<18|o<<12|c<<6|63&e[t++])<65536)s+=String.fromCharCode(i);else{var l=i-65536;s+=String.fromCharCode(55296|l>>10,56320|1023&l)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function Y(e,t){return(e>>>=0)?Z(n(),e,t):""}function J(e){U=e,h.HEAP8=V=new Int8Array(e),h.HEAP16=new Int16Array(e),h.HEAP32=H=new Int32Array(e),h.HEAPU8=G=new Uint8Array(e),h.HEAPU16=new Uint16Array(e),h.HEAPU32=q=new Uint32Array(e),h.HEAPF32=new Float32Array(e),h.HEAPF64=K=new Float64Array(e)}k&&(U=h.buffer);var Q=h.INITIAL_MEMORY||16777216;if(k)L=h.wasmMemory,U=h.buffer;else if(h.wasmMemory)L=h.wasmMemory;else if(!((L=new WebAssembly.Memory({initial:Q/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw _("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&_("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");L&&(U=L.buffer),Q=U.byteLength,J(U);var $,ee=[],te=[],ne=[];function ae(){return R}function re(){!0,!k&&xe(te)}var se=0,ie=null,oe=null;function ce(e){h.onAbort&&h.onAbort(e),_(e="Aborted("+e+")"),W=!0,B=1,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw u(t),t}var le;function ue(e){return e.startsWith("data:application/octet-stream;base64,")}function de(e){return e.startsWith("file://")}function he(e){try{if(e==le&&A)return new Uint8Array(A);if(m)return m(e);throw"both async and sync fetching of the wasm failed"}catch(nt){ce(nt)}}ue(le="tfjs-backend-wasm-threaded-simd.wasm")||(le=S(le));var pe={};function fe(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function me(e){var t=ve.pthreads[e];(function(e,t){e||ce(t)})(t),ve.returnWorkerToPool(t)}function ge(e){var t=ve.getNewWorker();if(!t)return 6;ve.runningWorkers.push(t),ve.pthreads[e.pthread_ptr]=t,t.pthread_ptr=e.pthread_ptr;var n={cmd:"run",start_routine:e.startRoutine,arg:e.arg,pthread_ptr:e.pthread_ptr};return t.runPthread=()=>{w&&t.ref(),t.postMessage(n,e.transferList),delete t.runPthread},t.loaded&&t.runPthread(),0}function be(e){if(k)return Ce(1,1,e);B=e,ae()||(ve.terminateAllThreads(),h.onExit&&h.onExit(e),W=!0),y(e,new fe(e))}var ye=function(e,t){if(B=e,!t&&k)throw we(e),"unwind";be(e)};var ve={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){k?ve.initWorker():ve.initMainThread()},initMainThread:function(){for(var e=8;e--;)ve.allocateUnusedWorker()},initWorker:function(){R=!1},setExitStatus:function(e){B=e},terminateAllThreads:function(){for(var e of Object.values(ve.pthreads))ve.returnWorkerToPool(e);for(var e of ve.unusedWorkers)e.terminate();ve.unusedWorkers=[]},returnWorkerToPool:function(e){var t=e.pthread_ptr;delete ve.pthreads[t],ve.unusedWorkers.push(e),ve.runningWorkers.splice(ve.runningWorkers.indexOf(e),1),e.pthread_ptr=0,w&&e.unref(),Xe(t)},receiveObjectTransfer:function(e){},threadInitTLS:function(){ve.tlsInitFunctions.forEach(e=>e())},loadWasmModuleToWorker:function(e,n){e.onmessage=t=>{var a=t.data,r=a.cmd;if(e.pthread_ptr&&(ve.currentProxiedOperationCallerThread=e.pthread_ptr),a.targetThread&&a.targetThread!=Ge()){var s=ve.pthreads[a.targetThread];return s?s.postMessage(a,a.transferList):_('Internal error! Worker sent a message "'+r+'" to target pthread '+a.targetThread+", but that thread no longer exists!"),void(ve.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===r?Te(a.queue):"spawnThread"===r?ge(a):"cleanupThread"===r?me(a.thread):"killThread"===r?function(e){var t=ve.pthreads[e];delete ve.pthreads[e],t.terminate(),Xe(e),ve.runningWorkers.splice(ve.runningWorkers.indexOf(t),1),t.pthread_ptr=0}(a.thread):"cancelThread"===r?function(e){ve.pthreads[e].postMessage({cmd:"cancel"})}(a.thread):"loaded"===r?(e.loaded=!0,w&&e.unref(),n&&n(e),e.runPthread&&e.runPthread()):"print"===r?E("Thread "+a.threadId+": "+a.text):"printErr"===r?_("Thread "+a.threadId+": "+a.text):"alert"===r?alert("Thread "+a.threadId+": "+a.text):"setimmediate"===a.target?e.postMessage(a):"callHandler"===r?h[a.handler](...a.args):r&&_("worker sent an unknown command "+r),ve.currentProxiedOperationCallerThread=void 0},e.onerror=e=>{throw _("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},w&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){})));var a=[];for(var r of["onExit","onAbort","print","printErr"])h.hasOwnProperty(r)&&a.push(r);e.postMessage({cmd:"load",handlers:a,urlOrBlob:h.mainScriptUrlOrBlob||t,wasmMemory:L,wasmModule:P})},allocateUnusedWorker:function(){var e,t=S("tfjs-backend-wasm-threaded-simd.worker.js");e=new Worker(t),ve.unusedWorkers.push(e)},getNewWorker:function(){return 0==ve.unusedWorkers.length&&(ve.allocateUnusedWorker(),ve.loadWasmModuleToWorker(ve.unusedWorkers[0])),ve.unusedWorkers.pop()}};function xe(e){for(;e.length>0;)e.shift()(h)}function we(e){if(k)return Ce(2,0,e);try{ye(e)}catch(nt){!function(e){if(e instanceof fe||"unwind"==e)return B;y(1,e)}(nt)}}h.PThread=ve,h.establishStackSpace=function(){var e=Ge(),t=i()[e+52>>>2],n=i()[e+56>>>2];Ye(t,t-n),Qe(t)};var ke=[];function Ie(e,t,n,a){return k?Ce(3,1,e,t,n,a):Se(e,t,n,a)}function Se(e,t,n,a){if("undefined"==typeof SharedArrayBuffer)return _("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var r=[];if(k&&0===r.length)return Ie(e,t,n,a);var s={startRoutine:n,pthread_ptr:e,arg:a,transferList:r};return k?(s.cmd="spawnThread",postMessage(s,r),0):ge(s)}h.invokeEntryPoint=function(e,t){var n=function(e){var t=ke[e];return t||(e>=ke.length&&(ke.length=e+1),ke[e]=t=$.get(e)),t}(e)(t);ae()?ve.setExitStatus(n):Ze(n)};var Ne;function Te(e){Atomics.store(i(),e>>2,1),Ge()&&Ke(e),Atomics.compareExchange(i(),e>>2,1,0)}function Oe(e){var t=Je(),n=e();return Qe(t),n}function Ce(e,t){var n=arguments.length-2,a=arguments;return Oe(()=>{for(var r=n,s=$e(8*r),i=s>>3,o=0;o<n;o++){var l=a[2+o];c()[i+o>>>0]=l}return qe(e,r,s,t)})}h.executeNotifiedProxyingQueue=Te,Ne=w?()=>{var e=a.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.timeOrigin+performance.now();var Ee=[];function _e(e){try{return L.grow(e-U.byteLength+65535>>>16),J(L.buffer),1}catch(nt){}}function Ae(e){return k?Ce(4,1,e):52}function Re(e,t,n,a,r){return k?Ce(5,1,e,t,n,a,r):70}var De=[null,[],[]];function Fe(e,t){var n=De[e];0===t||10===t?((1===e?E:_)(Z(n,0)),n.length=0):n.push(t)}function Me(e,t,a,r){if(k)return Ce(6,1,e,t,a,r);for(var s=0,i=0;i<a;i++){var c=o()[t>>>2],l=o()[t+4>>>2];t+=8;for(var u=0;u<l;u++)Fe(e,n()[c+u>>>0]);s+=l}return o()[r>>>2]=s,0}function je(e){return h["_"+e]}function ze(e,t){(L.buffer!=U&&J(L.buffer),V).set(e,t>>>0)}function Le(e,t,a,r,s){var i={string:e=>{var t=0;if(null!=e&&0!==e){var a=1+(e.length<<2);(function(e,t,a){(function(e,t,n,a){if(!(a>0))return 0;for(var r=n>>>=0,s=n+a-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343)o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i);if(o<=127){if(n>=s)break;t[n++>>>0]=o}else if(o<=2047){if(n+1>=s)break;t[n++>>>0]=192|o>>6,t[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++>>>0]=224|o>>12,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}else{if(n+3>=s)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}}t[n>>>0]=0})(e,n(),t,a)})(e,t=$e(a),a)}return t},array:e=>{var t=$e(e.length);return ze(e,t),t}};var o=je(e),c=[],l=0;if(r)for(var u=0;u<r.length;u++){var d=i[a[u]];d?(0===l&&(l=Je()),c[u]=d(r[u])):c[u]=r[u]}var h,p=o.apply(null,c);return h=p,0!==l&&Qe(l),p=function(e){return"string"===t?Y(e):"boolean"===t?!!e:e}(h)}ve.init();var Pe,Be,We,Ue=[null,be,we,Ie,Ae,Re,Me],Ve={__emscripten_init_main_thread_js:function(e){He(e,!x,1,!v),ve.threadInitTLS()},__emscripten_thread_cleanup:function(e){k?postMessage({cmd:"cleanupThread",thread:e}):me(e)},__pthread_create_js:Se,_emscripten_default_pthread_stack_size:function(){return 65536},_emscripten_get_now_is_monotonic:function(){return!0},_emscripten_notify_task_queue:function(e,t,n,a){if(e==t)setTimeout(()=>Te(a));else if(k)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:a});else{var r=ve.pthreads[e];if(!r)return;r.postMessage({cmd:"processProxyingQueue",queue:a})}return 1},_emscripten_set_offscreencanvas_size:function(e,t,n){return-1},abort:function(){ce("")},emscripten_check_blocking_allowed:function(){w||x||function e(t){e.shown||(e.shown={}),e.shown[t]||(e.shown[t]=1,w&&(t="warning: "+t),_(t))}("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function(){return Date.now()},emscripten_get_heap_max:function(){return 4294901760},emscripten_get_now:Ne,emscripten_memcpy_big:function(e,t,a){n().copyWithin(e>>>0,t>>>0,t+a>>>0)},emscripten_num_logical_cores:function(){return w?z().cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(e,t,n){Ee.length=t;for(var a=n>>3,r=0;r<t;r++)Ee[r]=c()[a+r>>>0];return(e<0?pe[-e-1]:Ue[e]).apply(null,Ee)},emscripten_resize_heap:function(e){var t=n().length;if((e>>>=0)<=t)return!1;var a,r,s=4294901760;if(e>s)return!1;for(var i=1;i<=4;i*=2){var o=t*(1+.2/i);if(o=Math.min(o,e+100663296),_e(Math.min(s,(a=Math.max(e,o))+((r=65536)-a%r)%r)))return!0}return!1},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},exit:ye,fd_close:Ae,fd_seek:Re,fd_write:Me,memory:L||h.wasmMemory},Ge=(function(){var e={env:Ve,wasi_snapshot_preview1:Ve};function t(e,t){var n=e.exports;if(h.asm=n,function(e){ve.tlsInitFunctions.push(e)}(h.asm._emscripten_tls_init),$=h.asm.__indirect_function_table,function(e){te.unshift(e)}(h.asm.__wasm_call_ctors),P=t,!k){var a=ve.unusedWorkers.length;ve.unusedWorkers.forEach((function(e){ve.loadWasmModuleToWorker(e,(function(){--a||function(e){if(se--,h.monitorRunDependencies&&h.monitorRunDependencies(se),0==se&&(null!==ie&&(clearInterval(ie),ie=null),oe)){var t=oe;oe=null,t()}}()}))}))}}function n(e){t(e.instance,e.module)}function a(t){return function(){if(!A&&(v||x)){if("function"==typeof fetch&&!de(le))return fetch(le,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+le+"'";return e.arrayBuffer()})).catch((function(){return he(le)}));if(f)return new Promise((function(e,t){f(le,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return he(le)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){_("failed to asynchronously prepare wasm: "+e),ce(e)}))}if(k||(se++,h.monitorRunDependencies&&h.monitorRunDependencies(se)),h.instantiateWasm)try{return h.instantiateWasm(e,t)}catch(r){_("Module.instantiateWasm callback failed with error: "+r),u(r)}(A||"function"!=typeof WebAssembly.instantiateStreaming||ue(le)||de(le)||w||"function"!=typeof fetch?a(n):fetch(le,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return _("wasm streaming compile failed: "+e),_("falling back to ArrayBuffer instantiation"),a(n)}))}))).catch(u)}(),h.___wasm_call_ctors=function(){return(h.___wasm_call_ctors=h.asm.__wasm_call_ctors).apply(null,arguments)},h._init=function(){return(h._init=h.asm.init).apply(null,arguments)},h._init_with_threads_count=function(){return(h._init_with_threads_count=h.asm.init_with_threads_count).apply(null,arguments)},h._get_threads_count=function(){return(h._get_threads_count=h.asm.get_threads_count).apply(null,arguments)},h._register_tensor=function(){return(h._register_tensor=h.asm.register_tensor).apply(null,arguments)},h._dispose_data=function(){return(h._dispose_data=h.asm.dispose_data).apply(null,arguments)},h._dispose=function(){return(h._dispose=h.asm.dispose).apply(null,arguments)},h._Abs=function(){return(h._Abs=h.asm.Abs).apply(null,arguments)},h._Acos=function(){return(h._Acos=h.asm.Acos).apply(null,arguments)},h._Acosh=function(){return(h._Acosh=h.asm.Acosh).apply(null,arguments)},h._Add=function(){return(h._Add=h.asm.Add).apply(null,arguments)},h._AddN=function(){return(h._AddN=h.asm.AddN).apply(null,arguments)},h._All=function(){return(h._All=h.asm.All).apply(null,arguments)},h._Any=function(){return(h._Any=h.asm.Any).apply(null,arguments)},h._ArgMax=function(){return(h._ArgMax=h.asm.ArgMax).apply(null,arguments)},h._ArgMin=function(){return(h._ArgMin=h.asm.ArgMin).apply(null,arguments)},h._Asin=function(){return(h._Asin=h.asm.Asin).apply(null,arguments)},h._Asinh=function(){return(h._Asinh=h.asm.Asinh).apply(null,arguments)},h._Atan=function(){return(h._Atan=h.asm.Atan).apply(null,arguments)},h._Atan2=function(){return(h._Atan2=h.asm.Atan2).apply(null,arguments)},h._Atanh=function(){return(h._Atanh=h.asm.Atanh).apply(null,arguments)},h._AvgPool=function(){return(h._AvgPool=h.asm.AvgPool).apply(null,arguments)},h._AvgPool3D=function(){return(h._AvgPool3D=h.asm.AvgPool3D).apply(null,arguments)},h._AvgPool3DGrad=function(){return(h._AvgPool3DGrad=h.asm.AvgPool3DGrad).apply(null,arguments)},h._AvgPoolGrad=function(){return(h._AvgPoolGrad=h.asm.AvgPoolGrad).apply(null,arguments)},h._BatchMatMul=function(){return(h._BatchMatMul=h.asm.BatchMatMul).apply(null,arguments)},h._Bincount=function(){return(h._Bincount=h.asm.Bincount).apply(null,arguments)},h._BitwiseAnd=function(){return(h._BitwiseAnd=h.asm.BitwiseAnd).apply(null,arguments)},h._Ceil=function(){return(h._Ceil=h.asm.Ceil).apply(null,arguments)},h._ClipByValue=function(){return(h._ClipByValue=h.asm.ClipByValue).apply(null,arguments)},h._Conv2D=function(){return(h._Conv2D=h.asm.Conv2D).apply(null,arguments)},h._Conv2DBackpropInput=function(){return(h._Conv2DBackpropInput=h.asm.Conv2DBackpropInput).apply(null,arguments)},h._Conv3D=function(){return(h._Conv3D=h.asm.Conv3D).apply(null,arguments)},h._Conv3DBackpropFilterV2=function(){return(h._Conv3DBackpropFilterV2=h.asm.Conv3DBackpropFilterV2).apply(null,arguments)},h._Conv3DBackpropInputV2=function(){return(h._Conv3DBackpropInputV2=h.asm.Conv3DBackpropInputV2).apply(null,arguments)},h._Cos=function(){return(h._Cos=h.asm.Cos).apply(null,arguments)},h._Cosh=function(){return(h._Cosh=h.asm.Cosh).apply(null,arguments)},h._CropAndResize=function(){return(h._CropAndResize=h.asm.CropAndResize).apply(null,arguments)},h._Cumprod=function(){return(h._Cumprod=h.asm.Cumprod).apply(null,arguments)},h._Cumsum=function(){return(h._Cumsum=h.asm.Cumsum).apply(null,arguments)},h._DenseBincount=function(){return(h._DenseBincount=h.asm.DenseBincount).apply(null,arguments)},h._DepthToSpace=function(){return(h._DepthToSpace=h.asm.DepthToSpace).apply(null,arguments)},h._DepthwiseConv2dNative=function(){return(h._DepthwiseConv2dNative=h.asm.DepthwiseConv2dNative).apply(null,arguments)},h._Diag=function(){return(h._Diag=h.asm.Diag).apply(null,arguments)},h._Dilation2D=function(){return(h._Dilation2D=h.asm.Dilation2D).apply(null,arguments)},h._Dilation2DBackpropFilter=function(){return(h._Dilation2DBackpropFilter=h.asm.Dilation2DBackpropFilter).apply(null,arguments)},h._Dilation2DBackpropInput=function(){return(h._Dilation2DBackpropInput=h.asm.Dilation2DBackpropInput).apply(null,arguments)},h._Elu=function(){return(h._Elu=h.asm.Elu).apply(null,arguments)},h._EluGrad=function(){return(h._EluGrad=h.asm.EluGrad).apply(null,arguments)},h._Equal=function(){return(h._Equal=h.asm.Equal).apply(null,arguments)},h._Erf=function(){return(h._Erf=h.asm.Erf).apply(null,arguments)},h._Exp=function(){return(h._Exp=h.asm.Exp).apply(null,arguments)},h._Expm1=function(){return(h._Expm1=h.asm.Expm1).apply(null,arguments)},h._FlipLeftRight=function(){return(h._FlipLeftRight=h.asm.FlipLeftRight).apply(null,arguments)},h._Floor=function(){return(h._Floor=h.asm.Floor).apply(null,arguments)},h._FloorDiv=function(){return(h._FloorDiv=h.asm.FloorDiv).apply(null,arguments)},h._FusedBatchNorm=function(){return(h._FusedBatchNorm=h.asm.FusedBatchNorm).apply(null,arguments)},h._FusedConv2D=function(){return(h._FusedConv2D=h.asm.FusedConv2D).apply(null,arguments)},h._FusedDepthwiseConv2D=function(){return(h._FusedDepthwiseConv2D=h.asm.FusedDepthwiseConv2D).apply(null,arguments)},h._Gather=function(){return(h._Gather=h.asm.Gather).apply(null,arguments)},h._GatherNd=function(){return(h._GatherNd=h.asm.GatherNd).apply(null,arguments)},h._Greater=function(){return(h._Greater=h.asm.Greater).apply(null,arguments)},h._GreaterEqual=function(){return(h._GreaterEqual=h.asm.GreaterEqual).apply(null,arguments)},h._IsFinite=function(){return(h._IsFinite=h.asm.IsFinite).apply(null,arguments)},h._IsInf=function(){return(h._IsInf=h.asm.IsInf).apply(null,arguments)},h._IsNan=function(){return(h._IsNan=h.asm.IsNan).apply(null,arguments)},h._LRN=function(){return(h._LRN=h.asm.LRN).apply(null,arguments)},h._LRNGrad=function(){return(h._LRNGrad=h.asm.LRNGrad).apply(null,arguments)},h._LeakyRelu=function(){return(h._LeakyRelu=h.asm.LeakyRelu).apply(null,arguments)},h._Less=function(){return(h._Less=h.asm.Less).apply(null,arguments)},h._LessEqual=function(){return(h._LessEqual=h.asm.LessEqual).apply(null,arguments)},h._LinSpace=function(){return(h._LinSpace=h.asm.LinSpace).apply(null,arguments)},h._Log=function(){return(h._Log=h.asm.Log).apply(null,arguments)},h._Log1p=function(){return(h._Log1p=h.asm.Log1p).apply(null,arguments)},h._LogicalAnd=function(){return(h._LogicalAnd=h.asm.LogicalAnd).apply(null,arguments)},h._LogicalNot=function(){return(h._LogicalNot=h.asm.LogicalNot).apply(null,arguments)},h._LogicalOr=function(){return(h._LogicalOr=h.asm.LogicalOr).apply(null,arguments)},h._LogicalXor=function(){return(h._LogicalXor=h.asm.LogicalXor).apply(null,arguments)},h._Max=function(){return(h._Max=h.asm.Max).apply(null,arguments)},h._MaxPool=function(){return(h._MaxPool=h.asm.MaxPool).apply(null,arguments)},h._MaxPool3D=function(){return(h._MaxPool3D=h.asm.MaxPool3D).apply(null,arguments)},h._MaxPool3DGrad=function(){return(h._MaxPool3DGrad=h.asm.MaxPool3DGrad).apply(null,arguments)},h._MaxPoolGrad=function(){return(h._MaxPoolGrad=h.asm.MaxPoolGrad).apply(null,arguments)},h._MaxPoolWithArgmax=function(){return(h._MaxPoolWithArgmax=h.asm.MaxPoolWithArgmax).apply(null,arguments)},h._Maximum=function(){return(h._Maximum=h.asm.Maximum).apply(null,arguments)},h._Mean=function(){return(h._Mean=h.asm.Mean).apply(null,arguments)},h._Min=function(){return(h._Min=h.asm.Min).apply(null,arguments)},h._Minimum=function(){return(h._Minimum=h.asm.Minimum).apply(null,arguments)},h._MirrorPad=function(){return(h._MirrorPad=h.asm.MirrorPad).apply(null,arguments)},h._Mod=function(){return(h._Mod=h.asm.Mod).apply(null,arguments)},h._Multinomial=function(){return(h._Multinomial=h.asm.Multinomial).apply(null,arguments)},h._Multiply=function(){return(h._Multiply=h.asm.Multiply).apply(null,arguments)},h._Neg=function(){return(h._Neg=h.asm.Neg).apply(null,arguments)},h._NonMaxSuppressionV3=function(){return(h._NonMaxSuppressionV3=h.asm.NonMaxSuppressionV3).apply(null,arguments)},h._NonMaxSuppressionV4=function(){return(h._NonMaxSuppressionV4=h.asm.NonMaxSuppressionV4).apply(null,arguments)},h._NonMaxSuppressionV5=function(){return(h._NonMaxSuppressionV5=h.asm.NonMaxSuppressionV5).apply(null,arguments)},h._NotEqual=function(){return(h._NotEqual=h.asm.NotEqual).apply(null,arguments)},h._OneHot=function(){return(h._OneHot=h.asm.OneHot).apply(null,arguments)},h._PadV2=function(){return(h._PadV2=h.asm.PadV2).apply(null,arguments)},h._Pow=function(){return(h._Pow=h.asm.Pow).apply(null,arguments)},h._Prelu=function(){return(h._Prelu=h.asm.Prelu).apply(null,arguments)},h._Prod=function(){return(h._Prod=h.asm.Prod).apply(null,arguments)},h._RealDiv=function(){return(h._RealDiv=h.asm.RealDiv).apply(null,arguments)},h._Reciprocal=function(){return(h._Reciprocal=h.asm.Reciprocal).apply(null,arguments)},h._Relu=function(){return(h._Relu=h.asm.Relu).apply(null,arguments)},h._Relu6=function(){return(h._Relu6=h.asm.Relu6).apply(null,arguments)},h._ResizeBilinear=function(){return(h._ResizeBilinear=h.asm.ResizeBilinear).apply(null,arguments)},h._ResizeBilinearGrad=function(){return(h._ResizeBilinearGrad=h.asm.ResizeBilinearGrad).apply(null,arguments)},h._ResizeNearestNeighbor=function(){return(h._ResizeNearestNeighbor=h.asm.ResizeNearestNeighbor).apply(null,arguments)},h._ResizeNearestNeighborGrad=function(){return(h._ResizeNearestNeighborGrad=h.asm.ResizeNearestNeighborGrad).apply(null,arguments)},h._Reverse=function(){return(h._Reverse=h.asm.Reverse).apply(null,arguments)},h._RotateWithOffset=function(){return(h._RotateWithOffset=h.asm.RotateWithOffset).apply(null,arguments)},h._Round=function(){return(h._Round=h.asm.Round).apply(null,arguments)},h._Rsqrt=function(){return(h._Rsqrt=h.asm.Rsqrt).apply(null,arguments)},h._ScatterNd=function(){return(h._ScatterNd=h.asm.ScatterNd).apply(null,arguments)},h._SearchSorted=function(){return(h._SearchSorted=h.asm.SearchSorted).apply(null,arguments)},h._SelectV2=function(){return(h._SelectV2=h.asm.SelectV2).apply(null,arguments)},h._Selu=function(){return(h._Selu=h.asm.Selu).apply(null,arguments)},h._Sigmoid=function(){return(h._Sigmoid=h.asm.Sigmoid).apply(null,arguments)},h._Sign=function(){return(h._Sign=h.asm.Sign).apply(null,arguments)},h._Sin=function(){return(h._Sin=h.asm.Sin).apply(null,arguments)},h._Sinh=function(){return(h._Sinh=h.asm.Sinh).apply(null,arguments)},h._Softmax=function(){return(h._Softmax=h.asm.Softmax).apply(null,arguments)},h._Softplus=function(){return(h._Softplus=h.asm.Softplus).apply(null,arguments)},h._SparseFillEmptyRows=function(){return(h._SparseFillEmptyRows=h.asm.SparseFillEmptyRows).apply(null,arguments)},h._SparseReshape=function(){return(h._SparseReshape=h.asm.SparseReshape).apply(null,arguments)},h._SparseSegmentReduction=function(){return(h._SparseSegmentReduction=h.asm.SparseSegmentReduction).apply(null,arguments)},h._SparseToDense=function(){return(h._SparseToDense=h.asm.SparseToDense).apply(null,arguments)},h._Sqrt=function(){return(h._Sqrt=h.asm.Sqrt).apply(null,arguments)},h._Square=function(){return(h._Square=h.asm.Square).apply(null,arguments)},h._SquaredDifference=function(){return(h._SquaredDifference=h.asm.SquaredDifference).apply(null,arguments)},h._Step=function(){return(h._Step=h.asm.Step).apply(null,arguments)},h._StridedSlice=function(){return(h._StridedSlice=h.asm.StridedSlice).apply(null,arguments)},h._Sub=function(){return(h._Sub=h.asm.Sub).apply(null,arguments)},h._Sum=function(){return(h._Sum=h.asm.Sum).apply(null,arguments)},h._Tan=function(){return(h._Tan=h.asm.Tan).apply(null,arguments)},h._Tanh=function(){return(h._Tanh=h.asm.Tanh).apply(null,arguments)},h._TensorScatterUpdate=function(){return(h._TensorScatterUpdate=h.asm.TensorScatterUpdate).apply(null,arguments)},h._Tile=function(){return(h._Tile=h.asm.Tile).apply(null,arguments)},h._TopK=function(){return(h._TopK=h.asm.TopK).apply(null,arguments)},h._Transform=function(){return(h._Transform=h.asm.Transform).apply(null,arguments)},h._Transpose=function(){return(h._Transpose=h.asm.Transpose).apply(null,arguments)},h.__FusedMatMul=function(){return(h.__FusedMatMul=h.asm._FusedMatMul).apply(null,arguments)},h._malloc=function(){return(h._malloc=h.asm.malloc).apply(null,arguments)},h._free=function(){return(h._free=h.asm.free).apply(null,arguments)},h.__emscripten_tls_init=function(){return(h.__emscripten_tls_init=h.asm._emscripten_tls_init).apply(null,arguments)},h._pthread_self=function(){return(Ge=h._pthread_self=h.asm.pthread_self).apply(null,arguments)}),He=(h.___errno_location=function(){return(h.___errno_location=h.asm.__errno_location).apply(null,arguments)},h.__emscripten_thread_init=function(){return(He=h.__emscripten_thread_init=h.asm._emscripten_thread_init).apply(null,arguments)}),qe=(h.__emscripten_thread_crashed=function(){return(h.__emscripten_thread_crashed=h.asm._emscripten_thread_crashed).apply(null,arguments)},h._emscripten_main_thread_process_queued_calls=function(){return(h._emscripten_main_thread_process_queued_calls=h.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},h._emscripten_main_browser_thread_id=function(){return(h._emscripten_main_browser_thread_id=h.asm.emscripten_main_browser_thread_id).apply(null,arguments)},h._emscripten_run_in_main_runtime_thread_js=function(){return(qe=h._emscripten_run_in_main_runtime_thread_js=h.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)}),Ke=(h._emscripten_dispatch_to_thread_=function(){return(h._emscripten_dispatch_to_thread_=h.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},h.__emscripten_proxy_execute_task_queue=function(){return(Ke=h.__emscripten_proxy_execute_task_queue=h.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)}),Xe=h.__emscripten_thread_free_data=function(){return(Xe=h.__emscripten_thread_free_data=h.asm._emscripten_thread_free_data).apply(null,arguments)},Ze=h.__emscripten_thread_exit=function(){return(Ze=h.__emscripten_thread_exit=h.asm._emscripten_thread_exit).apply(null,arguments)},Ye=h._emscripten_stack_set_limits=function(){return(Ye=h._emscripten_stack_set_limits=h.asm.emscripten_stack_set_limits).apply(null,arguments)},Je=h.stackSave=function(){return(Je=h.stackSave=h.asm.stackSave).apply(null,arguments)},Qe=h.stackRestore=function(){return(Qe=h.stackRestore=h.asm.stackRestore).apply(null,arguments)},$e=h.stackAlloc=function(){return($e=h.stackAlloc=h.asm.stackAlloc).apply(null,arguments)};h.dynCall_iijjiiii=function(){return(h.dynCall_iijjiiii=h.asm.dynCall_iijjiiii).apply(null,arguments)},h.dynCall_jiji=function(){return(h.dynCall_jiji=h.asm.dynCall_jiji).apply(null,arguments)};function et(e){if(e=e||b,!(se>0)){if(k)return l(h),re(),void startWorker(h);(function(){if(h.preRun)for("function"==typeof h.preRun&&(h.preRun=[h.preRun]);h.preRun.length;)e=h.preRun.shift(),ee.unshift(e);var e;xe(ee)})(),se>0||(h.setStatus?(h.setStatus("Running..."),setTimeout((function(){setTimeout((function(){h.setStatus("")}),1),t()}),1)):t())}function t(){Pe||(Pe=!0,h.calledRun=!0,!W&&(re(),l(h),h.onRuntimeInitialized&&h.onRuntimeInitialized(),function(){if(!k){if(h.postRun)for("function"==typeof h.postRun&&(h.postRun=[h.postRun]);h.postRun.length;)e=h.postRun.shift(),ne.unshift(e);xe(ne)}var e}()))}}if(h.keepRuntimeAlive=ae,h.wasmMemory=L,h.cwrap=function(e,t,n,a){var r=(n=n||[]).every(e=>"number"===e||"boolean"===e);return"string"!==t&&r&&!a?je(e):function(){return Le(e,t,n,arguments)}},h.ExitStatus=fe,h.PThread=ve,oe=function e(){Pe||et(),Pe||(oe=e)},h.preInit)for("function"==typeof h.preInit&&(h.preInit=[h.preInit]);h.preInit.length>0;)h.preInit.pop()();if(et(),d&&(Be={uncaughtException:a.listeners("uncaughtException").filter((function(e){return!d.uncaughtException.indexOf(e)>-1})),unhandledRejection:a.listeners("unhandledRejection").filter((function(e){return!d.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)We=WasmBackendModule;else{if("undefined"==typeof e)throw new Error("Could not find wasm module in post.js");We=e}if(Be){var tt=We._dispose;We._dispose=function(){tt(),Be.uncaughtException.forEach((function(e){a.removeListener("uncaughtException",e)})),Be.unhandledRejection.forEach((function(e){a.removeListener("unhandledRejection",e)}))}}return e.ready}})();"object"==typeof t&&"object"==typeof i?i.exports=o:"function"==typeof define&&n(79)?define([],(function(){return o})):"object"==typeof t&&(t.WasmBackendModuleThreadedSimd=o)}),P=b((e,t)=>{t.exports.wasmWorkerContents='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'}),B=b((t,s)=>{var i=(()=>{var t="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return t=t||e,function(e){var n,s,i,o="undefined"!=typeof(e=e||{})?e:{};o.ready=new Promise((function(e,t){n=e,s=t})),"undefined"!=typeof a&&a.listeners&&(i={uncaughtException:a.listeners("uncaughtException"),unhandledRejection:a.listeners("unhandledRejection")});var c,l,u,d=Object.assign({},o),h=[],p="object"==typeof window,f="function"==typeof importScripts,m="object"==typeof a&&"object"==typeof a.versions&&"string"==typeof a.versions.node,g="";if(m){var b=D(),y=F();g=f?y.dirname(g)+"/":r+"/",c=(e,t)=>(e=H(e)?new URL(e):y.normalize(e),b.readFileSync(e,t?void 0:"utf8")),u=e=>{var t=c(e,!0);return t.buffer||(t=new Uint8Array(t)),t},l=(e,t,n)=>{e=H(e)?new URL(e):y.normalize(e),b.readFile(e,(function(e,a){e?n(e):t(a.buffer)}))},a.argv.length>1&&a.argv[1].replace(/\\/g,"/"),h=a.argv.slice(2),a.on("uncaughtException",(function(e){if(!(e instanceof K))throw e})),a.on("unhandledRejection",(function(e){throw e})),(e,t)=>{if(k)throw a.exitCode=e,t;(function(e){e instanceof K||x("exiting due to exception: "+e)})(t),a.exit(e)},o.inspect=function(){return"[Emscripten Module object]"}}else(p||f)&&(f?g=self.location.href:"undefined"!=typeof document&&document.currentScript&&(g=document.currentScript.src),t&&(g=t),g=0!==g.indexOf("blob:")?g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):"",c=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},f&&(u=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),l=(e,t,n)=>{var a=new XMLHttpRequest;a.open("GET",e,!0),a.responseType="arraybuffer",a.onload=()=>{200==a.status||0==a.status&&a.response?t(a.response):n()},a.onerror=n,a.send(null)},e=>document.title=e);var v=o.print||console.log.bind(console),x=o.printErr||console.warn.bind(console);Object.assign(o,d),d=null,o.arguments&&(h=o.arguments),o.thisProgram&&o.thisProgram,o.quit&&o.quit;var w;o.wasmBinary&&(w=o.wasmBinary);var k=o.noExitRuntime||!0;"object"!=typeof WebAssembly&&W("no native wasm support detected");var I,S=!1;var N,T,O,C,E="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function _(e,t,n){for(var a=(t>>>=0)+n,r=t;e[r]&&!(r>=a);)++r;if(r-t>16&&e.buffer&&E)return E.decode(e.subarray(t,r));for(var s="";t<r;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var c=63&e[t++];if((i=224==(240&i)?(15&i)<<12|o<<6|c:(7&i)<<18|o<<12|c<<6|63&e[t++])<65536)s+=String.fromCharCode(i);else{var l=i-65536;s+=String.fromCharCode(55296|l>>10,56320|1023&l)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function A(e,t){return(e>>>=0)?_(O,e,t):""}function R(e){N=e,o.HEAP8=T=new Int8Array(e),o.HEAP16=new Int16Array(e),o.HEAP32=new Int32Array(e),o.HEAPU8=O=new Uint8Array(e),o.HEAPU16=new Uint16Array(e),o.HEAPU32=C=new Uint32Array(e),o.HEAPF32=new Float32Array(e),o.HEAPF64=new Float64Array(e)}o.INITIAL_MEMORY;var M=[],j=[],z=[];var L=0,P=null,B=null;function W(e){o.onAbort&&o.onAbort(e),x(e="Aborted("+e+")"),S=!0,1,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw s(t),t}var U,V;function G(e){return e.startsWith("data:application/octet-stream;base64,")}function H(e){return e.startsWith("file://")}function q(e){try{if(e==U&&w)return new Uint8Array(w);if(u)return u(e);throw"both async and sync fetching of the wasm failed"}catch(t){W(t)}}function K(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function X(e){for(;e.length>0;)e.shift()(o)}function Z(e){try{return I.grow(e-N.byteLength+65535>>>16),R(I.buffer),1}catch(t){}}G(U="tfjs-backend-wasm.wasm")||(V=U,U=o.locateFile?o.locateFile(V,g):g+V);var Y=[null,[],[]];function J(e,t){var n=Y[e];0===t||10===t?((1===e?v:x)(_(n,0)),n.length=0):n.push(t)}function Q(e){return o["_"+e]}function $(e,t,n,a,r){var s={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);(function(e,t,n){(function(e,t,n,a){if(!(a>0))return 0;for(var r=n>>>=0,s=n+a-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343)o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i);if(o<=127){if(n>=s)break;t[n++>>>0]=o}else if(o<=2047){if(n+1>=s)break;t[n++>>>0]=192|o>>6,t[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++>>>0]=224|o>>12,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}else{if(n+3>=s)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}}t[n>>>0]=0})(e,O,t,n)})(e,t=ie(n),n)}return t},array:e=>{var t=ie(e.length);return function(e,t){T.set(e,t>>>0)}(e,t),t}};var i=Q(e),o=[],c=0;if(a)for(var l=0;l<a.length;l++){var u=s[n[l]];u?(0===c&&(c=re()),o[l]=u(a[l])):o[l]=a[l]}var d,h=i.apply(null,o);return d=h,0!==c&&se(c),h=function(e){return"string"===t?A(e):"boolean"===t?!!e:e}(d)}var ee,te,ne,ae={abort:function(){W("")},emscripten_get_heap_max:function(){return 4294901760},emscripten_memcpy_big:function(e,t,n){O.copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_resize_heap:function(e){var t,n,a=O.length,r=4294901760;if((e>>>=0)>r)return!1;for(var s=1;s<=4;s*=2){var i=a*(1+.2/s);if(i=Math.min(i,e+100663296),Z(Math.min(r,(t=Math.max(e,i))+((n=65536)-t%n)%n)))return!0}return!1},fd_close:function(e){return 52},fd_seek:function(e,t,n,a,r){return 70},fd_write:function(e,t,n,a){for(var r=0,s=0;s<n;s++){var i=C[t>>>2],o=C[t+4>>>2];t+=8;for(var c=0;c<o;c++)J(e,O[i+c>>>0]);r+=o}return C[a>>>2]=r,0}},re=(function(){var e={env:ae,wasi_snapshot_preview1:ae};function t(e,t){var n=e.exports;o.asm=n,R((I=o.asm.memory).buffer),o.asm.__indirect_function_table,function(e){j.unshift(e)}(o.asm.__wasm_call_ctors),function(e){if(L--,o.monitorRunDependencies&&o.monitorRunDependencies(L),0==L&&(null!==P&&(clearInterval(P),P=null),B)){var t=B;B=null,t()}}()}function n(e){t(e.instance)}function a(t){return function(){if(!w&&(p||f)){if("function"==typeof fetch&&!H(U))return fetch(U,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+U+"'";return e.arrayBuffer()})).catch((function(){return q(U)}));if(l)return new Promise((function(e,t){l(U,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return q(U)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){x("failed to asynchronously prepare wasm: "+e),W(e)}))}if(L++,o.monitorRunDependencies&&o.monitorRunDependencies(L),o.instantiateWasm)try{return o.instantiateWasm(e,t)}catch(r){x("Module.instantiateWasm callback failed with error: "+r),s(r)}(w||"function"!=typeof WebAssembly.instantiateStreaming||G(U)||H(U)||m||"function"!=typeof fetch?a(n):fetch(U,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return x("wasm streaming compile failed: "+e),x("falling back to ArrayBuffer instantiation"),a(n)}))}))).catch(s)}(),o.___wasm_call_ctors=function(){return(o.___wasm_call_ctors=o.asm.__wasm_call_ctors).apply(null,arguments)},o._init=function(){return(o._init=o.asm.init).apply(null,arguments)},o._init_with_threads_count=function(){return(o._init_with_threads_count=o.asm.init_with_threads_count).apply(null,arguments)},o._get_threads_count=function(){return(o._get_threads_count=o.asm.get_threads_count).apply(null,arguments)},o._register_tensor=function(){return(o._register_tensor=o.asm.register_tensor).apply(null,arguments)},o._dispose_data=function(){return(o._dispose_data=o.asm.dispose_data).apply(null,arguments)},o._dispose=function(){return(o._dispose=o.asm.dispose).apply(null,arguments)},o._Abs=function(){return(o._Abs=o.asm.Abs).apply(null,arguments)},o._Acos=function(){return(o._Acos=o.asm.Acos).apply(null,arguments)},o._Acosh=function(){return(o._Acosh=o.asm.Acosh).apply(null,arguments)},o._Add=function(){return(o._Add=o.asm.Add).apply(null,arguments)},o._AddN=function(){return(o._AddN=o.asm.AddN).apply(null,arguments)},o._All=function(){return(o._All=o.asm.All).apply(null,arguments)},o._Any=function(){return(o._Any=o.asm.Any).apply(null,arguments)},o._ArgMax=function(){return(o._ArgMax=o.asm.ArgMax).apply(null,arguments)},o._ArgMin=function(){return(o._ArgMin=o.asm.ArgMin).apply(null,arguments)},o._Asin=function(){return(o._Asin=o.asm.Asin).apply(null,arguments)},o._Asinh=function(){return(o._Asinh=o.asm.Asinh).apply(null,arguments)},o._Atan=function(){return(o._Atan=o.asm.Atan).apply(null,arguments)},o._Atan2=function(){return(o._Atan2=o.asm.Atan2).apply(null,arguments)},o._Atanh=function(){return(o._Atanh=o.asm.Atanh).apply(null,arguments)},o._AvgPool=function(){return(o._AvgPool=o.asm.AvgPool).apply(null,arguments)},o._AvgPool3D=function(){return(o._AvgPool3D=o.asm.AvgPool3D).apply(null,arguments)},o._AvgPool3DGrad=function(){return(o._AvgPool3DGrad=o.asm.AvgPool3DGrad).apply(null,arguments)},o._AvgPoolGrad=function(){return(o._AvgPoolGrad=o.asm.AvgPoolGrad).apply(null,arguments)},o._BatchMatMul=function(){return(o._BatchMatMul=o.asm.BatchMatMul).apply(null,arguments)},o._Bincount=function(){return(o._Bincount=o.asm.Bincount).apply(null,arguments)},o._BitwiseAnd=function(){return(o._BitwiseAnd=o.asm.BitwiseAnd).apply(null,arguments)},o._Ceil=function(){return(o._Ceil=o.asm.Ceil).apply(null,arguments)},o._ClipByValue=function(){return(o._ClipByValue=o.asm.ClipByValue).apply(null,arguments)},o._Conv2D=function(){return(o._Conv2D=o.asm.Conv2D).apply(null,arguments)},o._Conv2DBackpropInput=function(){return(o._Conv2DBackpropInput=o.asm.Conv2DBackpropInput).apply(null,arguments)},o._Conv3D=function(){return(o._Conv3D=o.asm.Conv3D).apply(null,arguments)},o._Conv3DBackpropFilterV2=function(){return(o._Conv3DBackpropFilterV2=o.asm.Conv3DBackpropFilterV2).apply(null,arguments)},o._Conv3DBackpropInputV2=function(){return(o._Conv3DBackpropInputV2=o.asm.Conv3DBackpropInputV2).apply(null,arguments)},o._Cos=function(){return(o._Cos=o.asm.Cos).apply(null,arguments)},o._Cosh=function(){return(o._Cosh=o.asm.Cosh).apply(null,arguments)},o._CropAndResize=function(){return(o._CropAndResize=o.asm.CropAndResize).apply(null,arguments)},o._Cumprod=function(){return(o._Cumprod=o.asm.Cumprod).apply(null,arguments)},o._Cumsum=function(){return(o._Cumsum=o.asm.Cumsum).apply(null,arguments)},o._DenseBincount=function(){return(o._DenseBincount=o.asm.DenseBincount).apply(null,arguments)},o._DepthToSpace=function(){return(o._DepthToSpace=o.asm.DepthToSpace).apply(null,arguments)},o._DepthwiseConv2dNative=function(){return(o._DepthwiseConv2dNative=o.asm.DepthwiseConv2dNative).apply(null,arguments)},o._Diag=function(){return(o._Diag=o.asm.Diag).apply(null,arguments)},o._Dilation2D=function(){return(o._Dilation2D=o.asm.Dilation2D).apply(null,arguments)},o._Dilation2DBackpropFilter=function(){return(o._Dilation2DBackpropFilter=o.asm.Dilation2DBackpropFilter).apply(null,arguments)},o._Dilation2DBackpropInput=function(){return(o._Dilation2DBackpropInput=o.asm.Dilation2DBackpropInput).apply(null,arguments)},o._Elu=function(){return(o._Elu=o.asm.Elu).apply(null,arguments)},o._EluGrad=function(){return(o._EluGrad=o.asm.EluGrad).apply(null,arguments)},o._Equal=function(){return(o._Equal=o.asm.Equal).apply(null,arguments)},o._Erf=function(){return(o._Erf=o.asm.Erf).apply(null,arguments)},o._Exp=function(){return(o._Exp=o.asm.Exp).apply(null,arguments)},o._Expm1=function(){return(o._Expm1=o.asm.Expm1).apply(null,arguments)},o._FlipLeftRight=function(){return(o._FlipLeftRight=o.asm.FlipLeftRight).apply(null,arguments)},o._Floor=function(){return(o._Floor=o.asm.Floor).apply(null,arguments)},o._FloorDiv=function(){return(o._FloorDiv=o.asm.FloorDiv).apply(null,arguments)},o._FusedBatchNorm=function(){return(o._FusedBatchNorm=o.asm.FusedBatchNorm).apply(null,arguments)},o._FusedConv2D=function(){return(o._FusedConv2D=o.asm.FusedConv2D).apply(null,arguments)},o._FusedDepthwiseConv2D=function(){return(o._FusedDepthwiseConv2D=o.asm.FusedDepthwiseConv2D).apply(null,arguments)},o._Gather=function(){return(o._Gather=o.asm.Gather).apply(null,arguments)},o._GatherNd=function(){return(o._GatherNd=o.asm.GatherNd).apply(null,arguments)},o._Greater=function(){return(o._Greater=o.asm.Greater).apply(null,arguments)},o._GreaterEqual=function(){return(o._GreaterEqual=o.asm.GreaterEqual).apply(null,arguments)},o._IsFinite=function(){return(o._IsFinite=o.asm.IsFinite).apply(null,arguments)},o._IsInf=function(){return(o._IsInf=o.asm.IsInf).apply(null,arguments)},o._IsNan=function(){return(o._IsNan=o.asm.IsNan).apply(null,arguments)},o._LRN=function(){return(o._LRN=o.asm.LRN).apply(null,arguments)},o._LRNGrad=function(){return(o._LRNGrad=o.asm.LRNGrad).apply(null,arguments)},o._LeakyRelu=function(){return(o._LeakyRelu=o.asm.LeakyRelu).apply(null,arguments)},o._Less=function(){return(o._Less=o.asm.Less).apply(null,arguments)},o._LessEqual=function(){return(o._LessEqual=o.asm.LessEqual).apply(null,arguments)},o._LinSpace=function(){return(o._LinSpace=o.asm.LinSpace).apply(null,arguments)},o._Log=function(){return(o._Log=o.asm.Log).apply(null,arguments)},o._Log1p=function(){return(o._Log1p=o.asm.Log1p).apply(null,arguments)},o._LogicalAnd=function(){return(o._LogicalAnd=o.asm.LogicalAnd).apply(null,arguments)},o._LogicalNot=function(){return(o._LogicalNot=o.asm.LogicalNot).apply(null,arguments)},o._LogicalOr=function(){return(o._LogicalOr=o.asm.LogicalOr).apply(null,arguments)},o._LogicalXor=function(){return(o._LogicalXor=o.asm.LogicalXor).apply(null,arguments)},o._Max=function(){return(o._Max=o.asm.Max).apply(null,arguments)},o._MaxPool=function(){return(o._MaxPool=o.asm.MaxPool).apply(null,arguments)},o._MaxPool3D=function(){return(o._MaxPool3D=o.asm.MaxPool3D).apply(null,arguments)},o._MaxPool3DGrad=function(){return(o._MaxPool3DGrad=o.asm.MaxPool3DGrad).apply(null,arguments)},o._MaxPoolGrad=function(){return(o._MaxPoolGrad=o.asm.MaxPoolGrad).apply(null,arguments)},o._MaxPoolWithArgmax=function(){return(o._MaxPoolWithArgmax=o.asm.MaxPoolWithArgmax).apply(null,arguments)},o._Maximum=function(){return(o._Maximum=o.asm.Maximum).apply(null,arguments)},o._Mean=function(){return(o._Mean=o.asm.Mean).apply(null,arguments)},o._Min=function(){return(o._Min=o.asm.Min).apply(null,arguments)},o._Minimum=function(){return(o._Minimum=o.asm.Minimum).apply(null,arguments)},o._MirrorPad=function(){return(o._MirrorPad=o.asm.MirrorPad).apply(null,arguments)},o._Mod=function(){return(o._Mod=o.asm.Mod).apply(null,arguments)},o._Multinomial=function(){return(o._Multinomial=o.asm.Multinomial).apply(null,arguments)},o._Multiply=function(){return(o._Multiply=o.asm.Multiply).apply(null,arguments)},o._Neg=function(){return(o._Neg=o.asm.Neg).apply(null,arguments)},o._NonMaxSuppressionV3=function(){return(o._NonMaxSuppressionV3=o.asm.NonMaxSuppressionV3).apply(null,arguments)},o._NonMaxSuppressionV4=function(){return(o._NonMaxSuppressionV4=o.asm.NonMaxSuppressionV4).apply(null,arguments)},o._NonMaxSuppressionV5=function(){return(o._NonMaxSuppressionV5=o.asm.NonMaxSuppressionV5).apply(null,arguments)},o._NotEqual=function(){return(o._NotEqual=o.asm.NotEqual).apply(null,arguments)},o._OneHot=function(){return(o._OneHot=o.asm.OneHot).apply(null,arguments)},o._PadV2=function(){return(o._PadV2=o.asm.PadV2).apply(null,arguments)},o._Pow=function(){return(o._Pow=o.asm.Pow).apply(null,arguments)},o._Prelu=function(){return(o._Prelu=o.asm.Prelu).apply(null,arguments)},o._Prod=function(){return(o._Prod=o.asm.Prod).apply(null,arguments)},o._RealDiv=function(){return(o._RealDiv=o.asm.RealDiv).apply(null,arguments)},o._Reciprocal=function(){return(o._Reciprocal=o.asm.Reciprocal).apply(null,arguments)},o._Relu=function(){return(o._Relu=o.asm.Relu).apply(null,arguments)},o._Relu6=function(){return(o._Relu6=o.asm.Relu6).apply(null,arguments)},o._ResizeBilinear=function(){return(o._ResizeBilinear=o.asm.ResizeBilinear).apply(null,arguments)},o._ResizeBilinearGrad=function(){return(o._ResizeBilinearGrad=o.asm.ResizeBilinearGrad).apply(null,arguments)},o._ResizeNearestNeighbor=function(){return(o._ResizeNearestNeighbor=o.asm.ResizeNearestNeighbor).apply(null,arguments)},o._ResizeNearestNeighborGrad=function(){return(o._ResizeNearestNeighborGrad=o.asm.ResizeNearestNeighborGrad).apply(null,arguments)},o._Reverse=function(){return(o._Reverse=o.asm.Reverse).apply(null,arguments)},o._RotateWithOffset=function(){return(o._RotateWithOffset=o.asm.RotateWithOffset).apply(null,arguments)},o._Round=function(){return(o._Round=o.asm.Round).apply(null,arguments)},o._Rsqrt=function(){return(o._Rsqrt=o.asm.Rsqrt).apply(null,arguments)},o._ScatterNd=function(){return(o._ScatterNd=o.asm.ScatterNd).apply(null,arguments)},o._SearchSorted=function(){return(o._SearchSorted=o.asm.SearchSorted).apply(null,arguments)},o._SelectV2=function(){return(o._SelectV2=o.asm.SelectV2).apply(null,arguments)},o._Selu=function(){return(o._Selu=o.asm.Selu).apply(null,arguments)},o._Sigmoid=function(){return(o._Sigmoid=o.asm.Sigmoid).apply(null,arguments)},o._Sign=function(){return(o._Sign=o.asm.Sign).apply(null,arguments)},o._Sin=function(){return(o._Sin=o.asm.Sin).apply(null,arguments)},o._Sinh=function(){return(o._Sinh=o.asm.Sinh).apply(null,arguments)},o._Softmax=function(){return(o._Softmax=o.asm.Softmax).apply(null,arguments)},o._Softplus=function(){return(o._Softplus=o.asm.Softplus).apply(null,arguments)},o._SparseFillEmptyRows=function(){return(o._SparseFillEmptyRows=o.asm.SparseFillEmptyRows).apply(null,arguments)},o._SparseReshape=function(){return(o._SparseReshape=o.asm.SparseReshape).apply(null,arguments)},o._SparseSegmentReduction=function(){return(o._SparseSegmentReduction=o.asm.SparseSegmentReduction).apply(null,arguments)},o._SparseToDense=function(){return(o._SparseToDense=o.asm.SparseToDense).apply(null,arguments)},o._Sqrt=function(){return(o._Sqrt=o.asm.Sqrt).apply(null,arguments)},o._Square=function(){return(o._Square=o.asm.Square).apply(null,arguments)},o._SquaredDifference=function(){return(o._SquaredDifference=o.asm.SquaredDifference).apply(null,arguments)},o._Step=function(){return(o._Step=o.asm.Step).apply(null,arguments)},o._StridedSlice=function(){return(o._StridedSlice=o.asm.StridedSlice).apply(null,arguments)},o._Sub=function(){return(o._Sub=o.asm.Sub).apply(null,arguments)},o._Sum=function(){return(o._Sum=o.asm.Sum).apply(null,arguments)},o._Tan=function(){return(o._Tan=o.asm.Tan).apply(null,arguments)},o._Tanh=function(){return(o._Tanh=o.asm.Tanh).apply(null,arguments)},o._TensorScatterUpdate=function(){return(o._TensorScatterUpdate=o.asm.TensorScatterUpdate).apply(null,arguments)},o._Tile=function(){return(o._Tile=o.asm.Tile).apply(null,arguments)},o._TopK=function(){return(o._TopK=o.asm.TopK).apply(null,arguments)},o._Transform=function(){return(o._Transform=o.asm.Transform).apply(null,arguments)},o._Transpose=function(){return(o._Transpose=o.asm.Transpose).apply(null,arguments)},o.__FusedMatMul=function(){return(o.__FusedMatMul=o.asm._FusedMatMul).apply(null,arguments)},o._malloc=function(){return(o._malloc=o.asm.malloc).apply(null,arguments)},o._free=function(){return(o._free=o.asm.free).apply(null,arguments)},o.___errno_location=function(){return(o.___errno_location=o.asm.__errno_location).apply(null,arguments)},o.stackSave=function(){return(re=o.stackSave=o.asm.stackSave).apply(null,arguments)}),se=o.stackRestore=function(){return(se=o.stackRestore=o.asm.stackRestore).apply(null,arguments)},ie=o.stackAlloc=function(){return(ie=o.stackAlloc=o.asm.stackAlloc).apply(null,arguments)};o.dynCall_iijjiiii=function(){return(o.dynCall_iijjiiii=o.asm.dynCall_iijjiiii).apply(null,arguments)},o.dynCall_jiji=function(){return(o.dynCall_jiji=o.asm.dynCall_jiji).apply(null,arguments)};function oe(e){function t(){ee||(ee=!0,o.calledRun=!0,!S&&(!0,X(j),n(o),o.onRuntimeInitialized&&o.onRuntimeInitialized(),function(){if(o.postRun)for("function"==typeof o.postRun&&(o.postRun=[o.postRun]);o.postRun.length;)e=o.postRun.shift(),z.unshift(e);var e;X(z)}()))}e=e||h,L>0||(function(){if(o.preRun)for("function"==typeof o.preRun&&(o.preRun=[o.preRun]);o.preRun.length;)e=o.preRun.shift(),M.unshift(e);var e;X(M)}(),L>0)||(o.setStatus?(o.setStatus("Running..."),setTimeout((function(){setTimeout((function(){o.setStatus("")}),1),t()}),1)):t())}if(o.cwrap=function(e,t,n,a){var r=(n=n||[]).every(e=>"number"===e||"boolean"===e);return"string"!==t&&r&&!a?Q(e):function(){return $(e,t,n,arguments)}},B=function e(){ee||oe(),ee||(B=e)},o.preInit)for("function"==typeof o.preInit&&(o.preInit=[o.preInit]);o.preInit.length>0;)o.preInit.pop()();if(oe(),i&&(te={uncaughtException:a.listeners("uncaughtException").filter((function(e){return!i.uncaughtException.indexOf(e)>-1})),unhandledRejection:a.listeners("unhandledRejection").filter((function(e){return!i.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof e)ne=e;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");ne=WasmBackendModuleThreadedSimd}if(te){var ce=ne._dispose;ne._dispose=function(){ce(),te.uncaughtException.forEach((function(e){a.removeListener("uncaughtException",e)})),te.unhandledRejection.forEach((function(e){a.removeListener("unhandledRejection",e)}))}}return e.ready}})();"object"==typeof t&&"object"==typeof s?s.exports=i:"function"==typeof define&&n(79)?define([],(function(){return i})):"object"==typeof t&&(t.WasmBackendModule=i)}),W=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},U=class{refCount(e){return V("refCount")}incRef(e){return V("incRef")}timerAvailable(){return!0}time(e){return V("time")}read(e){return V("read")}readSync(e){return V("readSync")}readToGPU(e,t){return V("readToGPU")}numDataIds(){return V("numDataIds")}disposeData(e,t){return V("disposeData")}write(e,t,n){return V("write")}move(e,t,n,a,r){return V("move")}createTensorFromGPUData(e,t,n){return V("createTensorFromGPUData")}memory(){return V("memory")}floatPrecision(){return V("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return V("dispose")}};function V(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen"))}function G(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,X(e,t,n)}function H(e,t){if(e.length!==t.length)throw new Error("Array sizes must match to be shuffled together First array length was ".concat(e.length,"Second array length was ").concat(t.length));let n=e.length,a=0;for(;n>0;)a=Math.random()*n|0,n--,X(e,n,a),X(t,n,a)}function q(e,t,n){return Math.max(e,Math.min(t,n))}function K(e){return e%2===0?e:e+1}function X(e,t,n){let a=e[t];e[t]=e[n],e[n]=a}function Z(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function Y(e,t){let n=Math.random();return t*n+(1-n)*e}function J(e,t){let n=0;for(let a=0;a<e.length;a++){let r=Number(e[a])-Number(t[a]);n+=r*r}return n}function Q(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function $(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";Q(re(e,t),()=>n+" Shapes ".concat(e," and ").concat(t," must match"))}function ee(e){Q(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function te(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function ne(e){return 0===e.length}function ae(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function re(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function se(e){return e%1===0}function ie(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function oe(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function ce(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return G(t),t}function le(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function ue(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return new Promise((r,s)=>{let i=0,o=()=>{if(e())return void r();i++;let c=t(i);null!=n&&i>=n?s():null!=a?a(o,c):setTimeout(o,c)};o()})}function de(e,t){let n=1,a=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==a)throw Error("Shapes can only have 1 implicit size. Found -1 at dim ".concat(a," and dim ").concat(s));a=s}else if(e[s]<0)throw Error("Shapes can not be < 0. Found ".concat(e[s]," at dim ").concat(s));if(-1===a){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when there are 0 elements"));if(t%n!==0)throw Error("The implicit shape can't be a fractional number. Got ".concat(t," / ").concat(n));let r=e.slice();return r[a]=t/n,r}function he(e,t){let n=t.length;return Q((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but got axis ").concat(e)),Q(e.every(e=>se(e)),()=>"All values in axis param must be integers but got axis ".concat(e)),e.map(e=>e<0?n+e:e)}function pe(e,t){let n=[],a=[],r=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||r?null:he(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(null!=s){if(s[i]===o&&1!==e[o])throw new Error("Can't squeeze axis ".concat(o," since its dim '").concat(e[o],"' is not 1"));(null==s[i]||s[i]>o)&&1===e[o]&&(n.push(e[o]),a.push(o)),s[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),a.push(o))}return{newShape:n,keptDims:a}}function fe(e,t){return me(e,t)}function me(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function ge(e,t){for(let n=0;n<e.length;n++){let a=e[n];if(isNaN(a)||!isFinite(a))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(a,"."))}}function be(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function ye(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function ve(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function xe(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}function we(e){return"string"==typeof e||e instanceof String}function ke(e){return"boolean"==typeof e}function Ie(e){return"number"==typeof e}function Se(e){return Array.isArray(e)?Se(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Ie(e)?"float32":we(e)?"string":ke(e)?"bool":"float32"}function Ne(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Te(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Oe(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function Ce(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=new Array;if(1===t.length){let s=t[0]*(a?2:1);for(let t=0;t<s;t++)r[t]=n[e+t]}else{let s=t[0],i=t.slice(1),o=i.reduce((e,t)=>e*t)*(a?2:1);for(let t=0;t<s;t++)r[t]=Ce(e+t*o,i,n,a)}return r}function Ee(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];let a=e.reduce((e,t)=>e*t)*(n?2:1);if(0===a)return[];if(a!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return Ce(0,e,t,n)}function _e(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error("Unknown dtype ".concat(t))}function Ae(e,t){let n=Re(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function Re(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function De(e,t){let n=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return Ee(e,new Float32Array(n));if("int32"===t)return Ee(e,new Int32Array(n));if("bool"===t)return Ee(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function Fe(e){e.forEach(t=>{Q(Number.isInteger(t)&&t>=0,()=>"Tensor must have a shape comprised of positive integers but got shape [".concat(e,"]."))})}function Me(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function je(e,t,n){if(0===t)return[];if(1===t)return[e];let a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function ze(e){return e&&e.then&&"function"==typeof e.then}var Le="tfjsflags",Pe=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Be,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(Ue().getBool("IS_TEST")||Ue().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. Overwriting the platform with ").concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){let t=this.urlFlags[e];Ue().getBool("IS_TEST")||Ue().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(ze(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. Please use getAsync() instead."));return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"==typeof this.global||"undefined"==typeof this.global.location||"undefined"==typeof this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);Le in e&&e[Le].split(",").forEach(e=>{let[t,n]=e.split(":");this.urlFlags[t]=function(e,t){let n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:t}(0,n)})}};function Be(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];return We(t,a[0],a[1]),a.join("=")})),t}function We(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function Ue(){return Ge}var Ve,Ge=null;function He(){if(null==Ve){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof s)e=s;else if("undefined"!=typeof a)e=a;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}Ve=e}return Ve}function qe(e,t){let n=function(){let e=He();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{let a=t();return n.set(e,a),n.get(e)}}var Ke="Abs",Xe="Acos",Ze="Acosh",Ye="Add",Je="AddN",Qe="All",$e="Any",et="ArgMax",tt="ArgMin",nt="Asin",at="Asinh",rt="Atan",st="Atanh",it="Atan2",ot="AvgPool",ct="AvgPoolGrad",lt="AvgPool3D",ut="AvgPool3DGrad",dt="BatchMatMul",ht="BatchToSpaceND",pt="Bincount",ft="BitwiseAnd",mt="BroadcastTo",gt="BroadcastArgs",bt="Cast",yt="Ceil",vt="ClipByValue",xt="Complex",wt="ComplexAbs",kt="Concat",It="Conv2D",St="Conv2DBackpropFilter",Nt="Conv2DBackpropInput",Tt="Conv3D",Ot="Conv3DBackpropFilterV2",Ct="Conv3DBackpropInputV2",Et="Cos",_t="Cosh",At="Cumprod",Rt="Cumsum",Dt="CropAndResize",Ft="DenseBincount",Mt="DepthToSpace",jt="DepthwiseConv2dNative",zt="DepthwiseConv2dNativeBackpropFilter",Lt="DepthwiseConv2dNativeBackpropInput",Pt="Diag",Bt="Dilation2D",Wt="Dilation2DBackpropInput",Ut="Dilation2DBackpropFilter",Vt="Draw",Gt="RealDiv",Ht="Einsum",qt="Elu",Kt="EluGrad",Xt="Erf",Zt="Equal",Yt="Exp",Jt="ExpandDims",Qt="Expm1",$t="FFT",en="Fill",tn="FlipLeftRight",nn="Floor",an="FloorDiv",rn="FusedBatchNorm",sn="GatherV2",on="GatherNd",cn="Greater",ln="GreaterEqual",un="Identity",dn="IFFT",hn="Imag",pn="IsFinite",fn="IsInf",mn="IsNan",gn="LeakyRelu",bn="Less",yn="LessEqual",vn="LinSpace",xn="Log",wn="Log1p",kn="LogicalAnd",In="LogicalNot",Sn="LogicalOr",Nn="LogicalXor",Tn="LogSoftmax",On="LowerBound",Cn="LRN",En="LRNGrad",_n="MatrixBandPart",An="Max",Rn="Maximum",Dn="MaxPool",Fn="MaxPoolGrad",Mn="MaxPool3D",jn="MaxPool3DGrad",zn="MaxPoolWithArgmax",Ln="Mean",Pn="Min",Bn="Minimum",Wn="MirrorPad",Un="Mod",Vn="Multinomial",Gn="Multiply",Hn="Neg",qn="NotEqual",Kn="NonMaxSuppressionV3",Xn="NonMaxSuppressionV4",Zn="NonMaxSuppressionV5",Yn="OnesLike",Jn="OneHot",Qn="Pack",$n="PadV2",ea="Pool",ta="Pow",na="Prelu",aa="Prod",ra="RaggedGather",sa="RaggedRange",ia="RaggedTensorToTensor",oa="Range",ca="Real",la="Reciprocal",ua="Relu",da="Reshape",ha="ResizeNearestNeighbor",pa="ResizeNearestNeighborGrad",fa="ResizeBilinear",ma="ResizeBilinearGrad",ga="Relu6",ba="Reverse",ya="Round",va="Rsqrt",xa="ScatterNd",wa="TensorScatterUpdate",ka="SearchSorted",Ia="Select",Sa="Selu",Na="Slice",Ta="Sin",Oa="Sinh",Ca="Sign",Ea="Sigmoid",_a="Softplus",Aa="Sqrt",Ra="Sum",Da="SpaceToBatchND",Fa="SplitV",Ma="Softmax",ja="SparseFillEmptyRows",za="SparseReshape",La="SparseSegmentMean",Pa="SparseSegmentSum",Ba="SparseToDense",Wa="SquaredDifference",Ua="Square",Va="StaticRegexReplace",Ga="StridedSlice",Ha="StringNGrams",qa="StringSplit",Ka="StringToHashBucketFast",Xa="Sub",Za="Tan",Ya="Tanh",Ja="Tile",Qa="TopK",$a="Transform",er="Transpose",tr="Unique",nr="Unpack",ar="UnsortedSegmentSum",rr="UpperBound",sr="ZerosLike",ir="Step",or="FromPixels",cr="RotateWithOffset",lr="_FusedMatMul",ur="FusedConv2D",dr="FusedDepthwiseConv2D";function hr(){Ue().getBool("IS_TEST")||Ue().getBool("PROD")||console.warn(...arguments)}function pr(){Ue().getBool("IS_TEST")||Ue().getBool("PROD")||console.log(...arguments)}var fr=qe("kernelRegistry",()=>new Map),mr=qe("gradRegistry",()=>new Map);function gr(e,t){let n=Sr(e,t);return fr.get(n)}function br(e){return mr.get(e)}function yr(e){let t=fr.entries(),n=[];for(;;){let{done:a,value:r}=t.next();if(a)break;let[s,i]=r,[o]=s.split("_");o===e&&n.push(i)}return n}function vr(e){let{kernelName:t,backendName:n}=e,a=Sr(t,n);fr.has(a)&&hr("The kernel '".concat(t,"' for backend '").concat(n,"' is already registered")),fr.set(a,e)}function xr(e){let{kernelName:t}=e;mr.has(t)&&Ue().getBool("DEBUG")&&hr("Overriding the gradient for '".concat(t,"'")),mr.set(t,e)}function wr(e,t){let n=Sr(e,t);if(!fr.has(n))throw new Error("The kernel '".concat(e,"' for backend '").concat(t,"' is not registered"));fr.delete(n)}function kr(e){if(!mr.has(e))throw new Error("The gradient '".concat(e,"' for backend is not registered"));mr.delete(e)}function Ir(e,t){yr(e).forEach(e=>{vr(Object.assign({},e,{backendName:t}))})}function Sr(e,t){return"".concat(t,"_").concat(e)}var Nr={};function Tr(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}y(Nr,{arraysEqual:()=>re,arraysEqualWithNull:()=>ae,assert:()=>Q,assertNonNegativeIntegerDimensions:()=>Fe,assertNonNull:()=>ee,assertShapesMatch:()=>$,bytesFromStringArray:()=>xe,bytesPerElement:()=>ve,checkConversionForErrors:()=>ge,clamp:()=>q,computeStrides:()=>Oe,convertBackendValuesAndArrayBuffer:()=>_e,createScalarValue:()=>Gr,createShuffledIndices:()=>ce,decodeString:()=>Zr,distSquared:()=>J,encodeString:()=>Xr,fetch:()=>Kr,fingerPrint64:()=>Vr,flatten:()=>Jr,getArrayFromDType:()=>me,getTypedArrayFromDType:()=>fe,hasEncodingLoss:()=>ye,hexToLong:()=>Er,indexToLoc:()=>je,inferDtype:()=>Se,inferFromImplicitShape:()=>de,isBoolean:()=>ke,isFunction:()=>Ne,isInt:()=>se,isNumber:()=>Ie,isPromise:()=>ze,isScalarShape:()=>ne,isString:()=>we,isTypedArray:()=>Yr,isValidDtype:()=>be,locToIndex:()=>Me,makeOnesTypedArray:()=>Ae,makeZerosNestedTypedArray:()=>De,makeZerosTypedArray:()=>Re,nearestDivisor:()=>Te,nearestLargerEven:()=>K,now:()=>qr,parseAxisParam:()=>he,randUniform:()=>Y,repeatedTry:()=>ue,rightPad:()=>le,shuffle:()=>G,shuffleCombo:()=>H,sizeFromShape:()=>te,sizeToSquarishShape:()=>oe,squeezeShape:()=>pe,sum:()=>Z,swap:()=>X,tanh:()=>ie,toNestedArray:()=>Ee,toTypedArray:()=>Hr});var Or=v(x()),Cr=Or.default||Or;function Er(e){return Cr.fromString(e,!0,16)}var _r=Er("c3a5c85c97cb3127"),Ar=Er("b492b66fbe98f273"),Rr=Er("9ae16a3b2f90404f");function Dr(e){return e.xor(e.shru(47))}function Fr(e,t,n){let a=e.slice(t,t+n);return Cr.fromBytes(Array.from(a),!0,!0)}function Mr(e,t){return Fr(e,t,8)}function jr(e,t){return Fr(e,t,4)}function zr(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Lr(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Er("9ddfea08eb382d69"),a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function Pr(e,t,n,a){return function(e,t,n,a,r,s){r=r.add(e),s=zr(s.add(r).add(a),21);let i=r;return r=(r=r.add(t)).add(n),s=s.add(zr(r,44)),[r.add(a),s.add(i)]}(Mr(e,t),Mr(e,t+8),Mr(e,t+16),Mr(e,t+24),n,a)}function Br(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){let n=Rr.add(2*t),a=Mr(e,0).add(Rr),r=Mr(e,t-8);return Lr(zr(r,37).mul(n).add(a),zr(a,25).add(r).mul(n),n)}if(t>=4){let n=Rr.add(2*t);return Lr(jr(e,0).shl(3).add(t),jr(e,t-4),n)}if(t>0){let n=e[0]+(e[t>>1]<<8),a=t+(e[t-1]<<2);return Dr(Rr.mul(n).xor(_r.mul(a))).mul(Rr)}return Rr}function Wr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=Rr.add(2*t),a=Mr(e,0).mul(Ar),r=Mr(e,8),s=Mr(e,t-8).mul(n),i=Mr(e,t-16).mul(Rr);return Lr(zr(a.add(r),43).add(zr(s,30)).add(i),a.add(zr(r.add(Rr),18)).add(s),n)}function Ur(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=Rr.add(2*t),a=Mr(e,0).mul(Rr),r=Mr(e,8),s=Mr(e,t-8).mul(n),i=Mr(e,t-16).mul(Rr),o=zr(a.add(r),43).add(zr(s,30)).add(i),c=Lr(o,a.add(zr(r.add(Rr),18)).add(s),n),l=Mr(e,16).mul(n),u=Mr(e,24),d=o.add(Mr(e,t-32)).mul(n),h=c.add(Mr(e,t-24)).mul(n);return Lr(zr(l.add(u),43).add(zr(d,30)).add(h),l.add(zr(u.add(a),18)).add(d),n)}function Vr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=Cr.fromNumber(81,!0);if(t<=32)return t<=16?Br(e,t):Wr(e,t);if(t<=64)return Ur(e,t);let a=n,r=n.mul(Ar).add(113),s=Dr(r.mul(Rr).add(113)).mul(Rr),i=[Cr.UZERO,Cr.UZERO],o=[Cr.UZERO,Cr.UZERO];a=a.mul(Rr).add(Mr(e,0));let c=0,l=64*(t-1>>6),u=l+(t-1&63)-63;do{a=zr(a.add(r).add(i[0]).add(Mr(e,c+8)),37).mul(Ar),r=zr(r.add(i[1]).add(Mr(e,c+48)),42).mul(Ar),a=a.xor(o[1]),r=r.add(i[0]).add(Mr(e,c+40)),s=zr(s.add(o[0]),33).mul(Ar),i=Pr(e,c,i[1].mul(Ar),a.add(o[0])),o=Pr(e,c+32,s.add(o[1]),r.add(Mr(e,c+16))),[s,a]=[a,s],c+=64}while(c!==l);let d=Ar.add(s.and(255).shl(1));return c=u,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),a=zr(a.add(r).add(i[0]).add(Mr(e,c+8)),37).mul(d),r=zr(r.add(i[1]).add(Mr(e,c+48)),42).mul(d),a=a.xor(o[1].mul(9)),r=r.add(i[0].mul(9).add(Mr(e,c+40))),s=zr(s.add(o[0]),33).mul(d),i=Pr(e,c,i[1].mul(d),a.add(o[0])),o=Pr(e,c+32,s.add(o[1]),r.add(Mr(e,c+16))),[s,a]=[a,s],Lr(Lr(i[0],o[0],d).add(Dr(r).mul(_r)).add(s),Lr(i[1],o[1],d).add(a),d)}function Gr(e,t){return"string"===t?Xr(e):Hr([e],t)}function Hr(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Jr(e)),Ue().getBool("DEBUG")&&ge(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function qr(){return Ue().platform.now()}function Kr(e,t){return Ue().platform.fetch(e,t)}function Xr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",Ue().platform.encode(e,t)}function Zr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",Ue().platform.decode(e,t)}function Yr(e){return null!=Ue().platform.isTypedArray?Ue().platform.isTypedArray(e):Tr(e)}function Jr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||ze(e)||null==e||Yr(e)&&n)t.push(e);else if(Array.isArray(e)||Yr(e))for(let a=0;a<e.length;++a)Jr(e[a],t,n);else{let a=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(a=Math.max(a,Number(t)));for(let r=0;r<=a;r++)Jr(e[r],t,n)}return t}function Qr(e,t,n){if("float32"!==t)return!1;for(let a=0;a<e.length;a++){let t=e[a];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}var $r=class{logKernelProfile(e,t,n,a,r,s){let i="number"==typeof a?le("".concat(a,"ms"),9):a.error,o=le(e,25),c=t.rank,l=t.size,u=le(t.shape.toString(),14),d="";for(let h in r){let e=r[h];if(null!=e){let n=e.shape||t.shape,a=n.length;d+="".concat(h,": ").concat(a,"D ").concat(a>0?n:""," ")}}console.log("%c".concat(o,"\t%c").concat(i,"\t%c").concat(c,"D ").concat(u,"\t%c").concat(l,"\t%c").concat(d,"\t%c").concat(s),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function es(e,t,n,a){let r=Oe(t),s=function(e,t,n,a){let r=te(t),s=a[a.length-1],i=new Array(s).fill(0),o=t.length,c="complex64"===n?as(e):e;if(o>1)for(let l=0;l<r/s;l++){let e=l*s;for(let t=0;t<s;t++)i[t]=Math.max(i[t],ts(c[e+t],0,n).length)}return i}(e,t,n,r),i=t.length,o=function e(t,n,a,r,s){let i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],o="complex64"===a?2:1,c=n[0],l=n.length;if(0===l){if("complex64"===a){return[ts(as(t)[0],0,a)]}return"bool"===a?[ns(t[0])]:[t[0].toString()]}if(1===l){if(c>20){let e=3*o,n=Array.from(t.slice(0,e)),r=Array.from(t.slice((c-3)*o,c*o));return"complex64"===a&&(n=as(n),r=as(r)),["["+n.map((e,t)=>ts(e,s[t],a)).join(", ")+", ..., "+r.map((e,t)=>ts(e,s[c-3+t],a)).join(", ")+"]"]}return["["+("complex64"===a?as(t):Array.from(t)).map((e,t)=>ts(e,s[t],a)).join(", ")+"]"]}let u=n.slice(1),d=r.slice(1),h=r[0]*o,p=[];if(c>20){for(let n=0;n<3;n++){let r=n*h,i=r+h;p.push(...e(t.slice(r,i),u,a,d,s,!1))}p.push("...");for(let n=c-3;n<c;n++){let r=n*h,i=r+h;p.push(...e(t.slice(r,i),u,a,d,s,n===c-1))}}else for(let g=0;g<c;g++){let n=g*h,r=n+h;p.push(...e(t.slice(n,r),u,a,d,s,g===c-1))}let f=2===l?",":"";p[0]="["+(c>0?p[0]+f:"");for(let g=1;g<p.length-1;g++)p[g]=" "+p[g]+f;let m=",\n";for(let g=2;g<l;g++)m+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(i?"":m),p}(e,t,n,r,s),c=["Tensor"];return a&&(c.push("  dtype: ".concat(n)),c.push("  rank: ".concat(i)),c.push("  shape: [".concat(t,"]")),c.push("  values:")),c.push(o.map(e=>"    "+e).join("\n")),c.join("\n")}function ts(e,t,n){let a;return a=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(7))," + ").concat(parseFloat(e[1].toFixed(7)),"j"):we(e)?"'".concat(e,"'"):"bool"===n?ns(e):parseFloat(e.toFixed(7)).toString(),le(a,t)}function ns(e){return 0===e?"false":"true"}function as(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var rs=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=te(e),null!=n){let e=n.length;Q(e===this.size,()=>"Length of values '".concat(e,"' does not match the size inferred by the shape '").concat(this.size,"'."))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||me(t,this.size),this.strides=Oe(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];0===n.length&&(n=[0]),Q(n.length===this.rank,()=>"The number of provided coordinates (".concat(n.length,") must match the rank (").concat(this.rank,")"));let r=this.locToIndex(n);this.values[r]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let a=0;for(let s of t){if(s<0||s>=this.shape[a]){let e="Requested out of range element at ".concat(t,".   Buffer shape=").concat(this.shape);throw new Error(e)}a++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ss().makeTensor(this.values,this.shape,this.dtype)}},ss=null,is=null;var os=class{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=te(e),this.strides=Oe(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return is.buffer(this.shape,this.dtype,e)}bufferSync(){return is.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Ee(this.shape,e,"complex64"===this.dtype)}arraySync(){return Ee(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=ss().read(this.dataId);if("string"===this.dtype){let t=await e;try{return t.map(e=>Zr(e))}catch(hJ){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ss().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=ss().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>Zr(e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await ss().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(ss().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return is.print(this,e)}clone(){return this.throwIfDisposed(),is.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return es(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),is.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),ss().makeVariable(this,e,t,n)}};function cs(){return qe("Tensor",()=>os)}Object.defineProperty(os,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),cs();var ls=class extends os{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and previous value (").concat(this.dtype,") must match"));if(!re(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and previous value (").concat(this.shape,") must match"));ss().disposeTensor(this),this.dataId=e.dataId,ss().incRef(this,null)}dispose(){ss().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(ls,Symbol.hasInstance,{value:e=>e instanceof os&&null!=e.assign&&e.assign instanceof Function});var us,ds,hs,ps,fs,ms,gs={};y(gs,{assertTypesMatch:()=>Is,getTensorsInContainer:()=>Ns,isTensorInList:()=>Ss,makeTypesMatch:()=>ks}),(ds=us||(us={})).R0="R0",ds.R1="R1",ds.R2="R2",ds.R3="R3",ds.R4="R4",ds.R5="R5",ds.R6="R6",function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(hs||(hs={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(ps||(ps={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(fs||(fs={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(ms||(ms={}));var bs={float32:fs,int32:hs,bool:ps,complex64:ms};function ys(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return bs[e][t]}function vs(e){return ys(e,"int32")}function xs(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function ws(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function ks(e,t){if(e.dtype===t.dtype)return[e,t];let n=ys(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Is(e,t){Q(e.dtype===t.dtype,()=>"The dtypes of the first(".concat(e.dtype,") and second(").concat(t.dtype,") input must match"))}function Ss(e,t){return t.some(t=>t.id===e.id)}function Ns(e){let t=[];return function e(t,n,a){if(null==t)return;if(t instanceof os)return void n.push(t);if(!function(e){return Array.isArray(e)||"object"==typeof e}(t))return;let r=t;for(let s in r){let t=r[s];a.has(t)||(a.add(t),e(t,n,a))}}(e,t,new Set),t}function Ts(e){return null!=e.kernelName}var Os=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},Cs=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Os}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods"));if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods"));this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(hr("".concat(e," backend was already registered. Reusing existing backend factory.")),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new class{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new $r)}profileKernel(e,t,n){let a,r,s=()=>{a=n()},i=qr();if(this.backendTimer.timerAvailable())r=this.backendTimer.time(s);else{s();for(let e of a)e.dataSync();r=Promise.resolve({kernelMs:qr()-i})}if(Ue().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<a.length;o++){let t=a[o];t.data().then(n=>{Qr(n,t.dtype,e)})}return{kernelName:e,outputs:a,inputs:t,timeMs:r.then(e=>e.kernelMs),extraInfo:r.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:s}=e;n.forEach(e=>{Promise.all([e.data(),a,s]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])})})}}(this.backendInstance),!0}setupRegisteredKernels(){yr(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){yr(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{let n=t.factory();if(!n||n instanceof U||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,a=n.then(n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0)).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,hr("Initialization of backend ".concat(e," failed")),hr(n.stack||n.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(hJ){return hr("Initialization of backend ".concat(e," failed")),hr(hJ.stack||hJ.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:a,asyncInit:r}=this.initializeBackend(n);if(r||a)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),a=n.backend,r=this.readSync(t),s=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun(()=>this.startScope(a),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{let e=n();return t(),e}catch(a){throw t(),a}}nextTensorId(){return Cs.nextTensorId++}nextVariableId(){return Cs.nextVariableId++}clone(e){let t=_s.runKernel(un,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],e=>({x:()=>{let t={x:e},n={dtype:"float32"};return _s.runKernel(bt,t,n)}}),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==gr(e,this.backendName))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let a=this.backend.numDataIds(),r=0;n.forEach(e=>{r+="complex64"===e.dtype?3:1});let s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=a-t-r-s;if(i>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak (").concat(i," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n,a=[],r=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let o,c=Ts(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Ts(e)){let{kernelName:t,inputs:s,attrs:i}=e;null==this.backendName&&this.backend;let c=gr(t,this.backendName);Q(null!=c,()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'")),n=()=>{let e=this.backend.numDataIds();o=c.kernelFunc({inputs:s,attrs:i,backend:this.backend});let n=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,n);let l=n.map(e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e));if(r){let e=this.getTensorsForGradient(t,s,l);a=this.saveTensorsForBackwardMode(e)}return l}}else{let{forwardFunc:t}=e,s=e=>{r&&(a=e.map(e=>this.keep(this.clone(e))))};n=()=>{let e=this.backend.numDataIds();o=this.tidy(()=>t(this.backend,s));let n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}let l,{inputs:u,attrs:d}=e,h=Ts(e)?null:e.backwardsFunc;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(l=this.profiler.profileKernel(c,u,()=>n()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(l),t=l.outputs):t=n()}),r&&this.addTapeNode(c,u,t,h,a,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(e=>null!=u[e]?u[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:l.timeMs,extraInfo:l.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,n){let a=br(e);if(null!=a){let e,r=a.inputsToSave||[],s=a.outputsToSave||[];a.saveAllInputs?(Q(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),e=Object.keys(t).map(e=>t[e])):e=r.map(e=>t[e]);let i=n.filter((e,t)=>s[t]);return e.concat(i)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let r=e;"string"===n&&we(e[0])&&(r=e.map(e=>Xr(e)));let s=a.write(r,t,n),i=new os(t,n,s,this.nextTensorId());if(this.trackTensor(i,a),"string"===n){let e=this.state.tensorInfo.get(s),t=xe(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,a){let r={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(r,a)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:a,dtype:r}=e,s=new os(a,r,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));let r=new ls(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error("Variable with name ".concat(r.name," was already registered"));return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*ve(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof ls||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*ve(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,r,s){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},o=br(e);null!=o&&(a=o.gradFunc),null!=a&&(i.gradient=e=>(e=e.map((e,t)=>{if(null==e){let e=n[t],a=Re(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e}),a(e.length>1?e:e[0],r,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=Ns(e),n=new Set(t.map(e=>e.id));for(let r=0;r<this.state.activeScope.track.length;r++){let e=this.state.activeScope.track[r];!e.kept&&!n.has(e.id)&&e.dispose()}let a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{!e.kept&&e.scopeId===a.id&&this.track(e)})}gradients(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Q(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));let r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Q(r instanceof os,()=>"The result y returned by f() must be a tensor.");let s=function(e,t,n){let a={},r={};for(let c=0;c<t.length;c++)a[t[c].id]=!0;for(let c=0;c<e.length;c++){let n=e[c],s=n.inputs;for(let e in s){let i=s[e],o=!1;for(let e=0;e<t.length;e++)if(a[i.id]){n.outputs.forEach(e=>a[e.id]=!0),o=!0,r[n.id]=!0;break}if(o)break}}let s={};s[n.id]=!0;let i={};for(let c=e.length-1;c>=0;c--){let t=e[c],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(let e in n)s[n[e].id]=!0,i[t.id]=!0;break}}let o=[];for(let c=0;c<e.length;c++){let t=e[c];if(r[t.id]&&i[t.id]){let e={};for(let r in t.inputs){let n=t.inputs[r];a[n.id]&&(e[r]=n)}let n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,r);if(!a&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let e={};e[r.id]=null==n?function(e){let t=Ae(te(e),"float32");return _s.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,a){for(let r=t.length-1;r>=0;r--){let s=t[r],i=[];if(s.outputs.forEach(t=>{let n=e[t.id];null!=n?i.push(n):i.push(null)}),null==s.gradient)throw new Error("Cannot compute gradient: gradient function not found for ".concat(s.kernelName,"."));let o=s.gradient(i);for(let t in s.inputs){if(!(t in o))throw new Error("Cannot backprop through input ".concat(t,". Available gradients found: ").concat(Object.keys(o),"."));let r=n(()=>o[t]());if("float32"!==r.dtype)throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ").concat(t," must have 'float32' dtype, but has '").concat(r.dtype,"'"));let i=s.inputs[t];if(!re(r.shape,i.shape))throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input '").concat(t,"' has shape '").concat(r.shape,"', which does not match the shape of the input '").concat(i.shape,"'"));if(null==e[i.id])e[i.id]=r;else{let t=e[i.id];e[i.id]=a(t,r),t.dispose()}}}}(e,s,e=>this.tidy(e),As);let a=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(let t of e.saved)t.dispose()}),this.state.activeTape=null),{value:r,grads:a}})}customGrad(e){var t=this;return Q(Ne(e),()=>"The f passed in customGrad(f) must be a function."),function(){for(var n=arguments.length,a=new Array(n),r=0;r<n;r++)a[r]=arguments[r];Q(a.every(e=>e instanceof os),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s,i={};a.forEach((e,t)=>{i[t]=e});let o=(t,n)=>(s=e(...a,n),Q(s.value instanceof os,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Q(Ne(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),c=(e,t)=>{let n=s.gradFunc(e,t),r=Array.isArray(n)?n:[n];Q(r.length===a.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Q(r.every(e=>e instanceof os),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let i={};return r.forEach((e,t)=>{i[t]=()=>e}),i};return t.runKernelFunc({forwardFunc:o,backwardsFunc:c,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=qr(),n=await this.backend.time(e);return n.wallMs=qr()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Os;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function Es(){let e=He();if(null==e._tfengine){let t=new Pe(e);e._tfengine=new Cs(t)}return function(e){Ge=e}(e._tfengine.ENV),function(e){ss=e}(()=>e._tfengine),e._tfengine}Cs.nextTensorId=0,Cs.nextVariableId=0;var _s=Es();function As(e,t){let n={a:e,b:t};return _s.runKernel(Ye,n)}var Rs,Ds={};function Fs(e){Rs=e}function Ms(e){if(void 0!==Rs)return Rs;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function js(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}y(Ds,{isBrowser:()=>js,isMobile:()=>Ms,mockIsMobile:()=>Fs});var zs=Ue();function Ls(e,t){let n=e;if(Yr(e))return"string"===t?[]:[e.length];if(xs(e)){let t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(ws(e))return[e.buffer.size/(null==t?4:ve(t))];if(!Array.isArray(e))return[];let a=[];for(;Array.isArray(n)||Yr(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&Ue().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function e(t,n,a){if(a=a||[],!Array.isArray(t)&&!Yr(t))return void Q(0===n.length,()=>"Element arr[".concat(a.join("]["),"] is a primitive, but should be an array/TypedArray of ").concat(n[0]," elements"));Q(n.length>0,()=>"Element arr[".concat(a.join("]["),"] should be a primitive, but is an array of ").concat(t.length," elements")),Q(t.length===n[0],()=>"Element arr[".concat(a.join("]["),"] should have ").concat(n[0]," elements, but has ").concat(t.length," elements"));let r=n.slice(1);for(let s=0;s<t.length;++s)e(t[s],r,a.concat(s))}(e,a,[]),a}function Ps(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(a,"' must be ").concat(e," tensor, but got ").concat(t," tensor"))}}function Bs(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof os)return Ps(a,e.dtype,t,n),e;let r=Se(e);if("string"!==r&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),Ps(a,r,t,n),null==e||!Yr(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let a=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a Tensor or TensorLike, but got '").concat(a,"'"))}let s=Ls(e,r);!Yr(e)&&!Array.isArray(e)&&(e=[e]);let i="string"!==r?Hr(e,r):Jr(e,[],!0);return _s.makeTensor(i,s,r)}function Ws(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a `Tensor[]` or `TensorLike[]`"));return e.map((e,r)=>Bs(e,"".concat(t,"[").concat(r,"]"),n,a))}zs.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),zs.registerFlag("IS_BROWSER",()=>js()),zs.registerFlag("IS_NODE",()=>"undefined"!=typeof a&&"undefined"!=typeof a.versions&&"undefined"!=typeof a.versions.node),zs.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),zs.registerFlag("IS_SAFARI",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),zs.registerFlag("PROD",()=>!1),zs.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>zs.getBool("DEBUG")),zs.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),zs.registerFlag("IS_TEST",()=>!1),zs.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>zs.getBool("DEBUG")),zs.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),zs.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),zs.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var Us="__op";function Vs(e){let t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with ".concat(t.length," keys."));let n=t[0],a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=Us;let r=function(){_s.startScope(n);try{let e=a(...arguments);return ze(e)&&console.error("Cannot return a Promise inside of tidy."),_s.endScope(e),e}catch(e){throw _s.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}var Gs=Vs({complex_:function(e,t){let n=Bs(e,"real","complex"),a=Bs(t,"imag","complex");$(n.shape,a.shape,"real and imag shapes, ".concat(n.shape," and ").concat(a.shape,", must match in call to tf.complex()."));let r={real:n,imag:a};return _s.runKernel(xt,r)}});function Hs(e,t,n,a){if(null==a)a=Se(e);else if("complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(ws(e)||xs(e)){if("float32"!==a&&"int32"!==a)throw new Error("Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ".concat(a,"."));return _s.backend.createTensorFromGPUData(e,t||n,a)}if(!Yr(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Fe(t);let e=te(t),a=te(n);Q(e===a,()=>"Based on the provided shape, [".concat(t,"], the tensor should have ").concat(e," values but has ").concat(a));for(let r=0;r<n.length;++r){let e=n[r],a=r!==n.length-1||e!==te(t.slice(r));Q(n[r]===t[r]||!a,()=>"Error creating a new Tensor. Inferred shape (".concat(n,") does not match the provided shape (").concat(t,"). "))}}return!Yr(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e="string"!==a?Hr(e,a):Jr(e,[],!0),_s.makeTensor(e,t,a)}function qs(e,t,n){return Hs(e,t,Ls(e,n),n)}var Ks={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Xs=class{static join(e){return new Xs(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e||(e instanceof Array||(e=[e]),0===(e=e.map(e=>Yr(e)?e.buffer:e)).length))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){let a=e[n];n!==e.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let r=t+a.byteLength;this.shards.push({buffer:a,start:t,end:r}),t=r}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);let n=this.findShardForByte(e);if(-1===n)throw new Error("Could not find start shard for byte ".concat(e));let a=new ArrayBuffer(t-e),r=new Uint8Array(a),s=0;for(let i=n;i<this.shards.length;i++){let n=this.shards[i],a=e+s-n.start,o=s,c=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,a,c-a);if(r.set(l,o),s+=l.length,t<n.end)break}return a}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;let n=function(e,t){let n=0,a=e.length;for(;n<=a;){let r=Math.floor((a-n)/2)+n,s=t(e[r]);if(0===s)return r;s<0?a=r:n=r+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}};async function Zs(e,t){let n=[],a=[],r=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let s=0;s<r.length;++s){let i=r[s],o=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error("Unsupported dtype in weight '".concat(i,"': ").concat(o.dtype));let c={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){let e=new Promise(async e=>{let t=await o.bytes(),n=t.reduce((e,t)=>e+t.length,0)+4*t.length,a=new Uint8Array(n),r=0;for(let s=0;s<t.length;s++){let e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);a.set(n,r),r+=4,a.set(e,r),r+=e.length}e(a)});a.push(e)}else a.push(o.data());null!=t&&(c.group=t),n.push(c)}return{data:Js(await Promise.all(a)),specs:n}}function Ys(e,t){let n,a=new Xs(e),r={},s=0;for(let i of t){let e,t=i.name,o=i.dtype,c=i.shape,l=te(c);if("quantization"in i){let r=i.quantization;if("uint8"===r.dtype||"uint16"===r.dtype){if(!("min"in r)||!("scale"in r))throw new Error("Weight ".concat(i.name," with quantization ").concat(r.dtype," doesn't have corresponding metadata min and scale."))}else{if("float16"!==r.dtype)throw new Error("Weight ".concat(i.name," has unknown quantization dtype ").concat(r.dtype,". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'."));if("float32"!==o)throw new Error("Weight ".concat(i.name," is quantized with ").concat(r.dtype," which only supports weights of type float32 not ").concat(o,"."))}let c=Ks[r.dtype],u=a.slice(s,s+l*c),d="uint8"===r.dtype?new Uint8Array(u):new Uint16Array(u);if("float32"===o)if("uint8"===r.dtype||"uint16"===r.dtype){e=new Float32Array(d.length);for(let t=0;t<d.length;t++){let n=d[t];e[t]=n*r.scale+r.min}}else{if("float16"!==r.dtype)throw new Error("Unsupported quantization type ".concat(r.dtype," for weight type float32."));void 0===n&&(n=oi()),e=n(d)}else{if("int32"!==o)throw new Error("Unsupported dtype in weight '".concat(t,"': ").concat(o));if("uint8"!==r.dtype&&"uint16"!==r.dtype)throw new Error("Unsupported quantization type ".concat(r.dtype," for weight type int32."));e=new Int32Array(d.length);for(let t=0;t<d.length;t++){let n=d[t];e[t]=Math.round(n*r.scale+r.min)}}s+=l*c}else if("string"===o){let t=te(i.shape);e=[];for(let n=0;n<t;n++){let t=new Uint32Array(a.slice(s,s+4))[0];s+=4;let n=new Uint8Array(a.slice(s,s+t));e.push(n),s+=t}}else{let n=Ks[o],i=a.slice(s,s+l*n);if("float32"===o)e=new Float32Array(i);else if("int32"===o)e=new Int32Array(i);else if("bool"===o)e=new Uint8Array(i);else{if("complex64"!==o)throw new Error("Unsupported dtype in weight '".concat(t,"': ").concat(o));{e=new Float32Array(i);let n=new Float32Array(e.length/2),a=new Float32Array(e.length/2);for(let t=0;t<n.length;t++)n[t]=e[2*t],a[t]=e[2*t+1];let s=qs(n,c,"float32"),o=qs(a,c,"float32");r[t]=Gs(s,o),s.dispose(),o.dispose()}}s+=l*n}"complex64"!==o&&(r[t]=qs(e,c,o))}return r}function Js(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0,n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))});let a=new Uint8Array(t),r=0;return n.forEach(e=>{a.set(new Uint8Array(e.buffer),r),r+=e.byteLength}),a.buffer}var Qs="undefined"!=typeof i&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function $s(e){return Qs?i.byteLength(e,"utf8"):new Blob([e]).size}function ei(e){return Xs.join(e)}function ti(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);let t=e.split("/");return t[t.length-1]}function ni(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function ai(e,t,n){let a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(a.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(a.initializerSignature=e.initializerSignature),a}async function ri(e,t){let n,a;return null!=e.weightsManifest&&([n,a]=await t(e.weightsManifest)),ai(e,n,a)}function si(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:$s(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:$s(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Xs(e.weightData).byteLength}}function ii(e){let t=[];for(let n of e)t.push(...n.weights);return t}function oi(){let e=function(){let e=e=>{let t=e<<13,n=0;for(;!(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return a=>{let r=new ArrayBuffer(4*a.length),s=new Uint32Array(r);for(let i=0;i<a.length;i++){let r=a[i],o=e[n[r>>10]+(1023&r)]+t[r>>10];s[i]=o}return new Float32Array(r)}}var ci=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==ci.instance&&(ci.instance=new ci),ci.instance}static registerSaveRouter(e){ci.getInstance().saveRouters.push(e)}static registerLoadRouter(e){ci.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return ci.getHandlers(e,"save")}static getLoadHandlers(e,t){return ci.getHandlers(e,"load",t)}static getHandlers(e,t,n){let a=[];return("load"===t?ci.getInstance().loadRouters:ci.getInstance().saveRouters).forEach(t=>{let r=t(e,n);null!==r&&a.push(r)}),a}},li=e=>ci.registerSaveRouter(e),ui=e=>ci.registerLoadRouter(e),di=e=>ci.getSaveHandlers(e),hi=(e,t)=>ci.getLoadHandlers(e,t),pi="tensorflowjs",fi="models_store",mi="model_info_store";function gi(){if(!Ue().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function bi(e){let t=e.result;t.createObjectStore(fi,{keyPath:"modelPath"}),t.createObjectStore(mi,{keyPath:"modelPath"})}var yi=class{constructor(e){if(this.indexedDB=gi(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((e,n)=>{let a=this.indexedDB.open(pi,1);a.onupgradeneeded=()=>bi(a),a.onsuccess=()=>{let r=a.result;if(null==t){let t=r.transaction(fi,"readonly"),a=t.objectStore(fi).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return r.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' in IndexedDB.")));e(a.result.modelArtifacts)},a.onerror=e=>(r.close(),n(a.error)),t.oncomplete=()=>r.close()}else{t.weightData=Xs.join(t.weightData);let a,i,o=si(t),c=r.transaction(mi,"readwrite"),l=c.objectStore(mi);try{a=l.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(s){return n(s)}a.onsuccess=()=>{i=r.transaction(fi,"readwrite");let a,s=i.objectStore(fi);try{a=s.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(u){return n(u)}a.onsuccess=()=>e({modelArtifactsInfo:o}),a.onerror=e=>{l=c.objectStore(mi);let t=l.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(a.error)),t.onerror=e=>(r.close(),n(a.error))}},a.onerror=e=>(r.close(),n(a.error)),c.oncomplete=()=>{null==i?r.close():i.oncomplete=()=>r.close()}}},a.onerror=e=>n(a.error)})}};yi.URL_SCHEME="indexeddb://";var vi=e=>Ue().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(yi.URL_SCHEME)?function(e){return new yi(e)}(e.slice(yi.URL_SCHEME.length)):null;ci.registerSaveRouter(vi),ci.registerLoadRouter(vi);var xi="/",wi="tensorflowjs_models",ki="info",Ii="model_topology",Si="weight_specs",Ni="weight_data",Ti="model_metadata";function Oi(e){return{info:[wi,e,ki].join(xi),topology:[wi,e,Ii].join(xi),weightSpecs:[wi,e,Si].join(xi),weightData:[wi,e,Ni].join(xi),modelMetadata:[wi,e,Ti].join(xi)}}function Ci(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function Ei(e){let t=e.split(xi);if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join(xi)}var _i=class{constructor(e){if(!Ue().getBool("IS_BROWSER")||"undefined"==typeof window||"undefined"==typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Oi(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let n=JSON.stringify(e.modelTopology),a=JSON.stringify(e.weightSpecs),r=si(e),s=Xs.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,a),this.LS.setItem(this.keys.weightData,function(e){if(Qs)return i.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}(s));let t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:r}}catch(t){throw Ci(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=").concat(r.modelTopologyBytes,", weightSpecsBytes=").concat(r.weightSpecsBytes,", weightDataBytes=").concat(r.weightDataBytes,"."))}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' is missing."));t.modelTopology=n;let a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' are missing."));t.weightSpecs=a;let r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){let e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error("In local storage, the binary weight values of model '".concat(this.modelPath,"' are missing."));return t.weightData=function(e){if(Qs){let t=i.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}(s),t}};_i.URL_SCHEME="localstorage://";var Ai=e=>Ue().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(_i.URL_SCHEME)?function(e){return new _i(e)}(e.slice(_i.URL_SCHEME.length)):null;ci.registerSaveRouter(Ai),ci.registerLoadRouter(Ai);var Ri="://",Di=class{constructor(){this.managers={}}static getInstance(){return null==Di.instance&&(Di.instance=new Di),Di.instance}static registerManager(e,t){Q(null!=e,()=>"scheme must not be undefined or null."),e.endsWith(Ri)&&(e=e.slice(0,e.indexOf(Ri))),Q(e.length>0,()=>"scheme must not be an empty string.");let n=Di.getInstance();Q(null==n.managers[e],()=>"A model store manager is already registered for scheme '".concat(e,"'.")),n.managers[e]=t}static getManager(e){let t=Di.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(Di.getInstance().managers)}};function Fi(e){if(-1===e.indexOf(Ri))throw new Error("The url string provided does not contain a scheme. Supported schemes are: ".concat(Di.getSchemes().join(",")));return{scheme:e.split(Ri)[0],path:e.split(Ri)[1]}}async function Mi(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];Q(e!==t,()=>"Old path and new path are the same: '".concat(e,"'"));let a=ci.getLoadHandlers(e);Q(a.length>0,()=>"Copying failed because no load handler is found for source URL ".concat(e,".")),Q(a.length<2,()=>"Copying failed because more than one (".concat(a.length,") load handlers for source URL ").concat(e,"."));let r=a[0],s=ci.getSaveHandlers(t);Q(s.length>0,()=>"Copying failed because no save handler is found for destination URL ".concat(t,".")),Q(s.length<2,()=>"Copying failed because more than one (".concat(a.length,") save handlers for destination URL ").concat(t,"."));let i=s[0],o=Fi(e).scheme,c=Fi(e).path,l=o===Fi(e).scheme,u=await r.load();n&&l&&await Di.getManager(o).removeModel(c);let d=await i.save(u);return n&&!l&&await Di.getManager(o).removeModel(c),d.modelArtifactsInfo}async function ji(){let e=Di.getSchemes(),t={};for(let n of e){let e=await Di.getManager(n).listModels();for(let a in e){t[n+Ri+a]=e[a]}}return t}async function zi(e){let t=Fi(e);return Di.getManager(t.scheme).removeModel(t.path)}async function Li(e,t){return Mi(e,t,!1)}async function Pi(e,t){return Mi(e,t,!0)}if(Ue().get("IS_BROWSER")){Ue().setPlatform("browser",new class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&Ue().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))):setTimeout(e,t)}isTypedArray(e){return Tr(e)}});try{Di.registerManager(_i.URL_SCHEME,new class{constructor(){Q(Ue().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Q("undefined"==typeof window||"undefined"!=typeof window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=wi+xi,n=xi+ki;for(let a=0;a<this.LS.length;++a){let r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){e[Ei(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){let t=Oi(e=function(e){return e.startsWith(_i.URL_SCHEME)?e.slice(_i.URL_SCHEME.length):e}(e));if(null==this.LS.getItem(t.info))throw new Error("Cannot find model at path '".concat(e,"'"));let n=JSON.parse(this.LS.getItem(t.info));return Ci(t),n}})}catch(ds){}try{Di.registerManager(yi.URL_SCHEME,new class{constructor(){this.indexedDB=gi()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(pi,1);n.onupgradeneeded=()=>bi(n),n.onsuccess=()=>{let a=n.result,r=a.transaction(mi,"readonly"),s=r.objectStore(mi).getAll();s.onsuccess=()=>{let t={};for(let e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(a.close(),t(s.error)),r.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)})}async removeModel(e){return e=function(e){return e.startsWith(yi.URL_SCHEME)?e.slice(yi.URL_SCHEME.length):e}(e),new Promise((t,n)=>{let a=this.indexedDB.open(pi,1);a.onupgradeneeded=()=>bi(a),a.onsuccess=()=>{let r,s=a.result,i=s.transaction(mi,"readwrite"),o=i.objectStore(mi),c=o.get(e);c.onsuccess=()=>{if(null==c.result)return s.close(),n(new Error("Cannot find model with path '".concat(e,"' in IndexedDB.")));{let a=o.delete(e),i=()=>{r=s.transaction(fi,"readwrite");let a=r.objectStore(fi).delete(e);a.onsuccess=()=>t(c.result.modelArtifactsInfo),a.onerror=e=>n(c.error)};a.onsuccess=i,a.onerror=e=>(i(),s.close(),n(c.error))}},c.onerror=e=>(s.close(),n(c.error)),i.oncomplete=()=>{null==r?s.close():r.oncomplete=()=>s.close()}},a.onerror=e=>n(a.error)})}})}catch(ds){}}var Bi,Wi=()=>w();function Ui(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",Fe(e),new rs(e,t,n)}Ue().get("IS_NODE")&&!Ue().get("IS_BROWSER")&&Ue().setPlatform("node",new class{constructor(){this.util=k(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=Ue().global.fetch?Ue().global.fetch(e,t):(null==Bi&&(Bi=Wi()),Bi(e,t))}now(){let e=a.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});var Vi=Vs({cast_:function(e,t){let n=Bs(e,"x","cast");if(!be(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");let a={x:n},r={dtype:t};return _s.runKernel(bt,a,r)}});var Gi=Vs({clone_:function(e){let t={x:Bs(e,"x","clone","string_or_numeric")};return _s.runKernel(un,t)}});function Hi(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}function qi(){Ue().set("PROD",!0)}function Ki(){Ue().set("DEBUG",!0)}function Xi(){Ue().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Zi(e){Ue().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Yi(){_s.disposeVariables()}function Ji(){return _s}function Qi(){return _s.memory()}function $i(e){return _s.profile(e)}function eo(e,t){return _s.tidy(e,t)}function to(e){Ns(e).forEach(e=>e.dispose())}function no(e){return _s.keep(e)}function ao(e){return _s.time(e)}function ro(e){return _s.setBackend(e)}function so(){return _s.ready()}function io(){return _s.backendName}function oo(e){_s.removeBackend(e)}function co(e){return _s.findBackend(e)}function lo(e){return _s.findBackendFactory(e)}function uo(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return _s.registerBackend(e,t,n)}function ho(){return _s.backend}function po(e,t){Ue().setPlatform(e,t)}Es(),function(e){is=e}({buffer:Ui,cast:Vi,clone:Gi,print:Hi}),function(e){e}(Zi);var fo=Vs({add_:function(e,t){let n=Bs(e,"a","add"),a=Bs(t,"b","add");[n,a]=ks(n,a);let r={a:n,b:a};return _s.runKernel(Ye,r)}});var mo=Vs({floorDiv_:function(e,t){let n=Bs(e,"a","floorDiv"),a=Bs(t,"b","floorDiv");[n,a]=ks(n,a);let r={a:n,b:a};return _s.runKernel(an,r)}});var go=Vs({div_:function(e,t){let n=Bs(e,"a","div"),a=Bs(t,"b","div");if([n,a]=ks(n,a),"int32"===n.dtype&&"int32"===a.dtype)return mo(n,a);let r={a:n,b:a};return _s.runKernel(Gt,r,{})}});var bo=Vs({mul_:function(e,t){let n=Bs(e,"a","mul"),a=Bs(t,"b","mul");[n,a]=ks(n,a);let r={a:n,b:a};return _s.runKernel(Gn,r)}});var yo=Vs({abs_:function(e){let t=Bs(e,"x","abs");if("complex64"===t.dtype){let e={x:t};return _s.runKernel(wt,e)}{let e={x:t};return _s.runKernel(Ke,e)}}});var vo=Vs({acos_:function(e){let t={x:Bs(e,"x","acos")};return _s.runKernel(Xe,t)}});var xo=Vs({acosh_:function(e){let t={x:Bs(e,"x","acosh")};return _s.runKernel(Ze,t)}});var wo=Vs({addN_:function(e){Q(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),Q(e.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got ".concat(e.length));let t=e.map((e,t)=>Bs(e,"tensors".concat(t),"addN")),n=t[0];t.forEach(e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(e=>{if(!re(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let a=t;return _s.runKernel(Je,a)}});var ko=Vs({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a={x:Bs(e,"x","all","bool")},r={axis:t,keepDims:n};return _s.runKernel(Qe,a,r)}});var Io=Vs({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a={x:Bs(e,"x","any","bool")},r={axis:t,keepDims:n};return _s.runKernel($e,a,r)}});var So=Vs({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:Bs(e,"x","argMax")},a={axis:t};return _s.runKernel(et,n,a)}});var No=Vs({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:Bs(e,"x","argMin")},a={axis:t};return _s.runKernel(tt,n,a)}});var To=Vs({asin_:function(e){let t={x:Bs(e,"x","asin")};return _s.runKernel(nt,t)}});var Oo=Vs({asinh_:function(e){let t={x:Bs(e,"x","asinh")};return _s.runKernel(at,t)}});var Co=Vs({atan_:function(e){let t={x:Bs(e,"x","atan")};return _s.runKernel(rt,t)}});var Eo=Vs({atan2_:function(e,t){let n=Bs(e,"a","atan2"),a=Bs(t,"b","atan2");[n,a]=ks(n,a);let r={a:n,b:a};return _s.runKernel(it,r)}});var _o=Vs({atanh_:function(e){let t={x:Bs(e,"x","atanh")};return _s.runKernel(st,t)}});function Ao(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0,i=e[3],o=[...t,i],c=qo(r);return Fo(e,o,n,s,a,null,null,c)}function Ro(e,t,n,a,r,s){let i,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",[c,l]=zo(t);if("channelsLast"===o)i=[c,l,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));i=[c,l,e[1],e[1]]}return Fo(e,i,n,a,r,s,!1,o)}function Do(e,t,n,a,r,s){let i,o,c=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC",[l,u,d]=Lo(t);if("NDHWC"===c)o="channelsLast",i=[l,u,d,e[4],e[4]];else{if("NCDHW"!==c)throw new Error("Unknown dataFormat ".concat(c));o="channelsFirst",i=[l,u,d,e[1],e[1]]}return Mo(e,i,n,a,r,!1,o,s)}function Fo(e,t,n,a,r,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[c,l,u,d]=[-1,-1,-1,-1];if("channelsLast"===o)[c,l,u,d]=e;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));[c,d,l,u]=e}let h,[p,f,,m]=t,[g,b]=zo(n),[y,v]=zo(a),x=Po(p,y),w=Po(f,v),{padInfo:k,outHeight:I,outWidth:S}=Bo(r,l,u,g,b,x,w,s,o),N=i?m*d:m;return"channelsFirst"===o?h=[c,N,I,S]:"channelsLast"===o&&(h=[c,I,S,N]),{batchSize:c,dataFormat:o,inHeight:l,inWidth:u,inChannels:d,outHeight:I,outWidth:S,outChannels:N,padInfo:k,strideHeight:g,strideWidth:b,filterHeight:p,filterWidth:f,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:v,inShape:e,outShape:h,filterShape:t}}function Mo(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[c,l,u,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[c,l,u,d,h]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[c,h,l,u,d]=e}let p,[f,m,g,,b]=t,[y,v,x]=Lo(n),[w,k,I]=Lo(a),S=Po(f,w),N=Po(m,k),T=Po(g,I),{padInfo:O,outDepth:C,outHeight:E,outWidth:_}=Wo(r,l,u,d,y,v,x,S,N,T,o),A=s?b*h:b;return"channelsFirst"===i?p=[c,A,C,E,_]:"channelsLast"===i&&(p=[c,C,E,_,A]),{batchSize:c,dataFormat:i,inDepth:l,inHeight:u,inWidth:d,inChannels:h,outDepth:C,outHeight:E,outWidth:_,outChannels:A,padInfo:O,strideDepth:y,strideHeight:v,strideWidth:x,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:N,effectiveFilterWidth:T,dilationDepth:w,dilationHeight:k,dilationWidth:I,inShape:e,outShape:p,filterShape:t}}function jo(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=Po(t,a);return Math.floor((e[0]*(n-1)-n+r)/2)}function zo(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Lo(e){return"number"==typeof e?[e,e,e]:e}function Po(e,t){return t<=1?e:e+(e-1)*(t-1)}function Bo(e,t,n,a,r,s,i,o,c){let l,u,d;if("number"==typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};let r=function(e,t,n,a,r){null==a&&(a=jo(e,t,n));let s=e[0],i=e[1];return[Uo((s-t+2*a)/n+1,r),Uo((i-t+2*a)/n+1,r)]}([t,n],s,a,e,o);u=r[0],d=r[1]}else if("same"===e){u=Math.ceil(t/a),d=Math.ceil(n/r);let e=Math.max(0,(u-1)*a+s-t),o=Math.max(0,(d-1)*r+i-n),c=Math.floor(e/2),h=e-c,p=Math.floor(o/2);l={top:c,bottom:h,left:p,right:o-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-s+1)/a),d=Math.ceil((n-i+1)/r);else{if("object"!=typeof e)throw Error("Unknown padding parameter: ".concat(e));{let h="channelsLast"===c?e[1][0]:e[2][0],p="channelsLast"===c?e[1][1]:e[2][1],f="channelsLast"===c?e[2][0]:e[3][0],m="channelsLast"===c?e[2][1]:e[3][1];l={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},u=Uo((t-s+h+p)/a+1,o),d=Uo((n-i+f+m)/r+1,o)}}return{padInfo:l,outHeight:u,outWidth:d}}function Wo(e,t,n,a,r,s,i,o,c,l,u){let d,h,p,f;if("valid"===e&&(e=0),"number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};let m=function(e,t,n,a,r,s){null==r&&(r=jo(e,t[0],a[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*r>=t[o]&&(i[o]=Uo((e[o]-t[o]+2*r)/a[o]+1,s));return i}([t,n,a,1],[o,c,l],1,[r,s,i],e,u);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error("Unknown padding parameter: ".concat(e));{h=Math.ceil(t/r),p=Math.ceil(n/s),f=Math.ceil(a/i);let e=(h-1)*r+o-t,u=(p-1)*s+c-n,m=(f-1)*i+l-a,g=Math.floor(e/2),b=e-g,y=Math.floor(u/2),v=u-y,x=Math.floor(m/2);d={top:y,bottom:v,left:x,right:m-x,front:g,back:b,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}function Uo(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function Vo(e){let[t,n,a]=zo(e);return 1===t&&1===n&&1===a}function Go(e,t){return Vo(e)||Vo(t)}function Ho(e){return zo(e).every(e=>e>0)}function qo(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function Ko(e,t,n){if(null!=n){if("string"==typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using dimRoundingMode ").concat(n," but got pad ").concat(t,"."));if("number"==typeof t)Q(se(t),()=>"Error in ".concat(e,": pad must be an integer when using dimRoundingMode ").concat(n," but got pad ").concat(t,"."));else{if("object"!=typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach(t=>{t.forEach(t=>{Q(se(t),()=>"Error in ".concat(e,": pad must be an integer when using dimRoundingMode ").concat(n," but got pad ").concat(t,"."))})})}}}var Xo=Vs({reshape_:function(e,t){let n={x:Bs(e,"x","reshape","string_or_numeric")},a={shape:t};return _s.runKernel(da,n,a)}});var Zo=Vs({avgPool_:function(e,t,n,a,r){let s=Bs(e,"x","avgPool","float32");Q(Go(n,1),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides ".concat(n," and dilations '").concat(1,"'"));let i=s,o=!1;3===s.rank&&(o=!0,i=Xo(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Q(4===i.rank,()=>"Error in avgPool: x must be rank 4 but got rank ".concat(i.rank,".")),Ko("avgPool",a,r);let c={x:i},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r},u=_s.runKernel(ot,c,l);return u=Vi(u,s.dtype),o?Xo(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var Yo=Vs({avgPool3d_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC",i=Bs(e,"x","avgPool3d","float32"),o=i,c=!1;4===i.rank&&(c=!0,o=Xo(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Q(5===o.rank,()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(o.rank,".")),Q("NDHWC"===s,()=>"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ".concat(s)),Q("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'")),Ko("avgPool3d",a,r);let l={x:o},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},d=_s.runKernel(lt,l,u);return d=Vi(d,o.dtype),c?Xo(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var Jo=Vs({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Q(e.length>=1,()=>"Pass at least one tensor to concat");let n=Ws(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))}),1===n.length)return Gi(n[0]);let a=n,r={axis:t};return _s.runKernel(kt,a,r)}});var Qo=Vs({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=Bs(e,"a","matMul"),s=Bs(t,"b","matMul");[r,s]=ks(r,s);let i={a:r,b:s},o={transposeA:n,transposeB:a};return _s.runKernel(dt,i,o)}});var $o=Vs({sigmoid_:function(e){let t={x:Bs(e,"x","sigmoid","float32")};return _s.runKernel(Ea,t)}});var ec=Vs({slice_:function(e,t,n){let a=Bs(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");let r={x:a},s={begin:t,size:n};return _s.runKernel(Na,r,s)}});var tc=Vs({tanh_:function(e){let t={x:Bs(e,"x","tanh","float32")};return _s.runKernel(Ya,t)}});var nc=Vs({basicLSTMCell_:function(e,t,n,a,r,s){let i=Bs(e,"forgetBias","basicLSTMCell"),o=Bs(t,"lstmKernel","basicLSTMCell"),c=Bs(n,"lstmBias","basicLSTMCell"),l=Bs(a,"data","basicLSTMCell"),u=Bs(r,"c","basicLSTMCell"),d=Bs(s,"h","basicLSTMCell"),h=Jo([l,d],1),p=Qo(h,o),f=fo(p,c),m=f.shape[0],g=f.shape[1]/4,b=[m,g],y=ec(f,[0,0],b),v=ec(f,[0,g],b),x=ec(f,[0,2*g],b),w=ec(f,[0,3*g],b),k=fo(bo($o(y),tc(v)),bo(u,$o(fo(i,x))));return[k,bo(tc(k),$o(w))]}});var ac=Vs({batchToSpaceND_:function(e,t,n){let a=Bs(e,"x","batchToSpaceND"),r=t.reduce((e,t)=>e*t);Q(a.rank>=1+t.length,()=>"input rank is ".concat(a.rank," but should be > than blockShape.length ").concat(t.length)),Q(n.length===t.length,()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length)),Q(a.shape[0]%r===0,()=>"input tensor batch is ".concat(a.shape[0]," but is not divisible by the product of the elements of blockShape ").concat(t.join(" * ")," === ").concat(r));let s={x:a},i={blockShape:t,crops:n};return _s.runKernel(ht,s,i)}});function rc(e){let t;return t=0===e.rank||1===e.rank?Xo(e,[1,1,1,e.size]):2===e.rank?Xo(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Xo(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}var sc=Vs({batchNorm_:function(e,t,n,a,r,s){null==s&&(s=.001);let i,o,c=Bs(e,"x","batchNorm"),l=Bs(t,"mean","batchNorm"),u=Bs(n,"variance","batchNorm");null!=r&&(i=Bs(r,"scale","batchNorm")),null!=a&&(o=Bs(a,"offset","batchNorm")),Q(l.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Q(null==o||l.rank===o.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Q(null==i||l.rank===i.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:rc(c),scale:i,offset:o,mean:l,variance:u},h={varianceEpsilon:s},p=_s.runKernel(rn,d,h);return Xo(p,c.shape)}});var ic=Vs({batchNorm2d_:function(e,t,n,a,r,s){let i,o,c=Bs(e,"x","batchNorm"),l=Bs(t,"mean","batchNorm"),u=Bs(n,"variance","batchNorm");return null!=r&&(i=Bs(r,"scale","batchNorm")),null!=a&&(o=Bs(a,"offset","batchNorm")),Q(2===c.rank,()=>"Error in batchNorm2D: x must be rank 2 but got rank ".concat(c.rank,".")),Q(2===l.rank||1===l.rank,()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ".concat(l.rank,".")),Q(2===u.rank||1===u.rank,()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ".concat(u.rank,".")),null!=i&&Q(2===i.rank||1===i.rank,()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ".concat(i.rank,".")),null!=o&&Q(2===o.rank||1===o.rank,()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ".concat(o.rank,".")),sc(c,l,u,o,i,s)}});var oc=Vs({batchNorm3d_:function(e,t,n,a,r,s){let i,o,c=Bs(e,"x","batchNorm"),l=Bs(t,"mean","batchNorm"),u=Bs(n,"variance","batchNorm");return null!=r&&(i=Bs(r,"scale","batchNorm")),null!=a&&(o=Bs(a,"offset","batchNorm")),Q(3===c.rank,()=>"Error in batchNorm3D: x must be rank 3 but got rank ".concat(c.rank,".")),Q(3===l.rank||1===l.rank,()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ".concat(l.rank,".")),Q(3===u.rank||1===u.rank,()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ".concat(u.rank,".")),null!=i&&Q(3===i.rank||1===i.rank,()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ".concat(i.rank,".")),null!=o&&Q(3===o.rank||1===o.rank,()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ".concat(o.rank,".")),sc(c,l,u,o,i,s)}});var cc=Vs({batchNorm4d_:function(e,t,n,a,r,s){let i,o,c=Bs(e,"x","batchNorm"),l=Bs(t,"mean","batchNorm"),u=Bs(n,"variance","batchNorm");return null!=r&&(i=Bs(r,"scale","batchNorm")),null!=a&&(o=Bs(a,"offset","batchNorm")),Q(4===c.rank,()=>"Error in batchNorm4D: x must be rank 4 but got rank ".concat(c.rank,".")),Q(4===l.rank||1===l.rank,()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ".concat(l.rank,".")),Q(4===u.rank||1===u.rank,()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ".concat(u.rank,".")),null!=i&&Q(4===i.rank||1===i.rank,()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ".concat(i.rank,".")),null!=o&&Q(4===o.rank||1===o.rank,()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ".concat(o.rank,".")),sc(c,l,u,o,i,s)}});var lc=Vs({bincount_:function(e,t,n){let a=Bs(e,"x","bincount"),r=Bs(t,"weights","bincount");Q("int32"===a.dtype,()=>"Error in bincount: input dtype must be int32, but got ".concat(a.dtype)),Q(n>=0,()=>"size must be non-negative, but got ".concat(n,".")),Q(r.size===a.size||0===r.size,()=>"Error in bincount: weights must have the same size as input or0-length, but got input shape: ".concat(a.shape,", weights shape: ").concat(r.shape,"."));let s={x:a,weights:r},i={size:n};return _s.runKernel(pt,s,i)}});var uc=Vs({bitwiseAnd_:function(e,t){let n=Bs(e,"x","bitwiseAnd"),a=Bs(t,"y","bitwiseAnd");if(!re(n.shape,a.shape))throw new Error("BitwiseAnd: Tensors must have the same shape. x: ".concat(n.shape,", y: ").concat(a.shape));if("int32"!==n.dtype||"int32"!==a.dtype)throw new Error("BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ".concat(n.dtype," and type of y: ").concat(a.dtype));let r={a:n,b:a};return _s.runKernel(ft,r)}});var dc=Vs({broadcastArgs_:function(e,t){let n=Bs(e,"s0","broadcastArgs","int32"),a=Bs(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error("broadcastArgs(): first input must be a vector (rank=1). Has rank ".concat(n.rank));if(1!==a.rank)throw new Error("broadcastArgs(): second input must be a vector (rank=1). Has rank ".concat(a.rank));let r={s0:n,s1:a};return _s.runKernel(gt,r)}});var hc=Vs({broadcastTo_:function(e,t){let n=Bs(e,"broadcastTo","x"),a=n.shape;if(Fe(t),t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){let e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Xo(n,e)}let r=n.shape,s=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])s[c]=1;else if(1!==n.shape[c])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(t,"]."));if(0===s.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length)return Gi(n);let i={x:n},o={reps:s};return _s.runKernel(Ja,i,o)}});var pc=Vs({ceil_:function(e){let t={x:Bs(e,"x","ceil","float32")};return _s.runKernel(yt,t)}});function fc(e,t,n){Fe(e);let a={shape:e,value:t,dtype:n=n||Se(t)};return _s.runKernel(en,{},a)}var mc=Vs({clipByValue_:function(e,t,n){let a=Bs(e,"x","clipByValue");if(Q(t<=n,()=>"Error in clip: min (".concat(t,") must be less than or equal to max (").concat(n,").")),t===n)return fc(a.shape,t,a.dtype);let r={x:a},s={clipValueMin:t,clipValueMax:n};return _s.runKernel(vt,r,s)}});var gc=Vs({concat1d_:function(e){return Jo(e,0)}});var bc=Vs({concat2d_:function(e,t){return Jo(e,t)}});var yc=Vs({concat3d_:function(e,t){return Jo(e,t)}});var vc=Vs({concat4d_:function(e,t){return Jo(e,t)}});var xc=Vs({conv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=Bs(e,"x","conv2d","float32"),c=Bs(t,"filter","conv2d","float32"),l=o,u=!1;3===o.rank&&(u=!0,l=Xo(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Q(4===l.rank,()=>"Error in conv2d: input must be rank 4, but got rank ".concat(l.rank,".")),Q(4===c.rank,()=>"Error in conv2d: filter must be rank 4, but got rank ".concat(c.rank,".")),Ko("conv2d",a,i);let d="NHWC"===r?l.shape[3]:l.shape[1];Q(d===c.shape[2],()=>"Error in conv2d: depth of input (".concat(d,") must match input depth for filter ").concat(c.shape[2],".")),Q(Go(n,s),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides ".concat(n," and dilations '").concat(s,"'")),Q(Ho(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),Q(Ho(n),()=>"Error in conv2D: Strides should be larger than 0.");let h={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},f=_s.runKernel(It,h,p);return u?Xo(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var wc=Vs({conv1d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0,o=Bs(e,"x","conv1d"),c=Bs(t,"filter","conv1d"),l=o,u=!1;2===o.rank&&(u=!0,l=Xo(o,[1,o.shape[0],o.shape[1]])),Q(3===l.rank,()=>"Error in conv1d: input must be rank 3, but got rank ".concat(l.rank,".")),Q(3===c.rank,()=>"Error in conv1d: filter must be rank 3, but got rank ".concat(c.rank,".")),Ko("conv1d",a,i),Q(l.shape[2]===c.shape[1],()=>"Error in conv1d: depth of input (".concat(l.shape[2],") must match input depth for filter ").concat(c.shape[1],".")),Q(Go(n,s),()=>"Error in conv1D: Either stride or dilation must be 1. Got stride ".concat(n," and dilation '").concat(s,"'")),Q(Ho(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),Q(Ho(n),()=>"Error in conv1D: Stride should be larger than 0."),Q("NWC"===r,()=>"Error in conv1d: got dataFormat of ".concat(r," but only NWC is currently supported."));let d=Xo(c,[1,c.shape[0],c.shape[1],c.shape[2]]),h=Xo(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=xc(h,d,[1,n],a,"NHWC",[1,s],i);return Xo(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});var kc=Vs({conv2DBackpropInput_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;Q(e.length===t.rank,()=>"Length of inShape (".concat(e.length,") and rank of dy (").concat(t.rank,") must match"));let o=e,c=t,l=!1;3===t.rank&&(l=!0,c=Xo(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Q(4===o.length,()=>"Error in conv2dDerInput: inShape must be length 4, but got length ".concat(o.length,".")),Q(4===c.rank,()=>"Error in conv2dDerInput: dy must be rank 4, but got rank ".concat(c.rank)),Q(4===n.rank,()=>"Error in conv2dDerInput: filter must be rank 4, but got rank ".concat(n.rank));let u="NHWC"===s?o[3]:o[1],d="NHWC"===s?c.shape[3]:c.shape[1];Q(u===n.shape[2],()=>"Error in conv2dDerInput: depth of input (".concat(u,") must match input depth for filter ").concat(n.shape[2],".")),Q(d===n.shape[3],()=>"Error in conv2dDerInput: depth of output (".concat(d,") must match output depth for filter ").concat(n.shape[3],".")),Ko("conv2dDerInput",r,i);let h={dy:c,filter:n},p={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,inputShape:o},f=_s.runKernel(Nt,h,p);return l?Xo(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var Ic=Vs({conv2dTranspose_:function(e,t,n,a,r,s){let i=Bs(e,"x","conv2dTranspose"),o=Bs(t,"filter","conv2dTranspose");return kc(n,i,o,a,r,"NHWC",s)}});var Sc=Vs({conv3d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1],i=Bs(e,"x","conv3d"),o=Bs(t,"filter","conv3d"),c=i,l=!1;4===i.rank&&(l=!0,c=Xo(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Q(5===c.rank,()=>"Error in conv3d: input must be rank 5, but got rank ".concat(c.rank,".")),Q(5===o.rank,()=>"Error in conv3d: filter must be rank 5, but got rank ".concat(o.rank,".")),Q(c.shape[4]===o.shape[3],()=>"Error in conv3d: depth of input (".concat(c.shape[4],") must match input depth for filter ").concat(o.shape[3],".")),Q(Go(n,s),()=>"Error in conv3D: Either strides or dilations must be 1. Got strides ".concat(n," and dilations '").concat(s,"'")),Q("NDHWC"===r,()=>"Error in conv3d: got dataFormat of ".concat(r," but only NDHWC is currently supported.")),Q(Ho(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),Q(Ho(n),()=>"Error in conv3D: Strides should be larger than 0.");let u={x:c,filter:o},d={strides:n,pad:a,dataFormat:r,dilations:s},h=_s.runKernel(Tt,u,d);return l?Xo(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});var Nc=Vs({conv3DBackpropInput_:function(e,t,n,a,r){Q(e.length===t.rank,()=>"Length of inShape (".concat(e.length,") and rank of dy (").concat(t.rank,") must match"));let s=e,i=t,o=!1;4===t.rank&&(o=!0,i=Xo(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let c=s[4],l=i.shape[4];Q(5===s.length,()=>"Error in conv3dDerInput: inShape must be length 5, but got length ".concat(s.length,".")),Q(5===i.rank,()=>"Error in conv3dDerInput: dy must be rank 5, but got rank ".concat(i.rank)),Q(5===n.rank,()=>"Error in conv3dDerInput: filter must be rank 5, but got rank ".concat(n.rank)),Q(c===n.shape[3],()=>"Error in conv3dDerInput: depth of input (".concat(c,") must match input depth for filter ").concat(n.shape[3],".")),Q(l===n.shape[4],()=>"Error in conv3dDerInput: depth of output (".concat(l,") must match output depth for filter ").concat(n.shape[4],"."));let u={dy:i,filter:n},d={pad:r,strides:a,inputShape:s},h=_s.runKernel(Ct,u,d);return o?Xo(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});var Tc=Vs({conv3dTranspose_:function(e,t,n,a,r){let s=Bs(e,"x","conv3dTranspose"),i=Bs(t,"filter","conv3dTranspose");return Nc(n,s,i,a,r)}});var Oc=Vs({cos_:function(e){let t={x:Bs(e,"x","cos","float32")};return _s.runKernel(Et,t)}});var Cc=Vs({cosh_:function(e){let t={x:Bs(e,"x","cosh","float32")};return _s.runKernel(_t,t)}});var Ec=Vs({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={x:Bs(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:a};return _s.runKernel(At,r,s)}});var _c=Vs({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={x:Bs(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:a};return _s.runKernel(Rt,r,s)}});var Ac=Vs({denseBincount_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=Bs(e,"x","denseBincount"),s=Bs(t,"weights","denseBincount");Q("int32"===r.dtype,()=>"Error in denseBincount: input dtype must be int32, but got ".concat(r.dtype)),Q(r.rank<=2,()=>"Error in denseBincount: input must be at most rank 2, but got rank ".concat(r.rank,".")),Q(n>=0,()=>"size must be non-negative, but got ".concat(n,".")),Q(s.size===r.size||0===s.size,()=>"Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ".concat(r.shape,", weights shape: ").concat(s.shape,"."));let i={x:r,weights:s},o={size:n,binaryOutput:a};return _s.runKernel(Ft,i,o)}});var Rc=Vs({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC",a=Bs(e,"x","depthToSpace","float32"),r="NHWC"===n?a.shape[1]:a.shape[2],s="NHWC"===n?a.shape[2]:a.shape[3],i="NHWC"===n?a.shape[3]:a.shape[1];Q(t>1,()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t)),Q(r*t>=0,()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(r," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(a.shape)),Q(s*t>=0,()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(s," and ").concat(t," for depthToSpace with input shape\n        ").concat(a.shape)),Q(i%(t*t)===0,()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(i," for depthToSpace with input shape ").concat(a.shape));let o={x:a},c={blockSize:t,dataFormat:n};return _s.runKernel(Mt,o,c)}});var Dc=Vs({depthwiseConv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=Bs(e,"x","depthwiseConv2d","float32"),c=Bs(t,"filter","depthwiseConv2d","float32"),l=o,u=!1;3===o.rank&&(u=!0,l=Xo(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Q(4===l.rank,()=>"Error in depthwiseConv2d: input must be rank 4, but got rank ".concat(l.rank,".")),Q(4===c.rank,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank ".concat(c.rank,"."));let d="NHWC"===r?l.shape[3]:l.shape[1];Q(d===c.shape[2],()=>"Error in depthwiseConv2d: number of input channels (".concat(d,") must match the inChannels dimension in filter ").concat(c.shape[2],".")),Ko("depthwiseConv2d",a,i);let h={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},f=_s.runKernel(jt,h,p);return u?Xo(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var Fc=Vs({diag_:function(e){let t={x:Bs(e,"x","diag")};return _s.runKernel(Pt,t)}});var Mc=Vs({dilation2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=Bs(e,"x","dilation2d"),o=Bs(t,"filter","dilation2d");Q(3===i.rank||4===i.rank,()=>"Error in dilation2d: input must be rank 3 or 4, but got rank ".concat(i.rank,".")),Q(3===o.rank,()=>"Error in dilation2d: filter must be rank 3, but got rank ".concat(o.rank,".")),Q("NHWC"===s,()=>"Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ".concat(s));let c=i,l=!1;3===i.rank&&(c=Xo(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),Q(c.shape[3]===o.shape[2],()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(c.shape[3]," vs ").concat(o.shape[2]));let u={x:c,filter:o},d={strides:n,pad:a,dilations:r},h=_s.runKernel(Bt,u,d);return l?Xo(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),jc={};function zc(e,t){let n=e.length,a=[];for(let r=0;r<n;r++){let s=n-1-r,i=e[s]||1;(t[t.length-1-r]||1)>1&&1===i&&a.unshift(s)}return a}function Lc(e,t){let n=[];for(let a=0;a<t.length;a++){let r=e[e.length-a-1],s=t.length-a-1,i=t[s];(null==r||1===r&&i>1)&&n.unshift(s)}return n}function Pc(e,t){let n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let s=e[e.length-r-1];null==s&&(s=1);let i=t[t.length-r-1];if(null==i&&(i=1),1===s)a[n-r-1]=i;else if(1===i)a[n-r-1]=s;else{if(s!==i){let n="Operands could not be broadcast together with shapes ".concat(e," and ").concat(t,".");throw Error(n)}a[n-r-1]=s}}return a}y(jc,{assertAndGetBroadcastShape:()=>Pc,getBroadcastDims:()=>zc,getReductionAxes:()=>Lc});var Bc=Vs({equal_:function(e,t){let n=Bs(e,"a","equal","string_or_numeric"),a=Bs(t,"b","equal","string_or_numeric");[n,a]=ks(n,a),Pc(n.shape,a.shape);let r={a:n,b:a};return _s.runKernel(Zt,r)}});var Wc=Vs({where_:function(e,t,n){let a=Bs(t,"a","where"),r=Bs(n,"b","where"),s=Bs(e,"condition","where","bool"),i=Pc(Pc(s.shape,a.shape),r.shape),o={condition:hc(s,i),t:hc(a,i),e:hc(r,i)};return _s.runKernel(Ia,o)}});var Uc=Vs({zerosLike_:function(e){let t={x:Bs(e,"x","zerosLike")};return _s.runKernel(sr,t)}});var Vc=Vs({divNoNan_:function(e,t){let n=Bs(e,"a","div"),a=Bs(t,"b","div");[n,a]=ks(n,a);let r=go(n,a),s=Uc(r),i=Bc(a,s);return Wc(i,s,r)}});var Gc=Vs({dot_:function(e,t){let n=Bs(e,"t1","dot"),a=Bs(t,"t2","dot");Q((1===n.rank||2===n.rank)&&(1===a.rank||2===a.rank),()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks ".concat(n.rank," and ").concat(a.rank,"."));let r=1===n.rank?n.size:n.shape[1],s=1===a.rank?a.size:a.shape[0];if(Q(r===s,()=>"Error in dot: inner dimensions of inputs must match, but got ".concat(r," and ").concat(s,".")),1===n.rank&&1===a.rank){let e=Xo(n,[1,-1]),t=Xo(a,[-1,1]),r=Qo(e,t);return Xo(r,[])}if(1===n.rank&&2===a.rank){let e=Xo(n,[1,-1]),t=Xo(a,[a.shape[0],a.shape[1]]),r=Qo(e,t);return Xo(r,[r.size])}if(2===n.rank&&1===a.rank){let e=Xo(a,[-1,1]),t=Qo(n,e);return Xo(t,[t.size])}{let e=Xo(a,[a.shape[0],a.shape[1]]);return Qo(n,e)}}});var Hc=Vs({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];let r=n.map((e,t)=>Bs(e,"tensors".concat(t),"einsum")),s={equation:e};return _s.runKernel(Ht,r,s)}});var qc=Vs({elu_:function(e){let t={x:Bs(e,"x","elu","float32")};return _s.runKernel(qt,t)}});var Kc=Vs({ensureShape_:function(e,t){let n=Bs(e,"x","ensureShape","string_or_numeric");if(!ae(n.shape,t))throw new Error("EnsureShape: Shape of tensor ".concat(n.shape," is not compatible with expected shape ").concat(t));return e}});var Xc=Vs({erf_:function(e){let t=Bs(e,"x","erf");Q("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=Vi(t,"float32"));let n={x:t};return _s.runKernel(Xt,n)}});function Zc(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Yc(e,t,n){let a=e.length+t.length,r=[],s=0,i=0;for(let o=0;o<a;o++)-1===n.indexOf(o)?r.push(e[s++]):r.push(t[i++]);return r}function Jc(e,t){let n=[],a=e.length;for(let r=0;r<a;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map(t=>e[t])]}function Qc(e,t){return Yc(e,t.map(e=>1),t)}function $c(e,t,n){Q(Zc(t,n),()=>"".concat(e," supports only inner-most axes for now. Got axes ").concat(t," and rank-").concat(n," input."))}function el(e,t){if(Zc(e,t))return null;let n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach(e=>n.push(e)),n}function tl(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function nl(e,t){let n=[];for(let a=t-e;a<t;++a)n.push(a);return n}var al=Vs({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a={x:Bs(e,"x","max")},r={reductionIndices:t,keepDims:n};return _s.runKernel(An,a,r)}});var rl=Vs({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a={x:Bs(e,"x","min")},r={axis:t,keepDims:n};return _s.runKernel(Pn,a,r)}});var sl=Vs({pow_:function(e,t){let n=Bs(e,"base","pow"),a=Bs(t,"exp","pow");[n,a]=ks(n,a);let r={a:n,b:a};return _s.runKernel(ta,r)}});function il(e,t){if((Yr(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Yr(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Hs(e,[],[],t)}var ol=Vs({sqrt_:function(e){let t={x:Bs(e,"x","sqrt","float32")};return _s.runKernel(Aa,t)}});var cl=Vs({square_:function(e){let t=Bs(e,"x","square");return _s.runKernel("Square",{x:t},{})}});var ll=Vs({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Bs(e,"x","sum");"bool"===a.dtype&&(a=Vi(a,"int32"));let r={x:a},s={axis:t,keepDims:n};return _s.runKernel(Ra,r,s)}});function ul(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return yo(e);if(1!==e.rank&&null===n)return ul(Xo(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return ll(yo(e),n);if(t===1/0)return al(yo(e),n);if(t===-1/0)return rl(yo(e),n);if("euclidean"===t||2===t)return ol(ll(sl(yo(e),il(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return al(ll(yo(e),n[0]),n[1]-1);if(t===1/0)return al(ll(yo(e),n[1]),n[0]);if(t===-1/0)return rl(ll(yo(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return ol(ll(cl(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}var dl=Vs({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=ul(e=Bs(e,"x","norm"),t,n),s=r.shape;if(a){let t=he(n,e.shape);s=Qc(r.shape,t)}return Xo(r,s)}});var hl=Vs({euclideanNorm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return dl(e,"euclidean",t,n)}});var pl=Vs({exp_:function(e){let t={x:Bs(e,"x","exp")};return _s.runKernel(Yt,t)}});var fl=Vs({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=Bs(e,"x","expandDims","string_or_numeric");Q(t<=n.rank,()=>"Axis must be <= rank of the tensor");let a={input:n},r={dim:t};return _s.runKernel(Jt,a,r)}});var ml=Vs({expm1_:function(e){let t={x:Bs(e,"x","expm1")};return _s.runKernel(Qt,t)}});var gl=Vs({tile_:function(e,t){let n=Bs(e,"x","tile","string_or_numeric");Q(n.rank===t.length,()=>"Error in transpose: rank of input ".concat(n.rank," must match length of reps ").concat(t,"."));let a={x:n},r={reps:t};return _s.runKernel(Ja,a,r)}});var bl=Vs({eye_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";null==t&&(t=e);let r=Ui([e,t],a),s=e<=t?e:t;for(let o=0;o<s;++o)r.set(1,o,o);let i=Xo(r.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return gl(fl(i,0),[n[0],1,1]);if(2===n.length)return gl(fl(fl(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return gl(fl(fl(fl(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D batchShapes, but received ".concat(n.length,"D."))}});var yl=Vs({floor_:function(e){let t={x:Bs(e,"x","floor","float32")};return _s.runKernel(nn,t)}});var vl=Vs({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=Bs(e,"x","gather"),s=Bs(t,"indices","gather","int32"),i={x:r,indices:s},o={axis:n,batchDims:a};return _s.runKernel(sn,i,o)}});var xl=Vs({greater_:function(e,t){let n=Bs(e,"a","greater","string_or_numeric"),a=Bs(t,"b","greater","string_or_numeric");[n,a]=ks(n,a),Pc(n.shape,a.shape);let r={a:n,b:a};return _s.runKernel(cn,r)}});var wl=Vs({greaterEqual_:function(e,t){let n=Bs(e,"a","greaterEqual","string_or_numeric"),a=Bs(t,"b","greaterEqual","string_or_numeric");[n,a]=ks(n,a),Pc(n.shape,a.shape);let r={a:n,b:a};return _s.runKernel(ln,r)}});var kl=Vs({imag_:function(e){let t={input:Bs(e,"input","imag")};return _s.runKernel(hn,t)}});var Il=Vs({isFinite_:function(e){let t={x:Bs(e,"x","isFinite")};return _s.runKernel(pn,t)}});var Sl=Vs({isInf_:function(e){let t={x:Bs(e,"x","isInf")};return _s.runKernel(fn,t)}});var Nl=Vs({isNaN_:function(e){let t={x:Bs(e,"x","isNaN")};return _s.runKernel(mn,t)}});var Tl=Vs({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2,n={x:Bs(e,"x","leakyRelu")},a={alpha:t};return _s.runKernel(gn,n,a)}});var Ol=Vs({less_:function(e,t){let n=Bs(e,"a","less","string_or_numeric"),a=Bs(t,"b","less","string_or_numeric");[n,a]=ks(n,a),Pc(n.shape,a.shape);let r={a:n,b:a};return _s.runKernel(bn,r)}});var Cl=Vs({lessEqual_:function(e,t){let n=Bs(e,"a","lessEqual","string_or_numeric"),a=Bs(t,"b","lessEqual","string_or_numeric");[n,a]=ks(n,a),Pc(n.shape,a.shape);let r={a:n,b:a};return _s.runKernel(yn,r)}});function El(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let a={start:e,stop:t,num:n};return _s.runKernel(vn,{},a)}var _l=Vs({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=Bs(e,"x","localResponseNormalization");Q(4===s.rank||3===s.rank,()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(s.rank,".")),Q(se(t),()=>"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ".concat(t,"."));let i=s,o=!1;3===s.rank&&(o=!0,i=Xo(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let c={x:i},l={depthRadius:t,bias:n,alpha:a,beta:r},u=_s.runKernel(Cn,c,l);return o?Xo(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var Al=Vs({log_:function(e){let t={x:Bs(e,"x","log","float32")};return _s.runKernel(xn,t)}});var Rl=Vs({log1p_:function(e){let t={x:Bs(e,"x","log1p")};return _s.runKernel(wn,t)}});function Dl(e){return Q(Ne(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let a=Bs(t,"x","tf.grad","string_or_numeric"),r=null!=n?Bs(n,"dy","tf.grad"):null;return _s.tidy(()=>{let{value:t,grads:n}=_s.gradients(()=>e(a),[a],r);return null!=r&&$(t.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Pl(n),n[0]})}}function Fl(e){return Q(Ne(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{Q(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let a=Ws(t,"args","tf.grads","string_or_numeric"),r=null!=n?Bs(n,"dy","tf.grads"):null;return _s.tidy(()=>{let{value:t,grads:n}=_s.gradients(()=>e(...a),a,r);return null!=r&&$(t.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Pl(n),n})}}function Ml(e){return Q(Ne(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{Q(t instanceof os,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),Q(null==n||n instanceof os,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:a,value:r}=_s.gradients(()=>e(t),[t],n);return Pl(a),{grad:a[0],value:r}}}function jl(e){return Q(Ne(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{Q(Array.isArray(t)&&t.every(e=>e instanceof os),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),Q(null==n||n instanceof os,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let a=_s.gradients(()=>e(...t),t,n);return null!=n&&$(a.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Pl(a.grads),a}}function zl(e,t){Q(Ne(e),()=>"The f passed in variableGrads(f) must be a function"),Q(null==t||Array.isArray(t)&&t.every(e=>e instanceof ls),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=null!=t;if(!n){t=[];for(let e in _s.registeredVariables)t.push(_s.registeredVariables[e])}let a=n?t.filter(e=>!e.trainable):null,r=t.length;Q((t=t.filter(e=>e.trainable)).length>0,()=>"variableGrads() expects at least one of the input variables to be trainable, but none of the ".concat(r," variables is trainable."));let{value:s,grads:i}=_s.gradients(e,t,null,!0);Q(i.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Q(0===s.rank,()=>"The f passed in variableGrads(f) must return a scalar, but it returned a rank-".concat(s.rank," tensor"));let o={};return t.forEach((e,t)=>{null!=i[t]&&(o[e.name]=i[t])}),null!=a&&a.forEach(e=>o[e.name]=null),{value:s,grads:o}}function Ll(e){return _s.customGrad(e)}function Pl(e){if(e.filter(e=>null==e).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}var Bl=Vs({neg_:function(e){let t={x:Bs(e,"x","neg")};return _s.runKernel(Hn,t)}});var Wl=Vs({softplus_:function(e){let t={x:Bs(e,"x","softplus")};return _s.runKernel(_a,t)}});var Ul=Vs({logSigmoid_:function(e){let t=Bs(e,"x","logSigmoid");return Ll(e=>({value:Bl(Wl(Bl(e))),gradFunc:t=>bo(t,$o(Bl(e)))}))(t)}});var Vl=Vs({sub_:function(e,t){let n=Bs(e,"a","sub"),a=Bs(t,"b","sub");[n,a]=ks(n,a);let r={a:n,b:a};return _s.runKernel(Xa,r)}});var Gl=Vs({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=Bs(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank ".concat(n.rank," and axis was ").concat(t));return Ll((e,n)=>{let a=al(e,t,!0),r=Vl(e,a),s=Vl(Vi(r,"float32"),Al(ll(pl(r),t,!0)));return n([s]),{value:s,gradFunc:(e,n)=>{let[a]=n,r=pl(a);return Vl(e,bo(ll(e,t,!0),r))}}})(n)}});var Hl=Vs({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Bs(e,"x","logSumExp"),r=he(t,a.shape),s=al(a,r,!0),i=Vl(a,s),o=pl(i),c=ll(o,r),l=Al(c),u=fo(Xo(s,l.shape),l);if(n){let e=Qc(u.shape,r);return Xo(u,e)}return u}});var ql=Vs({logicalAnd_:function(e,t){let n=Bs(e,"a","logicalAnd","bool"),a=Bs(t,"b","logicalAnd","bool");Pc(n.shape,a.shape);let r={a:n,b:a};return _s.runKernel(kn,r)}});var Kl=Vs({logicalNot_:function(e){let t={x:Bs(e,"x","logicalNot","bool")};return _s.runKernel(In,t)}});var Xl=Vs({logicalOr_:function(e,t){let n=Bs(e,"a","logicalOr","bool"),a=Bs(t,"b","logicalOr","bool");Pc(n.shape,a.shape);let r={a:n,b:a};return _s.runKernel(Sn,r)}});var Zl=Vs({logicalXor_:function(e,t){let n=Bs(e,"a","logicalXor","bool"),a=Bs(t,"b","logicalXor","bool");return Pc(n.shape,a.shape),ql(Xl(e,t),Kl(ql(e,t)))}}),Yl=2147483648;var Jl=Vs({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left",a=Bs(e,"sortedSequence","searchSorted"),r=Bs(t,"values","searchSorted"),s=a.shape[a.shape.length-1],i=r.shape[r.shape.length-1],o=Xo(a,[-1,s]),c=Xo(r,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(te(c.shape)>=Yl)throw new Error("values tensor size must less than ".concat(Yl));if(o.shape[1]>=Yl)throw new Error("trailing dim_size must less than ".concat(Yl," for int32 output type, was ").concat(o.shape[1]));let l={sortedSequence:o,values:c},u={side:n};return _s.runKernel(ka,l,u)}});function Ql(e,t){return Jl(e,t,"left")}var $l=Vs({maxPool_:function(e,t,n,a,r){let s=Bs(e,"x","maxPool"),i=s,o=!1;3===s.rank&&(o=!0,i=Xo(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Q(4===i.rank,()=>"Error in maxPool: input must be rank 4 but got rank ".concat(i.rank,".")),Q(Go(n,1),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(n," and dilations '").concat(1,"'")),Ko("maxPool",a,r);let c={x:i},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r},u=_s.runKernel(Dn,c,l);return o?Xo(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var eu=Vs({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC",i=Bs(e,"x","maxPool3d"),o=i,c=!1;4===i.rank&&(c=!0,o=Xo(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Q(5===o.rank,()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(o.rank,".")),Q("NDHWC"===s,()=>"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ".concat(s)),Ko("maxPool3d",a,r);let l={x:o},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},d=_s.runKernel(Mn,l,u);return c?Xo(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var tu=Vs({maxPoolWithArgmax_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s={x:Bs(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},o=_s.runKernel(zn,s,i);return{result:o[0],indexes:o[1]}}});var nu=Vs({maximum_:function(e,t){let n=Bs(e,"a","maximum"),a=Bs(t,"b","maximum");[n,a]=ks(n,a),"bool"===n.dtype&&(n=Vi(n,"int32"),a=Vi(a,"int32")),Pc(n.shape,a.shape);let r={a:n,b:a};return _s.runKernel(Rn,r)}});var au=Vs({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a={x:Bs(e,"x","mean")},r={axis:t,keepDims:n};return _s.runKernel(Ln,a,r)}});function ru(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Fe(e),"complex64"===t){let t=ru(e,"float32"),n=ru(e,"float32");return Gs(t,n)}let n=Re(te(e),t);return _s.makeTensor(n,e,t)}function su(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Fe(e),"complex64"===t){let t=su(e,"float32"),n=ru(e,"float32");return Gs(t,n)}let n=Ae(te(e),t);return _s.makeTensor(n,e,t)}function iu(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError("".concat(n," is not a valid third argument to meshgrid"));if(void 0===e)return[];let a=Bs(e,"x","meshgrid",e instanceof os?e.dtype:"float32");if(void 0===t)return[a];let r=Bs(t,"y","meshgrid",t instanceof os?t.dtype:"float32"),s=te(a.shape),i=te(r.shape);return"xy"===n?(a=Xo(a,[1,-1]),r=Xo(r,[-1,1]),[Qo(su([i,1],a.dtype),a),Qo(r,su([1,s],r.dtype))]):(a=Xo(a,[-1,1]),r=Xo(r,[1,-1]),[Qo(a,su([1,i],a.dtype)),Qo(su([s,1],r.dtype),r)])}var ou=Vs({minimum_:function(e,t){let n=Bs(e,"a","minimum"),a=Bs(t,"b","minimum");[n,a]=ks(n,a),"bool"===n.dtype&&(n=Vi(n,"int32"),a=Vi(a,"int32")),Pc(n.shape,a.shape);let r={a:n,b:a};return _s.runKernel(Bn,r)}});var cu=Vs({mirrorPad_:function(e,t,n){Q("reflect"===n||"symmetric"===n,()=>"Invalid mode. Mode must be either reflect or symmetric. Got ".concat(n,"."));let a=Bs(e,"x","mirrorPad");if(0===a.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Q(t.length===a.rank,()=>"Padding doesn't match input. Must be ".concat(a.rank,". Got ").concat(t.length,"."));let r="reflect"===n?1:0;for(let o=0;o<a.rank;o++)Q(2===t[o].length,()=>"Invalid number of paddings. Must be length of 2 each."),Q(t[o][0]>=0&&t[o][0]<=a.shape[o]-r&&t[o][1]>=0&&t[o][1]<=a.shape[o]-r,()=>"Padding in dimension ".concat(o," cannot be greater than or equal to ").concat(a.shape[o]-r," or less than 0 for input of shape ").concat(a.shape));let s={paddings:t,mode:n},i={x:a};return _s.runKernel(Wn,i,s)}});var lu=Vs({mod_:function(e,t){let n=Bs(e,"a","mod"),a=Bs(t,"b","mod");[n,a]=ks(n,a);let r={a:n,b:a};return _s.runKernel(Un,r)}});var uu=Vs({moments_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=he(t,(e=Bs(e,"x","moments")).shape),r=au(e,a,n),s=r.shape;n||(s=Qc(r.shape,a));let i=cl(Vl(Vi(e,"float32"),Xo(r,s))),o=au(i,a,n);return{mean:r,variance:o}}});var du=Vs({multiRNNCell_:function(e,t,n,a){let r=Bs(t,"data","multiRNNCell"),s=Ws(n,"c","multiRNNCell"),i=Ws(a,"h","multiRNNCell"),o=r,c=[];for(let d=0;d<e.length;d++){let t=e[d](o,s[d],i[d]);c.push(t[0]),c.push(t[1]),o=t[1]}let l=[],u=[];for(let d=0;d<c.length;d+=2)l.push(c[d]),u.push(c[d+1]);return[l,u]}});var hu=Vs({multinomial_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=Bs(e,"logits","multinomial"),s=r.size,i=r.rank;if(s<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got ".concat(s,"."));if(i>2)throw new Error("Rank of probabilities must be 1 or 2, but is ".concat(i));n=n||Math.random();let o={logits:1===i?Xo(r,[1,-1]):r},c={numSamples:t,seed:n,normalized:a},l=_s.runKernel(Vn,o,c);return 1===i?Xo(l,[l.size]):l}});var pu=Vs({notEqual_:function(e,t){let n=Bs(e,"a","notEqual","string_or_numeric"),a=Bs(t,"b","notEqual","string_or_numeric");[n,a]=ks(n,a),Pc(n.shape,a.shape);let r={a:n,b:a};return _s.runKernel(qn,r)}});var fu=Vs({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));let s={indices:Bs(e,"indices","oneHot","int32")},i={dtype:r,depth:t,onValue:n,offValue:a};return _s.runKernel(Jn,s,i)}});var mu=Vs({onesLike_:function(e){let t={x:Bs(e,"x","onesLike")};return _s.runKernel(Yn,t)}});var gu=Vs({outerProduct_:function(e,t){let n=Bs(e,"v1","outerProduct"),a=Bs(t,"v2","outerProduct");Q(1===n.rank&&1===a.rank,()=>"Error in outerProduct: inputs must be rank 1, but got ranks ".concat(n.rank," and ").concat(a.rank,"."));let r=Xo(n,[-1,1]),s=Xo(a,[1,-1]);return Qo(r,s)}});var bu=Vs({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=Bs(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let r={paddings:t,constantValue:n},s={x:a};return _s.runKernel($n,s,r)}});var yu=Vs({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Q(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),bu(e,[t],n)}});var vu=Vs({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Q(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),bu(e,t,n)}});var xu=Vs({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Q(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),bu(e,t,n)}});var wu=Vs({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Q(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),bu(e,t,n)}});var ku=Vs({spaceToBatchND_:function(e,t,n){let a=Bs(e,"x","spaceToBatchND");Q(a.rank>=1+t.length,()=>"input rank ".concat(a.rank," should be > than [blockShape] ").concat(t.length)),Q(n.length===t.length,()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length)),Q(a.shape.reduce((e,a,r)=>r>0&&r<=t.length?e&&(a+n[r-1][0]+n[r-1][1])%t[r-1]===0:e,!0),()=>"input spatial dimensions ".concat(a.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString()));let r={x:a},s={blockShape:t,paddings:n};return _s.runKernel(Da,r,s)}});var Iu=Vs({pool_:function(e,t,n,a,r,s,i){null==r&&(r=[1,1]),null==s&&(s=1),0===a&&(a="valid");let o=Bs(e,"x","maxPool"),c=o,l=!1;3===o.rank&&(l=!0,c=Xo(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Q(Go(s,r),()=>"Error in pool: Either strides or dilations must be 1. Got strides ".concat(s," and dilations '").concat(r,"'"));let u,d=Ro(c.shape,t,s,r,a),h=[d.dilationHeight,d.dilationWidth];u="same"===a?function(e,t){let n=e.map((e,n)=>e+(e-1)*(t[n]-1)).map(e=>e-1),a=n.map(e=>Math.floor(e/2)),r=n.map((e,t)=>e-a[t]);return n.map((e,t)=>[a[t],r[t]])}([d.filterHeight,d.filterWidth],h):[[0,0],[0,0]];let p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){let a=n.map(e=>e[0]),r=n.map(e=>e[1]),s=e.concat(a,r),i=t.map((e,t)=>(e-s[t]%e)%e),o=r.map((e,t)=>e+i[t]),c=t.map((e,t)=>[a[t],o[t]]),l=t.map((e,t)=>[0,i[t]]);return[c,l]}([d.inHeight,d.inWidth],h,u),g=p?a:"valid",b=p?c:ku(c,h,f),y=("avg"===n?()=>Zo(b,t,s,g,i):()=>$l(b,t,s,g,i))(),v=p?y:ac(y,h,m);return l?Xo(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});var Su=Vs({prelu_:function(e,t){let n={x:Bs(e,"x","prelu"),alpha:Bs(t,"alpha","prelu")};return _s.runKernel(na,n)}});var Nu=Vs({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Bs(e,"x","prod");"bool"===a.dtype&&(a=Vi(a,"int32"));let r={x:a},s={axis:t,keepDims:n};return _s.runKernel(aa,r,s)}});var Tu=Vs({raggedGather_:function(e,t,n,a){let r={paramsNestedSplits:e.map((e,t)=>Bs(e,"tensors".concat(t),"raggedGather","int32")),paramsDenseValues:Bs(t,"paramsDenseValues","raggedGather"),indices:Bs(n,"indices","raggedGather","int32")},s={outputRaggedRank:a},i=_s.runKernel(ra,r,s);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});var Ou=Vs({raggedRange_:function(e,t,n){let a=Bs(e,"starts","raggedRange"),r={starts:a,limits:Bs(t,"limits","raggedRange",a.dtype),deltas:Bs(n,"deltas","raggedRange",a.dtype)},s=_s.runKernel(sa,r);return{rtNestedSplits:s[0],rtDenseValues:s[1]}}});var Cu=Vs({raggedTensorToTensor_:function(e,t,n,a,r){let s=Bs(e,"shape","raggedTensorToTensor","int32"),i=Bs(t,"values","raggedTensorToTensor"),o={shape:s,values:i,defaultValue:Bs(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:a.map((e,t)=>Bs(e,"tensors".concat(t),"raggedTensorToTensor","int32"))},c={rowPartitionTypes:r};return _s.runKernel(ia,o,c)}});var Eu=Vs({rand_:function(e,t,n){Fe(e);let a=te(e),r=null;if(null==n||"float32"===n)r=new Float32Array(a);else if("int32"===n)r=new Int32Array(a);else{if("bool"!==n)throw new Error("Unknown data type ".concat(n));r=new Uint8Array(a)}for(let s=0;s<a;s++)r[s]=t();return _s.makeTensor(r,e,n)}}),_u=v(A()),Au={};y(Au,{TEST_EPSILON_FLOAT16:()=>Ru,createVideoElement:()=>Vu,encodeStrings:()=>Uu,expectArrayBuffersEqual:()=>Wu,expectArraysClose:()=>Du,expectArraysEqual:()=>zu,expectNumbersClose:()=>Lu,expectPromiseToFail:()=>ju,expectValuesInRange:()=>Bu,play:()=>Gu,testEpsilon:()=>Fu});var Ru=.1;function Du(e,t,n){return null==n&&(n=Fu()),Mu(e,t,(e,t)=>Pu(e,t,n))}function Fu(){return 32===_s.backend.floatPrecision()?.001:Ru}function Mu(e,t,n){let a=!0;if((Yr(e)||Yr(t))&&(a=!1),Yr(e)&&Yr(t)&&(a=!0),a){let n=e.constructor.name,a=t.constructor.name;if(n!==a)throw new Error("Arrays are of different type. Actual: ".concat(n,". Expected: ").concat(a))}if(Array.isArray(e)&&Array.isArray(t)){let n=Ls(e),a=Ls(t);if(!re(n,a))throw new Error("Arrays have different shapes. Actual: [".concat(n,"]. Expected: [").concat(a,"]"))}let r=Yr(e)?e:Jr(e),s=Yr(t)?t:Jr(t);if(r.length!==s.length)throw new Error("Arrays have different lengths actual: ".concat(r.length," vs expected: ").concat(s.length,".\nActual:   ").concat(r,".\nExpected: ").concat(s,"."));for(let i=0;i<s.length;++i){let e=r[i],t=s[i];if(!n(e,t))throw new Error("Arrays differ: actual[".concat(i,"] = ").concat(e,", expected[").concat(i,"] = ").concat(t,".\nActual:   ").concat(r,".\nExpected: ").concat(s,"."))}"undefined"!=typeof expect&&expect().nothing()}function ju(e,t){e().then(()=>t.fail(),()=>t()),"undefined"!=typeof expect&&expect().nothing()}function zu(e,t){let n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return we(e)||we(e[0])||we(t)||we(t[0])?Mu(e,n,(e,t)=>e==t):Mu(e,t,(e,t)=>Pu(e,t,0))}function Lu(e,t,n){if(null==n&&(n=Fu()),!Pu(e,t,n))throw new Error("Numbers differ: actual === ".concat(e,", expected === ").concat(t));"undefined"!=typeof expect&&expect().nothing()}function Pu(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Bu(e,t,n){for(let a=0;a<e.length;a++)if(e[a]<t||e[a]>n)throw new Error("Value out of range:".concat(e[a]," low: ").concat(t,", high: ").concat(n))}function Wu(e,t){let n=new Float32Array(e),a=new Float32Array(t);if(n.length!==a.length)throw new Error("Expected ArrayBuffer to be of length ".concat(a.length,", but it was ").concat(n.length));for(let r=0;r<a.length;r++)if(n[r]!==a[r])throw new Error("Expected ArrayBuffer value at ".concat(r," to be ").concat(a[r]," but got ").concat(n[r]," instead"))}function Uu(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?Uu(n):e[t]=Xr(n)}return e}function Vu(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(e=>{t.addEventListener("loadeddata",n=>e(t)),t.load()})}async function Gu(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var Hu=class{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);let s=r||Math.random();this.random=_u.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,r,s;do{a=2*this.random()-1,r=2*this.random()-1,s=a*a+r*r}while(s>=1||0===s);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*a*i,t=this.mean+this.stdDev*r*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},qu=class{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;let r=a||Math.random();this.randu=_u.alea(r.toString()),this.randn=new Hu(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,r,s;for(;;){do{a=this.randn.nextValue(),s=1+this.c*a}while(s<=0);if(s*=s*s,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),r=this.randu(),r<t||Math.log(r)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}},Ku=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"==typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=_u.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};var Xu=Vs({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;if(Fe(e),null==n&&(n=1),null==a&&(a="float32"),"float32"!==a&&"int32"!==a)throw new Error("Unsupported data type ".concat(a));let s=new qu(t,n,a,r),i=Ui(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var Zu=Vs({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(Fe(e),null!=a&&"bool"===a)throw new Error("Unsupported data type ".concat(a));let s=new Hu(t,n,a,!1,r),i=Ui(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var Yu=Vs({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error("Unsupported data type ".concat(t));return Zu(e,0,1,t,n)}});var Ju=Vs({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;Fe(e);let s=Ui(e,a),i=new Ku(t,n,null,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}});var Qu=Vs({randomUniformInt_:function(e,t,n,a){return Ju(e,t,n,"int32",a)}});function $u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");let r={start:e,stop:t,step:n,dtype:a};return _s.runKernel(oa,{},r)}var ed=Vs({real_:function(e){let t={input:Bs(e,"input","real")};return _s.runKernel(ca,t)}});var td=Vs({reciprocal_:function(e){let t={x:Bs(e,"x","reciprocal")};return _s.runKernel(la,t)}});var nd=Vs({relu_:function(e){let t={x:Bs(e,"x","relu")};return _s.runKernel(ua,t)}});var ad=Vs({relu6_:function(e){let t={x:Bs(e,"x","relu6")};return _s.runKernel(ga,t)}});var rd=Vs({reverse_:function(e,t){let n={x:Bs(e,"x","reverse")},a={dims:t};return _s.runKernel(ba,n,a)}});var sd=Vs({reverse1d_:function(e){let t=Bs(e,"x","reverse");return Q(1===t.rank,()=>"Error in reverse1D: x must be rank 1 but got rank ".concat(t.rank,".")),rd(t,0)}});var id=Vs({reverse2d_:function(e,t){let n=Bs(e,"x","reverse");return Q(2===n.rank,()=>"Error in reverse2D: x must be rank 2 but got rank ".concat(n.rank,".")),rd(n,t)}});var od=Vs({reverse3d_:function(e,t){let n=Bs(e,"x","reverse");return Q(3===n.rank,()=>"Error in reverse3D: x must be rank 3 but got rank ".concat(n.rank,".")),rd(n,t)}});var cd=Vs({reverse4d_:function(e,t){let n=Bs(e,"x","reverse");return Q(4===n.rank,()=>"Error in reverse4D: x must be rank 4 but got rank ".concat(n.rank,".")),rd(n,t)}});var ld=Vs({round_:function(e){let t={x:Bs(e,"x","round")};return _s.runKernel(ya,t)}});var ud=Vs({rsqrt_:function(e){let t={x:Bs(e,"x","rsqrt","float32")};return _s.runKernel(va,t)}});var dd=Vs({selu_:function(e){let t={x:Bs(e,"x","selu")};return _s.runKernel(Sa,t)}});var hd=Vs({separableConv2d_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC",o=Bs(e,"x","separableConv2d"),c=Bs(t,"depthwiseFilter","separableConv2d"),l=Bs(n,"pointwiseFilter","separableConv2d"),u=o,d=!1;if(3===o.rank&&(d=!0,u=Xo(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Q(4===u.rank,()=>"Error in separableConv2d: input must be rank 4, but got rank ".concat(u.rank,".")),Q(4===c.rank,()=>"Error in separableConv2d: depthwise filter must be rank 4, but got rank ".concat(c.rank,".")),Q(4===l.rank,()=>"Error in separableConv2d: pointwise filter must be rank 4, but got rank ".concat(c.rank,".")),Q(1===l.shape[0],()=>"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ".concat(l.shape[0],".")),Q(1===l.shape[1],()=>"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ".concat(l.shape[1],"."));let h=c.shape[2],p=c.shape[3];Q(l.shape[2]===h*p,()=>"Error in separableConv2d: the third dimension of pointwise filter must be ".concat(h*p,", but got ").concat(l.shape[2],"."));let f=Dc(u,c,a,r,i,s),m=xc(f,l,1,"valid",i);return d?Xo(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});var pd=async function(e,t){let n=Bs(e,"x","setdiff1d"),a=Bs(t,"y","setdiff1d");Q(n.dtype===a.dtype,()=>"x and y should have the same dtype, but got x (".concat(n.dtype,") and y (").concat(a.dtype,").")),Q(1===n.rank,()=>"x should be 1D tensor, but got x (".concat(n.shape,").")),Q(1===a.rank,()=>"y should be 1D tensor, but got y (".concat(a.shape,")."));let r=await n.data(),s=await a.data(),i=new Set(s),o=0;for(let u=0;u<r.length;u++)i.has(r[u])||o++;let c=new rs([o],n.dtype),l=new rs([o],"int32");for(let u=0,d=0;u<r.length;u++)i.has(r[u])||(c.values[d]=r[u],l.values[d]=u,d++);return[c.toTensor(),l.toTensor()]};var fd=Vs({sign_:function(e){let t={x:Bs(e,"x","sign")};return _s.runKernel(Ca,t)}});var md=Vs({sin_:function(e){let t={x:Bs(e,"x","sin","float32")};return _s.runKernel(Ta,t)}});var gd=Vs({sinh_:function(e){let t={x:Bs(e,"x","sinh")};return _s.runKernel(Oa,t)}});var bd=Vs({slice1d_:function(e,t,n){let a=Bs(e,"x","slice1d");return Q(1===a.rank,()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(a.rank," tensor")),ec(a,[t],[n])}});var yd=Vs({slice2d_:function(e,t,n){let a=Bs(e,"x","slice2d");return Q(2===a.rank,()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(a.rank," tensor")),ec(a,t,n)}});var vd=Vs({slice3d_:function(e,t,n){let a=Bs(e,"x","slice3d");return Q(3===a.rank,()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(a.rank," tensor")),ec(a,t,n)}});var xd=Vs({slice4d_:function(e,t,n){let a=Bs(e,"x","slice4d");return Q(4===a.rank,()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(a.rank," tensor")),ec(a,t,n)}});var wd=Vs({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=Bs(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank ".concat(n.rank," and dim was ").concat(t));let a={logits:n},r={dim:t};return _s.runKernel(Ma,a,r)}});var kd=Vs({fft_:function(e){Q("complex64"===e.dtype,()=>"The dtype for tf.spectral.fft() must be complex64 but got ".concat(e.dtype,"."));let t={input:e};return _s.runKernel($t,t)}});var Id=Vs({ifft_:function(e){Q("complex64"===e.dtype,()=>"The dtype for tf.spectral.ifft() must be complex64 but got ".concat(e.dtype,"."));let t={input:e};return _s.runKernel(dn,t)}});var Sd=Vs({irfft_:function(e){let t,n=e.shape[e.shape.length-1],a=e.size/n;if(n<=2){let r=Xo(e,[a,n]);t=Id(r)}else{let r=[a,2*(n-1)],s=Xo(ed(e),[a,n]),i=Xo(kl(e),[a,n]),o=rd(ec(s,[0,1],[a,n-2]),1),c=bo(rd(ec(i,[0,1],[a,n-2]),1),il(-1)),l=Jo([s,o],1),u=Jo([i,c],1),d=Xo(Gs(l,u),[r[0],r[1]]);t=Id(d)}if(t=ed(t),3===e.rank&&0!==e.shape[0]){let n=t,a=e.shape[0];t=Xo(t,[a,t.shape[0]/a,t.shape[1]]),n.dispose()}return t}});var Nd=Vs({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a={x:Bs(e,"x","split")},r={numOrSizeSplits:t,axis:n};return _s.runKernel(Fa,a,r)}});var Td=Vs({rfft_:function(e,t){Q("float32"===e.dtype,()=>"The dtype for rfft() must be real value but got ".concat(e.dtype));let n,a=e.shape[e.shape.length-1],r=e.size/a;if(null!=t&&t<a){let r=e.shape.map(e=>0),s=e.shape.map(e=>e);s[e.shape.length-1]=t,n=ec(e,r,s),a=t}else if(null!=t&&t>a){let r=e.shape.map(e=>e);r[e.shape.length-1]=t-a,n=Jo([e,ru(r)],e.shape.length-1),a=t}else n=e;let s=Uc(n),i=Xo(Gs(n,s),[r,a]),o=kd(i),c=Math.floor(a/2)+1,l=ed(o),u=kl(o),d=Nd(l,[c,a-c],l.shape.length-1),h=Nd(u,[c,a-c],u.shape.length-1),p=n.shape.slice();return p[n.shape.length-1]=c,Xo(Gs(d[0],h[0]),p)}});var Od=Vs({squaredDifference_:function(e,t){let n=Bs(e,"a","squaredDifference"),a=Bs(t,"b","squaredDifference");[n,a]=ks(n,a),Pc(n.shape,a.shape);let r={a:n,b:a};return _s.runKernel(Wa,r,{})}});var Cd=Vs({squeeze_:function(e,t){let n=Bs(e,"x","squeeze","string_or_numeric");return Xo(n,pe(n.shape,t).newShape)}});var Ed=Vs({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=Ws(e,"tensors","stack","string_or_numeric");Q(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Q(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let a=n,r={axis:t};return _s.runKernel(Qn,a,r)}});var _d=Vs({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:Bs(e,"x","step")},a={alpha:t};return _s.runKernel(ir,n,a)}});var Ad=Vs({stridedSlice_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,l={x:Bs(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:a,beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:c};return _s.runKernel(Ga,l,u)}});var Rd=Vs({tan_:function(e){let t={x:Bs(e,"x","tan","float32")};return _s.runKernel(Za,t)}});function Dd(e,t){ee(e);let n=Ls(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Hs(e,null,n,t)}function Fd(e,t,n){if(ee(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");let a=Ls(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Hs(e,t,a,n)}function Md(e,t,n){if(ee(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");let a=Ls(e,n);if(3!==a.length&&1!==a.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Hs(e,t,a,n)}function jd(e,t,n){if(ee(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");let a=Ls(e,n);if(4!==a.length&&1!==a.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Hs(e,t,a,n)}function zd(e,t,n){if(ee(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");let a=Ls(e,n);if(5!==a.length&&1!==a.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Hs(e,t,a,n)}function Ld(e,t,n){if(ee(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");let a=Ls(e,n);if(6!==a.length&&1!==a.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Hs(e,t=t||a,a,n)}var Pd={};function Bd(e,t,n){let a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ".concat(n.shape,", indices.shape: ").concat(t.shape,", shape: ").concat(e,", sliceDim: ").concat(a,", and batchDim: ").concat(r,".");if(n.rank<r)throw new Error(s+" update.rank < ".concat(r,". "));if(e.length<a+(n.rank-r))throw new Error(s+" Output shape length < ".concat(a+(n.rank-r)));if(n.rank!==r+e.length-a)throw new Error(s+" update.rank != ".concat(r+e.length-a));for(let i=0;i<r;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+" updates.shape[".concat(i,"] (").concat(n.shape[i],") != indices.shape[").concat(i,"] (").concat(t.shape[i],")."));for(let i=0;i<n.rank-r;++i)if(n.shape[i+r]!==e[i+a])throw new Error(s+" updates.shape[".concat(i+r,"] (").concat(n.shape[i+r],") != shape[").concat(i+r,"] (").concat(e[i+r],")"))}function Wd(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}Bd(n,t,e)}function Ud(e,t,n){let a=t.shape.length,r=a>1?t.shape[a-1]:1,s=n.length,i=1;for(let c=r;c<s;++c)i*=n[c];let o=r<1?1:r;return{sliceRank:r,numUpdates:te(t.shape)/o,sliceSize:i,strides:[...Oe(n.slice(0,r)),1],outputSize:te(n)}}y(Pd,{calculateShapes:()=>Ud,validateInput:()=>Wd,validateUpdateShape:()=>Bd});var Vd=Vs({tensorScatterUpdate_:function(e,t,n){let a=Bs(e,"tensor","tensorScatterupdate"),r=Bs(t,"indices","tensorScatterupdate","int32"),s=Bs(n,"updates","tensorScatterupdate");if(Wd(s,r,a.shape),a.dtype!==s.dtype)throw new Error("tensor and updates must have the same dtype, instead they are ".concat(a.dtype," and ").concat(s.dtype,"."));let i={tensor:a,indices:r,updates:s};return _s.runKernel(wa,i,{})}});var Gd=Vs({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],a=Bs(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");let r=a.shape[a.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>r)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(r,") but got ").concat(t));let s={x:a},i={k:t,sorted:n},[o,c]=_s.runKernel(Qa,s,i);return{values:o,indices:c}}});var Hd=Vs({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(Fe(e),null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");let s=new Hu(t,n,a,!0,r),i=Ui(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var qd=Vs({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=Bs(e,"x","unique","string_or_numeric");Q(n.rank>0,()=>"The input tensor must be at least 1D");let a={x:n},r={axis:t},[s,i]=_s.runKernel(tr,a,r);return{values:s,indices:i}}});var Kd=Vs({unsortedSegmentSum_:function(e,t,n){let a=Bs(e,"x","unsortedSegmentSum"),r=Bs(t,"segmentIds","unsortedSegmentSum","int32");Q(se(n),()=>"numSegments must be of dtype int");let s={x:a,segmentIds:r},i={numSegments:n};return _s.runKernel(ar,s,i)}});var Xd=Vs({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=Bs(e,"x","unstack","string_or_numeric");Q(t>=-n.shape.length&&t<n.shape.length,()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")"));let a={value:n},r={axis:t};return _s.runKernel(nr,a,r)}});function Zd(e,t){return Jl(e,t,"right")}function Yd(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return _s.makeVariable(e,t,n,a)}function Jd(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let a=Ui(e,"int32"),r=Ui([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let t=a.indexToLoc(n[s]),i=s*e.length;r.values.set(t,i)}return r.toTensor()}var Qd=async function(e){let t=Bs(e,"condition","whereAsync","bool"),n=await t.data(),a=Jd(t.shape,n);return e!==t&&t.dispose(),a};var $d=async function(e,t,n){let a=Bs(e,"tensor","boolMask"),r=Bs(t,"mask","boolMask","bool"),s=null==n?0:n,i=r.rank,o=a.shape;Q(i>0,()=>"mask cannot be scalar"),$(o.slice(s,s+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let m=s;m<s+i;m++)c*=o[m];let l=o.slice(0,s).concat([c],o.slice(s+i)),u=Xo(a,l),d=Xo(r,[-1]),h=await Qd(d),p=Cd(h,[1]),f=vl(u,p,s);return e!==a&&a.dispose(),t!==r&&r.dispose(),p.dispose(),u.dispose(),d.dispose(),h.dispose(),f};var eh=Vs({transpose_:function(e,t,n){let a=Bs(e,"x","transpose");if(null==t&&(t=a.shape.map((e,t)=>t).reverse()),Q(a.rank===t.length,()=>"Error in transpose: rank of input ".concat(a.rank," must match length of perm ").concat(t,".")),t.forEach(e=>{Q(e>=0&&e<a.rank,()=>"All entries in 'perm' must be between 0 and ".concat(a.rank-1," but got ").concat(t))}),a.rank<=1)return a.clone();let r={x:a},s={perm:t};return"complex64"===a.dtype?eo(()=>{let e=ed(a),t=kl(a);return e=_s.runKernel(er,{x:e},s),t=_s.runKernel(er,{x:t},s),n&&(t=Bl(t)),Gs(e,t)}):_s.runKernel(er,r,s)}});var th=Vs({movingAverage_:function(e,t,n,a){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=Bs(e,"v","movingAverage"),i=Bs(t,"x","movingAverage"),o=Bs(n,"decay","movingAverage");Is(s,i),Q(re(s.shape,i.shape),()=>"Shape mismatch in v and x");let c=il(1),l=Vl(c,o),u=bo(Vl(i,s),l);if(r){Q(null!=a,()=>"When using zeroDebias: true, step is required.");let e=Bs(a,"step","movingAverage");u=go(u,Vl(c,sl(o,e)))}return fo(s,u)}});var nh=Vs({scatterND_:function(e,t,n){Fe(n);let a=Bs(e,"indices","scatterND","int32"),r=Bs(t,"updates","scatterND");Wd(r,a,n);let s={indices:a,updates:r},i={shape:n};return _s.runKernel(xa,s,i)}});function ah(e,t,n,a){if("int32"!==e.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was ".concat(e.dtype,"."));if(e.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape ".concat(e.shape,"."));let r=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error("outputShape has incorrect number of elements:, ".concat(n.length,", should be: ").concat(s,"."));let i=t.size;if(0!==t.rank&&(1!==t.rank||i!==r))throw new Error("sparseValues has incorrect shape ".concat(t.shape,", should be [] or [").concat(r,"]"));if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}var rh=Vs({sparseToDense_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;Fe(n);let r=Bs(e,"sparseIndices","sparseToDense","int32"),s=Bs(t,"sparseValues","sparseToDense","string_or_numeric"),i=Bs(a,"defaultValue","sparseToDense",s.dtype);ah(r,s,n,i);let o={sparseIndices:r,sparseValues:s,defaultValue:i},c={outputShape:n};return _s.runKernel(Ba,o,c)}});var sh=Vs({gatherND_:function(e,t){let n=Bs(t,"indices","gatherND","int32"),a={params:Bs(e,"x","gatherND","string_or_numeric"),indices:n};return _s.runKernel(on,a)}});var ih=Vs({dropout_:function(e,t,n,a){let r=Bs(e,"x","dropout");if(Q("float32"===r.dtype,()=>"x has to be a floating point tensor since it's going to be scaled, but got a ".concat(r.dtype," tensor instead.")),Q(t>=0&&t<1,()=>"rate must be a float in the range [0, 1), but got ".concat(t,".")),0===t)return e instanceof os?r.clone():r;let s=function(e,t){if(null==t)return e.shape.slice();if(re(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?n.push(e.shape[a]):n.push(t[a]);return n}return t}(r,n),i=1-t,o=go(yl(fo(Ju(s,0,1,"float32",a),i)),i);return bo(r,o)}});function oh(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function ch(e,t,n){let a=1-e%2,r=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+a-1);r[s]=t-n*Math.cos(i)}return Dd(r,"float32")}var lh=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=Bs(e,"predictions","inTopK"),r=Bs(t,"targets","inTopK");Q(a.rank>1,()=>"inTopK() expects the predictions to be of rank 2 or higher, but got ".concat(a.rank)),Q(a.rank-1===r.rank,()=>"predictions rank should be 1 larger than targets rank, but got predictions rank ".concat(a.rank," and targets rank ").concat(r.rank)),$(a.shape.slice(0,a.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=a.shape[a.shape.length-1];Q(n>0&&n<=s,()=>"'k' passed to inTopK() must be > 0 && <= the predictions last dimension (".concat(s,"), but got ").concat(n));let i=await a.data(),o=await r.data(),[c,l]=[i.length/s,s],u=fe("bool",c);for(let d=0;d<c;d++){let e=d*l,t=i.subarray(e,e+l),a=[];for(let n=0;n<t.length;n++)a.push({value:t[n],index:n});a.sort((e,t)=>t.value-e.value),u[d]=0;for(let r=0;r<n;r++)if(a[r].index===o[d]){u[d]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),qs(u,r.shape,"bool")},uh={};y(uh,{conv2d:()=>gh,depthwiseConv2d:()=>vh,matMul:()=>xh});var dh=Vs({conv2DBackpropFilter_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Xo(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=Xo(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Q(4===o.rank,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape ".concat(o.shape,".")),Q(4===c.rank,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape ".concat(c.shape,".")),Q(4===n.length,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got ".concat(n,"."));let l="NHWC"===s?o.shape[3]:o.shape[1],u="NHWC"===s?c.shape[3]:c.shape[1];Q(l===n[2],()=>"Error in conv2dDerFilter: depth of input ".concat(l,") must match input depth in filter (").concat(n[2],".")),Q(u===n[3],()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must match output depth for filter (").concat(n[3],").")),Ko("conv2dDerFilter",r,i);let d={x:o,dy:c},h={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,filterShape:n};return _s.runKernel(St,d,h)}});function hh(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return bo(e,_d(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function ph(e,t){let n=t,a=Lc(e.shape,t.shape);return a.length>0&&(n=ll(n,a)),Xo(n,e.shape)}function fh(e,t,n,a){if("linear"===t)return e;if("relu"===t)return nd(e);if("elu"===t)return qc(e);if("relu6"===t)return ad(e);if("prelu"===t)return Su(e,n);if("leakyrelu"===t)return Tl(e,a);if("sigmoid"===t)return $o(e);throw new Error("Unknown fused activation ".concat(t,"."))}var mh=(e,t)=>!(e>0)||"linear"===t;var gh=Vs({fusedConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:d}=e;if(l=l||"linear",!1===mh(_s.state.gradientDepth,l)){Q("NHWC"===s,()=>"Error in fused conv2d: got dataFormat of ".concat(s," but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let e=xc(t,n,a,r,s,i,o);return null!=c&&(e=fo(e,c)),fh(e,l,u,d)}let h=Bs(t,"x","conv2d","float32"),p=Bs(n,"filter","conv2d","float32"),f=h,m=!1;3===h.rank&&(m=!0,f=Xo(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Q(4===f.rank,()=>"Error in fused conv2d: input must be rank 4, but got rank ".concat(f.rank,".")),Q(4===p.rank,()=>"Error in fused conv2d: filter must be rank 4, but got rank ".concat(p.rank,".")),Ko("fused conv2d",r,o);let g="NHWC"===s?f.shape[3]:f.shape[1];Q(p.shape[2]===g,()=>"Error in conv2d: depth of input (".concat(g,") must match input depth for filter ").concat(p.shape[2],".")),Q(Go(a,i),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides ".concat(a," and dilations '").concat(i,"'"));let b,y,v=Fo(f.shape,p.shape,a,i,r,o);if(null!=c&&(b=Bs(c,"bias","fused conv2d"),[b]=ks(b,h),"NHWC"===s?Pc(v.outShape,b.shape):(Q(b.shape.length<=1,()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-".concat(b.shape.length,".")),Q(0===b.shape.length||b.shape[0]===v.outChannels||1===b.shape[0],()=>"Error in fused conv2d: bias shape (".concat(b.shape,") is not compatible with the number of output channels (").concat(v.outChannels,")")))),null!=u){let e=u.shape;if(Q(e.length<=1||3===e.length,()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-".concat(e.length,".")),1===e.length)Q(1===e[0]||e[0]===v.outChannels,()=>"Error in fused conv2d: PReLU activation weights (".concat(e,") is not compatible with the number of output channels (").concat(v.outChannels,")."));else if(3===e.length)try{Pc(e,v.outShape)}catch(I){let t="Error in fused conv2d: PReLU activation weights (".concat(e,") is not compatible with the output shape of the conv2d (").concat(v.outShape,").");throw Error(t)}y=Bs(u,"prelu weights","fused conv2d")}let x=(e,t)=>{Q("NHWC"===s,()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(s," but only NHWC is currently supported."));let[n,o,c,u]=t,d=hh(e,c,l);Q(Vo(i),()=>"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '".concat(i,"'"));let h=[kc(o.shape,d,n,a,r),dh(o,d,n.shape,a,r)];if(null!=u){let e=ph(u,d);h.push(e)}return h},w={x:f,filter:p,bias:b,preluActivationWeights:y},k={strides:a,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:d};return null==c?Ll((e,t,n)=>{let a=_s.runKernel(ur,w,k);return n([t,e,a]),m&&(a=Xo(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}})(f,p):Ll((e,t,n,a)=>{let r=_s.runKernel(ur,w,k);return a([t,e,r,n]),m&&(r=Xo(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}})(f,p,b)}});var bh=Vs({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Xo(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=Xo(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={x:o,dy:c},u={strides:a,pad:r,dimRoundingMode:i,dilations:s,filterShape:n};return _s.runKernel(zt,l,u)}});var yh=Vs({depthwiseConv2dNativeBackpropInput_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=t,c=!1;3===t.rank&&(c=!0,o=Xo(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={dy:o,filter:n},u={strides:a,pad:r,dimRoundingMode:i,dilations:s,inputShape:e},d=_s.runKernel(Lt,l,u);return c?Xo(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});var vh=Vs({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:d}=e;if(!1===mh(_s.state.gradientDepth,l)){let e=Dc(t,n,a,r,s,i,o);return null!=c&&(e=fo(e,c)),fh(e,l,u,d)}let h=Bs(t,"x","depthwiseConv2d","float32"),p=Bs(n,"filter","depthwiseConv2d","float32"),f=h,m=!1;3===h.rank&&(m=!0,f=Xo(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Q(4===f.rank,()=>"Error in fused depthwiseConv2d: input must be rank 4, but got rank ".concat(f.rank,".")),Q(4===p.rank,()=>"Error in fused depthwiseConv2d: filter must be rank 4, but got rank ".concat(p.rank,".")),Q(f.shape[3]===p.shape[2],()=>"Error in fused depthwiseConv2d: number of input channels (".concat(f.shape[3],") must match the inChannels dimension in filter ").concat(p.shape[2],".")),null==i&&(i=[1,1]),Q(Go(a,i),()=>"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ".concat(a," and dilations '").concat(i,"'")),Ko("fused depthwiseConv2d",r,o);let g,b,y=Fo(f.shape,p.shape,a,i,r,o,!0);null!=c&&(g=Bs(c,"bias","fused conv2d"),[g]=ks(g,h),Pc(y.outShape,g.shape)),null!=u&&(b=Bs(u,"prelu weights","fused depthwiseConv2d"));let v=(e,t)=>{Q(Vo(i),()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '".concat(i,"'"));let[n,s,c,u]=t,d=hh(e,c,l),h=yh(s.shape,d,n,a,r,i,o),p=bh(s,d,n.shape,a,r,i,o);if(null!=u){return[h,p,ph(g,d)]}return[h,p]},x={x:f,filter:p,bias:g,preluActivationWeights:b},w={strides:a,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:d};return null==c?Ll((e,t,n)=>{let a=_s.runKernel(dr,x,w);return n([t,e,a]),m&&(a=Xo(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}})(f,p):Ll((e,t,n,a)=>{let r=_s.runKernel(dr,x,w);return a([t,e,r,n]),m&&(r=Xo(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}})(f,p,g)}});var xh=Vs({fusedMatMul_:function(e){let{a:t,b:n,transposeA:a=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:c=.2}=e;if(!1===mh(_s.state.gradientDepth,i)){let e=Qo(t,n,a,r);return null!=s&&(e=fo(e,s)),fh(e,i,o,c)}let l=Bs(t,"a","fused matMul"),u=Bs(n,"b","fused matMul");[l,u]=ks(l,u);let d=a?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=a?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),g=u.shape.slice(0,-2),b=te(m),y=te(g);Q(d===h,()=>"Error in fused matMul: inner shapes (".concat(d,") and (").concat(h,") of Tensors with shapes ").concat(l.shape," and ").concat(u.shape," and transposeA=").concat(a," and transposeB=").concat(r," must match."));let v,x,w=Pc(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),k=Xo(l,a?[b,d,p]:[b,p,d]),I=Xo(u,r?[y,f,h]:[y,h,f]);null!=s&&(v=Bs(s,"bias","fused matMul"),[v]=ks(v,l),Pc(w,v.shape)),null!=o&&(x=Bs(o,"prelu weights","fused matMul"));let S=(e,t)=>{let n,o,[c,l,u,d]=t,h=hh(Xo(e,u.shape),u,i);if(a||r?!a&&r?(n=Qo(h,l,!1,!1),o=Qo(h,c,!0,!1)):a&&!r?(n=Qo(l,h,!1,!0),o=Qo(c,h,!1,!1)):(n=Qo(l,h,!0,!0),o=Qo(h,c,!0,!0)):(n=Qo(h,l,!1,!0),o=Qo(c,h,!0,!1)),null!=s){return[n,o,ph(d,h)]}return[n,o]},N={a:k,b:I,bias:v,preluActivationWeights:x},T={transposeA:a,transposeB:r,activation:i,leakyreluAlpha:c};return null==s?Ll((e,t,n)=>{let a=_s.runKernel(lr,N,T);return n([e,t,a]),{value:Xo(a,w),gradFunc:S}})(k,I):Ll((e,t,n,a)=>{let r=_s.runKernel(lr,N,T);return a([e,t,r,n]),{value:Xo(r,w),gradFunc:S}})(k,I,v)}});var wh=Vs({hammingWindow_:function(e){return ch(e,.54,.46)}});var kh=Vs({hannWindow_:function(e){return ch(e,.5,.5)}});var Ih=Vs({frame_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=0,i=[];for(;s+t<=e.size;)i.push(ec(e,s,t)),s+=n;if(a)for(;s<e.size;){let a=s+t-e.size,o=Jo([ec(e,s,t-a),fc([a],r)]);i.push(o),s+=n}return 0===i.length?Fd([],[0,t]):Xo(Jo(i),[i.length,t])}});var Sh=Vs({stft_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:kh;null==a&&(a=oh(t));let s=Ih(e,t,n),i=bo(s,r(t));return Td(i,a)}});var Nh=Vs({cropAndResize_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=Bs(e,"image","cropAndResize"),o=Bs(t,"boxes","cropAndResize","float32"),c=Bs(n,"boxInd","cropAndResize","int32"),l=o.shape[0];Q(4===i.rank,()=>"Error in cropAndResize: image must be rank 4,but got rank ".concat(i.rank,".")),Q(2===o.rank&&4===o.shape[1],()=>"Error in cropAndResize: boxes must be have size [".concat(l,",4] but had shape ").concat(o.shape,".")),Q(1===c.rank&&c.shape[0]===l,()=>"Error in cropAndResize: boxInd must be have size [".concat(l,"] but had shape ").concat(o.shape,".")),Q(2===a.length,()=>"Error in cropAndResize: cropSize must be of length 2, but got length ".concat(a.length,".")),Q(a[0]>=1&&a[1]>=1,()=>"cropSize must be atleast [1,1], but was ".concat(a)),Q("bilinear"===r||"nearest"===r,()=>"method must be bilinear or nearest, but was ".concat(r));let u={image:i,boxes:o,boxInd:c},d={method:r,extrapolationValue:s,cropSize:a};return _s.runKernel(Dt,u,d)}});var Th=Vs({flipLeftRight_:function(e){let t=Bs(e,"image","flipLeftRight","float32");Q(4===t.rank,()=>"Error in flipLeftRight: image must be rank 4,but got rank ".concat(t.rank,"."));let n={image:t};return _s.runKernel(tn,n,{})}});var Oh=Vs({grayscaleToRGB_:function(e){let t=Bs(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];Q(t.rank>=2,()=>"Error in grayscaleToRGB: images must be at least rank 2, but got rank ".concat(t.rank,".")),Q(1===a,()=>"Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ".concat(a,"."));let r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,gl(t,r)}});var Ch=Vs({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=Bs(e,"image","rotateWithOffset","float32");Q(4===r.rank,()=>"Error in rotateWithOffset: image must be rank 4,but got rank ".concat(r.rank,"."));let s={image:r},i={radians:t,fillValue:n,center:a};return _s.runKernel(cr,s,i)}});function Eh(e,t,n,a,r,s){null==a&&(a=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==s&&(s=0);let i=e.shape[0];return n=Math.min(n,i),Q(0<=a&&a<=1,()=>"iouThreshold must be in [0, 1], but was '".concat(a,"'")),Q(2===e.rank,()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'")),Q(4===e.shape[1],()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1])),Q(1===t.rank,()=>"scores must be a 1D tensor"),Q(t.shape[0]===i,()=>"scores has incompatible shape with boxes. Expected ".concat(i,", but was ").concat(t.shape[0])),Q(0<=s&&s<=1,()=>"softNmsSigma must be in [0, 1], but was '".concat(s,"'")),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s}}var _h=Vs({nonMaxSuppression_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=Bs(e,"boxes","nonMaxSuppression","float32"),i=Bs(t,"scores","nonMaxSuppression","float32"),o=Eh(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let c={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return _s.runKernel(Kn,{boxes:s,scores:i},c)}});function Ah(e,t,n){let a=function(e,t,n){return function(e,t,n){let a=0,r=e.length,s=0,i=!1;for(;a<r;){s=a+(r-a>>>1);let o=n(t,e[s]);o>0?a=s+1:(r=s,i=!o)}return i?a:-a-1}(e,t,n||Rh)}(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function Rh(e,t){return e>t?1:e<t?-1:0}function Dh(e,t,n,a,r){return jh(e,t,n,a,r,0)}function Fh(e,t,n,a,r,s){return jh(e,t,n,a,r,0,!1,s,!0)}function Mh(e,t,n,a,r,s){return jh(e,t,n,a,r,s,!0)}function jh(e,t,n,a,r,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8],l=[];for(let g=0;g<t.length;g++)t[g]>r&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(Ph);let u=s>0?-.5/s:0,d=[],h=[];for(;d.length<n&&l.length>0;){let t=l.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=t;if(n<r)break;let o=!1;for(let c=d.length-1;c>=i;--c){let n=zh(e,s,d[c]);if(n>=a){o=!0;break}if(t.score=t.score*Lh(a,u,n),t.score<=r)break}t.suppressBeginIndex=d.length,o||(t.score===n?(d.push(s),h.push(t.score)):t.score>r&&Ah(l,t,Ph))}let p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));let m={selectedIndices:d};return i&&(m.selectedScores=h),c&&(m.validOutputs=p),m}function zh(e,t,n){let a=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),s=Math.min(a[0],a[2]),i=Math.min(a[1],a[3]),o=Math.max(a[0],a[2]),c=Math.max(a[1],a[3]),l=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),p=(o-s)*(c-i),f=(d-l)*(h-u);if(p<=0||f<=0)return 0;let m=Math.max(s,l),g=Math.max(i,u),b=Math.min(o,d),y=Math.min(c,h),v=Math.max(b-m,0)*Math.max(y-g,0);return v/(p+f-v)}function Lh(e,t,n){let a=Math.exp(t*n*n);return n<=e?a:0}function Ph(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}var Bh=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=Bs(e,"boxes","nonMaxSuppressionAsync"),i=Bs(t,"scores","nonMaxSuppressionAsync"),o=Eh(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let c=await Promise.all([s.data(),i.data()]),l=c[0],u=c[1],{selectedIndices:d}=Dh(l,u,n,a,r);return s!==e&&s.dispose(),i!==t&&i.dispose(),Dd(d,"int32")};var Wh=Vs({nonMaxSuppressionWithScore_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=Bs(e,"boxes","nonMaxSuppression"),o=Bs(t,"scores","nonMaxSuppression"),c=Eh(i,o,n,a,r,s);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,s=c.softNmsSigma;let l={boxes:i,scores:o},u={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s},d=_s.runKernel(Zn,l,u);return{selectedIndices:d[0],selectedScores:d[1]}}});var Uh=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=Bs(e,"boxes","nonMaxSuppressionAsync"),o=Bs(t,"scores","nonMaxSuppressionAsync"),c=Eh(i,o,n,a,r,s);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,s=c.softNmsSigma;let l=await Promise.all([i.data(),o.data()]),u=l[0],d=l[1],{selectedIndices:h,selectedScores:p}=Mh(u,d,n,a,r,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Dd(h,"int32"),selectedScores:Dd(p)}};var Vh=Vs({nonMaxSuppressionPadded_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=Bs(e,"boxes","nonMaxSuppression"),o=Bs(t,"scores","nonMaxSuppression"),c=Eh(i,o,n,a,r,null),l=c.maxOutputSize,u=c.iouThreshold,d=c.scoreThreshold,h={boxes:i,scores:o},p={maxOutputSize:l,iouThreshold:u,scoreThreshold:d,padToMaxOutputSize:s},f=_s.runKernel(Xn,h,p);return{selectedIndices:f[0],validOutputs:f[1]}}});var Gh=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=Bs(e,"boxes","nonMaxSuppressionAsync"),o=Bs(t,"scores","nonMaxSuppressionAsync"),c=Eh(i,o,n,a,r,null),l=c.maxOutputSize,u=c.iouThreshold,d=c.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=Fh(h,p,l,u,d,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Dd(f,"int32"),validOutputs:il(m,"int32")}};var Hh=Vs({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=Bs(e,"images","resizeBilinear");Q(3===r.rank||4===r.rank,()=>"Error in resizeBilinear: x must be rank 3 or 4, but got rank ".concat(r.rank,".")),Q(2===t.length,()=>"Error in resizeBilinear: new shape must 2D, but got shape ".concat(t,".")),Q(!1===a||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=r,i=!1;3===r.rank&&(i=!0,s=Xo(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let[]=t,o={images:s},c={alignCorners:n,halfPixelCenters:a,size:t},l=_s.runKernel(fa,o,c);return i?Xo(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});var qh=Vs({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=Bs(e,"images","resizeNearestNeighbor");Q(3===r.rank||4===r.rank,()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ".concat(r.rank,".")),Q(2===t.length,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape ".concat(t,".")),Q("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype"),Q(!1===a||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=r,i=!1;3===r.rank&&(i=!0,s=Xo(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let[]=t,o={images:s},c={alignCorners:n,halfPixelCenters:a,size:t},l=_s.runKernel(ha,o,c);return i?Xo(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});function Kh(e,t){let n,a,r,s,i,o,c=Dd([-1]),l=Dd([0]),u=Dd([0]);for(let d=0;d<e.size-1;d++){n=ec(e,0,d+1),a=ec(e,d+1),i=go(ll(n),t),o=go(ll(a),t);let h=ll(bo(n,$u(0,n.size)));r=go(h,ll(n));let p=fc(a.shape,n.size),f=fo($u(0,a.size),p),m=bo(a,f);s=go(ll(m),ll(a));let g=Vl(r,s),b=Vl(r,s),y=bo(i,o);u=bo(bo(y,g),b);let v=xl(u,l);l=Wc(v,u,l),c=Wc(v,Dd([d]),c)}return c}var Xh=Vs({threshold_:function(e){let t,n,a,r,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,c=Bs(e,"image","threshold"),l=.2989,u=.587,d=.114,h=c.shape[0]*c.shape[1],p=bo(Dd([o]),255);if(Q(3===c.rank,()=>"Error in threshold: image must be rank 3,but got rank ".concat(c.rank,".")),Q(3===c.shape[2]||1===c.shape[2],()=>"Error in threshold: image color channel must be equal to 3 or 1but got ".concat(c.shape[2],".")),Q("int32"===c.dtype||"float32"===c.dtype,()=>"Error in dtype: image dtype must be int32 or float32,but got dtype ".concat(c.dtype,".")),Q("otsu"===s||"binary"===s,()=>"Method must be binary or otsu, but was ".concat(s)),3===c.shape[2]){[t,n,a]=Nd(c,[1,1,1],-1);let e=bo(t,l),s=bo(n,u),i=bo(a,d);r=fo(fo(e,s),i)}else r=e;if("otsu"===s){p=Kh(lc(Vi(ld(r),"int32"),qs([]),256),h)}let f=i?Cl(r,p):xl(r,p);return Vi(bo(f,255),"int32")}});var Zh=Vs({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0,i=Bs(e,"image","transform","float32"),o=Bs(t,"transforms","transform","float32");Q(4===i.rank,()=>"Error in transform: image must be rank 4,but got rank ".concat(i.rank,".")),Q(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Q(null==s||2===s.length,()=>"Error in transform: outputShape must be [height, width] or null, but got ".concat(s,"."));let c={image:i,transforms:o},l={interpolation:n,fillMode:a,fillValue:r,outputShape:s};return _s.runKernel($a,c,l)}});var Yh=Vs({bandPart_:function(e,t,n){let a=Bs(e,"a","bandPart");Q(a.rank>=2,()=>"bandPart(): Rank must be at least 2, got ".concat(a.rank,"."));let r,s,i=a.shape,[o,c]=a.shape.slice(-2);"number"==typeof t?(Q(t%1===0,()=>"bandPart(): numLower must be an integer, got ".concat(t,".")),Q(t<=o,()=>"bandPart(): numLower (".concat(t,") must not be greater than the number of rows (").concat(o,").")),r=Bs(t<0?o:t,"numLower","bandPart")):(Q("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),r=Wc(Ol(t,0),o,ou(t,o))),"number"==typeof n?(Q(n%1===0,()=>"bandPart(): numUpper must be an integer, got ".concat(n,".")),Q(n<=c,()=>"bandPart(): numUpper (".concat(n,") must not be greater than the number of columns (").concat(c,").")),s=Bs(n<0?c:n,"numUpper","bandPart")):(Q("int32"===n.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),s=Wc(Ol(n,0),c,ou(n,c)));let l=Xo($u(0,o,1,"int32"),[-1,1]),u=$u(0,c,1,"int32"),d=Vl(l,u),h=ql(Cl(d,r),wl(d,Bl(s))),p=ru([o,c],a.dtype);return Xo(Ed(Xd(Xo(a,[-1,o,c])).map(e=>Wc(h,e,p))),i)}});var Jh=Vs({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Q(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let n=e[0].shape[0];for(let t=1;t<e.length;++t)Q(e[t].shape[0]===n,()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: (".concat(e[t].shape[0]," vs. ").concat(n,")"))}else t=!0,e=Nd(e,e.shape[0],0).map(e=>Cd(e,[0]));Q(e.length<=e[0].shape[0],()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds number of dimensions (").concat(e[0].shape[0],")."));let n=[],a=e;for(let r=0;r<e.length;++r)n.push(_s.tidy(()=>{let e=a[r];if(r>0)for(let t=0;t<r;++t){let a=bo(ll(bo(n[t],e)),n[t]);e=Vl(e,a)}return go(e,dl(e,"euclidean"))}));return t?Ed(n,0):n}});function Qh(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return _s.tidy(()=>{Q(2===e.shape.length,()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor."));let n=e.shape[0],a=e.shape[1],r=bl(n),s=Gi(e),i=Fd([[1]],[1,1]),o=Gi(i),c=n>=a?a:n;for(let e=0;e<c;++e){let t=s,c=o,l=r;[o,s,r]=_s.tidy(()=>{let t=ec(s,[e,e],[n-e,1]),c=dl(t),l=ec(s,[e,e],[1,1]),u=Wc(xl(l,0),Fd([[-1]]),Fd([[1]])),d=Vl(l,bo(u,c)),h=go(t,d);o=1===h.shape[0]?Gi(i):Jo([i,ec(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);let p=Bl(go(Qo(u,d),c)),f=ec(s,[e,0],[n-e,a]),m=bo(p,o),g=eh(o);if(0===e)s=Vl(f,Qo(m,Qo(g,f)));else{let t=Vl(f,Qo(m,Qo(g,f)));s=Jo([ec(s,[0,0],[e,a]),t],0)}let b=eh(m),y=ec(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=Vl(y,Qo(Qo(y,o),b));else{let t=Vl(y,Qo(Qo(y,o),b));r=Jo([ec(r,[0,0],[n,e]),t],1)}return[o,s,r]}),to([t,c,l])}return!t&&n>a&&(r=ec(r,[0,0],[n,a]),s=ec(s,[0,0],[a,a])),[r,s]})}var $h,ep=Vs({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Q(e.rank>=2,()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank)),2===e.rank)return Qh(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),a=Xd(Xo(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];return a.forEach(e=>{let[n,a]=Qh(e,t);r.push(n),s.push(a)}),[Xo(Ed(r,0),e.shape),Xo(Ed(s,0),e.shape)]}}});!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}($h||($h={}));var tp=Vs({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:$h.SUM_BY_NONZERO_WEIGHTS,a=Bs(e,"losses","computeWeightedLoss"),r=null;null!=t&&(r=Bs(t,"weights","computeWeightedLoss"));let s=null==r?a:bo(a,r);if(n===$h.NONE)return s;if(n===$h.SUM)return ll(s);if(n===$h.MEAN){if(null==r)return au(s);{let e=a.size/r.size,t=go(ll(s),ll(r));return e>1?go(t,il(e)):t}}if(n===$h.SUM_BY_NONZERO_WEIGHTS){if(null==r)return go(ll(s),il(a.size));{let e=bo(r,su(a.shape)),t=Vi(ll(pu(e,il(0))),"float32");return go(ll(s),t)}}throw Error("Unknown reduction: ".concat(n))}});var np=Vs({absoluteDifference_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:$h.SUM_BY_NONZERO_WEIGHTS,r=Bs(e,"labels","absoluteDifference"),s=Bs(t,"predictions","absoluteDifference"),i=null;null!=n&&(i=Bs(n,"weights","absoluteDifference")),$(r.shape,s.shape,"Error in absoluteDifference: ");let o=yo(Vl(r,s));return tp(o,i,a)}});var ap=Vs({cosineDistance_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:$h.SUM_BY_NONZERO_WEIGHTS,s=Bs(e,"labels","cosineDistance"),i=Bs(t,"predictions","cosineDistance"),o=null;null!=a&&(o=Bs(a,"weights","cosineDistance")),$(s.shape,i.shape,"Error in cosineDistance: ");let c=il(1),l=Vl(c,ll(bo(s,i),n,!0));return tp(l,o,r)}});var rp=Vs({hingeLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:$h.SUM_BY_NONZERO_WEIGHTS,r=Bs(e,"labels","hingeLoss"),s=Bs(t,"predictions","hingeLoss"),i=null;null!=n&&(i=Bs(n,"weights","hingeLoss")),$(r.shape,s.shape,"Error in hingeLoss: ");let o=il(1);r=Vl(bo(il(2),r),o);let c=nd(Vl(o,bo(r,s)));return tp(c,i,a)}});var sp=Vs({huberLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:$h.SUM_BY_NONZERO_WEIGHTS,s=Bs(e,"labels","huberLoss"),i=Bs(t,"predictions","huberLoss"),o=null;null!=n&&(o=Bs(n,"weights","huberLoss")),$(s.shape,i.shape,"Error in huberLoss: ");let c=il(a),l=yo(Vl(i,s)),u=ou(l,c),d=Vl(l,u),h=fo(bo(il(.5),cl(u)),bo(c,d));return tp(h,o,r)}});var ip=Vs({logLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:$h.SUM_BY_NONZERO_WEIGHTS,s=Bs(e,"labels","logLoss"),i=Bs(t,"predictions","logLoss"),o=null;null!=n&&(o=Bs(n,"weights","logLoss")),$(s.shape,i.shape,"Error in logLoss: ");let c=il(1),l=il(a),u=Bl(bo(s,Al(fo(i,l)))),d=bo(Vl(c,s),Al(fo(Vl(c,i),l))),h=Vl(u,d);return tp(h,o,r)}});var op=Vs({meanSquaredError_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:$h.SUM_BY_NONZERO_WEIGHTS,r=Bs(e,"labels","meanSquaredError"),s=Bs(t,"predictions","meanSquaredError"),i=null;null!=n&&(i=Bs(n,"weights","meanSquaredError")),$(r.shape,s.shape,"Error in meanSquaredError: ");let o=Od(r,s);return tp(o,i,a)}});function cp(e,t){let n=Bs(e,"labels","sigmoidCrossEntropyWithLogits"),a=Bs(t,"logits","sigmoidCrossEntropyWithLogits");$(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");let r=nd(a),s=bo(a,n),i=Rl(pl(Bl(yo(a))));return fo(Vl(r,s),i)}var lp=Vs({sigmoidCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:$h.SUM_BY_NONZERO_WEIGHTS,s=Bs(e,"multiClassLabels","sigmoidCrossEntropy"),i=Bs(t,"logits","sigmoidCrossEntropy"),o=null;if(null!=n&&(o=Bs(n,"weights","sigmoidCrossEntropy")),$(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),a>0){let e=il(a),t=il(1),n=il(.5);s=fo(bo(s,Vl(t,e)),bo(n,e))}let c=cp(s,i);return tp(c,o,r)}});function up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ".concat(t.rank," and dim was ").concat(n));return Ll((e,t,a)=>{let r=Hl(t,[n],!0),s=Vl(Vi(t,"float32"),r);a([e,s]);let i=Bl(bo(s,e));return{value:ll(i,[n]),gradFunc:(e,t)=>{let[a,r]=t,s=Qc(e.shape,[n]);return[bo(Xo(e,s),Vl(Vi(a,"float32"),pl(r))),bo(Xo(e,s),Vl(pl(r),Vi(a,"float32")))]}}})(e,t)}var dp=Vs({softmaxCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:$h.SUM_BY_NONZERO_WEIGHTS,s=Bs(e,"onehotLabels","softmaxCrossEntropy"),i=Bs(t,"logits","softmaxCrossEntropy"),o=null;if(null!=n&&(o=Bs(n,"weights","softmaxCrossEntropy")),$(s.shape,i.shape,"Error in softmaxCrossEntropy: "),a>0){let e=il(a),t=il(1),n=il(s.shape[1]);s=fo(bo(s,Vl(t,e)),go(e,n))}let c=up(s,i);return tp(c,o,r)}});var hp=Vs({sparseFillEmptyRows_:function(e,t,n,a){let r=Bs(e,"indices","sparseFillEmptyRows","int32"),s=Bs(t,"values","sparseFillEmptyRows"),i=Bs(n,"denseShape","sparseFillEmptyRows","int32"),o=Bs(a,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==r.rank)throw new Error("Indices should be Tensor2D but received shape\n        ".concat(r.shape));if(1!==s.rank)throw new Error("Values should be Tensor1D but received shape ".concat(s.shape));if(1!==i.rank)throw new Error("Dense shape should be Tensor1D but received shape ".concat(i.shape));if(0!==o.rank)throw new Error("Default value should be a scalar but received shape ".concat(o.shape));let c={indices:r,values:s,denseShape:i,defaultValue:o},l=_s.runKernel(ja,c);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}});var pp=Vs({sparseReshape_:function(e,t,n){let a=Bs(e,"inputIndices","sparseReshape","int32"),r=Bs(t,"inputShape","sparseReshape","int32"),s=Bs(n,"newShape","sparseReshape","int32");if(2!==a.rank)throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(a.shape));if(1!==r.rank)throw new Error("Input shape should be Tensor1D but received shape ".concat(r.shape));if(1!==s.rank)throw new Error("New shape should be Tensor1D but received shape ".concat(s.shape));let i={inputIndices:a,inputShape:r,newShape:s},o=_s.runKernel(za,i);return{outputIndices:o[0],outputShape:o[1]}}});var fp=Vs({sparseSegmentMean_:function(e,t,n){let a=Bs(e,"data","sparseSegmentMean"),r=Bs(t,"indices","sparseSegmentMean","int32"),s=Bs(n,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error("Indices should be Tensor1D but received shape\n          ".concat(r.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(s.shape));let i={data:a,indices:r,segmentIds:s};return _s.runKernel(La,i)}});var mp=Vs({sparseSegmentSum_:function(e,t,n){let a=Bs(e,"data","sparseSegmentSum"),r=Bs(t,"indices","sparseSegmentSum","int32"),s=Bs(n,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error("Indices should be Tensor1D but received shape\n         ".concat(r.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(s.shape));let i={data:a,indices:r,segmentIds:s};return _s.runKernel(Pa,i)}});var gp=Vs({stringNGrams_:function(e,t,n,a,r,s,i,o){let c=Bs(e,"data","stringNGrams","string");if("string"!==c.dtype)throw new Error("Data must be of datatype string");if(1!==c.shape.length)throw new Error("Data must be a vector, saw: ".concat(c.shape));let l=Bs(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");let u={separator:n,nGramWidths:a,leftPad:r,rightPad:s,padWidth:i,preserveShortSequences:o},d={data:c,dataSplits:l},h=_s.runKernel(Ha,d,u);return{nGrams:h[0],nGramsSplits:h[1]}}});var bp=Vs({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],a=Bs(e,"input","stringSplit","string"),r=Bs(t,"delimiter","stringSplit","string");if(1!==a.rank)throw new Error("Input should be Tensor1D but received shape ".concat(a.shape));if(0!==r.rank)throw new Error("Delimiter should be a scalar but received shape ".concat(r.shape));let s={skipEmpty:n},i={input:a,delimiter:r},o=_s.runKernel(qa,i,s);return{indices:o[0],values:o[1],shape:o[2]}}});var yp=Vs({stringToHashBucketFast_:function(e,t){let n=Bs(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let r={input:n};return _s.runKernel(Ka,r,a)}});var vp=Vs({staticRegexReplace_:function(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=Bs(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:a};return _s.runKernel(Va,{x:r},s)}}),xp={fft:kd,ifft:Id,rfft:Td,irfft:Sd},wp={hammingWindow:wh,hannWindow:kh,frame:Ih,stft:Sh},kp={flipLeftRight:Th,grayscaleToRGB:Oh,resizeNearestNeighbor:qh,resizeBilinear:Hh,rotateWithOffset:Ch,cropAndResize:Nh,nonMaxSuppression:_h,nonMaxSuppressionAsync:Bh,nonMaxSuppressionWithScore:Wh,nonMaxSuppressionWithScoreAsync:Uh,nonMaxSuppressionPadded:Vh,nonMaxSuppressionPaddedAsync:Gh,threshold:Xh,transform:Zh},Ip={bandPart:Yh,gramSchmidt:Jh,qr:ep},Sp={absoluteDifference:np,computeWeightedLoss:tp,cosineDistance:ap,hingeLoss:rp,huberLoss:sp,logLoss:ip,meanSquaredError:op,sigmoidCrossEntropy:lp,softmaxCrossEntropy:dp},Np={sparseFillEmptyRows:hp,sparseReshape:pp,sparseSegmentMean:fp,sparseSegmentSum:mp},Tp={stringNGrams:gp,stringSplit:bp,stringToHashBucketFast:yp,staticRegexReplace:vp},Op={};y(Op,{Serializable:()=>Cp,SerializationMap:()=>Ep,registerClass:()=>_p});var Cp=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Ep=class{constructor(){this.classNameMap={}}static getMap(){return null==Ep.instance&&(Ep.instance=new Ep),Ep.instance}static register(e){Ep.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function _p(e){Q(null!=e.className,()=>"Class being registered does not have the static className property defined."),Q("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),Q(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Ep.register(e)}var Ap=class extends Cp{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0,{value:a,grads:r}=this.computeGradients(e,n);if(null!=n){let e=n.map(e=>({name:e.name,tensor:r[e.name]}));this.applyGradients(e)}else this.applyGradients(r);return to(r),t?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return zl(e,t)}dispose(){null!=this.iterations_&&to(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:il(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class ".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Ap,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var Rp=class extends Ap{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=_s.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let a=_s.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:eo(()=>Uc(a).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:eo(()=>Uc(a).variable(!1))});let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let s=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;eo(()=>{let e=fo(bo(s,this.rho),bo(cl(r),1-this.rho)),t=bo(go(ol(fo(i,this.epsilon)),ol(fo(s,this.epsilon))),r),n=fo(bo(i,this.rho),bo(cl(t),1-this.rho));s.assign(e),i.assign(n);let o=fo(bo(t,-this.learningRate),a);a.assign(o)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(to(this.accumulatedGrads.map(e=>e.variable)),to(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){let t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedUpdates=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},Dp=class extends Ap{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let a=_s.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:eo(()=>fc(a.shape,this.initialAccumulatorValue).variable(!1))});let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let s=this.accumulatedGrads[n].variable;eo(()=>{let e=fo(s,cl(r));s.assign(e);let t=fo(bo(go(r,ol(fo(e,_s.backend.epsilon()))),-this.learningRate),a);a.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&to(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},Fp=class extends Ap{static get className(){return"Adam"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],eo(()=>{this.accBeta1=il(t).variable(),this.accBeta2=il(n).variable()}),null==a&&(this.epsilon=_s.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);eo(()=>{let n=Vl(1,this.accBeta1),a=Vl(1,this.accBeta2);t.forEach((t,r)=>{let s=_s.registeredVariables[t];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:eo(()=>Uc(s).variable(!1))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:"".concat(t,"/v"),variable:eo(()=>Uc(s).variable(!1))});let i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;let o=this.accumulatedFirstMoment[r].variable,c=this.accumulatedSecondMoment[r].variable,l=fo(bo(o,this.beta1),bo(i,1-this.beta1)),u=fo(bo(c,this.beta2),bo(cl(i),1-this.beta2)),d=go(l,n),h=go(u,a);o.assign(l),c.assign(u);let p=fo(bo(go(d,fo(ol(h),this.epsilon)),-this.learningRate),s);s.assign(p)}),this.accBeta1.assign(bo(this.accBeta1,this.beta1)),this.accBeta2.assign(bo(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&to(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&to(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),eo(()=>{this.accBeta1.assign(sl(this.beta1,this.iterations_+1)),this.accBeta2.assign(sl(this.beta2,this.iterations_+1))});let t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedSecondMoment=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},Mp=class extends Ap{static get className(){return"Adamax"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],eo(()=>{this.iteration=il(0).variable(),this.accBeta1=il(t).variable()}),null==a&&(this.epsilon=_s.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);eo(()=>{let n=Vl(1,this.accBeta1),a=go(-this.learningRate,fo(bo(this.iteration,this.decay),1));t.forEach((t,r)=>{let s=_s.registeredVariables[t];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:Uc(s).variable(!1)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:"".concat(t,"/v"),variable:Uc(s).variable(!1)});let i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;let o=this.accumulatedFirstMoment[r].variable,c=this.accumulatedWeightedInfNorm[r].variable,l=fo(bo(o,this.beta1),bo(i,1-this.beta1)),u=bo(c,this.beta2),d=yo(i),h=nu(u,d);o.assign(l),c.assign(h);let p=fo(bo(go(a,n),go(l,fo(h,this.epsilon))),s);s.assign(p)}),this.iteration.assign(fo(this.iteration,1)),this.accBeta1.assign(bo(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&to(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&to(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},jp=class extends Ap{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let r=_s.registeredVariables[t];eo(()=>{let e=fo(bo(this.c,a),r);r.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=no(il(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},zp=class extends jp{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=il(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let a=_s.registeredVariables[t];null==this.accumulations[n]&&(this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:eo(()=>Uc(a).variable(!1))});let r=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&eo(()=>{let e,t=fo(bo(this.m,r),s);e=this.useNesterov?fo(bo(this.c,fo(s,bo(t,this.m))),a):fo(bo(this.c,t),a),r.assign(t),a.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&to(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},Lp=class extends Ap{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==a&&(this.epsilon=_s.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let a=_s.registeredVariables[t];null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:eo(()=>Uc(a).variable(!1))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:eo(()=>Uc(a).variable(!1))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:eo(()=>Uc(a).variable(!1))});let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let s=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;eo(()=>{let e=fo(bo(s,this.decay),bo(cl(r),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[n].variable,o=fo(bo(t,this.decay),bo(r,1-this.decay)),c=go(bo(r,this.learningRate),ol(Vl(e,fo(cl(o),this.epsilon)))),l=fo(bo(i,this.momentum),c);s.assign(e),t.assign(o),i.assign(l);let u=Vl(a,l);a.assign(u)}else{let e=fo(bo(s,this.decay),bo(cl(r),1-this.decay)),t=fo(bo(i,this.momentum),go(bo(r,this.learningRate),ol(fo(e,this.epsilon))));s.assign(e),i.assign(t);let n=Vl(a,t);a.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&to(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&to(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&to(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2;this.accumulatedMeanSquares=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedMoments=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},Pp=[Rp,Dp,Fp,Mp,zp,Lp,jp];var Bp={};y(Bp,{CompositeArrayBuffer:()=>Xs,browserFiles:()=>Vp,browserHTTPRequest:()=>Qp,concatenateArrayBuffers:()=>ei,copyModel:()=>Li,decodeWeights:()=>Ys,encodeWeights:()=>Zs,fromMemory:()=>nf,fromMemorySync:()=>af,getLoadHandlers:()=>hi,getModelArtifactsForJSON:()=>ri,getModelArtifactsForJSONSync:()=>ai,getModelArtifactsInfoForJSON:()=>si,getSaveHandlers:()=>di,getWeightSpecs:()=>ii,http:()=>Jp,isHTTPScheme:()=>Zp,listModels:()=>ji,loadWeights:()=>qp,moveModel:()=>Pi,registerLoadRouter:()=>ui,registerSaveRouter:()=>li,removeModel:()=>zi,weightsLoaderFactory:()=>Kp,withSaveHandler:()=>rf,withSaveHandlerSync:()=>sf});function Wp(e){return new Promise(e=>setTimeout(e)).then(e)}var Up=class{constructor(e){if(!Ue().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Up.URL_SCHEME)&&(e=e.slice(Up.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=Xs.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let t=ni(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),r=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(r.download=this.modelJsonFileName,r.href=a,await Wp(()=>r.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Wp(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:si(e)}}}};Up.URL_SCHEME="downloads://";function Vp(e){return new class{constructor(e){if(null==e||e.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received ".concat(e));this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=n=>{let a=JSON.parse(n.target.result),r=a.modelTopology;if(null==r)return void t(new Error("modelTopology field is missing from file ".concat(this.jsonFile.name)));if(null==a.weightsManifest)return void t(new Error("weightManifest field is missing from file ".concat(this.jsonFile.name)));if(0===this.weightsFiles.length)return void e({modelTopology:r});let s=ri(a,e=>this.loadWeights(e));e(s)},n.onerror=e=>t("Failed to read model topology and weights manifest JSON from file '".concat(this.jsonFile.name,"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let a=this.checkManifestAndWeightFiles(e),r=n.map(e=>this.loadWeightsFile(e,a[e]));return Promise.all(r).then(e=>[t,e])}loadWeightsFile(e,t){return new Promise((n,a)=>{let r=new FileReader;r.onload=e=>{let t=e.target.result;n(t)},r.onerror=t=>a("Failed to weights data from file of path '".concat(e,"'.")),r.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(e=>ti(e.name)),a={};for(let r of e)r.paths.forEach(e=>{let r=ti(e);if(-1!==t.indexOf(r))throw new Error("Duplicate file basename found in weights manifest: '".concat(r,"'"));if(t.push(r),-1===n.indexOf(r))throw new Error("Weight file with basename '".concat(r,"' is not provided."));a[e]=this.weightsFiles[n.indexOf(r)]});if(t.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest (".concat(t.length,") and the number of weight files provided (").concat(this.weightsFiles.length,")."));return a}}(e)}function Gp(e,t,n,a){var r;Q(null!=(r=e)&&Array.isArray(r)&&r.length>0,()=>"promises must be a none empty array"),function(e,t){Q(e>=0&&e<=1,()=>"Progress fraction must be in range [0, 1], but got startFraction ".concat(e)),Q(t>=0&&t<=1,()=>"Progress fraction must be in range [0, 1], but got endFraction ".concat(t)),Q(t>=e,()=>"startFraction must be no more than endFraction, but got startFraction ".concat(e," and endFraction ").concat(t))}(n=null==n?0:n,a=null==a?1:a);let s=0;return Promise.all(e.map(r=>(r.then(r=>{let i=n+ ++s/e.length*(a-n);return t(i),r}),r)))}async function Hp(e,t){null==t&&(t={});let n=null==t.fetchFunc?Ue().platform.fetch:t.fetchFunc,a=e.map(e=>n(e,t.requestInit,{isBinary:!0})),r=(null==t.onProgress?await Promise.all(a):await Gp(a,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?await Promise.all(r):await Gp(r,t.onProgress,.5,1)}async function qp(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return Kp(e=>Hp(e,{requestInit:a}))(e,t,n)}function Kp(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",a=arguments.length>2?arguments[2]:void 0,r=t.map(()=>!1),s={},i=null!=a?a.map(()=>!1):[],o=[];if(t.forEach((e,t)=>{let n=0;e.weights.forEach(e=>{let c="quantization"in e?e.quantization.dtype:e.dtype,l=Ks[c]*te(e.shape),u=()=>{r[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=a?a.forEach((t,n)=>{t===e.name&&(u(),i[n]=!0)}):u(),o.push(e.name),n+=l})}),!i.every(e=>e)){let e=a.filter((e,t)=>!i[t]);throw new Error("Could not find weights in manifest with names: ".concat(e.join(", "),". \nManifest JSON has weights with names: ").concat(o.join(", "),"."))}let c=r.reduce((e,t,n)=>(t&&e.push(n),e),[]),l=[];c.forEach(e=>{t[e].paths.forEach(e=>{let t=n+(n.endsWith("/")?"":"/")+e;l.push(t)})});let u=await e(l),d={},h=0;return c.forEach(e=>{let n=t[e].paths.length,a=new Xs(u.slice(h,h+n));s[e].forEach(e=>{let t=Ys(a.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(let n in t)d[n]=t[n]}),h+=n}),d}}ci.registerSaveRouter(e=>Ue().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Up.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new Up(e)}(e.slice(Up.URL_SCHEME.length)):null);var Xp=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Q("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Ue().platform.fetch,Q(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Q(2===e.length,()=>"URL paths for http must have a length of 2, (actual length is ".concat(e.length,").")),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=ni(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){let n=Xs.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}let a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:si(e),responses:[a]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status ".concat(a.status,"."))}async load(){let e,t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error("Request to ".concat(this.path," failed with status code ").concat(t.status,". Please verify this URL points to the model JSON of the model to load."));try{e=await t.json()}catch(uY){let t="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}let n=e.modelTopology,a=e.weightsManifest;if(null==n&&null==a)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model topology or manifest for weights."));return ri(e,e=>this.loadWeights(e))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=function(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}(t),r=this.weightPathPrefix||n,s=ii(e),i=[],o=[];for(let c of e)for(let e of c.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(e)):i.push(r+e+a);return this.weightUrlConverter&&i.push(...await Promise.all(o)),[s,await Hp(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})]}};function Zp(e){return null!=e.match(Xp.URL_SCHEME_REGEX)}Xp.URL_SCHEME_REGEX=/^https?:\/\//;var Yp=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>Zp(e)):Zp(e),n)return Jp(e,t)}return null};function Jp(e,t){return new Xp(e,t)}function Qp(e,t){return Jp(e,t)}ci.registerSaveRouter(Yp),ci.registerLoadRouter(Yp);var $p=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},ef=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},tf=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function nf(e,t,n,a){let r=arguments;return new tf(af(...r))}function af(e,t,n,a){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new $p(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new $p({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new $p({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a}))}function rf(e){return new ef(e)}function sf(e){return new ef(e)}var of={};y(of,{confusionMatrix:()=>cf});var cf=Vs({confusionMatrix_:function(e,t,n){let a=Bs(e,"labels","confusionMatrix"),r=Bs(t,"predictions","confusionMatrix");Q(null==n||n>0&&Number.isInteger(n),()=>"If provided, numClasses must be a positive integer, but got ".concat(n)),Q(1===a.rank,()=>"Expected the rank of labels to be 1, but got ".concat(a.rank)),Q(1===r.rank,()=>"Expected the rank of predictions to be 1, but got ".concat(r.rank)),Q(a.shape[0]===r.shape[0],()=>"Mismatch in the number of examples: ".concat(a.shape[0]," vs. ").concat(r.shape[0],". Labels and predictions should have the same number of elements.")),Q(n>0&&Number.isInteger(n),()=>"numClasses is required to be a positive integer, but got ".concat(n));let s=fu(Vi(a,"int32"),n),i=fu(Vi(r,"int32"),n),o=eh(s),c=Qo(o,i);return Vi(c,"int32")}}),lf={};y(lf,{draw:()=>bf,fromPixels:()=>yf,fromPixelsAsync:()=>ff,toPixels:()=>gf});var uf,df=!1;function hf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)a=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)r=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ".concat(e.constructor.name));o=!0}if(null!=gr(or,_s.backendName)){let n={pixels:e},a={numChannels:t};return _s.runKernel(or,n,a)}let c,l,[u,d]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(i)c=e.getContext("2d").getImageData(0,0,u,d).data;else if(a||n)c=e.data;else if(s||r||o){if(null==uf)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");uf=new OffscreenCanvas(1,1).getContext("2d")}else uf=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});uf.canvas.width=u,uf.canvas.height=d,uf.drawImage(e,0,0,u,d),c=uf.getImageData(0,0,u,d).data}if(4===t)l=new Int32Array(c);else{let e=u*d;l=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)l[n*t+e]=c[4*n+e]}return Md(l,[d,u,t],"int32")}function pf(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function ff(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3,n=null;if(Ue().getBool("WRAP_TO_IMAGEBITMAP")&&pf(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(uY){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return hf(n,t)}function mf(e){if(2!==e.rank&&3!==e.rank)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank ".concat(e.rank,"."));let t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error("toPixels only supports depth of size 1, 3 or 4 but got ".concat(t));if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error("Unsupported type for toPixels: ".concat(e.dtype,". Please use float32 or int32 tensors."))}async function gf(e,t){let n=Bs(e,"img","toPixels");if(!(e instanceof os)){let e=n;n=Vi(e,"int32"),e.dispose()}mf(n);let[a,r]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,c=new Uint8ClampedArray(r*a*4);for(let l=0;l<a*r;++l){let e=[0,0,0,255];for(let a=0;a<s;a++){let t=i[l*s+a];if("float32"===n.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===n.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ".concat(t,"."));1===s?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[a]=t*o}let t=4*l;c[t+0]=Math.round(e[0]),c[t+1]=Math.round(e[1]),c[t+2]=Math.round(e[2]),c[t+3]=Math.round(e[3])}if(null!=t){df||(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),df=!0),t.width=r,t.height=a;let e=t.getContext("2d"),n=new ImageData(c,r,a);e.putImageData(n,0,0)}return n!==e&&n.dispose(),c}function bf(e,t,n){let a=Bs(e,"img","draw");if(!(e instanceof os)){let e=a;a=Vi(e,"int32"),e.dispose()}mf(a),function(e){let t=(null==e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error("Alpha value ".concat(t," is suppoed to be in range [0 - 1]."))}(null==n?void 0:n.imageOptions);let r={image:a},s={canvas:t,options:n};_s.runKernel(Vt,r,s)}var yf=Vs({fromPixels_:hf}),vf={};function xf(e,t){let n=e.shape.length,a=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was ".concat(n,"."));if(a<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ".concat(a,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was ".concat(t.dtype,"."));if(t.shape[a-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: ".concat(t.shape[a-1]," vs. ").concat(n));if(0===te(e.shape))throw new Error("Requested more than 0 entries, but input is empty. Input shape: ".concat(e.shape,"."));let r=t.shape,s=r[r.length-1],i=1;for(let d=0;d<r.length-1;++d)i*=r[d];let o=e.shape,c=r.slice();c.pop();let l=1;for(let d=s;d<n;++d)l*=o[d],c.push(o[d]);let u=[...Oe(e.shape).map(e=>e/l),1].slice(0,s);return[c,i,l,u]}y(vf,{prepareAndValidate:()=>xf});var wf={};y(wf,{assertParamsValid:()=>kf,computeFlatOffset:()=>Mf,computeOutShape:()=>Sf,getNormalizedAxes:()=>Cf,isSliceContinous:()=>Ff,maskToAxes:()=>If,parseSliceParams:()=>jf,sliceInfo:()=>zf,startForAxis:()=>Rf,startIndicesWithElidedDims:()=>Ef,stopForAxis:()=>Df,stopIndicesWithElidedDims:()=>_f,stridesForAxis:()=>Af,stridesWithElidedDims:()=>Nf});function kf(e,t,n){let a=e.shape.length;Q(a===t.length,()=>"Error in slice".concat(a,"D: Length of begin ").concat(t," must match the rank of the array (").concat(a,").")),Q(a===n.length,()=>"Error in slice".concat(a,"D: Length of size ").concat(n," must match the rank of the array (").concat(a,")."));for(let r=0;r<a;++r)Q(t[r]+n[r]<=e.shape[r],()=>"Error in slice".concat(a,"D: begin[").concat(r,"] + size[").concat(r,"] (").concat(t[r]+n[r],") would overflow input.shape[").concat(r,"] (").concat(e.shape[r],")"))}function If(e){let t=[],n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function Sf(e,t,n){let a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function Nf(e,t,n,a){let r=[...e];for(let s=r.length;s<a.length;s++)r.push(1);for(let s=0;s<n;s++)0===s?r[t]=1:(r.splice(t,0,1),r.pop());return r}function Tf(e,t,n){return n<=e?n:n-(t-1)}function Of(e,t){let n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function Cf(e,t,n,a,r,s,i,o,c){let l=e.length,u=new Array(l),d=new Array(l),h=new Array(l);if(t.length&&n>0){let c=t[0],l=n+1;u=Ef(i,c,l,a,e),d=_f(o,c,l,r,e),h=Nf(s,c,l,e)}else for(let p=0;p<l;p++)u[p]=Rf(i,a,s,e,p,c),d[p]=Df(o,r,s,e,p,c),h[p]=Af(s,p,c);return{begin:u,end:d,strides:h}}function Ef(e,t,n,a,r){let s=[...r],i=Of(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let r=Tf(t,n,o),i=a[r];e&1<<r&&(i=0),s[o]=i}return s}function _f(e,t,n,a,r){let s=[...r],i=Of(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let r=Tf(t,n,o),i=a[r];e&1<<r&&(i=Number.MAX_SAFE_INTEGER),s[o]=i}for(let o=0;o<s.length;o++){let e=r[o];s[o]<0&&(s[o]+=e),s[o]=q(0,s[o],r[o])}return s}function Af(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function Rf(e,t,n,a,r,s){let i=t[r],o=n[r]||1;(e&1<<r||s&1<<r||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let c=a[r];return i<0&&(i+=c),i=q(0,i,c-1),i}function Df(e,t,n,a,r,s){let i=t[r],o=n[r]||1;(e&1<<r||s&1<<r||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let c=a[r];return i<0&&(i+=c),i=o>0?q(0,i,c):q(-1,i,c-1),i}function Ff(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function Mf(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function jf(e,t,n){let a,r,s=e.shape.length;return a="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),a.forEach(e=>{Q(-1!==e,()=>"slice() does not support negative begin indexing.")}),r=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,r=r.map((t,n)=>t>=0?t:(Q(-1===t,()=>"Negative size values should be exactly -1 but got ".concat(t," for the slice() size at index ").concat(n,".")),e.shape[n]-a[n])),[a,r]}function zf(e,t,n,a,r,s,i,o,c){let l;if(null==a?(l=new Array(t.length),l.fill(1)):l=a,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1,d={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:c};for(let y=0;y<d.dims;y++)u&&1<<y&o&&d.numAddAxisAfterEllipsis++,1<<y&i&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);let h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){let r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input has only ").concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[a]),null!=e.end&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}(d,h);let p=!0,f=!0,m=!0,g=[],b=[];for(let y=0;y<e.length;++y){if(0===h.strides[y])throw Error("strides[".concat(y,"] must be non-zero"));let t=!!(h.shrinkAxisMask&1<<y),n=e[y];if(-1===n){g.push(t?1:-1);continue}let a=[h.beginMask&1<<y,h.endMask&1<<y],r=[h.strides[y]>0?0:-1,h.strides[y]>0?n:n-1];if(t&&h.strides[y]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[y];let s=!!(h.beginMask&1<<y&&h.endMask&1<<y);if(h.beginValid&&h.endValid){if(t){let e=h.begin[y]<0?n+h.begin[y]:h.begin[y];if(h.begin[y]=e,h.end[y]=h.begin[y]+1,e<0||e>=n)throw Error("slice index ".concat(h.begin[y]," of dimension ").concat(y," out of bounds."))}else h.begin[y]=Lf(h.begin[y],0,h.strides[y],n,a,r),h.end[y]=Lf(h.end[y],1,h.strides[y],n,a,r);let e=1===h.strides[y]&&0===h.begin[y]&&h.end[y]===n;p=p&&e,f=f&&(0===y&&1===h.strides[y]||e)}else p=p&&1===h.strides[y]&&s,f=f&&(0===y&&1===h.strides[y]||s);let i,o=!1;if(h.beginValid&&h.endValid?(i=h.end[y]-h.begin[y],o=!0):t?(i=1,o=!0):s&&n>=0&&(i=h.strides[y]<0?-n:n,o=!0),o){let e;e=0===i||i<0!=h.strides[y]<0?0:Math.trunc(i/h.strides[y])+(i%h.strides[y]!==0?1:0),g.push(e)}else g.push(-1)}for(let y=0;y<h.finalShapeGatherIndices.length;++y){let e=h.finalShapeGatherIndices[y];e>=0?b.push(g[e]):-2===e&&b.push(1)}return{finalShapeSparse:b.filter((e,t)=>-2!==h.finalShapeGatherIndices[t]),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function Lf(e,t,n,a,r,s){if(r[t])return n>0?s[t]:s[t+1&1];{let t=e<0?a+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}var Pf="4.7.0",Bf=class{static sgd(e){return new jp(e)}static momentum(e,t){return new zp(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new Lp(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new Fp(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new Rp(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new Mp(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new Dp(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},Wf=Bf,Uf="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof o?o:e=>e();function Vf(){return new Promise(e=>Uf(()=>e()))}var Gf,Hf={};function qf(e,t){let n=e[0].length;e.forEach((e,t)=>{Q(e.length===n,()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same as the rank of the rest (").concat(n,")"))}),Q(t>=0&&t<n,()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,"."));let a=e[0];e.forEach((e,r)=>{for(let s=0;s<n;s++)Q(s===t||e[s]===a[s],()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(r,"] (").concat(e,") does not match the shape of the rest (").concat(a,") along the non-concatenated axis ").concat(r,"."))})}function Kf(e,t){let n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}function Xf(e,t,n){let a=new Array;if(null==n&&null==t)return a;if(null==t)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(null==n)return a;if(e+n.length!==a.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(a.length));for(let r=1;r<n.length;++r){let s=n[r],i=a[a.length-n.length+r],o=a[i];if(s>=0)if(o>=0){if(o!==s)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(r+e,"] = ").concat(s," but shape[").concat(r+e,"] = ").concat(o))}else a[i]=s}return a}function Zf(e){let t={FIRST_DIM_SIZE:Gf.FIRST_DIM_SIZE,VALUE_ROWIDS:Gf.VALUE_ROWIDS,ROW_LENGTHS:Gf.ROW_LENGTHS,ROW_SPLITS:Gf.ROW_SPLITS,ROW_LIMITS:Gf.ROW_LIMITS,ROW_STARTS:Gf.ROW_STARTS},n=[];for(let a of e){if(!(a in t))break;n.push(t[a])}return n}function Yf(e){return 0===e.length?0:e[0]===Gf.FIRST_DIM_SIZE?e.length-1:e.length}function Jf(e,t){if(null==e||null==t)return;let n=e.length,a=t.length;if(n>=a)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(a,")"));for(let r=0;r<Math.min(n,a-1);++r){let n=e[r],a=t[r+1];if(n>=0&&a>=0&&1!==n&&n!==a)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(r-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(r-e.length,"] = ").concat(a))}}y(Hf,{ERF_A1:()=>lm,ERF_A2:()=>um,ERF_A3:()=>dm,ERF_A4:()=>hm,ERF_A5:()=>pm,ERF_P:()=>cm,PARALLELIZE_THRESHOLD:()=>Qf,RowPartitionType:()=>Gf,SELU_SCALE:()=>om,SELU_SCALEALPHA:()=>im,applyActivation:()=>fh,assertAndGetBroadcastShape:()=>Pc,assertAxesAreInnerMostDims:()=>$c,assertParamsConsistent:()=>qf,assignToTypedArray:()=>vm,axesAreInnerMostDims:()=>Zc,calculateShapes:()=>Ud,checkEinsumDimSizes:()=>Nm,checkPadOnDimRoundingMode:()=>Ko,combineLocations:()=>Yc,combineRaggedTensorToTensorShapes:()=>Xf,complexWithEvenIndex:()=>gm,complexWithOddIndex:()=>bm,computeConv2DInfo:()=>Fo,computeConv3DInfo:()=>Mo,computeDefaultPad:()=>jo,computeDilation2DInfo:()=>Ao,computeOptimalWindowSize:()=>$f,computeOutAndReduceShapes:()=>Jc,computeOutShape:()=>Kf,computePool2DInfo:()=>Ro,computePool3DInfo:()=>Do,convertConv2DDataFormat:()=>qo,decodeEinsumEquation:()=>Im,eitherStridesOrDilationsAreOne:()=>Go,expandShapeToKeepDim:()=>Qc,exponent:()=>wm,exponents:()=>xm,fromStringArrayToUint8:()=>Km,fromUint8ToStringArray:()=>qm,getAxesPermutation:()=>el,getBroadcastDims:()=>zc,getComplexWithIndex:()=>ym,getEinsumComputePath:()=>Tm,getEinsumPermutation:()=>Sm,getFusedBiasGradient:()=>ph,getFusedDyActivation:()=>hh,getImageCenter:()=>em,getInnerMostAxes:()=>nl,getPermuted:()=>nm,getRaggedRank:()=>Yf,getReductionAxes:()=>Lc,getReshaped:()=>tm,getReshapedPermuted:()=>am,getRowPartitionTypesHelper:()=>Zf,getSliceBeginCoords:()=>rm,getSliceSize:()=>sm,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>_m,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Am,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Rm,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Mm,getSparseReshapeInputOutputMismatchErrorMessage:()=>zm,getSparseReshapeInputOutputMultipleErrorMessage:()=>jm,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Dm,getSparseReshapeNegativeOutputDimErrorMessage:()=>Fm,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Wm,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Lm,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Pm,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Bm,getUndoAxesPermutation:()=>tl,isIdentityPermutation:()=>Om,log:()=>pr,mergeRealAndImagArrays:()=>fm,prepareAndValidate:()=>xf,prepareSplitSize:()=>Em,segment_util:()=>Um,shouldFuse:()=>mh,slice_util:()=>wf,splitRealAndImagArrays:()=>mm,stridesOrDilationsArePositive:()=>Ho,tupleValuesAreOne:()=>Vo,upcastType:()=>ys,validateDefaultValueShape:()=>Jf,validateInput:()=>Wd,validateUpdateShape:()=>Bd,warn:()=>hr}),function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Gf||(Gf={}));var Qf=30;function $f(e){return e<=Qf?e:Te(e,Math.floor(Math.sqrt(e)))}function em(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function tm(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=[];if(a)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);let n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function nm(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],a=[];if(n){a.push(t);for(let n=t+1;n<e;++n)n<=2*t?(a.push(n),a.push(n-(t+1))):a.push(n)}else{let n=[],r=[];for(let a=1;a<e;++a)a>=2*t+1||a%2===1?r.push(a):n.push(a);a.push(...n),a.push(0),a.push(...r)}return a}function am(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?a?r.push(t[s-1]*e[s]):r.push(e[s]/t[s-1]):r.push(e[s]);return r}function rm(e,t){let n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function sm(e,t,n){let a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}var im=1.7580993408473768,om=1.0507009873554805,cm=.3275911,lm=.254829592,um=-.284496736,dm=1.421413741,hm=-1.453152027,pm=1.061405429;function fm(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:".concat(e.length,", imag: ").concat(t.length,"."));let n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function mm(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function gm(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function bm(e){let t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function ym(e,t){return{real:e[2*t],imag:e[2*t+1]}}function vm(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function xm(e,t){let n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){let s=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(s),a[r]=Math.sin(s)}return{real:n,imag:a}}function wm(e,t,n){let a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}var km=/->/g;function Im(e,t){let n=((e=e.replace(/\s/g,"")).length-e.replace(km,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat("->",'").'));let[a,r]=e.split("->");Q(-1===a.indexOf("..."),()=>'The ellipsis notation ("'.concat("...",'") is not supported yet.'));let s=a.split(","),i=s.length;if(t!==i)throw new Error("Expected ".concat(i," input tensors, received ").concat(t));if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let d=0;d<r.length;++d){let e=r[d];if(!s.some(t=>-1!==t.indexOf(e)))throw new Error("Output subscripts contain the label ".concat(e," not present in the input subscripts."));-1===o.indexOf(e)&&o.push(e)}for(let d=0;d<a.length;++d){let e=a[d];-1===o.indexOf(e)&&","!==e&&o.push(e)}let c=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error("Found duplicate axes in input component ".concat(s[d],". Support for duplicate axes in input is not implemented yet."));c[d]=[];for(let e=0;e<s[d].length;++e)c[d].push(o.indexOf(s[d][e]))}let l=o.length,u=[];for(let d=r.length;d<l;++d)u.push(d);return{allDims:o,summedDims:u,idDims:c}}function Sm(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;let a=[];for(let r=0;r<e;++r)-1===n[r]&&a.push(r);return n=n.filter(e=>-1!==e),{permutationIndices:n,expandDims:a}}function Nm(e,t,n){let a=new Array(e);for(let r=0;r<n.length;++r){let e=n[r].shape;for(let n=0;n<t[r].length;++n)void 0===a[t[r][n]]?a[t[r][n]]=e[n]:Q(a[t[r][n]]===e[n],()=>"Expected dimension ".concat(a[t[r][n]]," at axis ").concat(n," of input shaped ").concat(JSON.stringify(e),", but got dimension ").concat(e[n]))}}function Tm(e,t){let n=e,a=[],r=0;0===e.length&&n.push(-1),r=e.length+1;for(let i=0;i<r;++i)a.push([]);let s=[];for(let i=0;i<n.length;++i){let e=Cm(t,n[i]);for(let t of e)-1===s.indexOf(t)&&(a[i].push(t),s.push(t))}return{path:n,steps:a}}function Om(e){return e.every((e,t)=>e===t)}function Cm(e,t){let n=[];for(let a=0;a<e.length;++a)(0===e[a].length||-1!==e[a].indexOf(t)||-1===t)&&n.push(a);return n}function Em(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=[];if("number"==typeof t)Q(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),a=new Array(t).fill(e.shape[n]/t);else{Q(t.reduce((e,t)=>(-1===t&&(e+=1),e),0)<=1,()=>"There should be only one negative value in split array.");let r=t.indexOf(-1);if(-1!==r){let a=t.reduce((e,t)=>t>0?e+t:e);t[r]=e.shape[n]-a}Q(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),a=t}return a}function _m(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function Am(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function Rm(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function Dm(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function Fm(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function Mm(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function jm(e,t){let n=te(e),a=te(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(a,". inputShape=").concat(e," outputShape= ").concat(t)}function zm(e,t){let n=te(e),a=te(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(a,". inputShape=").concat(e," outputShape=").concat(t)}function Lm(){return"segment ids must be >= 0"}function Pm(){return"segment ids are not increasing"}function Bm(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function Wm(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}var Um={};function Vm(e,t){let n,a=!1;for(e<=Qf?(n=e,a=!0):n=Te(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=Te(e,n+1);return n}function Gm(e,t,n){let a=[],r=e.length;for(let s=0;s<r;s++)s!==t?a.push(e[s]):a.push(n);return a}function Hm(e,t,n,a){let r=t.shape.length,s=e.shape.length;if(0!==a&&(a<-r||a>r))throw new Error("Expect batchDims in the range of [-".concat(r,", ").concat(r,"], but got ").concat(a));if(a<0&&(a+=r),a>s)throw new Error("batchDims (".concat(a,") must be less than rank(x) (\n    ").concat(s,")."));if(n<a)throw new Error("batchDims (".concat(a,") must be less than or equal to axis (").concat(n,")."));for(let d=0;d<a;++d)if(e.shape[d]!==t.shape[d])throw new Error("x.shape[".concat(d,"]: ").concat(e.shape[d]," should be equal to indices.shape[").concat(d,"]: ").concat(t.shape[d],"."));let i=e.shape[n],o=[],c=1,l=1,u=1;for(let d=0;d<a;++d)o.push(e.shape[d]),c*=e.shape[d];for(let d=a;d<n;d++)o.push(e.shape[d]),l*=e.shape[d];for(let d=a;d<r;d++)o.push(t.shape[d]);for(let d=n+1;d<s;d++)o.push(e.shape[d]),u*=e.shape[d];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:i,outputShape:o}}function qm(e){try{return e.map(e=>Zr(e))}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(t))}}function Km(e){return e.map(e=>Xr(e))}y(Um,{collectGatherOpShapeInfo:()=>Hm,computeOutShape:()=>Gm,segOpComputeOptimalWindowSize:()=>Vm});var Xm={};y(Xm,{nonMaxSuppressionV3Impl:()=>Dh,nonMaxSuppressionV4Impl:()=>Fh,nonMaxSuppressionV5Impl:()=>Mh,whereImpl:()=>Jd}),function(){for(let e of Pp)_p(e)}();var Zm={kernelName:Ke,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bo(e,_d(Vi(n,"float32"),-1))}}},Ym={kernelName:Xe,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=cl(Vi(n,"float32")),a=ol(Vl(il(1),t));return Bl(go(e,a))}}}},Jm={kernelName:Ze,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=ol(Vl(cl(Vi(n,"float32")),1));return go(e,t)}}}},Qm={kernelName:Ye,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Pc(n.shape,a.shape);return{a:()=>{let t=e,a=Lc(n.shape,r);return a.length>0&&(t=ll(t,a)),Xo(t,n.shape)},b:()=>{let t=e,n=Lc(a.shape,r);return n.length>0&&(t=ll(t,n)),Xo(t,a.shape)}}}},$m={kernelName:Je,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((t,a)=>{n[a]=()=>e.clone()}),n}},eg={kernelName:et,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Uc(n)}}},tg={kernelName:tt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Uc(n)}}},ng={kernelName:nt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>go(e,ol(Vl(il(1),cl(Vi(n,"float32")))))}}},ag={kernelName:at,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=ol(fo(il(1),cl(Vi(n,"float32"))));return go(e,t)}}}},rg={kernelName:it,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Pc(n.shape,a.shape);return{a:()=>{let t=fo(cl(n),cl(a)),s=bo(e,go(a,t)),i=Lc(n.shape,r);return i.length>0&&(s=ll(s,i)),Xo(s,n.shape)},b:()=>{let t=fo(cl(n),cl(a)),s=Bl(bo(e,go(n,t))),i=Lc(a.shape,r);return i.length>0&&(s=ll(s,i)),Xo(s,a.shape)}}}},sg={kernelName:rt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>go(e,fo(cl(Vi(n,"float32")),1))}}},ig={kernelName:st,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>go(e,Vl(il(1),cl(Vi(n,"float32"))))}}};var og=Vs({avgPool3dGrad_:function(e,t,n,a,r,s){let i=Bs(e,"dy","avgPool3dGrad"),o=Bs(t,"input","avgPool3dGrad"),c=i,l=o,u=!1;4===o.rank&&(u=!0,c=Xo(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=Xo(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Q(5===c.rank,()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank ".concat(c.rank,".")),Q(5===l.rank,()=>"Error in avgPool3dGrad: input must be rank 5 but got rank ".concat(l.rank,".")),Ko("avgPool3dGrad",r,s);let d={dy:c,input:l},h={filterSize:n,strides:a,pad:r,dimRoundingMode:s},p=_s.runKernel(ut,d,h);return u?Xo(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),cg={kernelName:lt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>og(e,a,r,s,i,o)}}};var lg=Vs({avgPoolGrad_:function(e,t,n,a,r){let s=Bs(e,"dy","avgPoolGrad"),i=Bs(t,"input","avgPoolGrad");Q(i.rank===s.rank,()=>"Rank of input (".concat(i.rank,") does not match rank of dy (").concat(s.rank,")"));let o=i,c=s,l=!1;3===i.rank&&(l=!0,o=Xo(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=Xo(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Q(4===c.rank,()=>"Error in avgPoolGrad: dy must be rank 4 but got rank ".concat(c.rank,".")),Q(4===o.rank,()=>"Error in avgPoolGrad: input must be rank 4 but got rank ".concat(o.rank,"."));let u={dy:c,input:o},d={filterSize:n,strides:a,pad:r},h=_s.runKernel(ct,u,d);return l?Xo(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),ug={kernelName:ot,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:s,pad:i}=n;return{x:()=>lg(e,a,r,s,i)}}},dg={kernelName:dt,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[a,r]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>Qo(e,r,!1,!1),b:()=>Qo(e,a,!0,!1)}:s&&!i?{a:()=>Qo(r,e,!1,!0),b:()=>Qo(a,e,!1,!1)}:{a:()=>Qo(r,e,!0,!0),b:()=>Qo(e,a,!0,!0)}:{a:()=>Qo(e,r,!1,!0),b:()=>Qo(a,e,!0,!1)}}},hg={kernelName:ht,gradFunc:(e,t,n)=>{let{blockShape:a,crops:r}=n;return{x:()=>ku(e,a,r)}}},pg={kernelName:mt,gradFunc:(e,t,n)=>{let a=n,r=a.inputShape,s=a.shape,i=Array.from(s);for(let c=r.length-1;c>=0;c--)if(r[c]===s[c])i[c]=1;else if(1!==r[c])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(s,"]."));let o=[];for(let c=0;c<i.length;c++)i[c]>1&&o.push(c);return{x:()=>ll(e,o,!0)}}},fg={kernelName:bt,gradFunc:e=>({x:()=>e.clone()})},mg={kernelName:yt,gradFunc:e=>({x:()=>Uc(e)})},gg={kernelName:vt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{clipValueMin:r,clipValueMax:s}=n;return{x:()=>Wc(ql(wl(a,r),Cl(a,s)),e,Uc(e))}}},bg={kernelName:wt,inputsToSave:["x"],gradFunc:Zm.gradFunc},yg={kernelName:kt,saveAllInputs:!0,gradFunc:(e,t,n)=>{let a=t.map(e=>e.shape),{axis:r}=n,s=he(r,t[0].shape)[0],i=a.map(e=>e[s]);return Nd(e,i,s).map(e=>()=>e)}},vg={kernelName:It,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,{dilations:s,strides:i,pad:o,dataFormat:c}=n;return Q(Vo(s),()=>"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '".concat(s,"'")),{x:()=>kc(a.shape,e,r,i,o,c),filter:()=>dh(a,e,r.shape,i,o,c)}}},xg={kernelName:Nt,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:c}=n;return{dy:()=>xc(e,r,s,i,o,1,c),filter:()=>dh(e,a,r.shape,s,i,o,c)}}};var wg=Vs({conv3DBackpropFilter_:function(e,t,n,a,r){let s=e;4===e.rank&&(s=Xo(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=Xo(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Q(5===s.rank,()=>"Error in conv3dDerFilter: input must be rank 5, but got shape ".concat(s.shape,".")),Q(5===i.rank,()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape ".concat(i.shape,".")),Q(5===n.length,()=>"Error in conv3dDerFilter: filterShape must be length 5, but got ".concat(n,".")),Q(s.shape[4]===n[3],()=>"Error in conv3dDerFilter: depth of input ".concat(s.shape[4],") must match input depth in filter (").concat(n[3],".")),Q(i.shape[4]===n[4],()=>"Error in conv3dDerFilter: depth of dy (".concat(i.shape[4],") must match output depth for filter (").concat(n[4],")."));let o={x:s,dy:i},c={strides:a,pad:r,filterShape:n};return _s.runKernel(Ot,o,c)}}),kg={kernelName:Tt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:s}=n;Q(Vo(a),()=>"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '".concat(a,"'"));let[i,o]=t;return{x:()=>Nc(i.shape,e,o,r,s),filter:()=>wg(i,e,o.shape,r,s)}}},Ig={kernelName:Et,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bo(Bl(md(Vi(n,"float32"))),e)}}},Sg={kernelName:_t,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bo(gd(Vi(n,"float32")),e)}}},Ng={kernelName:Rt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r,exclusive:s,reverse:i}=n;return{x:()=>{let t=el([r],a.rank),n=_c(e,r,s,!i);return null!=t&&(n=eh(n,t)),n}}}},Tg={kernelName:jt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:s,dimRoundingMode:i}=n,o=null==a?[1,1]:a;Q(Vo(o),()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '".concat(o,"'"));let[c,l]=t;return Q(4===c.rank,()=>"Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ".concat(c.rank,".")),Q(4===l.rank,()=>"Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ".concat(l.rank,".")),Q(c.shape[3]===l.shape[2],()=>"Error in gradient of depthwiseConv2d: number of input channels (".concat(c.shape[3],") must match the inChannels dimension in filter ").concat(l.shape[2],".")),Q(Go(r,o),()=>"Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ".concat(r," and dilations '").concat(o,"'.")),Ko("depthwiseConv2d",s,i),{x:()=>yh(c.shape,e,l,r,s,o,i),filter:()=>bh(c,e,l.shape,r,s,o,i)}}},Og={kernelName:Bt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,s={x:a,filter:r,dy:e},i={x:a,filter:r,dy:e};return{x:()=>_s.runKernel(Wt,s,n),filter:()=>_s.runKernel(Ut,i,n)}}},Cg={kernelName:qt,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,a={dy:e,y:n};return{x:()=>_s.runKernel(Kt,a)}}},Eg={kernelName:Xt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,a=bo(pl(Bl(cl(n))),2/Math.sqrt(Math.PI));return{x:()=>bo(e,a)}}},_g={kernelName:Yt,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bo(e,n)}}},Ag={kernelName:Jt,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>Xo(e,n.shape)}}},Rg={kernelName:Qt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bo(e,pl(n))}}},Dg={kernelName:nn,gradFunc:e=>({x:()=>Uc(e)})},Fg={kernelName:an,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Pc(n.shape,a.shape);return{a:()=>{let t=go(e,Vi(a,"float32")),s=Lc(n.shape,r);return s.length>0?Xo(ll(t,s),n.shape):t},b:()=>{let t=bo(e,Vi(n,"float32")),s=Lc(a.shape,r);s.length>0&&(t=Xo(ll(t,s),a.shape));let i=cl(a);return Bl(go(t,Vi(i,"float32")))}}}},Mg={kernelName:rn,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:a}=n,[r,s,i,o]=t,c=null==o?il(1):o,l=Lc(s.shape,r.shape),u=[];if(1===s.rank){for(let e=0;e<r.shape.length-1;++e)u.push(r.shape[e]);u.push(1)}let d=Vl(r,s),h=bo(e,c),p=ud(fo(i,il(a))),f=bo(bo(bo(p,p),p),il(-.5));return{x:()=>1===s.rank?Xo(bo(bo(e,gl(Xo(p,[1,1,1,s.shape[0]]),u)),c),r.shape):Xo(bo(bo(e,p),c),r.shape),mean:()=>{let e=bo(bo(p,il(-1)),h);return 1===s.rank&&(e=ll(e,l)),Xo(e,s.shape)},variance:()=>{let e=bo(bo(f,d),h);return 1===s.rank&&(e=ll(e,l)),Xo(e,s.shape)},scale:()=>{let t=bo(d,p),n=bo(e,t);return 1===s.rank&&(n=ll(n,l)),Xo(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=ll(t,l)),Xo(t,s.shape)}}}},jg={kernelName:sn,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[a,r]=t,{axis:s}=n,i=he(s,a.shape)[0];return{x:()=>{let t=a.shape,n=r.size,o=t.slice(0,i),c=o.length,l=t.slice(s,t.length).slice(1),u=l.length,d=zg(0,c),h=zg(c+1,c+1+u),p=Lg([o,[n],l]),f=Xo(e,p),m=Xo(r,[n]),g=Lg([[c],d,h]),b=eh(f,g),y=Kd(b,m,a.shape[i]),v=tl(g);return y=eh(y,v),y},indices:()=>r}}};function zg(e,t){let n=[];for(let a=e;a<t;++a)n.push(a);return n}function Lg(e){let t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}var Pg={kernelName:ln,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>Uc(n),b:()=>Uc(a)}}},Bg={kernelName:un,gradFunc:e=>({x:()=>Vi(e,"float32")})},Wg={kernelName:pn,gradFunc:e=>({x:()=>Uc(e)})},Ug={kernelName:fn,gradFunc:e=>({x:()=>Uc(e)})},Vg={kernelName:mn,gradFunc:e=>({x:()=>Uc(e)})},Gg={kernelName:gn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{alpha:r}=n,s=xl(a,0);return{x:()=>Wc(s,e,bo(e,r))}}},Hg={kernelName:wn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>go(e,fo(n,1))}}},qg={kernelName:xn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>go(e,Vi(n,"float32"))}}},Kg={kernelName:Tn,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n;return{logits:()=>{let t=pl(a);return Vl(e,bo(ll(e,r,!0),t))}}}};var Xg=Vs({localResponseNormalizationBackprop_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5,o={x:e,y:t,dy:n},c={depthRadius:a,bias:r,alpha:s,beta:i};return _s.runKernel(En,o,c)}}),Zg={kernelName:Cn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{depthRadius:s,bias:i,alpha:o,beta:c}=n;return{x:()=>Xg(a,r,e,s,i,o,c)}}};function Yg(e,t,n,a){return t.rank<n.rank&&(t=Xo(t,Qc(t.shape,a))),e.rank<n.rank&&(e=Xo(e,Qc(e.shape,a))),{x:()=>bo(e,Vi(Bc(n,t),e.dtype))}}var Jg={kernelName:An,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{reductionIndices:r}=a,s=t[0],i=Yg(e,t[1],s,he(r,s.shape));return{x:()=>i.x()}}},Qg={kernelName:Rn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>bo(e,Vi(wl(n,a),"float32")),b:()=>bo(e,Vi(Ol(n,a),"float32"))}}};var $g=Vs({maxPool3dGrad_:function(e,t,n,a,r,s,i){let o=Bs(e,"dy","maxPool3dGrad"),c=Bs(t,"input","maxPool3dGrad"),l=Bs(n,"output","maxPool3dGrad"),u=o,d=c,h=l,p=!1;4===c.rank&&(p=!0,u=Xo(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=Xo(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),h=Xo(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),Q(5===u.rank,()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank ".concat(u.rank,".")),Q(5===d.rank,()=>"Error in maxPool3dGrad: input must be rank 5 but got rank ".concat(d.rank,".")),Q(5===h.rank,()=>"Error in maxPool3dGrad: output must be rank 5 but got rank ".concat(h.rank,".")),Ko("maxPool3dGrad",s,i);let f={dy:u,input:d,output:h},m={filterSize:a,strides:r,pad:s,dimRoundingMode:i},g=_s.runKernel(jn,f,m);return p?Xo(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),eb={kernelName:Mn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:c}=n;return{x:()=>$g(e,a,r,s,i,o,c)}}};var tb=Vs({maxPoolGrad_:function(e,t,n,a,r,s,i){let o=Bs(e,"dy","maxPoolGrad"),c=Bs(t,"input","maxPoolGrad"),l=Bs(n,"output","maxPoolGrad");Q(c.rank===o.rank,()=>"Rank of input (".concat(c.rank,") does not match rank of dy (").concat(o.rank,")")),Q(4===o.rank,()=>"Error in maxPoolGrad: dy must be rank 4 but got rank ".concat(o.rank,".")),Q(4===c.rank,()=>"Error in maxPoolGrad: input must be rank 4 but got rank ".concat(c.rank,".")),Ko("maxPoolGrad",s,i);let u={dy:o,input:c,output:l},d={filterSize:a,strides:r,pad:s,dimRoundingMode:i};return _s.runKernel(Fn,u,d)}}),nb={kernelName:$n,inputsToSave:["x"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,s=r.map(e=>e[0]);return{x:()=>ec(e,s,a.shape)}}};function ab(e,t,n){let a=e.shape.length,r=a-n.length,s=Hf.getAxesPermutation(n,a),i=e;null!=s&&(i=eh(e,s));let o=i.shape.slice(),c=o.splice(a-n.length,n.length).reduce((e,t)=>e*t,1);o.push(c);let l=function(e,t,n){let a=e.shape.slice();a[n]=1;let r=Xo(t,a),s=Ec(e,n,!0,!1),i=Ec(e,n,!0,!0),o=bo(s,i);return bo(r,o)}(i.reshape(o),t,r);if(l=l.reshape(i.shape),null!=s){let e=Hf.getUndoAxesPermutation(s);l=eh(l,e)}return l}var rb={kernelName:Da,gradFunc:(e,t,n)=>{let{blockShape:a,paddings:r}=n;return{x:()=>ac(e,a,r)}}},sb={kernelName:Fa,gradFunc:(e,t,n)=>{let{axis:a}=n;return{x:()=>Jo(e,a)}}};var ib=[Zm,Ym,Jm,Qm,$m,eg,tg,ng,ag,rg,sg,ig,cg,ug,dg,hg,pg,fg,mg,gg,bg,yg,xg,vg,kg,Ig,Sg,Ng,Tg,Og,{kernelName:Gt,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Pc(n.shape,a.shape);return{a:()=>{let t=go(e,Vi(a,"float32")),s=Lc(n.shape,r);return s.length>0?Xo(ll(t,s),n.shape):t},b:()=>{let t=bo(e,Vi(n,"float32")),s=Lc(a.shape,r);s.length>0&&(t=Xo(ll(t,s),a.shape));let i=cl(a);return Bl(go(t,Vi(i,"float32")))}}}},Cg,Eg,_g,Ag,Rg,Fg,Dg,Mg,jg,Pg,Bg,Wg,Ug,Vg,Gg,Hg,qg,Kg,Zg,Jg,Jg,Qg,eb,{kernelName:Dn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>tb(e,a,r,s,i,o)}}},{kernelName:Ln,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,s=he(r,a.shape),i=te(Jc(a.shape,s)[1]);return{x:()=>{let t=a.shape.slice();s.forEach(e=>{t[e]=1});let n=Xo(e,t);return go(bo(n,su(a.shape,"float32")),i)}}}},{kernelName:Pn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{axis:r}=a,[s,i]=t,o=Yg(e,i,s,he(r,s.shape));return{x:()=>o.x()}}},{kernelName:Bn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>bo(e,Vi(Cl(n,a),"float32")),b:()=>bo(e,Vi(xl(n,a),"float32"))}}},{kernelName:Wn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,s=r.map(e=>e[0]);return{x:()=>ec(e,s,a.shape)}}},{kernelName:Un,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Pc(n.shape,a.shape);return{a:()=>{let t=Lc(n.shape,r);return t.length>0?Xo(ll(e,t),n.shape):e},b:()=>{let t=bo(e,Bl(yl(go(n,a)))),s=Lc(a.shape,r);return s.length>0?Xo(ll(t,s),a.shape):t}}}},{kernelName:Gn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Pc(n.shape,a.shape);return{a:()=>{let t=bo(e,Vi(a,"float32")),s=Lc(n.shape,r);return s.length>0?Xo(ll(t,s),n.shape):t},b:()=>{let t=bo(e,Vi(n,"float32")),s=Lc(a.shape,r);return s.length>0?Xo(ll(t,s),a.shape):t}}}},{kernelName:Hn,gradFunc:e=>({x:()=>Bl(e)})},{kernelName:Jn,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>ru(n.shape,"float32")}}},{kernelName:Yn,gradFunc:e=>({x:()=>Uc(e)})},{kernelName:Qn,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:a}=n;return Xd(e,a).map(e=>()=>e)}},nb,nb,{kernelName:ta,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,a,r]=t,s=n,i=a,o=Pc(s.shape,i.shape);return{a:()=>{let t=Vi(i,"float32"),n=bo(e,bo(t,sl(s,Vl(t,il(1))))),a=Lc(s.shape,o);return a.length>0&&(n=ll(n,a)),Xo(n,s.shape)},b:()=>{let t=xl(s,0),n=Wc(t,Al(s),Uc(s)),a=bo(e,bo(r,n)),c=Lc(i.shape,o);return c.length>0&&(a=ll(a,c)),Xo(a,i.shape)}}}},{kernelName:na,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,a]=t,r=xl(n,0);return{x:()=>Wc(r,e,bo(e,a)),alpha:()=>{let t=Wc(r,Uc(e),bo(e,n)),s=Lc(a.shape,e.shape);return s.length>0&&(t=ll(t,s)),Xo(t,a.shape)}}}},{kernelName:aa,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,s=[];return s=null==r?a.shape.map((e,t)=>t):"number"==typeof r?[r]:r,{x:()=>ab(a,e,s)}}},{kernelName:la,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>go(e,Bl(cl(n)))}}},{kernelName:ga,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,a=bo(Cl(n,6),_d(n));return{x:()=>bo(e,Vi(a,"float32"))}}},{kernelName:ua,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bo(e,Vi(_d(n),"float32"))}}},{kernelName:da,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Xo(e,n.shape)}}},{kernelName:fa,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>_s.runKernel(ma,r,n)}}},{kernelName:ha,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>_s.runKernel(pa,r,n)}}},{kernelName:ba,gradFunc:(e,t,n)=>{let{dims:a}=n,r=he(a,e.shape);return{x:()=>rd(e,r)}}},{kernelName:ya,gradFunc:e=>({x:()=>Uc(e)})},{kernelName:va,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Bl(go(e,bo(sl(n,1.5),2)))}}},{kernelName:Ia,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>Vi(Uc(n),"float32"),t:()=>bo(e,Vi(n,e.dtype)),e:()=>bo(e,Vi(Kl(n),e.dtype))}}},{kernelName:Sa,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=xl(n,il(0)),a=il(im),r=il(om),s=bo(e,r),i=bo(bo(e,a),pl(Vi(n,"float32")));return Wc(t,s,i)}}}},{kernelName:Ea,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bo(e,bo(n,Vl(il(1),n)))}}},{kernelName:Ca,gradFunc:e=>({x:()=>Uc(e)})},{kernelName:Ta,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bo(Oc(Vi(n,"float32")),e)}}},{kernelName:Oa,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bo(Cc(Vi(n,"float32")),e)}}},{kernelName:Na,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{begin:r,size:s}=n,i=a.shape,[o,c]=jf(a,r,s),l=[];for(let u=0;u<e.rank;u++)l.push([o[u],i[u]-o[u]-c[u]]);return{x:()=>bu(e,l)}}},{kernelName:Ma,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{dim:r}=n,s=bo(e,a);return{logits:()=>Vl(s,bo(ll(s,[r],!0),a))}}},{kernelName:_a,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bo(e,$o(n))}}},rb,rb,sb,sb,{kernelName:Aa,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>go(e,bo(ol(Vi(n,"float32")),2))}}},{kernelName:Wa,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=il(2);return{a:()=>bo(e,bo(r,Vl(n,a))),b:()=>bo(e,bo(r,Vl(a,n)))}}},{kernelName:Ua,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bo(e,bo(Vi(n,"float32"),2))}}},{kernelName:ir,gradFunc:e=>({x:()=>Uc(e)})},{kernelName:Xa,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Pc(n.shape,a.shape);return{a:()=>{let t=e,a=Lc(n.shape,r);return a.length>0&&(t=ll(t,a)),Xo(t,n.shape)},b:()=>{let t=e,n=Lc(a.shape,r);return n.length>0&&(t=ll(t,n)),Xo(Bl(t),a.shape)}}}},{kernelName:Ra,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,r=a.shape.slice(),{axis:s}=n;he(s,a.shape).forEach(e=>{r[e]=1});let i=Xo(e,r),o=bo(i,su(a.shape,"float32"));return{x:()=>o}}},{kernelName:Za,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>go(e,cl(Oc(n)))}}},{kernelName:Ya,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bo(Vl(il(1),cl(n)),e)}}},{kernelName:Ja,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{reps:r}=n;return{x:()=>{let t=Uc(a);if(1===a.rank)for(let n=0;n<r[0];++n)t=fo(t,ec(e,[n*a.shape[0]],[a.shape[0]]));else if(2===a.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)t=fo(t,ec(e,[n*a.shape[0],s*a.shape[1]],[a.shape[0],a.shape[1]]));else if(3===a.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let i=0;i<r[2];++i)t=fo(t,ec(e,[n*a.shape[0],s*a.shape[1],i*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else{if(4!==a.rank)throw new Error("Gradient for tile operation is not implemented for rank-".concat(a.rank," tensors yet."));for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let i=0;i<r[2];++i)for(let o=0;o<r[3];++o)t=fo(t,ec(e,[n*a.shape[0],s*a.shape[1],i*a.shape[2],o*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]))}return t}}}},{kernelName:er,gradFunc:(e,t,n)=>{let a=n,{perm:r}=a,s=tl(r);return{x:()=>eh(e,s)}}},{kernelName:nr,gradFunc:(e,t,n)=>{let a=n,{axis:r}=a;return{value:()=>Ed(e,r)}}},{kernelName:ar,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>function(e,t){let n=nu(t,Uc(t)),a=vl(e,n),r=wl(t,il(0,"int32")),s=a.rank-r.rank;for(let o=0;o<s;++o)r=fl(r,o+1);r=ql(r,su(a.shape,"bool"));let i=Uc(a);return Wc(r,a,i)}(e,n)}}},{kernelName:sr,gradFunc:e=>({x:()=>Uc(e)})}];for(let t of ib)xr(t);cs().prototype.abs=function(){return this.throwIfDisposed(),yo(this)},cs().prototype.acos=function(){return this.throwIfDisposed(),vo(this)},cs().prototype.acosh=function(){return this.throwIfDisposed(),xo(this)},cs().prototype.add=function(e){return this.throwIfDisposed(),fo(this,e)},cs().prototype.all=function(e,t){return this.throwIfDisposed(),ko(this,e,t)},cs().prototype.any=function(e,t){return this.throwIfDisposed(),Io(this,e,t)},cs().prototype.argMax=function(e){return this.throwIfDisposed(),So(this,e)},cs().prototype.argMin=function(e){return this.throwIfDisposed(),No(this,e)},cs().prototype.asScalar=function(){return this.throwIfDisposed(),Q(1===this.size,()=>"The array must have only 1 element."),Xo(this,[])},cs().prototype.asType=function(e){return this.throwIfDisposed(),Vi(this,e)},cs().prototype.as1D=function(){return this.throwIfDisposed(),Xo(this,[this.size])},cs().prototype.as2D=function(e,t){return this.throwIfDisposed(),Xo(this,[e,t])},cs().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Xo(this,[e,t,n])},cs().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),Xo(this,[e,t,n,a])},cs().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),Xo(this,[e,t,n,a,r])},cs().prototype.asin=function(){return this.throwIfDisposed(),To(this)},cs().prototype.asinh=function(){return this.throwIfDisposed(),Oo(this)},cs().prototype.atan=function(){return this.throwIfDisposed(),Co(this)},cs().prototype.atan2=function(e){return this.throwIfDisposed(),Eo(this,e)},cs().prototype.atanh=function(){return this.throwIfDisposed(),_o(this)},cs().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),Zo(this,e,t,n,a)},cs().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),ac(this,e,t)},cs().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),sc(this,e,t,n,a,r)},cs().prototype.broadcastTo=function(e){return this.throwIfDisposed(),hc(this,e)},cs().prototype.cast=function(e){return this.throwIfDisposed(),Vi(this,e)},cs().prototype.ceil=function(){return this.throwIfDisposed(),pc(this)},cs().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),mc(this,e,t)},cs().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof os&&(e=[e]),Jo([this,...e],t)},cs().prototype.conv1d=function(e,t,n,a,r,s){return this.throwIfDisposed(),wc(this,e,t,n,a,r,s)},cs().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),Ic(this,e,t,n,a,r)},cs().prototype.conv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),xc(this,e,t,n,a,r,s)},cs().prototype.cos=function(){return this.throwIfDisposed(),Oc(this)},cs().prototype.cosh=function(){return this.throwIfDisposed(),Cc(this)},cs().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Ec(this,e,t,n)},cs().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),_c(this,e,t,n)},cs().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Rc(this,e,t)},cs().prototype.depthwiseConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),Dc(this,e,t,n,a,r,s)},cs().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),Mc(this,e,t,n,a,r)},cs().prototype.divNoNan=function(e){return this.throwIfDisposed(),Vc(this,e)},cs().prototype.div=function(e){return this.throwIfDisposed(),go(this,e)},cs().prototype.dot=function(e){return this.throwIfDisposed(),Gc(this,e)},cs().prototype.elu=function(){return this.throwIfDisposed(),qc(this)},cs().prototype.equal=function(e){return this.throwIfDisposed(),Bc(this,e)},cs().prototype.erf=function(){return this.throwIfDisposed(),Xc(this)},cs().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),hl(this,e,t)},cs().prototype.exp=function(){return this.throwIfDisposed(),pl(this)},cs().prototype.expandDims=function(e){return this.throwIfDisposed(),fl(this,e)},cs().prototype.expm1=function(){return this.throwIfDisposed(),ml(this)},cs().prototype.fft=function(){return this.throwIfDisposed(),kd(this)},cs().prototype.flatten=function(){return this.throwIfDisposed(),Xo(this,[this.size])},cs().prototype.floor=function(){return this.throwIfDisposed(),yl(this)},cs().prototype.floorDiv=function(e){return this.throwIfDisposed(),mo(this,e)},cs().prototype.gather=function(e,t,n){return this.throwIfDisposed(),vl(this,e,t,n)},cs().prototype.greaterEqual=function(e){return this.throwIfDisposed(),wl(this,e)},cs().prototype.greater=function(e){return this.throwIfDisposed(),xl(this,e)},cs().prototype.ifft=function(){return this.throwIfDisposed(),Id(this)},cs().prototype.irfft=function(){return this.throwIfDisposed(),Sd(this)},cs().prototype.isFinite=function(){return this.throwIfDisposed(),Il(this)},cs().prototype.isInf=function(){return this.throwIfDisposed(),Sl(this)},cs().prototype.isNaN=function(){return this.throwIfDisposed(),Nl(this)},cs().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Tl(this,e)},cs().prototype.lessEqual=function(e){return this.throwIfDisposed(),Cl(this,e)},cs().prototype.less=function(e){return this.throwIfDisposed(),Ol(this,e)},cs().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),_l(this,e,t,n,a)},cs().prototype.logSigmoid=function(){return this.throwIfDisposed(),Ul(this)},cs().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Gl(this,e)},cs().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Hl(this,e,t)},cs().prototype.log=function(){return this.throwIfDisposed(),Al(this)},cs().prototype.log1p=function(){return this.throwIfDisposed(),Rl(this)},cs().prototype.logicalAnd=function(e){return this.throwIfDisposed(),ql(this,e)},cs().prototype.logicalNot=function(){return this.throwIfDisposed(),Kl(this)},cs().prototype.logicalOr=function(e){return this.throwIfDisposed(),Xl(this,e)},cs().prototype.logicalXor=function(e){return this.throwIfDisposed(),Zl(this,e)},cs().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Qo(this,e,t,n)},cs().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),$l(this,e,t,n,a)},cs().prototype.max=function(e,t){return this.throwIfDisposed(),al(this,e,t)},cs().prototype.maximum=function(e){return this.throwIfDisposed(),nu(this,e)},cs().prototype.mean=function(e,t){return this.throwIfDisposed(),au(this,e,t)},cs().prototype.min=function(e,t){return this.throwIfDisposed(),rl(this,e,t)},cs().prototype.minimum=function(e){return this.throwIfDisposed(),ou(this,e)},cs().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),cu(this,e,t)},cs().prototype.mod=function(e){return this.throwIfDisposed(),lu(this,e)},cs().prototype.mul=function(e){return this.throwIfDisposed(),bo(this,e)},cs().prototype.neg=function(){return this.throwIfDisposed(),Bl(this)},cs().prototype.norm=function(e,t,n){return this.throwIfDisposed(),dl(this,e,t,n)},cs().prototype.notEqual=function(e){return this.throwIfDisposed(),pu(this,e)},cs().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),fu(this,e,t,n)},cs().prototype.onesLike=function(){return this.throwIfDisposed(),mu(this)},cs().prototype.pad=function(e,t){return this.throwIfDisposed(),bu(this,e,t)},cs().prototype.pool=function(e,t,n,a,r,s){return this.throwIfDisposed(),Iu(this,e,t,n,a,r,s)},cs().prototype.pow=function(e){return this.throwIfDisposed(),sl(this,e)},cs().prototype.prelu=function(e){return this.throwIfDisposed(),Su(this,e)},cs().prototype.prod=function(e,t){return this.throwIfDisposed(),Nu(this,e,t)},cs().prototype.reciprocal=function(){return this.throwIfDisposed(),td(this)},cs().prototype.relu=function(){return this.throwIfDisposed(),nd(this)},cs().prototype.relu6=function(){return this.throwIfDisposed(),ad(this)},cs().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Xo(this,e.shape)},cs().prototype.reshape=function(e){return this.throwIfDisposed(),Xo(this,e)},cs().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Hh(this,e,t,n)},cs().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),qh(this,e,t,n)},cs().prototype.reverse=function(e){return this.throwIfDisposed(),rd(this,e)},cs().prototype.rfft=function(){return this.throwIfDisposed(),Td(this)},cs().prototype.round=function(){return this.throwIfDisposed(),ld(this)},cs().prototype.rsqrt=function(){return this.throwIfDisposed(),ud(this)},cs().prototype.selu=function(){return this.throwIfDisposed(),dd(this)},cs().prototype.separableConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),hd(this,e,t,n,a,r,s)},cs().prototype.sigmoid=function(){return this.throwIfDisposed(),$o(this)},cs().prototype.sign=function(){return this.throwIfDisposed(),fd(this)},cs().prototype.sin=function(){return this.throwIfDisposed(),md(this)},cs().prototype.sinh=function(){return this.throwIfDisposed(),gd(this)},cs().prototype.slice=function(e,t){return this.throwIfDisposed(),ec(this,e,t)},cs().prototype.softmax=function(e){return this.throwIfDisposed(),wd(this,e)},cs().prototype.softplus=function(){return this.throwIfDisposed(),Wl(this)},cs().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),ku(this,e,t)},cs().prototype.split=function(e,t){return this.throwIfDisposed(),Nd(this,e,t)},cs().prototype.sqrt=function(){return this.throwIfDisposed(),ol(this)},cs().prototype.square=function(){return this.throwIfDisposed(),cl(this)},cs().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Od(this,e)},cs().prototype.squeeze=function(e){return this.throwIfDisposed(),Cd(this,e)},cs().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof os?[this,e]:[this,...e];return Ed(n,t)},cs().prototype.step=function(e){return this.throwIfDisposed(),_d(this,e)},cs().prototype.stridedSlice=function(e,t,n,a,r,s,i,o){return this.throwIfDisposed(),Ad(this,e,t,n,a,r,s,i,o)},cs().prototype.sub=function(e){return this.throwIfDisposed(),Vl(this,e)},cs().prototype.sum=function(e,t){return this.throwIfDisposed(),ll(this,e,t)},cs().prototype.tan=function(){return this.throwIfDisposed(),Rd(this)},cs().prototype.tanh=function(){return this.throwIfDisposed(),tc(this)},cs().prototype.tile=function(e){return this.throwIfDisposed(),gl(this,e)},cs().prototype.toBool=function(){return this.throwIfDisposed(),Vi(this,"bool")},cs().prototype.toFloat=function(){return this.throwIfDisposed(),Vi(this,"float32")},cs().prototype.toInt=function(){return this.throwIfDisposed(),Vi(this,"int32")},cs().prototype.topk=function(e,t){return this.throwIfDisposed(),Gd(this,e,t)},cs().prototype.transpose=function(e){return this.throwIfDisposed(),eh(this,e)},cs().prototype.unique=function(e){return this.throwIfDisposed(),qd(this,e)},cs().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Kd(this,e,t)},cs().prototype.unstack=function(e){return this.throwIfDisposed(),Xd(this,e)},cs().prototype.where=function(e,t){return this.throwIfDisposed(),Wc(e,this,t)},cs().prototype.zerosLike=function(){return this.throwIfDisposed(),Uc(this)};var ob=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ob.prototype)}},cb=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,cb.prototype)}},lb=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,lb.prototype)}},ub=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ub.prototype)}},db=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,db.prototype)}},hb=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(e,"."));if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}};function pb(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}{let n=new Array(t);return n.fill(e),n}}function fb(e,t){if(!e)throw new db(t)}function mb(e,t){let n=0;for(let a of e)a===t&&n++;return n}function gb(e){return 1===e.length?e[0]:e}function bb(e){return Array.isArray(e)?e:[e]}function yb(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function vb(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}var xb={};function wb(e){if(null==e)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function kb(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(e=>kb(e));else{let t=Object.keys(e);for(let n of t){let t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?kb(t):e[n]=t.value)}}}function Ib(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"==typeof e){let r,s=e;if(s in n)r=n[s];else if(s in xb)r=xb[s];else if(r=t[s],null==r)throw new lb("Unknown ".concat(a,": ").concat(e,". This may be due to one of the following reasons:\n1. The ").concat(a," is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ").concat(a," is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."));return r}{let s=e;if(null==s.className||null==s.config)throw new lb("".concat(a,": Improper config format: ").concat(JSON.stringify(s),".\n'className' and 'config' must set."));let i,o,c=s.className;if(c in n?[i,o]=n[c]:c in xb?[i,o]=xb.className:c in t&&([i,o]=t[c]),null==i)throw new lb("Unknown ".concat(a,": ").concat(c,". This may be due to one of the following reasons:\n1. The ").concat(a," is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ").concat(a," is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."));if(null!=o){let e={};for(let n of Object.keys(xb))e[n]=xb[n];for(let r of Object.keys(n))e[r]=n[r];s.config.customObjects=e;let t=Object.assign({},xb);for(let r of Object.keys(n))xb[r]=n[r];kb(s.config);let a=o(i,s.config,n,r);return xb=Object.assign({},t),a}{let e=Object.assign({},xb);for(let a of Object.keys(n))xb[a]=n[a];let t=new i(s.config);return xb=Object.assign({},e),t}}}function Sb(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function Nb(e){if(null==e)return e;let t=[];for(let n of e)-1===t.indexOf(n)&&t.push(n);return t}function Tb(e){if(null==e)throw new lb("Invalid value in obj: ".concat(JSON.stringify(e)));for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Ob(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new lb("".concat(n," is not a valid ").concat(t,".  Valid values are ").concat(e," or null/undefined."))}function Cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return fb(n>=0),fb(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every(e=>typeof e===t)}function Eb(e,t){Array.isArray(e)?(Nr.assert(e.length>0,()=>"".concat(t," is unexpectedly an empty array.")),e.forEach((e,n)=>Eb(e,"element ".concat(n+1," of ").concat(t)))):Nr.assert(Number.isInteger(e)&&e>0,()=>"Expected ".concat(t," to be a positive integer, but got ").concat(function e(t){return null===t?"null":Array.isArray(t)?"["+t.map(t=>e(t)).join(",")+"]":"string"==typeof t?'"'.concat(t,'"'):"".concat(t)}(e),"."))}function _b(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var Ab=0;function Rb(){return Ab++}var Db={};function Fb(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in Db||(Db[e]=0),Db[e]+=1,e+Db[e].toString()}var Mb=["channelsFirst","channelsLast"],jb=["nearest","bilinear"],zb=["valid","same","causal"],Lb=["max","avg"],Pb=["sum","mul","concat","ave"],Bb=new Map;function Wb(e){Ob(Mb,"DataFormat",e)}function Ub(e){Ob(zb,"PaddingMode",e)}function Vb(e){Ob(Lb,"PoolMode",e)}var Gb=[];function Hb(e,t){Gb.push(e);try{let e=t();return Gb.pop(),e}catch(hJ){throw Gb.pop(),hJ}}function qb(e){if(!Yb(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===Gb.length?"":Gb.join("/")+"/")+e}function Kb(e){if(!Yb(e))throw new Error("Not a valid tensor name: '"+e+"'");Bb.has(e)||Bb.set(e,0);let t=Bb.get(e);if(Bb.set(e,Bb.get(e)+1),t>0){let n="".concat(e,"_").concat(t);return Bb.set(n,1),n}return e}var Xb,Zb=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Yb(e){return!!e.match(Zb)}function Jb(e){return e===parseInt(e.toString(),10)}function Qb(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function $b(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a<t&&(t=a)}return t}function ey(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a>t&&(t=a)}return t}function ty(e,t){if(t<e)throw new lb("end (".concat(t,") < begin (").concat(e,") is forbidden."));let n=[];for(let a=e;a<t;++a)n.push(a);return n}function ny(){return null==Xb&&(Xb=ho().epsilon()),Xb}function ay(e,t){return Vi(e,t)}function ry(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Xo(e,n)}function sy(e){let t=[Qb(e.shape)];return Xo(e,t)}function iy(e,t,n){return eo(()=>{switch(e.rank){case 1:return bd(e,t,n);case 2:return yd(e,[t,0],[n,e.shape[1]]);case 3:return vd(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return xd(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return ec(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return ec(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new lb("sliceAlongFirstAxis() received an unsupported tensor rank: ".concat(e.rank))}})}function oy(e,t,n){return eo(()=>{switch(e.rank){case 1:return bd(e,t,n);case 2:return yd(e,[0,t],[e.shape[0],n]);case 3:return vd(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return xd(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new lb("sliceAlongLastAxis() received an unsupported tensor rank: ".concat(e.rank))}})}function cy(e,t,n,a){return eo(()=>{switch(e.rank){case 1:return bd(e,t,n);case 2:switch(a){case 1:return iy(e,t,n);case 2:return oy(e,t,n);default:throw new lb("The axis is not within the rank of the tensor ".concat(a))}case 3:switch(a){case 1:return iy(e,t,n);case 2:return vd(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return oy(e,t,n);default:throw new lb("The axis is not within the rank of the tensor ".concat(a))}case 4:switch(a){case 1:return iy(e,t,n);case 2:return xd(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return xd(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return oy(e,t,n);default:throw new lb("The axis is not within the rank of the tensor ".concat(a))}default:throw new lb("sliceAlongLastAxis() received an unsupported tensor rank: ".concat(e.rank))}})}function ly(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),Jo(e,n)}function uy(e,t){switch(e.rank){case 1:return gc([e,t]);case 2:return bc([e,t],0);case 3:return yc([e,t],0);case 4:return vc([e,t],0);default:throw new lb("concatAlongFirstAxis() received an unsupported tensor rank: ".concat(e.rank))}}function dy(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new lb("The length of input n (".concat(t.length,") does not match the number of dimensions in input x (").concat(e.rank,")"));return gl(e,t)}function hy(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;return Zu(e,t,n,a,r)}function py(e,t,n,a){if(e.rank<2||t.rank<2)throw new ub("dot requires both inputs to be rank >= 2 but got x shape = ".concat(e.shape," and y shape = ").concat(t.shape));if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new ub("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ".concat(e.shape," and  y shape = ").concat(t.shape))}if(2===e.rank&&2===t.rank)return uh.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?gy(e.rank,a,"channelsLast"):null,activation:n});{let r=e.shape.slice(),s=r.pop();e=Xo(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),c=i.pop(),l=[...i,o],u=Array.from({length:t.rank},(e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n);t=Xo(eh(t,u),[c,-1]);let d=[...r,...l],h=!1,p=!1;return Xo(uh.matMul({a:e,b:t,transposeA:h,transposeB:p,bias:a?gy(e.rank,a,"channelsLast"):null,activation:n}),d)}}function fy(e,t,n){return eo(()=>(t=Array.isArray(t)?Dd(t,"int32"):Vi(t,"int32"),vl(e,t,n)))}function my(e){return bo(e,e)}function gy(e,t,n){let a=t.shape;if(1!==t.rank&&t.rank!==e)throw new lb("Unexpected bias dimensions: ".concat(t.rank,"; expected it to be 1 or ").concat(e));if(5===e){if("channelsFirst"===n)return 1===a.length?Xo(t,[1,a[0],1,1,1]):Xo(t,[1,a[3],a[0],a[1],a[2]]);if("channelsLast"===n)return 1===a.length?Xo(t,[1,1,1,1,a[0]]):Xo(t,[1].concat(a))}else if(4===e){if("channelsFirst"===n)return 1===a.length?Xo(t,[1,a[0],1,1]):Xo(t,[1,a[2],a[0],a[1]]);if("channelsLast"===n)return 1===a.length?Xo(t,[1,1,1,a[0]]):Xo(t,[1].concat(a))}else if(3===e){if("channelsFirst"===n)return 1===a.length?Xo(t,[1,a[0],1]):Xo(t,[1,a[1],a[0]]);if("channelsLast"===n)return 1===a.length?Xo(t,[1,1,a[0]]):Xo(t,[1].concat(a))}else if(e<3)return t;throw new lb("Unsupported input rank by biasAdd: ".concat(t.rank))}function by(e,t,n){return eo(()=>(null==n&&(n="channelsLast"),Wb(n),fo(e,gy(e.rank,t,n))))}function yy(e,t,n,a){return eo(()=>ih(e,t,n,a))}function vy(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return n?e():t()}var xy=["fanIn","fanOut","fanAvg"],wy=["normal","uniform","truncatedNormal"];var ky=class extends Op.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},Iy=class extends ky{apply(e,t){return ru(e,t)}};Iy.className="Zeros",Op.registerClass(Iy);var Sy=class extends ky{apply(e,t){return su(e,t)}};Sy.className="Ones",Op.registerClass(Sy);var Ny=class extends ky{constructor(e){if(super(),"object"!=typeof e)throw new lb("Expected argument of type ConstantConfig but got ".concat(e));if(void 0===e.value)throw new lb("config must have value set but got ".concat(e));this.value=e.value}apply(e,t){return eo(()=>bo(il(this.value),su(e,t)))}getConfig(){return{value:this.value}}};Ny.className="Constant",Op.registerClass(Ny);var Ty=class extends ky{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Ju(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Ty.className="RandomUniform",Op.registerClass(Ty);var Oy=class extends ky{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new ub("randomNormal does not support dType ".concat(t,"."));return hy(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Oy.className="RandomNormal",Op.registerClass(Oy);var Cy=class extends ky{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new ub("truncatedNormal does not support dType ".concat(t,"."));return Hd(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Cy.className="TruncatedNormal",Op.registerClass(Cy);var Ey=class extends ky{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return eo(()=>{if(2!==e.length||e[0]!==e[1])throw new lb("Identity matrix initializer can only be used for 2D square matrices.");return bo(this.gain,bl(e[0]))})}getConfig(){return{gain:this.gain}}};Ey.className="Identity",Op.registerClass(Ey);var _y=class extends ky{constructor(e){if(super(),e.scale<0)throw new lb("scale must be a positive float. Got: ".concat(e.scale));this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function(e){Ob(xy,"FanMode",e)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function(e){Ob(wy,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){let n=function(e){let t,n,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(Wb(a),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===a){let a=Qb(e,2);t=e[1]*a,n=e[0]*a}else if("channelsLast"===a){let a=Qb(e,0,e.length-2);t=e[e.length-2]*a,n=e[e.length-1]*a}}else{let a=Qb(e);t=Math.sqrt(a),n=Math.sqrt(a)}return[t,n]}(e),a=n[0],r=n[1],s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,a):"fanOut"===this.mode?s/=Math.max(1,r):s/=Math.max(1,(a+r)/2),"normal"===this.distribution){let n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new ub("".concat(this.getClassName()," does not support dType ").concat(t,"."));return Hd(e,0,n,t,this.seed)}{let n=Math.sqrt(3*s);return Ju(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};_y.className="VarianceScaling",Op.registerClass(_y);var Ay=class extends _y{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return _y.className}};Ay.className="GlorotUniform",Op.registerClass(Ay);var Ry=class extends _y{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return _y.className}};Ry.className="GlorotNormal",Op.registerClass(Ry);var Dy=class extends _y{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return _y.className}};Dy.className="HeNormal",Op.registerClass(Dy);var Fy=class extends _y{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return _y.className}};Fy.className="HeUniform",Op.registerClass(Fy);var My=class extends _y{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return _y.className}};My.className="LeCunNormal",Op.registerClass(My);var jy=class extends _y{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return _y.className}};jy.className="LeCunUniform",Op.registerClass(jy);var zy=class extends ky{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return eo(()=>{if(e.length<2)throw new ub("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError("Unsupported data type ".concat(t,"."));t=t;let n=Nr.sizeFromShape(e.slice(0,-1)),a=e[e.length-1],r=n*a;r>this.ELEMENTS_WARN_SLOW&&console.warn("Orthogonal initializer is being called on a matrix with more than ".concat(this.ELEMENTS_WARN_SLOW," (").concat(r,") elements: Slowness may result."));let s=hy([Math.max(a,n),Math.min(a,n)],0,1,t,this.seed),i=Ip.qr(s,!1),o=i[0],c=i[1].flatten().stridedSlice([0],[Math.min(a,n)*Math.min(a,n)],[Math.min(a,n)+1]);return o=bo(o,c.sign()),n<a&&(o=o.transpose()),bo(il(this.gain),o.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};zy.className="Orthogonal",Op.registerClass(zy);var Ly={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Py(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Ib(e,Op.SerializationMap.getMap().classNameMap,t,"initializer")}function By(e){return wb(e)}function Wy(e){if("string"==typeof e){let t=e in Ly?Ly[e]:e;if("GlorotNormal"===t)return new Ry;if("GlorotUniform"===t)return new Ay;if("HeNormal"===t)return new Dy;if("HeUniform"===t)return new Fy;if("LeCunNormal"===t)return new My;if("LeCunUniform"===t)return new jy;{let e={};return e.className=t,e.config={},Py(e)}}return e instanceof ky?e:Py(e)}function Uy(e){return Array.isArray(e)&&Array.isArray(e[0])}function Vy(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Gy(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new lb("Expected Tensor length to be 1; got ".concat(e.length));t=e[0]}else t=e;return t}function Hy(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return(e=e)[0];throw new lb("Expected exactly 1 Shape; got ".concat(e.length))}return e}function qy(e){let t=0;for(let n of e)0===n.shape.length?t+=1:t+=n.shape.reduce((e,t)=>e*t);return t}var Ky="Variable",Xy=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ky,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=Rb(),n=null==n?Ky:n,this.originalName=qb(n),this.name=Kb(this.originalName),this.trainable_=a,this.constraint=r,this.val=Yd(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function Zy(e){return e.map(e=>e.read())}function Yy(e){e.forEach(e=>{e[0].write(e[1])})}var Jy=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},Qy=class{constructor(e,t,n,a,r,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=i,this.id=Rb(),null!=s&&(this.originalName=qb(s),this.name=Kb(this.originalName)),this.rank=t.length}},$y=0,ev=class{constructor(e,t){this.callArgs=t,this.id=$y++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},tv=0,nv=class extends Op.Serializable{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=tv++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let e=this.getClassName();t=yb(e)+"_"+Fb(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new cb("The layer has never been called and thus has no defined ".concat(t,"."));if(this.inboundNodes.length<=e)throw new lb("Asked to get ".concat(t," at node ").concat(e,", but the layer has only ").concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[e]}getInputAt(e){return gb(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return gb(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ob("Layer ".concat(this.name,' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.'));if(0===this.inboundNodes.length)throw new ob("Layer ".concat(this.name," is not connected, no input to return."));return gb(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new ob("Layer ".concat(this.name," has no inbound nodes."));if(this.inboundNodes.length>1)throw new ob("Layer ".concat(this.name,' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.'));return gb(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=bb(e),null==this.inputSpec||0===this.inputSpec.length)return;let t=bb(this.inputSpec);if(e.length!==t.length)throw new lb("Layer ".concat(this.name," expects ").concat(t.length," inputs, but it received ").concat(e.length," input tensors. Input received: ").concat(e));for(let n=0;n<e.length;n++){let a=e[n],r=t[n];if(null==r)continue;let s=a.rank;if(null!=r.ndim&&s!==r.ndim)throw new lb("Input ".concat(n," is incompatible with layer ").concat(this.name,": expected ndim=").concat(r.ndim,", found ndim=").concat(s));if(null!=r.maxNDim&&s>r.maxNDim)throw new lb("Input ".concat(n," is incompatible with layer ").concat(this.name,": expected max_ndim=").concat(r.maxNDim,", found ndim=").concat(s));if(null!=r.minNDim&&s<r.minNDim)throw new lb("Input ".concat(n," is incompatible with layer ").concat(this.name,": expected min_ndim=").concat(r.minNDim,", found ndim=").concat(s,"."));if(null!=r.dtype&&a.dtype!==r.dtype)throw new lb("Input ".concat(n," is incompatible with layer ").concat(this.name," : expected dtype=").concat(r.dtype,", found dtype=").concat(a.dtype,"."));if(r.axes){let e=a.shape;for(let t in r.axes){let a=Number(t),s=r.axes[t],i=a>=0?e[a]:e[e.length+a];if(null!=s&&-1===[s,null].indexOf(i))throw new lb("Input ".concat(n," is incompatible with layer ").concat(this.name,": expected axis ").concat(a," of input shape to have value ").concat(s," but got shape ").concat(e,"."))}}if(null!=r.shape)for(let e=0;e<r.shape.length;++e){let t=r.shape[e],s=a.shape[e];if(null!=t&&null!=s&&t!==s)throw new lb("Input ".concat(n," is incompatible with layer ").concat(this.name,": expected shape=").concat(r.shape,", found shape=").concat(a.shape,"."))}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=bb(e),a=!0;for(let s of n)if(!(s instanceof Qy)){a=!1;break}let r=!0;for(let s of n)if(s instanceof Qy){r=!1;break}if(a===r)throw new lb("Arguments to apply() must be all SymbolicTensors or all Tensors");return Hb(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let t=[];for(let n of bb(e))t.push(n.shape);this.build(gb(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let a=this.call(e,t),r=bb(a),s=[];for(let e of r)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(a=gb(s),null!=this.activityRegularizer)throw new ub("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}{let n,a=function(e){e=bb(e);let t=[];for(let n of e)t.push(n.shape);return gb(t)}(e),r=this.computeOutputShape(a),s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),n=null!=r&&r.length>0&&Array.isArray(r[0])?r.map((n,a)=>new Qy(s,n,this,bb(e),t,this.name,a)):new Qy(s,r,this,bb(e),t,this.name),this.addInboundNode(e,n,null,null,a,r,t),this._refCount++,null!=this.activityRegularizer)throw new ub("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return n}})}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: ".concat(JSON.stringify(e),") does not match that of the batchInputShape (").concat(JSON.stringify(this.batchInputShape),") of the layer ").concat(this.name));else{let t=!1;this.batchInputShape.forEach((n,a)=>{null!=n&&null!=e[a]&&e[a]!==n&&(t=!0)}),t&&console.warn("The shape of the input tensor (".concat(JSON.stringify(e),") does not match the expectation of layer ").concat(this.name,": ").concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new ob("The layer ".concat(this.name," has never been called and thus has no defined output shape."));let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new ob("The layer ".concat(this.name,' has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.'))}countParams(){if(!this.built)throw new cb("You tried to call countParams() on ".concat(this.name,", but the layer is not built yet. Build it first by calling build(batchInputShape)."));return qy(this.weights)}build(e){this.built=!0}getWeights(){return Zy(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){eo(()=>{let t=this.weights;if(t.length!==e.length)throw new lb('You called setWeights(weights) on layer "'.concat(this.name,'" with a weight list of length ').concat(e.length,", but the layer was expecting ").concat(t.length," weights. Provided weights: ").concat(e,"..."));if(0===t.length)return;let n=[],a=Zy(t);for(let r=0;r<a.length;++r){let s=a[r],i=t[r],o=e[r];if(!Nr.arraysEqual(s.shape,o.shape))throw new lb("Layer weight shape ".concat(s.shape," not compatible with provided weight shape ").concat(o.shape));n.push([i,o])}Yy(n)})}addWeight(e,t,n,a,r,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new lb("Duplicate weight name ".concat(e," for layer ").concat(this.name));this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(a=null!=o?o():Wy("zeros"));let c=a.apply(t,n),l=new Xy(c,n,e,s,i);return c.dispose(),null!=r&&this.addLoss(()=>r.apply(l.read())),null==s&&(s=!0),s?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=bb(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer ".concat(this.name," does not support masking, but was passed an inputMask."));t.forEach(e=>{if(null!=e)throw new TypeError("Layer ".concat(this.name," does not support masking, but was passed an inputMask."))})}return null}return t}addInboundNode(e,t,n,a,r,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=bb(e);t=bb(t),n=bb(n),a=bb(a),r=Vy(r),s=Vy(s);let c=[],l=[],u=[];for(let d of o)c.push(d.sourceLayer),l.push(d.nodeIndex),u.push(d.tensorIndex);new ev({outboundLayer:this,inboundLayers:c,nodeIndices:l,tensorIndices:u,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:s},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been built yet."));if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used yet."));this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};var av=class extends nv{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Fb("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new lb("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new lb("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new lb("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let a=new Qy(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new ev({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new lb("Cannot pass any input to an InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};function rv(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new lb("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new av({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}av.className="InputLayer",Op.registerClass(av);var sv=class{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof sv)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new lb("Duplicate key: name=".concat(e.name,", id=").concat(e.id));return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Vi(t,e.dtype)}catch(n){throw new lb("The dtype of the feed (".concat(t.dtype,") can not be cast to the dtype of the key '").concat(e.name,"' (").concat(e.dtype,")."))}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Qy){if(null==this.id2Value[e.id])throw new lb("Nonexistent key: ".concat(e.name));return this.id2Value[e.id]}{let t=this.name2Id[e];if(null==t)throw new lb("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Value[t]}}getMask(e){if(e instanceof Qy){if(null==this.id2Value[e.id])throw new lb("Nonexistent key: ".concat(e.name));return this.id2Mask[e.id]}{let t=this.name2Id[e];if(null==t)throw new lb("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&to(this.id2Mask)}},iv=new hb,ov=new hb;function cv(e,t,n,a){let r=null!=n&&n.training,s=Array.isArray(e),i=s?e:[e],o=i.map(e=>e.name),c=[],l=t.names();for(let f of o)-1!==l.indexOf(f)?c.push(t.getValue(f)):c.push(null);null!=a&&(a.maxNumTensors=-1/0,a.minNumTensors=1/0);let u,d=o.join(",")+"|"+t.names().sort().join(","),h=iv.get(d);if(null==h){let e=function(e,t){Nr.assert(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],a={};if(1===e.length){let r=uv(e[0],t);n=r.sorted,a=r.recipientMap}else{let r=new Set;for(let s of e){let{sorted:e,recipientMap:i}=uv(s,t);for(let t of e)r.has(t.name)||(n.push(t),r.add(t.name));for(let t in i)null==a[t]&&(a[t]=new Set),i[t].forEach(e=>a[t].add(e))}}return{sorted:n,recipientCounts:lv(a)}}(i,t);h=e.sorted,u=e.recipientCounts,iv.put(d,h),ov.put(d,u)}u={},r||Object.assign(u,ov.get(d));let p=new sv(t);for(let f=0;f<h.length;++f){if(null!=a){let e=Qi().numTensors;e>a.maxNumTensors&&(a.maxNumTensors=e),e<a.minNumTensors&&(a.minNumTensors=e)}let e=h[f],s=e.sourceLayer;if(s instanceof av)continue;let i=[],l=[],d=[],m=!1;for(let n of e.inputs){let e=p.getValue(n),a=p.getMask(n);i.push(e),l.push(a),null!=a&&(m=!0),r||(u[n.name]--,0===u[n.name]&&!t.hasKey(n)&&-1===o.indexOf(n.name)&&!e.isDisposed&&!0!==n.sourceLayer.stateful&&d.push(e))}m&&((n=n||{}).mask=l[0]);let g=bb(s.apply(i,n)),b=null;s.supportsMasking&&(b=s.computeMask(i,l));let y=dv(e),v=Array.isArray(y)?y:[y];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(b)?b[0]:b);let e=o.indexOf(v[t].name);-1!==e&&(c[e]=g[t])}r||to(d)}return p.disposeMasks(),s?c:c[0]}function lv(e){let t={};for(let n in e)t[n]=e[n].size;return t}function uv(e,t){let n=new Set,a=[],r={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let e=s[s.length-1];if(n.has(e.name)){s.pop();continue}let t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),a.push(e),n.add(e.name),t&&i.pop();else{i.push(s.length-1);for(let t of e.inputs)null==r[t.name]&&(r[t.name]=new Set),r[t.name].add(e.name),!n.has(t.name)&&s.push(t)}}return{sorted:a,recipientMap:r}}function dv(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(let a of e.sourceLayer.inboundNodes[t].outputTensors)if(a.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}Ue().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,(function(e){null!=iv&&iv.setMaxEntries(e),null!=ov&&ov.setMaxEntries(e)}));var hv={};function pv(e,t){return eo(()=>ol(ll(bo(e,e),t,!0)))}y(hv,{maxNorm:()=>Iv,minMaxNorm:()=>Tv,nonNeg:()=>Nv,unitNorm:()=>Sv});var fv=class extends Op.Serializable{getConfig(){return{}}},mv=class extends fv{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return eo(()=>{let t=pv(e,this.axis),n=mc(t,0,this.maxValue);return bo(e,go(n,fo(ny(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};mv.className="MaxNorm",Op.registerClass(mv);var gv=class extends fv{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return eo(()=>go(e,fo(ny(),pv(e,this.axis))))}getConfig(){return{axis:this.axis}}};gv.className="UnitNorm",Op.registerClass(gv);var bv=class extends fv{apply(e){return nd(e)}};bv.className="NonNeg",Op.registerClass(bv);var yv=class extends fv{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return eo(()=>{let t=pv(e,this.axis),n=fo(bo(this.rate,mc(t,this.minValue,this.maxValue)),bo(1-this.rate,t));return bo(e,go(n,fo(ny(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};yv.className="MinMaxNorm",Op.registerClass(yv);var vv={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function xv(e){return wb(e)}function wv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Ib(e,Op.SerializationMap.getMap().classNameMap,t,"constraint")}function kv(e){if(null==e)return null;if("string"==typeof e){return wv({className:e in vv?vv[e]:e,config:{}})}return e instanceof fv?e:wv(e)}function Iv(e){return new mv(e)}function Sv(e){return new gv(e)}function Nv(){return new bv}function Tv(e){return new yv(e)}var Ov={};function Cv(){return new Iy}function Ev(){return new Sy}function _v(e){return new Ny(e)}function Av(e){return new Ty(e)}function Rv(e){return new Oy(e)}function Dv(e){return new Cy(e)}function Fv(e){return new Ey(e)}function Mv(e){return new _y(e)}function jv(e){return new Ay(e)}function zv(e){return new Ry(e)}function Lv(e){return new Dy(e)}function Pv(e){return new Fy(e)}function Bv(e){return new My(e)}function Wv(e){return new jy(e)}function Uv(e){return new zy(e)}y(Ov,{constant:()=>_v,glorotNormal:()=>zv,glorotUniform:()=>jv,heNormal:()=>Lv,heUniform:()=>Pv,identity:()=>Fv,leCunNormal:()=>Bv,leCunUniform:()=>Wv,ones:()=>Ev,orthogonal:()=>Uv,randomNormal:()=>Rv,randomUniform:()=>Av,truncatedNormal:()=>Dv,varianceScaling:()=>Mv,zeros:()=>Cv});var Vv,Gv={};async function Hv(e){if(null==e)return;let t=[],n=[],a=[];for(let r in e){let s=e[r];if("number"!=typeof s){let e=s;t.push(e.data()),n.push(r),a.push(e)}}if(t.length>0){let r=await Promise.all(t);for(let t=0;t<r.length;++t)e[n[t]]=r[t][0];to(a)}}function qv(e){if(null!=e)for(let t in e){let n=e[t];"number"!=typeof n&&n.dispose()}}y(Gv,{Layer:()=>nv,RNN:()=>rk,RNNCell:()=>sk,activation:()=>LI,add:()=>KI,alphaDropout:()=>zS,average:()=>XI,averagePooling1d:()=>aS,averagePooling2d:()=>iS,averagePooling3d:()=>lS,avgPool1d:()=>rS,avgPool2d:()=>oS,avgPool3d:()=>uS,avgPooling1d:()=>sS,avgPooling2d:()=>cS,avgPooling3d:()=>dS,batchNormalization:()=>eS,bidirectional:()=>ES,categoryEncoding:()=>US,centerCrop:()=>BS,concatenate:()=>ZI,conv1d:()=>EI,conv2d:()=>_I,conv2dTranspose:()=>AI,conv3d:()=>RI,conv3dTranspose:()=>DI,convLstm2d:()=>NS,convLstm2dCell:()=>TS,cropping2D:()=>MI,dense:()=>PI,depthwiseConv2d:()=>zI,dot:()=>$I,dropout:()=>BI,elu:()=>II,embedding:()=>qI,flatten:()=>UI,gaussianDropout:()=>jS,gaussianNoise:()=>MS,globalAveragePooling1d:()=>hS,globalAveragePooling2d:()=>pS,globalMaxPool1d:()=>AS,globalMaxPool2d:()=>RS,globalMaxPooling1d:()=>fS,globalMaxPooling2d:()=>mS,gru:()=>vS,gruCell:()=>xS,input:()=>sw,inputLayer:()=>kI,layerNormalization:()=>tS,leakyReLU:()=>NI,lstm:()=>wS,lstmCell:()=>kS,masking:()=>LS,maxPool1d:()=>DS,maxPool2d:()=>FS,maxPooling1d:()=>gS,maxPooling2d:()=>bS,maxPooling3d:()=>yS,maximum:()=>YI,minimum:()=>JI,multiply:()=>QI,permute:()=>HI,prelu:()=>TI,randomWidth:()=>VS,reLU:()=>SI,repeatVector:()=>VI,rescaling:()=>PS,reshape:()=>GI,resizing:()=>WS,rnn:()=>OS,separableConv2d:()=>FI,simpleRNN:()=>IS,simpleRNNCell:()=>SS,softmax:()=>OI,spatialDropout1d:()=>WI,stackedRNNCells:()=>CS,thresholdedReLU:()=>CI,timeDistributed:()=>_S,upSampling2d:()=>jI,zeroPadding2d:()=>nS}),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(Vv||(Vv={}));var Kv=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},Xv=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},Zv=class extends Kv{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});let n=null==t.size?0:t.size;this.seen+=n;for(let a in t){let e=t[a];if("number"==typeof e)this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+e*n;else{let t;a in this.totals?t=this.totals[a]:this.totals[a]=0;let r=eo(()=>fo(this.totals[a],bo(e,n)));this.totals[a]=r,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(let n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?t[n]=this.totals[n]/this.seen:eo(()=>{let e=bo(go(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),no(t[n])}))}},Yv=class extends Kv{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(let n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let r in this.history){let a=this.history[r];for(let s=0;s<a.length;++s)if("number"!=typeof a[s]){let i=a[s];e.push(i.data()),t.push(r),n.push(s)}}let a=await Promise.all(e);for(let r=0;r<a.length;++r)this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=a[r][0]}},Jv=class extends Kv{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Vf,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Nr.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let a,r=null!=n?n():Nr.now();return function(){let s=null!=n?n():Nr.now();return s-r<t||(r=s,a=e(...arguments)),a}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let a=[];null!=this.yield&&(await Hv(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await Hv(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];null!=this.epochEnd&&(await Hv(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await Hv(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];null!=this.batchEnd&&(await Hv(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Nr.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await Hv(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await Hv(e),await this.trainEnd(e))}};function Qv(e,t){return null==e&&(e={}),e instanceof Kv?[e]:Array.isArray(e)&&e[0]instanceof Kv?e:bb(e).map(e=>new Jv(e,t))}var $v=class{constructor(){}static registerCallbackConstructor(e,t){Nr.assert(e>=0&&Number.isInteger(e),()=>"Verbosity level is expected to be an integer >= 0, but got ".concat(e)),$v.checkForDuplicate(t),null==$v.constructors[e]&&($v.constructors[e]=[]),$v.constructors[e].push(t)}static checkForDuplicate(e){for(let t in $v.constructors)$v.constructors[+t].forEach(t=>{if(t===e)throw new lb("Duplicate callback constructor.")})}static clear(){$v.constructors={}}static createCallbacks(e){let t=[];for(let n in $v.constructors){let a=+n;e>=a&&t.push(...$v.constructors[a])}return t.map(e=>new e)}};function ex(e,t,n,a,r,s,i,o,c){let l=new Yv,u=[new Zv,...$v.createCallbacks(t)];null!=e&&u.push(...e),u.push(l);let d=new Xv(u);return d.setParams({epochs:n,initialEpoch:a,samples:r,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:c}),{callbackList:d,history:l}}function tx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Ib(e,Op.SerializationMap.getMap().classNameMap,t,"layer",n)}function nx(e,t){return eo(()=>{"float32"!==e.dtype&&(e=Vi(e,"float32"));let n=ll(my(e),t,!0),a=fc(n.shape,ny()),r=ol(nu(n,a));return go(e,r)})}function ax(e,t){return eo(()=>au(my(Vl(t,e)),-1))}function rx(e,t){return eo(()=>au(yo(Vl(t,e)),-1))}function sx(e,t){return eo(()=>{let n=Vl(e,t),a=mc(yo(e),ny(),Number.MAX_VALUE),r=yo(go(n,a));return bo(100,au(r,-1))})}function ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return eo(()=>{if(n)t=wd(t);else{let e=ll(t,t.shape.length-1,!0);t=go(t,e)}return t=mc(t,ny(),1-ny()),Bl(ll(bo(Vi(e,"float32"),Al(t)),t.shape.length-1))})}function ox(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return eo(()=>{let a=Vi(yl(sy(e)),"int32"),r=(t=mc(t,ny(),1-ny())).shape;return ix(Xo(fu(a,r[r.length-1]),r),t,n)})}function cx(e,t){return eo(()=>{let n;return n=mc(t,ny(),1-ny()),n=Al(go(n,Vl(1,n))),au(function(e,t){if(!Nr.arraysEqual(e.shape,t.shape))throw new lb("logits and labels must have the same shape, but got shapes ".concat(JSON.stringify(e.shape)," and ").concat(JSON.stringify(t.shape)));return eo(()=>{let n=nd(t),a=Bl(yo(t));return fo(Vl(n,bo(t,e)),Rl(pl(a)))})}(e,n),-1)})}function lx(e,t){return eo(()=>{let n=nx(e,-1),a=nx(t,-1),r=bo(n,a);return Bl(ll(r,-1))})}$v.constructors={};var ux={meanSquaredError:ax,meanAbsoluteError:rx,meanAbsolutePercentageError:sx,meanSquaredLogarithmicError:function(e,t){return eo(()=>{let n=mc(t,ny(),Number.MAX_VALUE),a=Al(fo(1,n)),r=mc(e,ny(),Number.MAX_VALUE),s=Al(fo(1,r));return au(my(Vl(a,s)),-1)})},squaredHinge:function(e,t){return eo(()=>{let n=nu(0,Vl(1,bo(e,t)));return au(my(n),-1)})},hinge:function(e,t){return eo(()=>{let n=nu(0,Vl(1,bo(e,t)));return au(n,-1)})},categoricalHinge:function(e,t){return eo(()=>{let n=ll(bo(e,t),-1),a=al(bo(Vl(1,e),t),-1);return nu(0,fo(1,Vl(a,n)))})},logcosh:function(e,t){return eo(()=>{let n=Math.log(2),a=Vl(t,e),r=Vl(fo(a,Wl(bo(-2,a))),n);return au(r,-1)})},categoricalCrossentropy:ix,sparseCategoricalCrossentropy:ox,binaryCrossentropy:cx,kullbackLeiblerDivergence:function(e,t){return eo(()=>{let n=mc(e,ny(),1),a=mc(t,ny(),1);return ll(bo(e,Al(go(n,a))),-1)})},poisson:function(e,t){return eo(()=>{let n=Al(fo(ny(),t));return au(Vl(t,bo(e,n)),-1)})},cosineProximity:lx};function dx(e){if("string"==typeof e){if(e in ux)return ux[e];let t="Unknown loss ".concat(e);throw e.toLowerCase().includes("softmaxcrossentropy")&&(t="Unknown loss ".concat(e,'. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy')),new lb(t)}return e}function hx(e,t){return eo(()=>{let n=bo(.5,mu(t)),a=ay(xl(t,n),e.dtype);return au(Bc(e,a),-1)})}function px(e,t){return eo(()=>ay(Bc(So(e,-1),So(t,-1)),"float32"))}function fx(e,t){return eo(()=>Vi(ll(ql(Bc(e,1),Bc(t,1))),"float32"))}function mx(e,t){return eo(()=>{let n=fx(e,t),a=function(e,t){return eo(()=>Vi(ll(ql(Bc(e,0),Bc(t,1))),"float32"))}(e,t),r=fo(n,a);return Vi(Wc(xl(r,0),go(n,r),0),"float32")})}function gx(e,t){return eo(()=>{let n=fx(e,t),a=function(e,t){return eo(()=>Vi(ll(ql(Bc(e,1),Bc(t,0))),"float32"))}(e,t),r=fo(n,a);return Vi(Wc(xl(r,0),go(n,r),0),"float32")})}function bx(e,t){return cx(e,t)}function yx(e,t){return e.rank===t.rank&&(e=Cd(e,[e.rank-1])),(t=So(t,-1)).dtype!==e.dtype&&(t=Vi(t,e.dtype)),Vi(Bc(e,t),"float32")}var vx=ix,xx=ox,wx={binaryAccuracy:hx,categoricalAccuracy:px,precision:mx,categoricalCrossentropy:vx,sparseCategoricalCrossentropy:xx,mse:ax,MSE:ax,mae:rx,MAE:rx,mape:sx,MAPE:sx,cosine:lx};function kx(e){if("string"==typeof e&&e in wx)return wx[e];if("string"!=typeof e&&null!=e)return e;throw new lb("Unknown metric ".concat(e))}function Ix(e){if(fb(null!==e,"Unknown LossOrMetricFn ".concat(e)),"string"==typeof e)return e;{let t;for(let n of Object.keys(ux))if(ux[n]===e){t=n;break}if(void 0!==t)return t;for(let n of Object.keys(wx))if(wx[n]===e){t=n;break}return void 0!==t?t:e.name}}function Sx(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!Nx(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let n=JSON.stringify(e);n.length>1048576&&console.warn('User-defined metadata of model "'.concat(t,'" is too large in size (length=').concat(n.length," when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576."))}}function Nx(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if("string"!=typeof n||!Nx(e[n]))return!1;return!0}if(Array.isArray(e)){for(let t of e)if(!Nx(t))return!1;return!0}return!1}{let t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function Tx(e){let t;return t=null!=e.collectedTrainableWeights?qy(e.collectedTrainableWeights):qy(e.trainableWeights),t}function Ox(e){let t=!0,n=[],a=[];for(let r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(let r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(let r of e.layers){let e=!1;for(let n of r.inboundNodes)if(-1!==a.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}function Cx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,a="";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+" "),a+=e[r],a=a.slice(0,t[r]),a+=" ".repeat(t[r]-a.length);n(a)}function Ex(e,t,n){let a,r;try{r=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(o){r="multiple"}try{a=JSON.stringify(e.outputShape)}catch(o){a="multiple"}let s=e.name,i=e.getClassName();Cx(["".concat(s," (").concat(i,")"),r,a,e.countParams().toString()],t,n)}function _x(e,t,n,a){let r,s;try{s=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(u){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch(u){r="multiple"}let i=[];for(let d of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(d)))for(let e=0;e<d.inboundLayers.length;++e){let t=d.inboundLayers[e].name,n=d.nodeIndices[e],a=d.tensorIndices[e];i.push("".concat(t,"[").concat(n,"][").concat(a,"]"))}let o=e.name,c=e.getClassName(),l=0===i.length?"":i[0];Cx(["".concat(o," (").concat(c,")"),s,r,e.countParams().toString(),l],t,a);for(let d=1;d<i.length;++d)Cx(["","","","",i[d]],t,a)}function Ax(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function Rx(e,t){if(null===e)return null;if("string"==typeof e)return vb(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],a=e.length;for(let r=0;r<a;++r){let a=e[r];Ax(t,r,a)?n.push(a):n.push(Rx(a,t))}return n}{let t={};for(let n of Object.keys(e)){let a=e[n];if("name"===n&&"string"==typeof a)t[n]=a;else{let e=vb(n);t[e]=Rx(a,e)}}return t}}var Dx="4.7.0",Fx=class extends nv{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){let e=this.getClassName().toLowerCase();this.name=Fb(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Nb(this.inputs).length!==this.inputs.length)throw new lb("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ".concat(this.inputs.map(e=>e.name)));Nb(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ".concat(this.outputs.map(e=>e.name))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(let b of this.inputs){let e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;fb(0===t,"input layer has >1 nodes"),fb(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let t=this.inputLayers[b];if(!(t instanceof av))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: ".concat(e.inputs,". Input ").concat(b," (0-based) originates from layer type ").concat(t.getClassName(),"."));this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);let t={},n={},a={},r={},s={},i=[],o=(e,t,n,a,r,c)=>{(null==a||null==r||null==c)&&(a=e.sourceLayer,r=e.nodeIndex,c=e.tensorIndex);let l=a.inboundNodes[r];if(-1!==n.indexOf(l))throw new cb("The tensor ".concat(e.name,' at layer "').concat(a.name,'" is part of a cycle.'));if(-1!==t.indexOf(l))return;this.containerNodes.add(Fx.nodeKey(a,r)),a.id in s||(s[a.id]=Object.keys(s).length),-1===n.indexOf(l)&&n.push(l);let u=l.inboundLayers.length;for(let s=0;s<u;s++){let e=l.inputTensors[s],a=l.inboundLayers[s],r=l.nodeIndices[s],i=l.tensorIndices[s];o(e,t,n,a,r,i)}for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);i.push(l)},c=[],l=[];for(let b of this.outputs)o(b,c,l);let u=i.slice().reverse();for(let b of u){n[b.id]=b,b.id in t||(t[b.id]=0);let e=t[b.id],s=null==a[b.outboundLayer.id]?0:a[b.outboundLayer.id];e=Math.max(e,s),a[b.outboundLayer.id]=e,r[b.outboundLayer.id]=b.outboundLayer,t[b.id]=e;for(let a=0;a<b.inboundLayers.length;a++){let r=b.inboundLayers[a],s=b.nodeIndices[a],i=r.inboundNodes[s],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}let d={};for(let b in t){let e=t[b];e in d||(d[e]=[]),d[e].push(n[b])}let h={};for(let b in a){let e=a[b];e in h||(h[e]=[]),h[e].push(r[b])}let p=Object.keys(h).map(e=>parseInt(e,10)).sort(Sb);this.layers=[];for(let b of p){let e=h[b];e.sort((e,t)=>{let n=s[e.id],a=s[t.id];return n<a?-1:n>a?1:0});for(let t of e)t instanceof Fx&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=h,p=Object.keys(d).map(e=>parseInt(e,10)).sort(Sb);let f=this.inputs.slice(),m=[];for(let b of p)for(let e of d[b]){let t=e.outboundLayer;if(null!=t){for(let n of e.inputTensors)if(-1===f.indexOf(n))throw new cb("Graph disconnected: cannot obtain value for tensor ".concat(n,' at layer "').concat(t.name,'". The following previous layers were accessed without issue: ').concat(m));for(let t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=d;let g=this.layers.map(e=>e.name);for(let b of g){let e=g.filter(e=>e===b).length;if(1!==e)throw new cb('The name "'.concat(b,'" is used ').concat(e," times in the model. All layer names should be unique. Layer names: ")+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new ev({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new lb("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n={},a=0;for(let s of this.layers)for(let e of s.weights){if(null!=n[e.originalName])throw new lb("Duplicate weight name: ".concat(e.originalName));n[e.originalName]=e,a++}let r=[];for(let s in e){let a=s;if(null==n[s]){let e=s.split("/");a=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[a])r.push([n[a],e[s]]);else if(t)throw new lb("Provided weight data has no target variable: ".concat(s));delete n[a]}if(t){let e=[];for(let t in n)e.push(t);if(e.length>0)throw new lb("".concat(e.length," of ").concat(a," weights are not set: ").concat(e))}Yy(r)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers ".concat(Dx),t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=function e(t,n){if(null==t)return null;if("string"==typeof t)return yb(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){let a=[],r=t.length;for(let s=0;s<r;++s){let r=t[s];Ax(n,s,r)?a.push(r):a.push(e(r,n))}return a}{let n={};for(let a of Object.keys(t)){let r=t[a],s=yb(a);n[s]="name"!==a&&"className"!==a||"string"!=typeof r?e(r,a):r}return n}}(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return eo(()=>{e=bb(e);let n=new sv;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return cv(this.outputs,n,t)})}computeMask(e,t){return eo(()=>{let n;return e=bb(e),n=null==t?pb(null,e.length):bb(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){let t=Vy(e);if(t.length!==this.inputLayers.length)throw new lb("Invalid inputShape argument ".concat(e,": model has ").concat(this.inputLayers.length," tensor inputs."));let n={};for(let i=0;i<t.length;i++){let e=this.inputLayers[i],a=t[i];n[e.name+"_0_0"]=a}let a=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(Sb);if(a.length>1)for(let i of a){let e=this.nodesByDepth[i];for(let t of e){let e=t.outboundLayer;if(-1!==this.inputLayers.map(e=>e.id).indexOf(e.id))continue;let a=[];for(let i=0;i<t.inboundLayers.length;i++){let e=t.inboundLayers[i],r=t.nodeIndices[i],s=t.tensorIndices[i],o=n["".concat(e.name,"_").concat(r,"_").concat(s)];a.push(o)}let r=Vy(e.computeOutputShape(gb(a))),s=e.inboundNodes.indexOf(t);for(let t=0;t<r.length;t++){n["".concat(e.name,"_").concat(s,"_").concat(t)]=r[t]}}}let r=[],s=[];for(let i=0;i<this.outputLayers.length;i++){let e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],a="".concat(e.name,"_").concat(t,"_").concat(n);s.push(a)}for(let i=0;i<s.length;i++){let e=s[i];fb(e in n),r.push(n[e])}return gb(r)}runInternalGraph(e,t){null==t&&(t=pb(null,e.length));let n={};for(let o=0;o<this.inputs.length;++o){let a=this.inputs[o],r=e[o],s=t[o];n[a.id]=[r,s]}let a=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(Sb);for(let o of a){let e=this.nodesByDepth[o];for(let t of e){let e=t.outboundLayer,a=t.inputTensors,r=t.outputTensors,s=new Array;for(let t of a)t.id in n&&s.push(n[t.id]);if(s.length===a.length){let a,i,o,c,l={};if(null!=t.callArgs&&(l=t.callArgs),1===s.length){let[t,n]=s[0];null==l.mask&&(l.mask=n),o=bb(e.call(t,l)),c=bb(e.computeMask(t,n)),a=[t],i=[n]}else a=s.map(e=>e[0]),i=s.map(e=>e[1]),null==l.mask&&(l.mask=i),o=bb(e.call(a,l)),c=bb(e.computeMask(a,i));if(e.activityRegularizer)throw new ub("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<r.length;++e){let t=r[e],a=o[e],s=c[e];n[t.id]=[a,s]}}}}let r=[],s=[],i=[];for(let o of this.outputs){fb(o.id in n,"Could not compute output ".concat(o.name," : ").concat(o.id));let[e,t]=n[o.id];i.push(e.shape),r.push(e),s.push(t)}return[r,s,i]}buildNodeConversionMap(e){let t,n={};for(let a of this.layers){t=a instanceof Fx?1:0;for(let e=0;e<a.inboundNodes.length;e++){let r=Fx.nodeKey(a,e);this.containerNodes.has(r)&&(n[r]=t,t+=1)}}return n}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new lb("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(let n of this.layers)if(n.name===e)return n;throw new lb("No such layer: ".concat(e))}findLayer(e){if(this.layers.length<=e)throw new lb("Was asked to retrieve layer at index ".concat(e,", but model only has ").concat(this.layers.length," layer(s)."));return this.layers[e]}calculateLosses(){return eo(()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let a=Fx.nodeKey(t,n);this.containerNodes.has(a)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let i of this.layers){let e=i.getClassName(),a=i.getConfig(),r=[];for(let n=0;n<i.inboundNodes.length;n++){let e=i.inboundNodes[n],a=Fx.nodeKey(i,n),o={};if(this.containerNodes.has(a)){if(e.callArgs)try{JSON.stringify(e.callArgs),o=e.callArgs}catch(s){console.warn("Layer ".concat(i.name," was passed non-serializable keyword arguments: ").concat(e.callArgs,". They will not be included in the serialized model (and thus will be missing at deserialization time).")),o={}}if(e.inboundLayers.length>0){let n=[];for(let a=0;a<e.inboundLayers.length;a++){let r=e.inboundLayers[a],s=e.nodeIndices[a],i=e.tensorIndices[a],c=t[Fx.nodeKey(r,s)];null==c&&(c=0),n.push([r.name,c,i,o])}r.push(n)}}}let o={};o.name=i.name,o.className=e,o.config=a,o.inboundNodes=r,n.push(o)}e.layers=n;let a=[];for(let i=0;i<this.inputLayers.length;i++){let e=this.inputLayers[i],n=this.inputLayersNodeIndices[i],r=Fx.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let s=t[r];null==s&&(s=0);let o=this.inputLayersTensorIndices[i];a.push([e.name,s,o])}e.inputLayers=a;let r=[];for(let i=0;i<this.outputLayers.length;i++){let e=this.outputLayers[i],n=this.outputLayersNodeIndices[i],a=Fx.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let s=t[a];null==s&&(s=0);let o=this.outputLayersTensorIndices[i];r.push([e.name,s,o])}return e.outputLayers=r,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={},r={};function s(e,t){e.name in r?r[e.name].push(t):r[e.name]=[t]}function i(e,t){let n,r=[];for(let i of t){let o=i[0],c=i[1],l=i[2];if(n=null==i[3]?{}:i[3],!(o in a))return void s(e,t);let u=a[o];if(u.inboundNodes.length<=c)return void s(e,t);let d=u.inboundNodes[c];r.push(d.outputTensors[l])}r.length>0&&e.apply(gb(r),n)}function o(e){let r=e.name,i=tx(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),a[r]=i,e.inboundNodes.forEach(e=>{if(!(e instanceof Array))throw new lb("Corrupted configuration, expected array for nodeData: ".concat(e));s(i,e)})}let c=t.name,l=t.layers;for(let f of l)o(f);for(;!Tb(r);)for(let e of l){let t=a[e.name];if(t.name in r){let e=r[t.name];delete r[t.name];for(let n of e)i(t,n)}}let u=[],d=[],h=t.inputLayers;for(let f of h){let e=f[0],t=f[1],n=f[2];fb(e in a);let r=a[e].inboundNodes[t].outputTensors;u.push(r[n])}let p=t.outputLayers;for(let f of p){let e=f[0],t=f[1],n=f[2];fb(e in a);let r=a[e].inboundNodes[t].outputTensors;d.push(r[n])}return new e({inputs:u,outputs:d,name:c})}get stateful(){if(this._stateful)throw new lb("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){eo(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};function Mx(e,t){return function(e,t,n){let a=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>null);if(1===a)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error("Provided ".concat(n," is an array of ").concat(e.length," element(s), but the model has ").concat(a," outputs. Make sure a set of weights is provided for each model output."));return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){let n=[];return t.forEach(t=>{t in e?n.push(e[t]):n.push(null)}),n}throw new Error("The model has multiple (".concat(a,") outputs, so ").concat(n," must be either an array with ").concat(a," elements or an object with ").concat(t," keys. Provided ").concat(n," not understood: ").concat(JSON.stringify(e)))}(e,t,"classWeight")}async function jx(e,t,n,a){if(null!=t||null!=a)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){let t=eo(()=>{if(1===e.shape.length)return Gi(e);if(2===e.shape.length){if(e.shape[1]>1)return So(e,1);if(1===e.shape[1])return Xo(e,[e.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1],") during handling of class weights. The size is expected to be >= 1."))}throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank,") during handling of class weights. The rank is expected to be 1 or 2."))}),a=Array.from(await t.data());to(t);let r=[];return a.forEach(e=>{if(null==n[e])throw new Error("classWeight must contain all classes in the training data. The class ".concat(e," exists in the data but not in classWeight"));r.push(n[e])}),Dd(r,"float32")}return null}function zx(e,t){return bo(e,t)}function Lx(e,t){let n,a,r=t;n=r.xs,a=r.ys,Nr.assert(null!=n&&null!=a,()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ".concat(t));let s=Px("input",e.inputNames,n),i=Px("output",e.outputNames,a),o=s[0].shape[0];Nr.assert(s.length===e.inputs.length,()=>"LayersModel has ".concat(e.inputs.length," inputs, but the dataset provides ").concat(s.length," inputs.  (Expected input keys: ").concat(JSON.stringify(e.inputNames),")")),Nr.assert(i.length===e.outputs.length,()=>"LayersModel has ".concat(e.outputs.length," outputs, but the dataset provides ").concat(i.length," outputs.  (Expected output keys: ").concat(JSON.stringify(e.outputNames),")"));for(let c=0;c<s.length;c++)Nr.assert(s[c].shape[0]===o,()=>"Batch size mismatch: input ".concat(e.inputNames[c]," has ").concat(s[c].shape[0],"; expected  ").concat(o," based on input ").concat(e.inputNames[0],"."));for(let c=0;c<i.length;c++)Nr.assert(i[c].shape[0]===o,()=>"Batch size mismatch: output ".concat(e.outputNames[c]," has ").concat(i[c].shape[0],"; expected  ").concat(o," based on input ").concat(e.inputNames[0],"."));return{xs:s,ys:i}}function Px(e,t,n){if(n instanceof os)return[n];if(Array.isArray(n))return Nr.assert(n.length===t.length,()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(t.length," to match the ").concat(e," keys ").concat(t,".")),n;{let a=[];for(let r of t){if(null==n[r])throw new lb("The feature data generated by the dataset lacks the required ".concat(e," key '").concat(r,"'."));a.push(n[r])}return a}}async function Bx(e,t,n){let a=null!=n.batchesPerEpoch;if(Nr.assert(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),Nr.assert(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),Nr.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>"For fitDataset(), config.epochs is expected to be a positive integer, but got ".concat(n.epochs)),Nr.assert(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>"For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ".concat(n.batchesPerEpoch)),Nr.assert(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let r,s,i=null!=n.validationData;if(i)if(Wx(n.validationData))Nr.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ".concat(n.validationBatches));else{let e=function(e){if(3===e.length)throw new ub("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);r=e.xs,s=e.ys}let o,c=e.makeTrainFunction(),l=e.getDedupedMetricsNames();o=i?l.slice().concat(l.map(e=>"val_"+e)):l.slice();let u=Qv(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=ex(u,d,n.epochs,null,null,function(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,i,o);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let o={};await h.onEpochBegin(f);let u=0,d=0;for(a||(m=await t.iterator());!a||u<n.batchesPerEpoch;){let t=await m.next();if(a&&t.done){console.warn("You provided `batchesPerEpoch` as ".concat(n.batchesPerEpoch,", but your dataset iterator ran out of data after ").concat(u," batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, ").concat(n.batchesPerEpoch*n.epochs," batches). You may need to use the repeat() function when building your dataset."));break}if(null!=t.value){let{xs:a,ys:r}=Lx(e,t.value),s={};s.batch=d,s.size=a[0].shape[0],await h.onBatchBegin(d,s);let i=[];if(null!=n.classWeight){let t=Mx(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await jx(r[e],null,t[e]))}let o=a.concat(r).concat(i),p=c(o);to(o);for(let e=0;e<l.length;++e){let t=l[e],n=p[e];s[t]=n,no(n)}await h.onBatchEnd(d,s),qv(s),d++,u++}if(a?u>=n.batchesPerEpoch:t.done){if(i){let t;t=Wx(n.validationData)?bb(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):bb(e.evaluate(r,s,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)o["val_".concat(e.metricsNames[n])]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,o),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Wx(e){return"function"==typeof e.iterator}function Ux(e){Nr.assert(e>0&&Number.isInteger(e),()=>"batchSize is required to be a positive integer, but got ".concat(e))}function Vx(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(e=>iy(e,t,n-t)):iy(e,t,n-t)}function Gx(e,t){return eo(()=>null==e?null:Array.isArray(e)?e.map(e=>Gx(e,t)):fy(e,"int32"===t.dtype?t:Vi(t,"int32")))}function Hx(e,t){let n=[],a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}function qx(e){let t=[];e instanceof os&&(e=[e]);for(let n=0;n<e.length;++n){let a=e[n];if(1===a.rank)t.push(ry(a,1));else{if(0===a.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function Kx(e,t){if(null==e)return;let n=[];if(t instanceof os)n.push(t.id);else if(Array.isArray(t))t.forEach(e=>n.push(e.id));else if(null!=t)for(let r in t){let e=t[r];n.push(e.id)}let a=[];if(e instanceof os)-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach(e=>{-1===n.indexOf(e.id)&&a.push(e)});else if(null!=e)for(let r in e){let t=e[r];-1===n.indexOf(t.id)&&a.push(t)}a.forEach(e=>{e.isDisposed||e.dispose()})}function Xx(e){return Array.isArray(e)}function Zx(e){return!function(e){return e instanceof os}(e)&&!Xx(e)}function Yx(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(Xx(e)&&e.length>0)t=!0;else if(Zx(e)){for(let n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new lb("Error when checking model ".concat(s," expected no data, but got ").concat(e))}return[]}if(null==e)return t.map(e=>null);if(Zx(e)){e=e,a=[];for(let n of t){if(null==e[n])throw new lb('No data provided for "'.concat(n,'". Need data for each key in: ').concat(t));a.push(e[n])}}else if(Xx(e)){if((e=e).length!==t.length)throw new lb("Error when checking model ".concat(s,": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ").concat(t.length," Tensor(s), but instead got the following list of Tensor(s): ").concat(e));a=e}else{if(e=e,t.length>1)throw new lb("The model ".concat(s," expects ").concat(t.length," Tensor(s), but only received one Tensor. Found: Tensor with shape ").concat(e.shape));a=[e]}if(a=qx(a),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=a[i];if(e.shape.length!==n[i].length)throw new lb("Error when checking ".concat(s,": expected ").concat(t[i]," to have ").concat(n[i].length," dimension(s). but got array with shape ").concat(e.shape));for(let t=0;t<n[i].length;++t){if(0===t&&!r)continue;let a=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&a!==o)throw new lb("".concat(s," expected a batch of elements where each example has shape [").concat(n[i].slice(1,n[i].length),"] (i.e.,tensor shape [*,").concat(n[i].slice(1,n[i].length),"]) but the ").concat(s," received an input with ").concat(e.shape[0]," examples, each with shape [").concat(e.shape.slice(1,e.shape.length),"] (tensor shape [").concat(e.shape,"])"))}}return a}function Jx(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new lb("Error when checking model ".concat(s,": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ").concat(t.length," Tensor(s), but instead got ").concat(e.length," Tensors(s)."));a=e}else{if(t.length>1)throw new lb("The model expects ".concat(t.length," ").concat(s," Tensors, but only received one Tensor. Found: array with shape ").concat(JSON.stringify(e.shape),"."));a=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=a[i];if(e.shape.length!==n[i].length)throw new lb("Error when checking ".concat(s,": expected ").concat(t[i]," to have ").concat(n[i].length," dimension(s), but got array with shape ").concat(JSON.stringify(e.shape)));for(let a=0;a<n[i].length;++a){if(0===a&&!r)continue;let o=e.shape[a],c=n[i][a];if(null!=c&&c!==o)throw new lb("Error when checking ".concat(s,": expected ").concat(t[i]," to have shape ").concat(JSON.stringify(n[i])," but got array with shape ").concat(JSON.stringify(e.shape),"."))}}}var Qx=class extends Fx{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new lb("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,n){let a,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log,s=Ox(e),i=["Layer (type)","Input Shape","Output shape","Param #"];if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(e=>Math.floor(t*e))),!s){i.push("Receives inputs"),a=[];for(let t in e.nodesByDepth)a.push(...e.nodesByDepth[t])}r("_".repeat(t)),Cx(i,n,r),r("=".repeat(t));let o=e.layers;for(let u=0;u<o.length;++u)s?Ex(o[u],n,r):_x(o[u],n,a,r),r((u===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let c=Tx(e),l=qy(e.nonTrainableWeights);r("Total params: ".concat(c+l)),r("Trainable params: ".concat(c)),r("Non-trainable params: ".concat(l)),r("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){let t={Adagrad:()=>Wf.adagrad(.01),Adadelta:()=>Wf.adadelta(1,.95,ny()),Adam:()=>Wf.adam(.001,.9,.999,ny()),Adamax:()=>Wf.adamax(.002,.9,.999,ny(),0),RMSProp:()=>Wf.rmsprop(.001,.9,0,ny()),SGD:()=>Wf.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new lb("Unknown Optimizer ".concat(e))}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Ap))throw new lb("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new lb("When passing an Array as loss, it should have one entry per model output. The model has ".concat(this.outputs.length," output(s), but you passed loss=").concat(e.loss,"."));t=e.loss.map(e=>dx(e))}else{let n=dx(e.loss);this.outputs.forEach(e=>{t.push(n)})}else{e.loss=e.loss;for(let t in e.loss)if(-1===this.outputNames.indexOf(t))throw new lb('Unknown entry in loss dictionary: "'.concat(t,'". Only expected the following keys: ').concat(this.outputNames));for(let n of this.outputNames)null==e.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ').concat(n," during training")),t.push(dx(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Hb("loss",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}});let a=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>[]);let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ".concat(e));n=e}if(Array.isArray(n))return t.map(e=>n);{let e=[];for(let a of t){let t=n.hasOwnProperty(a)?n[a]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),r=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};Hb("metric",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,a,s;for(let i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){let t,r=this.internalOutputShapes[e];1===r[r.length-1]||this.lossFunctions[e]===cx?-1!==["accuracy","acc"].indexOf(i)?a=hx:-1!==["crossentropy","ce"].indexOf(i)&&(a=bx):this.lossFunctions[e]===ox?-1!==["accuracy","acc"].indexOf(i)?a=yx:-1!==["crossentropy","ce"].indexOf(i)&&(a=xx):-1!==["accuracy","acc"].indexOf(i)?a=px:-1!==["crossentropy","ce"].indexOf(i)&&(a=vx),-1!==["accuracy","acc"].indexOf(i)?t="acc":-1!==["crossentropy","ce"].indexOf(i)&&(t="ce"),s=a,n=""+t}else s=kx(i),n=""+Ix(i);let t;Hb(n,()=>{t=s}),r(e,n,t)}})(a[e])}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=null==n.batchSize?32:n.batchSize;Ux(a);let r=this.standardizeUserDataXY(e,t,!0,a);try{let s=r[0].concat(r[1]);this.makeTestFunction();let i=this.testFunction;return gb(this.testLoop(i,s,a,n.verbose,n.steps))}finally{Kx(r[0],e),Kx(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){let a=null!=(n=n||{}).batches,r=e.testFunction,s=[];if(n.verbose>0)throw new ub("Verbose mode is not implemented yet.");Nr.assert(!a||n.batches>0&&Number.isInteger(n.batches),()=>"Test loop expects `batches` to be a positive integer, but received ".concat(JSON.stringify(n.batches)));let i=function(e){return"function"==typeof e.next}(t)?t:await t.iterator(),o=0,c=0;for(;!a||c<n.batches;){let t=await i.next();if(s=eo(()=>{if(t.value){let{xs:n,ys:a}=Lx(e,t.value),i=n.concat(a),l=eo(()=>r(i));if(to(i),0===c)for(let e=0;e<l.length;++e)s.push(il(0));let u=i[0].shape[0];for(let e=0;e<l.length;++e){let t=l[e],n=s[e];s[e]=eo(()=>fo(s[e],bo(u,t))),c>0&&to(n)}to(l),o+=u,++c}return s}),t.done){a&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, ".concat(n.batches," batches). You may need to use the repeat() function when building your dataset."));break}}for(let l=0;l<s.length;++l){let e=s[l];s[l]=go(s[l],o),to(e)}return gb(s)}(this,e,t)}checkNumSamples(e,t,n){let a,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(a=null,null!=t)throw new lb("If ".concat(r," is set, batchSize must be null or undefined.Got batchSize = ").concat(t))}else{if(null==e)throw new lb("Either the input data should have a defined shape, or ".concat(r," shoud be specified."));a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new lb("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),s=new sv;if(e instanceof os&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new lb("The number of inputs provided (".concat(e.length,") does not match the number of inputs of this model (").concat(this.inputs.length,")."));for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(let o of this.inputs){let t=e[o.name];if(null==t)throw new lb("No value is provided for the model's input ".concat(o.name));s.add(o,t)}let i=cv(r,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=pb(null,e.length),n=e.length;for(let a of this.layers){let r=Array.isArray(a.output)?a.output:[a.output],s=r.map(e=>e.name);for(let a=0;a<e.length;++a){let i=s.indexOf(e[a]);if(-1!==i&&(t[a]=r[i],n--),0===n)break}if(0===n)break}if(n>0){let n=[];throw t.forEach((t,a)=>{null==t&&n.push(e[a])}),new lb("Cannot find SymbolicTensors for output name(s): ".concat(JSON.stringify(n)))}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return eo(()=>{let a=this.checkNumSamples(e);if(n)throw new ub("Verbose predictLoop() is not implemented yet.");let r=Hx(a,t),s=this.outputs.map(e=>[]);for(let t=0;t<r.length;++t)eo(()=>{let n=r[t][0],a=r[t][1],s=Vx(e,n,a),i=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)i.push({key:this.inputs[e],value:s[e]});else i.push({key:this.inputs[0],value:s});let o=new sv(i);return cv(this.outputs,o)}).forEach((e,t)=>s[t].push(e));return gb(s.map(e=>Jo(e,0)))})}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=qx(e);Jx(n,this.inputNames,this.feedInputShapes,!1);try{let a=null==t.batchSize?32:t.batchSize;return Ux(a),this.predictLoop(n,a)}finally{Kx(n,e)}}predictOnBatch(e){Jx(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new cb("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let r=0;r<this.feedOutputShapes.length;++r){let e=this.feedOutputShapes[r];this.feedLossFns[r]===ox?a.push(e.slice(0,e.length-1).concat([1])):a.push(e)}if(function(e,t,n){let a=Nb(e.map(e=>e.shape[0]));a.sort();let r=Nb(t.map(e=>e.shape[0]));if(r.sort(),a.length>1)throw new lb("All input Tensors (x) should have the same number of samples. Got array shapes: ".concat(JSON.stringify(e.map(e=>e.shape))));if(r.length>1)throw new lb("All target Tensors (y) should have the same number of samples. Got array shapes: ".concat(JSON.stringify(t.map(e=>e.shape))));if(a.length>0&&r.length>0&&!Nr.arraysEqual(a,r))throw new lb("Input Tensors should have the same number of samples as target Tensors. Found ".concat(a[0]," input sample(s) and ").concat(r[0]," target sample(s)."))}(e=Yx(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Yx(t,this.feedOutputNames,a,!1,"target")),function(e,t,n){let a=[ax,cx,ix];for(let r=0;r<e.length;++r){let s=e[r],i=t[r],o=n[r];if(null!=i){if(i===ix&&1===s.shape[s.shape.length-1])throw new lb("You are passing a target array of shape ".concat(s.shape," while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes]."));if(-1!==a.indexOf(i)){let e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){let a=e[n],r=t[n];if(null!=r&&a!==r)throw new lb("A target Tensor with shape ".concat(s.shape," was passed for an output of shape ").concat(o,", while using a loss function that expects targets to have the same shape as the output."))}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new lb("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ".concat(n,". Found: ").concat(e[0].shape[0]," sample(s)."));return[e,t]}async standardizeUserData(e,t,n,a){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0,[i,o]=this.standardizeUserDataXY(e,t,r,s);if(null!=n)throw new Error("sample weight is not supported yet.");let c=null;if(null!=a){let e=Mx(a,this.outputNames);c=[];for(let t=0;t<e.length;++t)c.push(await jx(o[t],null,e[t]))}return[i,o,c]}testLoop(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4?arguments[4]:void 0;return eo(()=>{let s=this.checkNumSamples(t,n,r,"steps"),i=[];if(a>0)throw new ub("Verbose mode is not implemented yet.");if(null!=r)throw new ub("steps mode in testLoop() is not implemented yet");{let a=Hx(s,n),r=Dd(ty(0,s));for(let n=0;n<a.length;++n){let s=a[n][0],o=a[n][1],c=iy(r,s,o-s),l=Gx(t,c),u=e(l);if(0===n)for(let e=0;e<u.length;++e)i.push(il(0));for(let e=0;e<u.length;++e){let t=u[e];i[e]=fo(i[e],bo(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=go(i[e],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let a=e[n],r=a;if(mb(e,a)>1){let t=mb(e.slice(0,n),a);r+="_".concat(t)}t.push(r)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(()=>{let e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});let i,o=new sv(e),c=cv(this.outputs,o,{training:!0});for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(a[n],c[n]);null!=r[n]&&(e=zx(e,r[n]));let s=au(e);t.push(s),i=0===n?e:fo(i,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{let t=this.metricsTensors[n][0],r=this.metricsTensors[n][1];e=au(t(a[r],c[r]))}no(e),s.push(e)}return i=au(i),this.calculateLosses().forEach(e=>{i=fo(i,e)}),i},!0,i)].concat(s)}}makeTestFunction(){this.testFunction=e=>eo(()=>{let t,n=[],a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:a[e]});let i=new sv(s),o=cv(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){let a=this.lossFunctions[e],s=au(a(r[e],o[e]));t=0===e?s:fo(t,s),n.push(t)}for(let e=0;e<this.metricsTensors.length;++e){let t=this.metricsTensors[e][0],a=this.metricsTensors[e][1],s=au(t(r[a],o[a]));n.push(s)}return n})}async fit(e,t){let n,a,r,s,i,o,c,l,u,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{let h=null==d.batchSize?32:d.batchSize;Ux(h);let p=!1,f=await this.standardizeUserData(e,t,d.sampleWeight,d.classWeight,p,h);n=f[0],a=f[1],u=f[2];let m,g=!1;if(null!=d.validationData&&d.validationData.length>0){if(g=!0,2!==d.validationData.length)throw 3===d.validationData.length?new ub("validationData including sample weights is not supported yet."):new lb("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ".concat(d.validationData," is invalid."));i=d.validationData[0],o=d.validationData[1];let e=!0,t=await this.standardizeUserData(i,o,null,null,e,h);c=t[0],l=t[1],m=c.concat(l)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){g=!0;let e=Math.floor(n[0].shape[0]*(1-d.validationSplit)),t=n[0].shape[0];c=Vx(n,e,t),r=n,n=Vx(n,0,e),l=Vx(a,e,t),s=a,a=Vx(a,0,e),m=c.concat(l)}else null!=d.validationSteps&&(g=!0);let b=n.concat(a).concat(u);this.checkTrainableWeightsConsistency();let y,v,x=this.makeTrainFunction(),w=this.getDedupedMetricsNames();g?(this.makeTestFunction(),y=this.testFunction,v=w.slice().concat(w.map(e=>"val_"+e))):(y=null,m=[],v=w.slice());let k=Qv(d.callbacks,d.yieldEvery);return await this.fitLoop(x,b,w,h,d.epochs,d.verbose,k,y,m,d.shuffle,v,d.initialEpoch,null,null)}finally{this.isTraining=!1,Kx(n,e),Kx(a,t),Kx(r,e),Kx(s,t),Kx(c,i),Kx(l,o),null!=u&&to(u)}}async fitLoop(e,t,n,a,r,s,i,o,c,l,u,d,h,p){null==a&&(a=32),null==r&&(r=1),null==l&&(l=!0),null==d&&(d=0);let f=!1;if(null!=o&&null!=c&&(f=!0),null!=p&&(f=!0,null==h))throw new lb("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m,g=this.checkNumSamples(t,a,h,"steps_per_epoch");null!=g&&(m=ty(0,g)),null==s&&(s=1);let{callbackList:b,history:y}=ex(i,s,r,d,g,h,a,f,u);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let v=d;v<r;++v){await b.onEpochBegin(v);let r={};if(null!=h)throw new ub("stepsPerEpoch mode is not implemented yet.");{if("batch"===l)throw new ub("batch shuffling is not implemneted yet");l&&Nr.shuffle(m);let s=Dd(m),i=Hx(g,a);for(let l=0;l<i.length;++l){let u={};if(await b.onBatchBegin(l,u),eo(()=>{let d=i[l][0],h=i[l][1],p=iy(s,d,h-d);u.batch=l,u.size=h-d;let m=Gx(t,p),g=e(m);for(let e=0;e<n.length;++e){let t=n[e],a=g[e];u[t]=a,no(a)}if(l===i.length-1&&f){let e=this.testLoop(o,c,a);for(let t=0;t<n.length;++t){let a=n[t],s=e[t];no(s),r["val_"+a]=s}}}),await b.onBatchEnd(l,u),qv(u),this.stopTraining_)break}s.dispose()}if(await b.onEpochEnd(v,r),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Bx(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),a=n[0],r=n[1],s=this.makeTrainFunction()(a.concat(r)),i=[];for(let o of s){let e=await o.data();i.push(e[0])}return to(s),Kx(n[0],e),Kx(n[1],t),gb(i)}getNamedWeights(e){let t=[],n=null!=e&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let s=0;s<a.length;++s)n&&!a[s].trainable||t.push({name:a[s].originalName,tensor:r[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let t=Qi().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Qi().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=yb(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(e=>yb(e))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let a of t){if("string"!=typeof n[a])throw new Error("Serialization of non-string loss is not supported.");e[a]=yb(n[a])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[yb(Ix(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>yb(Ix(e)));{let e={};for(let t in this.metrics)e[t]=yb(Ix(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");let t,n,a=tx(Rx(e.optimizer_config));if("string"==typeof e.loss)t=vb(e.loss);else if(Array.isArray(e.loss))t=e.loss.map(e=>vb(e));else if(null!=e.loss){t={};for(let n in e.loss)t[n]=vb(e.loss[n])}if(Array.isArray(e.metrics))n=e.metrics.map(e=>vb(e));else if(null!=e.metrics){n={};for(let t in e.metrics)n[t]=vb(e.metrics[t])}this.compile({loss:t,metrics:n,optimizer:a})}async save(e,t){if("string"==typeof e){let t=Bp.getSaveHandlers(e);if(0===t.length)throw new lb("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new lb("Found more than one (".concat(t.length,") save handlers for URL '").concat(e,"'"));e=t[0]}if(null==e.save)throw new lb("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Bp.encodeWeights(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(Dx),convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();let e="optimizer",{data:t,specs:r}=await Bp.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...r),n.data=Bp.concatenateArrayBuffers([n.data,t])}return null!=this.userDefinedMetadata&&(Sx(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){Sx(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};Qx.className="Model",Op.registerClass(Qx);var $x=class extends Qx{};async function ew(e,t){"modelTopology"in e||(e={modelTopology:e});let n=(e=e).modelTopology;null!=n.model_config&&(n=n.model_config);let a=tx(Rx(n),t);if(null!=e.weightsManifest){let t=await Bp.loadWeights(e.weightsManifest,e.pathPrefix,a.weights.map(e=>e.originalName)),n={};for(let e of a.weights)n[e.originalName]=t[e.originalName];a.loadWeights(n),to(t)}return a}async function tw(e,t){if(null==t&&(t={}),"string"==typeof e){let n=Bp.getLoadHandlers(e,t);if(0===n.length)n.push(Bp.browserHTTPRequest(e,t));else if(n.length>1)throw new lb("Found more than one (".concat(n.length,") load handlers for URL '").concat(e,"'"));e=n[0]}return async function(e,t,n){if(null==n&&(n={}),null==e.load)throw new lb("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let a=await e.load(),r=a.modelTopology;null!=r.model_config&&(r=r.model_config);let s=null==n.strict||n.strict,i=null!=a.weightData&&null!=a.weightSpecs&&s,o=tx(Rx(r),t,i),c=a.trainingConfig;if(null!=c&&o.loadTrainingConfig(c),null!=a.userDefinedMetadata&&o.setUserDefinedMetadata(a.userDefinedMetadata),null!=a.weightData){if(null==a.weightSpecs)throw new lb("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:e,optimizerWeights:t}=function(e,t){let n=Bp.decodeWeights(e,t),a={},r=[];return t.forEach(e=>{"optimizer"===e.group?r.push({name:e.name,tensor:n[e.name]}):a[e.name]=n[e.name]}),{modelWeights:a,optimizerWeights:r}}(a.weightData,a.weightSpecs);o.loadWeights(e,s),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),to(e),to(t.map(e=>e.tensor))}return o}(e,void 0,t)}$x.className="Functional",Op.registerClass($x);var nw=class extends Qx{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Fb("sequential_"),null!=e.layers)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new lb("Negative dimension size caused by adding layer ".concat(e.name," with input shape [").concat(e.inboundNodes[0].inputTensors[0].shape,"]"))}add(e){let t,n=e instanceof nw||e instanceof Qx;if(n){if(t=e,1!==t.outputs.length)throw new lb("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==t.inputs.length)throw new lb("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new lb("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let t=rv({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(n)this.outputs=t.outputs,this.inputs=t.inputs;else{if(1!==e.inboundNodes.length)throw new lb("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ".concat(e.name," which has ").concat(e.inboundNodes.length," pre-existing inbound connections."));if(1!==e.inboundNodes[0].outputTensors.length)throw new lb("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=function e(t,n,a){if((null==n||null!=a&&a>0)&&(n=t.sourceLayer,a=t.nodeIndex),0===n.inboundNodes.length)return[t];{let t=n.inboundNodes[a];if(0===t.inboundLayers.length)return t.inputTensors;{let n=[];for(let a=0;a<t.inboundLayers.length;a++){let r=e(t.inputTensors[a],t.inboundLayers[a],t.nodeIndices[a]);for(let e of r)-1===n.indexOf(e)&&n.push(e)}return n}}}(this.outputs[0])}this.inboundNodes=[],new ev({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:pb(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{let t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(Hy(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Qx({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new cb("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new cb("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new cb("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new cb("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new lb("Legacy serialization format not supported yet.");n=t}else Nr.assert(null!=t.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),n=t.layers,delete t.layers,r=t;let s=new e(r);if(!(s instanceof nw))throw new ub("Sequential.fromConfig called on non-Sequential input: ".concat(s));for(let i of n){let e=tx(i,void 0,a);a&&e.setFastWeightInitDuringBuild(!0),s.add(e)}return s}set stopTraining(e){if(null==this.model)throw new lb("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new lb("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};function aw(e){return new Qx(e)}function rw(e){return new nw(e)}function sw(e){return rv(e)}function iw(e,t){$v.registerCallbackConstructor(e,t)}nw.className="Sequential",Op.registerClass(nw);var ow=class extends Op.Serializable{getConfig(){return{}}},cw=class extends ow{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new ub("Support for alpha values other than 1 (".concat(t,") is not implemented yet."));return qc(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}};cw.className="elu",Op.registerClass(cw);var lw=class extends ow{apply(e){return dd(e)}};lw.className="selu",Op.registerClass(lw);var uw=class extends ow{apply(e){return nd(e)}};uw.className="relu",Op.registerClass(uw);var dw=class extends ow{apply(e){return eo(()=>ou(6,nd(e)))}};dw.className="relu6",Op.registerClass(dw);var hw=class extends ow{apply(e){return e}};hw.className="linear",Op.registerClass(hw);var pw=class extends ow{apply(e){return $o(e)}};pw.className="sigmoid",Op.registerClass(pw);var fw=class extends ow{apply(e){return function(e){return eo(()=>{let t=fo(.5,bo(.2,e));return mc(t,0,1)})}(e)}};fw.className="hardSigmoid",Op.registerClass(fw);var mw=class extends ow{apply(e){return Wl(e)}};mw.className="softplus",Op.registerClass(mw);var gw=class extends ow{apply(e){return function(e){return eo(()=>go(e,fo(yo(e),1)))}(e)}};gw.className="softsign",Op.registerClass(gw);var bw=class extends ow{apply(e){return tc(e)}};bw.className="tanh",Op.registerClass(bw);var yw=class extends ow{apply(e){return wd(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}};yw.className="softmax",Op.registerClass(yw);var vw=class extends ow{apply(e){return Gl(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}};vw.className="logSoftmax",Op.registerClass(vw);var xw=class extends ow{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return eo(()=>bo($o(bo(e,t)),e))}};xw.className="swish",Op.registerClass(xw);var ww=class extends ow{apply(e){return eo(()=>bo(e,tc(Wl(e))))}};function kw(e){return e.getClassName()}function Iw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Ib(e,Op.SerializationMap.getMap().classNameMap,t,"activation")}function Sw(e){if(null==e){let e={className:"linear",config:{}};return Iw(e)}if("string"==typeof e){let t={};return t.className=e,t.config={},Iw(t)}return e instanceof ow?e:Iw(e)}function Nw(e){if(null!=e&&"object"!=typeof e)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: ".concat(e))}ww.className="mish",Op.registerClass(ww);var Tw=class extends Op.Serializable{},Ow=class extends Tw{constructor(e){super(),Nw(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return eo(()=>{let t=ru([1]);return this.hasL1&&(t=fo(t,ll(bo(this.l1,yo(e))))),this.hasL2&&(t=fo(t,ll(bo(this.l2,my(e))))),Xo(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Ow.className="L1L2",Op.registerClass(Ow);var Cw={l1l2:"L1L2"};function Ew(e){return wb(e)}function _w(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Ib(e,Op.SerializationMap.getMap().classNameMap,t,"regularizer")}function Aw(e){if(null==e)return null;if("string"==typeof e){return _w({className:e in Cw?Cw[e]:e,config:{}})}return e instanceof Tw?e:_w(e)}var Rw=class extends nv{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=Gy(e);let n=nd(e);return null!=this.maxValue&&(n=mc(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};Rw.className="ReLU",Op.registerClass(Rw);var Dw=class extends nv{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Gy(e);return Tl(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Dw.className="LeakyReLU",Op.registerClass(Dw);var Fw=class extends nv{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Wy(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Aw(e.alphaRegularizer),this.alphaConstraint=kv(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new lb("Expected sharedAxes to be a number or an array of numbers, but got ".concat(e.sharedAxes));this.sharedAxes=[e.sharedAxes]}}build(e){let t=(e=Hy(e)).slice(1);if(null!=this.sharedAxes)for(let a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(null!=this.sharedAxes)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new Jy({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Gy(e),Su(e,this.alpha.read())}getConfig(){let e={alphaInitializer:By(this.alphaInitializer),alphaRegularizer:Ew(this.alphaRegularizer),alphaConstraint:xv(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};Fw.className="PReLU",Op.registerClass(Fw);var Mw=class extends nv{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new ub("Non-default alpha value (".concat(e.alpha,") is not supported by the ELU layer yet."));this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Gy(e);return qc(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Mw.className="ELU",Op.registerClass(Mw);var jw=class extends nv{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){let n=Gy(e);return bo(n,Vi(xl(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};jw.className="ThresholdedReLU",Op.registerClass(jw);var zw=class extends nv{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new yw).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){let n=Gy(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function Lw(e,t,n){if("number"==typeof e)return pb(e,t);if(e.length!==t)throw new lb("The ".concat(n," argument must be an integer or tuple of ").concat(t," integers. Received: ").concat(e.length," elements."));for(let a=0;a<t;++a){let r=e[a];if(!Jb(r))throw new lb("The ".concat(n," argument must be an integer or tuple of ").concat(t," integers. Received: ").concat(JSON.stringify(e)," including a non-integer number ").concat(r))}return e}function Pw(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1;if(null==e)return e;let s,i=t+(t-1)*(r-1);return s="same"===n?e:e-i+1,Math.floor((s+a-1)/a)}function Bw(e,t,n,a){if(null==e)return null;if("valid"===a)e=e*t+ey([n-t,0]);else{if("same"!==a)throw new lb("Unsupport padding mode: ".concat(a,"."));e*=t}return e}function Ww(e,t){return eo(()=>(Wb(t),"channelsFirst"===t?eh(e,[0,2,3,1]):e))}function Uw(e,t){return eo(()=>(Wb(t),"channelsFirst"===t?eh(e,[0,2,3,4,1]):e))}function Vw(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return eo(()=>{if(null==s&&(s="channelsLast"),Wb(s),3!==e.rank&&4!==e.rank)throw new lb("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ".concat(e.rank,"."));if(3!==t.rank&&4!==t.rank)throw new lb("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ".concat(e.rank,"."));let c=Ww(e,s);if("causal"===r)throw new ub("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=uh.conv2d({x:c,filter:t,strides:a,pad:"same"===r?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(c=eh(c,[0,3,1,2])),c})}zw.className="Softmax",Op.registerClass(zw);var Gw=class extends nv{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Gw.verifyArgs(t),this.rank=e,Eb(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new ub("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is not implemented yet."));if(this.kernelSize=Lw(t.kernelSize,e,"kernelSize"),this.strides=Lw(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,Ub(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Wb(this.dataFormat),this.activation=Sw(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=Wy(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=kv(t.biasConstraint),this.biasRegularizer=Aw(t.biasRegularizer),this.activityRegularizer=Aw(t.activityRegularizer),this.dilationRate=Lw(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new lb("dilationRate must be a number or an array of a single number for 1D convolution, but received ".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new lb("dilationRate must be a number or array of two numbers for 2D convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new lb("dilationRate must be a number or array of three numbers for 3D convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(e){if(fb("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!Cb(e.kernelSize,"number",1,3))throw new lb("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize),"."))}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:kw(this.activation),useBias:this.useBias,biasInitializer:By(this.biasInitializer),biasRegularizer:Ew(this.biasRegularizer),activityRegularizer:Ew(this.activityRegularizer),biasConstraint:xv(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},Hw=class extends Gw{constructor(e,t){super(e,t),this.kernel=null,Hw.verifyArgs(t),this.filters=t.filters,Eb(this.filters,"filters"),this.kernelInitializer=Wy(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=kv(t.kernelConstraint),this.kernelRegularizer=Aw(t.kernelRegularizer)}build(e){e=Hy(e);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new lb("The channel dimension of the input should be defined. Found ".concat(e[t]));let n=e[t],a=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return eo(()=>{e=Gy(e);let t,n=null==this.bias?null:this.bias.read(),a=_b(this.activation.getClassName());if(null!=a&&2===this.rank)t=Vw(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(1===this.rank)t=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return eo(()=>{if(null==s&&(s="channelsLast"),Wb(s),3!==e.shape.length)throw new lb("The input of a conv1dWithBias operation should be 3, but is ".concat(e.shape.length," instead."));if(3!==t.shape.length)throw new lb("The kernel for a conv1dWithBias operation should be 3, but is ".concat(t.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new lb("The bias for a conv1dWithBias operation should be 1, but is ".concat(t.shape.length," instead"));if("channelsFirst"===s&&(e=eh(e,[0,2,1])),"causal"===r)throw new ub("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=wc(e,t,a,"same"===r?"same":"valid","NWC",i);return null!=n&&(o=by(o,n)),o})}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=Vw(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new ub("convolutions greater than 3D are not implemented yet.");t=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return eo(()=>{if(null==s&&(s="channelsLast"),Wb(s),4!==e.rank&&5!==e.rank)throw new lb("conv3dWithBias expects input to be of rank 4 or 5, but received ".concat(e.rank,"."));if(4!==t.rank&&5!==t.rank)throw new lb("conv3dWithBias expects kernel to be of rank 4 or 5, but received ".concat(e.rank,"."));let o=Uw(e,s);if("causal"===r)throw new ub("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Sc(o,t,a,"same"===r?"same":"valid","NDHWC",i),null!=n&&(o=by(o,n)),"channelsFirst"===s&&(o=eh(o,[0,4,1,2,3])),o})}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t})}computeOutputShape(e){e=Hy(e);let t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<n.length;++r){let e=Pw(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(e)}let a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t),a.push(this.filters)):(a.push(this.filters),a=a.concat(t)),a}getConfig(){let e={filters:this.filters,kernelInitializer:By(this.kernelInitializer),kernelRegularizer:Ew(this.kernelRegularizer),kernelConstraint:xv(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new lb("Convolution layer expected config.filters to be a 'number' > 0 but got ".concat(JSON.stringify(e.filters)))}},qw=class extends Hw{constructor(e){super(2,e),qw.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Cb(e.kernelSize,"number",1,2))throw new lb("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize),"."))}};qw.className="Conv2D",Op.registerClass(qw);var Kw=class extends Hw{constructor(e){super(3,e),Kw.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new lb("Conv3D expects config.kernelSize to be number or [number, number, number], but received ".concat(JSON.stringify(e.kernelSize),"."))}};Kw.className="Conv3D",Op.registerClass(Kw);var Xw=class extends qw{constructor(e){if(super(e),this.inputSpec=[new Jy({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new lb("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ".concat(this.padding))}build(e){if(4!==(e=Hy(e)).length)throw new lb("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new lb("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Jy({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return eo(()=>{let t=Gy(e);if(4!==t.shape.length)throw new lb("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-".concat(t.shape.length));let n,a,r=t.shape,s=r[0];"channelsFirst"===this.dataFormat?(n=2,a=3):(n=1,a=2);let i=r[n],o=r[a],c=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],d=this.strides[1],h=[s,Bw(i,u,c,this.padding),Bw(o,d,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=eh(t,[0,2,3,1]));let p=Ic(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=eh(p,[0,3,1,2])),null!=this.bias&&(p=by(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p})}computeOutputShape(e){let t,n,a,r=(e=Hy(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,a=3):(t=3,n=1,a=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],c=this.strides[1];return r[t]=this.filters,r[n]=Bw(r[n],o,s,this.padding),r[a]=Bw(r[a],c,i,this.padding),r}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};Xw.className="Conv2DTranspose",Op.registerClass(Xw);var Zw=class extends Kw{constructor(e){if(super(e),this.inputSpec=[new Jy({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new lb("Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ".concat(this.padding))}build(e){if(5!==(e=Hy(e)).length)throw new lb("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new lb("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Jy({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return eo(()=>{let t=Gy(e);if(5!==t.shape.length)throw new lb("Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-".concat(t.shape.length));let n,a,r,s=t.shape,i=s[0];"channelsFirst"===this.dataFormat?(r=2,n=3,a=4):(r=1,n=2,a=3);let o=s[r],c=s[n],l=s[a],u=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[i,Bw(o,p,u,this.padding),Bw(c,f,d,this.padding),Bw(l,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=eh(t,[0,2,3,4,1]));let b=Tc(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=eh(b,[0,4,1,2,3])),null!==this.bias&&(b=by(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b})}computeOutputShape(e){let t,n,a,r,s=(e=Hy(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,a=3,r=4):(t=4,n=1,a=2,r=3);let i=this.kernelSize[0],o=this.kernelSize[1],c=this.kernelSize[2],l=this.strides[0],u=this.strides[1],d=this.strides[2];return s[t]=this.filters,s[n]=Bw(s[n],l,i,this.padding),s[a]=Bw(s[a],u,o,this.padding),s[r]=Bw(s[r],d,c,this.padding),s}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};Zw.className="Conv3DTranspose",Op.registerClass(Zw);var Yw=class extends Hw{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new lb("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new lb("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new lb("SeparableConv".concat(this.rank,"D supports only padding modes: 'same' and 'valid', but received ").concat(JSON.stringify(t.padding)));this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Wy(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Aw(t.depthwiseRegularizer),this.depthwiseConstraint=kv(t.depthwiseConstraint),this.pointwiseInitializer=Wy(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Aw(t.pointwiseRegularizer),this.pointwiseConstraint=kv(t.pointwiseConstraint)}build(e){if((e=Hy(e)).length<this.rank+2)throw new lb("Inputs to SeparableConv".concat(this.rank,"D should have rank ").concat(this.rank+2,", but received input shape: ").concat(JSON.stringify(e)));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new lb("The channel dimension of the inputs should be defined, but found ".concat(JSON.stringify(e[t])));let n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let s=0;s<this.rank;++s)r.push(1);r.push(n*this.depthMultiplier,this.filters);this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.inputSpec=[new Jy({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return eo(()=>{let t;if(e=Gy(e),1===this.rank)throw new ub("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=eh(e,[0,2,3,1])),t=hd(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=by(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=eh(t,[0,3,1,2])),t})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=By(this.depthwiseInitializer),e.pointwiseInitializer=By(this.pointwiseInitializer),e.depthwiseRegularizer=Ew(this.depthwiseRegularizer),e.pointwiseRegularizer=Ew(this.pointwiseRegularizer),e.depthwiseConstraint=xv(this.depthwiseConstraint),e.pointwiseConstraint=xv(this.pointwiseConstraint),e}};Yw.className="SeparableConv";var Jw=class extends Yw{constructor(e){super(2,e)}};Jw.className="SeparableConv2D",Op.registerClass(Jw);var Qw=class extends Hw{constructor(e){super(1,e),Qw.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Cb(e.kernelSize,"number",1,1))throw new lb("Conv1D expects config.kernelSize to be number or number[] with length 1, but received ".concat(JSON.stringify(e.kernelSize),"."))}};Qw.className="Conv1D",Op.registerClass(Qw);var $w=class extends nv{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return eo(()=>{if(e=Gy(e),"channelsLast"===this.dataFormat){let t=cy(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return cy(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let t=cy(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return cy(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};$w.className="Cropping2D",Op.registerClass($w);var ek=class extends nv{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Wb(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function(e){Ob(jb,"InterpolationFormat",e)}(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){let t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{let t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return eo(()=>{let t=Gy(e),n=t.shape;if("channelsFirst"===this.dataFormat){t=eh(t,[0,2,3,1]);let e=this.size[0]*n[2],a=this.size[1]*n[3],r="nearest"===this.interpolation?kp.resizeNearestNeighbor(t,[e,a]):kp.resizeBilinear(t,[e,a]);return eh(r,[0,3,1,2])}{let e=this.size[0]*n[1],a=this.size[1]*n[2];return"nearest"===this.interpolation?kp.resizeNearestNeighbor(t,[e,a]):kp.resizeBilinear(t,[e,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};ek.className="UpSampling2D",Op.registerClass(ek);var tk=class extends Gw{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Wy(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=kv(e.depthwiseConstraint),this.depthwiseRegularizer=Aw(e.depthwiseRegularizer)}build(e){if((e=Hy(e)).length<4)throw new lb("Inputs to DepthwiseConv2D should have rank 4. Received input shape: ".concat(JSON.stringify(e),"."));let t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new lb("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (".concat(e[t],")."));let n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return eo(()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",r=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return eo(()=>{null==r&&(r="channelsLast"),Wb(r);let i=Ww(e,r);if(4!==e.rank)throw new lb("Input for depthwiseConv2d is required to be 4-D, but is instead ".concat(e.rank,"-D"));if(4!==t.rank)throw new lb("depthwiseKernel is required to be 4-D, but is instead ".concat(t.rank,"-D"));return i=Dc(i,t,n,"same"===a?"same":"valid","NHWC",s),"channelsFirst"===r&&(i=eh(i,[0,3,1,2])),i})}(e=Gy(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=by(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t})}computeOutputShape(e){e=Hy(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=Pw(t,this.kernelSize[0],this.padding,this.strides[0]),s=Pw(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],a,r,s]:[e[0],r,s,a]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=By(this.depthwiseInitializer),e.depthwiseRegularizer=Ew(this.depthwiseRegularizer),e.depthwiseConstraint=xv(this.depthwiseRegularizer),e}};function nk(e,t,n,a){if(Array.isArray(e)){if(null!=t||null!=n)throw new lb("When inputs is an array, neither initialState or constants should be provided");null!=a&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=r(t),constants:n=r(n)}}function ak(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return eo(()=>{let c=t.shape.length;if(c<3)throw new lb("Input should be at least 3D, but is ".concat(c,"D."));let l=[1,0].concat(ty(2,c));if(t=eh(t,l),null!=s)throw new ub("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&(r=Vi(Vi(r,"bool"),"float32"),r.rank===c-1&&(r=fl(r,-1)),r=eh(r,l)),a&&(t=rd(t,0),null!=r&&(r=rd(r,0)));let u,d,h,p=[],f=n,m=t.shape[0],g=Xd(t);null!=r&&(d=Xd(r));for(let t=0;t<m;++t){let n=g[t],a=eo(()=>e(n,f));if(null==r)u=a[0],f=a[1];else{let e=eo(()=>{let e=d[t],n=Vl(mu(e),e);return{output:fo(bo(a[0],e),bo(f[0],n)),newStates:f.map((t,r)=>fo(bo(a[1][r],e),bo(t,n)))}});u=e.output,f=e.newStates}o&&p.push(u)}return o&&(h=Ed(p,1)),[u,h,f]})}tk.className="DepthwiseConv2D",Op.registerClass(tk);var rk=class extends nv{constructor(e){let t;if(super(e),null==e.cell)throw new lb("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new hk({cells:e.cell}):e.cell,null==t.stateSize)throw new lb("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Jy({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return ty(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(e=>null)}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Uy(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n,a=t[0];if(n=this.returnSequences?[e[0],e[1],a]:[e[0],a],this.returnState){let a=[];for(let n of t)a.push([e[0],n]);return[n].concat(a)}return n}computeMask(e,t){return eo(()=>{Array.isArray(t)&&(t=t[0]);let e=this.returnSequences?t:null;if(this.returnState){let t=this.states.map(e=>null);return[e].concat(t)}return e})}get states(){if(null==this.states_){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new ub("Constants support is not implemented in RNN yet.");Uy(e)&&(e=e[0]),e=e;let t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Jy({shape:[t,null,...n]});let a,r=[e[0]].concat(e.slice(2));if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Nr.arraysEqual(this.stateSpec.map(e=>e.shape[e.shape.length-1]),a))throw new lb("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; However cell.stateSize is ").concat(this.cell.stateSize))}else this.stateSpec=a.map(e=>new Jy({shape:[null,e]}));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];eo(()=>{if(!this.stateful)throw new ob("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(null==n)throw new lb("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>ru([n,e])):this.states_=[ru([n,this.cell.stateSize])];else if(null==e)to(this.states_),null!=this.keptStates&&(to(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>ru([n,e])):this.states_[0]=ru([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new lb("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), but it received ").concat(e.length," state value(s). Input received: ").concat(e));!0===t?this.keptStates.push(this.states_.slice()):to(this.states_);for(let t=0;t<this.states_.length;++t){let a=e[t],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,r];if(!Nr.arraysEqual(a.shape,s))throw new lb("State ".concat(t," is incompatible with layer ").concat(this.name,": expected shape=").concat(s,", received shape=").concat(a.shape));this.states_[t]=a}}this.states_=this.states_.map(e=>no(e.clone()))})}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});let r=nk(e,n,a,this.numConstants);e=r.inputs,n=r.initialState,a=r.constants;let s=[],i=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(let e of n)this.stateSpec.push(new Jy({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=a&&(t.constants=a,s=s.concat(a),this.numConstants=a.length),s[0]instanceof Qy){let n=[e].concat(s),a=this.inputSpec.concat(i),r=this.inputSpec;this.inputSpec=a;let o=super.apply(n,t);return this.inputSpec=r,o}return super.apply(e,t)}call(e,t){return eo(()=>{let n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;e=Gy(e),null==r&&(r=this.stateful?this.states_:this.getInitialState(e));let s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==s)throw new lb("RNN Layer has ".concat(s," state(s) but was passed ").concat(r.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:a},o=ak((e,t)=>{let n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]},e,r,this.goBackwards,n,null,this.unroll,this.returnSequences),c=o[0],l=o[1],u=o[2];this.stateful&&this.resetStates(u,a);let d=this.returnSequences?l:c;return this.returnState?[d].concat(u):d})}getInitialState(e){return eo(()=>{let t=ru(e.shape);return t=ll(t,[1,2]),t=ry(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>e>1?dy(t,[1,e]):t):this.cell.stateSize>1?[dy(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===rk.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=tx(t.cell,n);return new e(Object.assign(t,{cell:a}))}};rk.className="RNN",Op.registerClass(rk);var sk=class extends nv{},ik=class extends sk{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Eb(this.units,"units"),this.activation=Sw(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Wy(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wy(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wy(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Aw(e.kernelRegularizer),this.recurrentRegularizer=Aw(e.recurrentRegularizer),this.biasRegularizer=Aw(e.biasRegularizer),this.kernelConstraint=kv(e.kernelConstraint),this.recurrentConstraint=kv(e.recurrentConstraint),this.biasConstraint=kv(e.biasConstraint),this.dropout=$b([1,ey([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=$b([1,ey([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Hy(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return eo(()=>{if(2!==(e=e).length)throw new lb("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length,"."));let n=e[1];e=e[0];let a=null!=t.training&&t.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=pk({ones:()=>mu(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=pk({ones:()=>mu(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));let r,s=this.dropoutMask,i=this.recurrentDropoutMask;r=py(null!=s?bo(e,s):e,this.kernel.read()),null!=this.bias&&(r=by(r,this.bias.read())),null!=i&&(n=bo(n,i));let o=fo(r,py(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:kw(this.activation),useBias:this.useBias,kernelInitializer:By(this.kernelInitializer),recurrentInitializer:By(this.recurrentInitializer),biasInitializer:By(this.biasInitializer),kernelRegularizer:Ew(this.kernelRegularizer),recurrentRegularizer:Ew(this.recurrentRegularizer),biasRegularizer:Ew(this.biasRegularizer),activityRegularizer:Ew(this.activityRegularizer),kernelConstraint:xv(this.kernelConstraint),recurrentConstraint:xv(this.recurrentConstraint),biasConstraint:xv(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};ik.className="SimpleRNNCell",Op.registerClass(ik);var ok=class extends rk{constructor(e){e.cell=new ik(e),super(e)}call(e,t){return eo(()=>{null!=this.cell.dropoutMask&&(to(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(to(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return new e(t)}};ok.className="SimpleRNN",Op.registerClass(ok);var ck=class extends sk{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new lb("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Eb(this.units,"units"),this.activation=Sw(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Sw(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Wy(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wy(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wy(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Aw(e.kernelRegularizer),this.recurrentRegularizer=Aw(e.recurrentRegularizer),this.biasRegularizer=Aw(e.biasRegularizer),this.kernelConstraint=kv(e.kernelConstraint),this.recurrentConstraint=kv(e.recurrentConstraint),this.biasConstraint=kv(e.biasConstraint),this.dropout=$b([1,ey([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=$b([1,ey([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){let t=(e=Hy(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return eo(()=>{if(2!==(e=e).length)throw new lb("GRUCell expects 2 input Tensors (inputs, h, c), got ".concat(e.length,"."));let n=null!=t.training&&t.training,a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=pk({ones:()=>mu(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=pk({ones:()=>mu(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let r,s,i,o=this.dropoutMask,c=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=bo(e,o[0]));let l=py(e,this.kernel.read());this.useBias&&(l=by(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=bo(a,c[0]));let u=this.recurrentKernel.read(),[d,h]=Nd(u,[2*this.units,this.units],u.rank-1),p=py(a,d),[f,m,g]=Nd(l,3,l.rank-1),[b,y]=Nd(p,2,p.rank-1);r=this.recurrentActivation.apply(fo(f,b)),s=this.recurrentActivation.apply(fo(m,y));let v=py(bo(s,a),h);i=this.activation.apply(fo(g,v));let x=fo(bo(r,a),bo(fo(1,Bl(r)),i));return[x,x]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:kw(this.activation),recurrentActivation:kw(this.recurrentActivation),useBias:this.useBias,kernelInitializer:By(this.kernelInitializer),recurrentInitializer:By(this.recurrentInitializer),biasInitializer:By(this.biasInitializer),kernelRegularizer:Ew(this.kernelRegularizer),recurrentRegularizer:Ew(this.recurrentRegularizer),biasRegularizer:Ew(this.biasRegularizer),activityRegularizer:Ew(this.activityRegularizer),kernelConstraint:xv(this.kernelConstraint),recurrentConstraint:xv(this.recurrentConstraint),biasConstraint:xv(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};ck.className="GRUCell",Op.registerClass(ck);var lk=class extends rk{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new ck(e),super(e)}call(e,t){return eo(()=>{null!=this.cell.dropoutMask&&(to(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(to(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};lk.className="GRU",Op.registerClass(lk);var uk=class extends sk{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Eb(this.units,"units"),this.activation=Sw(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Sw(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Wy(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wy(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wy(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Aw(e.kernelRegularizer),this.recurrentRegularizer=Aw(e.recurrentRegularizer),this.biasRegularizer=Aw(e.biasRegularizer),this.kernelConstraint=kv(e.kernelConstraint),this.recurrentConstraint=kv(e.recurrentConstraint),this.biasConstraint=kv(e.biasConstraint),this.dropout=$b([1,ey([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=$b([1,ey([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;let n,a=(e=Hy(e))[e.length-1];if(this.kernel=this.addWeight("kernel",[a,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let e=this.biasInitializer,a=this.units;n=new((t=class extends ky{apply(t,n){let r=e.apply([a]),s=(new Sy).apply([a]),i=e.apply([2*a]);return uy(uy(r,s),i)}}).className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return eo(()=>{let n=null!=t.training&&t.training;if(3!==(e=e).length)throw new lb("LSTMCell expects 3 input Tensors (inputs, h, c), got ".concat(e.length,"."));let a=e[1],r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=pk({ones:()=>mu(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=pk({ones:()=>mu(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s,i,o,c,l=this.dropoutMask,u=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=bo(e,l[0]));let d=py(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=bo(a,u[0])),d=fo(d,py(a,this.recurrentKernel.read())),this.useBias&&(d=by(d,this.bias.read()));let[h,p,f,m]=Nd(d,4,d.rank-1);s=this.recurrentActivation.apply(h),i=this.recurrentActivation.apply(p),o=fo(bo(i,r),bo(s,this.activation.apply(f))),c=this.recurrentActivation.apply(m);let g=bo(c,this.activation.apply(o));return[g,g,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:kw(this.activation),recurrentActivation:kw(this.recurrentActivation),useBias:this.useBias,kernelInitializer:By(this.kernelInitializer),recurrentInitializer:By(this.recurrentInitializer),biasInitializer:By(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ew(this.kernelRegularizer),recurrentRegularizer:Ew(this.recurrentRegularizer),biasRegularizer:Ew(this.biasRegularizer),activityRegularizer:Ew(this.activityRegularizer),kernelConstraint:xv(this.kernelConstraint),recurrentConstraint:xv(this.recurrentConstraint),biasConstraint:xv(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};uk.className="LSTMCell",Op.registerClass(uk);var dk=class extends rk{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new uk(e),super(e)}call(e,t){return eo(()=>{null!=this.cell.dropoutMask&&(to(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(to(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};dk.className="LSTM",Op.registerClass(dk);var hk=class extends sk{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return eo(()=>{let n=(e=e).slice(1),a=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?a.push(n.splice(0,e.stateSize.length)):a.push(n.splice(0,1));a.reverse();let r,s=[];for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=a[i],r=0===i?[e[0]].concat(n):[r[0]].concat(n),r=o.call(r,t),s.push(r.slice(1))}n=[];for(let e of s.slice().reverse())n.push(...e);return[r[0]].concat(n)})}build(e){let t;Uy(e)&&(e=e[0]),e=e,this.cells.forEach((n,a)=>{Hb("RNNCell_".concat(a),()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t={cells:this.cells.map(e=>({className:e.getClassName(),config:e.getConfig()}))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=[];for(let r of t.cells)a.push(tx(r,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Zy(e)}setWeights(e){let t=[];for(let n of this.cells){let a=n.weights.length,r=e.splice(a);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],r[e]])}Yy(t)}};function pk(e){let{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:s}=e,i=()=>null!=s?s(t(),n):yy(t(),n),o=()=>vy(i,t,a);return!r||r<=1?no(o().clone()):Array(r).fill(void 0).map(o).map(e=>no(e.clone()))}hk.className="StackedRNNCells",Op.registerClass(hk);var fk=class extends rk{constructor(e){if(e.unroll)throw new ub("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new ub("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Jy({ndim:5})]}call(e,t){return eo(()=>{if(null!=this.cell.dropoutMask&&(to(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(to(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new lb("ConvRNN2D cell does not support constants");let n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return eo(()=>{let{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=ru([a[0],...a.slice(2)]);return Array.isArray(t)?Array(t.length).fill(r):[r]})}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];eo(()=>{if(!this.stateful)throw new ob("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(null==n[0])throw new lb("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ru(r)):this.states_=[ru(r)];else if(null==e)to(this.states_),null!=this.keptStates&&(to(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ru(r)):this.states_[0]=ru(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new lb("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), but it received ").concat(e.length," state value(s). Input received: ").concat(e));t?this.keptStates.push(this.states_.slice()):to(this.states_);for(let t=0;t<this.states_.length;++t){let n=e[t],a=r;if(!Nr.arraysEqual(n.shape,a))throw new lb("State ".concat(t," is incompatible with layer ").concat(this.name,": expected shape=").concat(a,", received shape=").concat(n.shape));this.states_[t]=n}}this.states_=this.states_.map(e=>no(e.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,c=e[o?3:2],l=e[o?4:3],u=Pw(c,a[0],r,s[0],i[0]),d=Pw(l,a[1],r,s[1],i[1]);return[...e.slice(0,2),...o?[n,u,d]:[u,d,n]]}};fk.className="ConvRNN2D";var mk=class extends uk{constructor(e){let{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Eb(this.filters,"filters"),this.kernelSize=Lw(n,2,"kernelSize"),this.kernelSize.forEach(e=>Eb(e,"kernelSize")),this.strides=Lw(a||1,2,"strides"),this.strides.forEach(e=>Eb(e,"strides")),this.padding=r||"valid",Ub(this.padding),this.dataFormat=s||"channelsLast",Wb(this.dataFormat),this.dilationRate=Lw(i||1,2,"dilationRate"),this.dilationRate.forEach(e=>Eb(e,"dilationRate"))}build(e){var t;e=Hy(e);let n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new lb("The channel dimension of the input should be defined. Found ".concat(e[n]));let a=e[n],r=this.kernelSize.concat([a,4*this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){let n=this.biasInitializer,a=this.filters;e=new((t=class extends ky{apply(e,t){return ly([n.apply([a]),su([a]),n.apply([2*a])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return eo(()=>{if(3!==e.length)throw new lb("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ".concat(e.length,"."));let n=t.training||!1,a=e[0],r=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=pk({ones:()=>mu(a),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?bo(t[n],e):e,c=o(a,i,0),l=o(a,i,1),u=o(a,i,2),d=o(a,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=pk({ones:()=>mu(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,p=o(r,h,0),f=o(r,h,1),m=o(r,h,2),g=o(r,h,3),[b,y,v,x]=Nd(this.kernel.read(),4,3),[w,k,I,S]=this.useBias?Nd(this.bias.read(),4):[null,null,null,null];c=this.inputConv(c,b,w,this.padding),l=this.inputConv(l,y,k,this.padding),u=this.inputConv(u,v,I,this.padding),d=this.inputConv(d,x,S,this.padding);let[N,T,O,C]=Nd(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,N),f=this.recurrentConv(f,T),m=this.recurrentConv(m,O),g=this.recurrentConv(g,C);let E=this.recurrentActivation.apply(fo(c,p)),_=this.recurrentActivation.apply(fo(l,f)),A=fo(bo(_,s),bo(E,this.activation.apply(fo(u,m)))),R=bo(this.recurrentActivation.apply(fo(d,g)),this.activation.apply(A));return[R,R,A]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]])}return n}(e,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),a)}inputConv(e,t,n,a){let r=xc(e,t,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?by(r,n,this.dataFormat):r}recurrentConv(e,t){return xc(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};mk.className="ConvLSTM2DCell",Op.registerClass(mk);var gk=class extends fk{constructor(e){let t=new mk(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};gk.className="ConvLSTM2D",Op.registerClass(gk);var bk=class extends nv{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;let t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(null==this.noiseShape[a]?t[a]:this.noiseShape[a]);return n}call(e,t){return eo(()=>{this.invokeCallHook(e,t);let n=Gy(e);if(0<this.rate&&this.rate<1){let e=null!=t.training&&t.training,a=this.getNoiseShape(n);return vy(()=>yy(n,this.rate,a,this.seed),()=>n,e)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};bk.className="Dropout",Op.registerClass(bk);var yk=class extends bk{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};yk.className="SpatialDropout1D",Op.registerClass(yk);var vk=class extends nv{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Eb(this.units,"units"),this.activation=Sw(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Wy(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Wy(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=kv(e.kernelConstraint),this.biasConstraint=kv(e.biasConstraint),this.kernelRegularizer=Aw(e.kernelRegularizer),this.biasRegularizer=Aw(e.biasRegularizer),this.activityRegularizer=Aw(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){let t=(e=Hy(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){let t=(e=Hy(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return eo(()=>{this.invokeCallHook(e,t);let n,a=Gy(e),r=_b(this.activation.getClassName());return null!=r?n=py(a,this.kernel.read(),r,this.bias?this.bias.read():null):(n=py(a,this.kernel.read()),null!=this.bias&&(n=by(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n})}getConfig(){let e={units:this.units,activation:kw(this.activation),useBias:this.useBias,kernelInitializer:By(this.kernelInitializer),biasInitializer:By(this.biasInitializer),kernelRegularizer:Ew(this.kernelRegularizer),biasRegularizer:Ew(this.biasRegularizer),activityRegularizer:Ew(this.activityRegularizer),kernelConstraint:xv(this.kernelConstraint),biasConstraint:xv(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};vk.className="Dense",Op.registerClass(vk);var xk=class extends nv{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Hy(e);for(let t of e.slice(1))if(null==t)throw new lb('The shape of the input to "Flatten" is not fully defined (got '.concat(e.slice(1),'). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.'));return[e[0],Qb(e,1)]}call(e,t){return eo(()=>{this.invokeCallHook(e,t);let n=Gy(e);if("channelsFirst"===this.dataFormat&&n.rank>1){let e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=eh(n,e)}return function(e){if(e.rank<=1)throw new lb("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank,"."));let t=[e.shape[0],Qb(e.shape,1)];return Xo(e,t)}(n)})}getConfig(){let e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};xk.className="Flatten",Op.registerClass(xk);var wk=class extends nv{constructor(e){super(e),this.supportsMasking=!0,this.activation=Sw(e.activation)}call(e,t){return eo(()=>{this.invokeCallHook(e,t);let n=Gy(e);return this.activation.apply(n)})}getConfig(){let e={activation:kw(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};wk.className="Activation",Op.registerClass(wk);var kk=class extends nv{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return eo(()=>function(e,t){return eo(()=>{if(2!==e.shape.length)throw new lb("repeat() expects a rank-2 tensor, but received a rank-".concat(e.shape.length," tensor."));return dy(ry(e,1),[1,t,1])})}(e=Gy(e),this.n))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};kk.className="RepeatVector",Op.registerClass(kk);var Ik=class extends nv{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",a=t.slice(),r=1,s=null;for(let o=0;o<a.length;++o){let e=a[o];if(this.isUnknown(e)){if(null!==s)throw new lb("Can only specifiy one unknown dimension.");s=o}else r*=e}let i=Qb(e);if(null!==s){if(0===r||i%r!==0)throw new lb(n);a[s]=i/r}else if(i!==r)throw new lb(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return eo(()=>{this.invokeCallHook(e,t);let n=Gy(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return Xo(n,r)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};Ik.className="Reshape",Op.registerClass(Ik);var Sk=class extends nv{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received ".concat(e.dims," instead."));let t=ty(1,e.dims.length+1);if(!Nr.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Jy({ndim:this.dims.length+1})]}computeOutputShape(e){let t=(e=Hy(e)).slice();return this.dims.forEach((n,a)=>{t[a+1]=e[n]}),t}call(e,t){return eh(Gy(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};Sk.className="Permute",Op.registerClass(Sk);var Nk=class extends nv{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Gy(e);return Io(pu(n,this.maskValue),-1)}call(e,t){return eo(()=>{this.invokeCallHook(e,t);let n=Gy(e),a=Io(pu(n,this.maskValue),-1,!0);return bo(n,Vi(a,n.dtype))})}};Nk.className="Masking",Op.registerClass(Nk);var Tk=class extends nv{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(bb(e.inputLength))}this.inputDim=e.inputDim,Eb(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Eb(this.outputDim,"outputDim"),this.embeddingsInitializer=Wy(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Aw(e.embeddingsRegularizer),this.activityRegularizer=Aw(e.activityRegularizer),this.embeddingsConstraint=kv(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return eo(()=>this.maskZero?(e=Gy(e),pu(e,Uc(e))):null)}computeOutputShape(e){if(e=Hy(e),null==this.inputLength)return[...e,this.outputDim];let t=bb(this.inputLength);if(t.length!==e.length-1)throw new lb('"inputLength" is '.concat(this.inputLength,", but received input shape has shape ").concat(e));{let n=0;for(let a=0;a<t.length;++a){let r=t[a],s=e[a+1];if(null!=r&&null!=s&&r!==s)throw new lb('"inputLength" is '.concat(this.inputLength,", but received input shape has shape ").concat(e));null==r&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return eo(()=>{this.invokeCallHook(e,t);let n=Gy(e);"int32"!==n.dtype&&(n=ay(n,"int32"));let a=fy(this.embeddings.read(),Xo(n,[n.size]));return Xo(a,Hy(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:By(this.embeddingsInitializer),embeddingsRegularizer:Ew(this.embeddingsRegularizer),activityRegularizer:Ew(this.activityRegularizer),embeddingsConstraint:xv(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};Tk.className="Embedding",Op.registerClass(Tk);var Ok=class extends nv{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new ub}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;let n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){let r=e[e.length-t.length+a],s=t[a];if(null==r||null==s||r<0||s<0)n.push(null);else if(1===r)n.push(s);else if(1===s)n.push(r);else{if(r!==s)throw new lb("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Hy(e)]),(e=e).length<2)throw new lb("A merge layer should be called on an Array of at least 2 inputs. Got ".concat(e.length," input(s)."));let t=[];for(let r of e)null!=r&&null!==r[0]&&t.push(r[0]);if(t=Nb(t),t.length>1)throw new lb("Can not merge tensors with different batch sizes. Got tensors with shapes: ".concat(JSON.stringify(e),"."));let n=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){let t=null==e[r]?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}let a=e.map(e=>e.length);-1===e.indexOf(null)&&1===Nb(a).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return eo(()=>{if(e=e,this.reshapeRequired){let t=[],n=e.map(e=>e.rank);if(-1===n.indexOf(null)){let a=ey(n);for(let n of e){let e=n.rank;for(let t=0;t<a-e;++t)n=ry(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(let s of e){let e=s.rank;if(null==e){let e=s.shape,a=e[0],r=e.slice(1).concat([a]),i=Xo(s,[a].concat(Qb(e.slice(1))));i=eh(i,[1,0]),i=Xo(i,r),t.push(i),n=!0}else if(e>1){let a=ty(1,e).concat([0]);t.push(eh(s,a)),n=!0}else t.push(s)}let a=this.mergeFunction(t),r=a.rank;if(n)if(null==r){let e=a.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));a=Xo(eh(Xo(a,[-1,t]),[1,0]),n)}else if(r>1){let e=[r-1].concat(ty(0,r-1));a=eh(a,e)}return a}}return this.mergeFunction(e)})}computeOutputShape(e){let t;t=null==(e=e)[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){let n=null==e[a]?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(let a of e)null!=a&&null!==a[0]&&n.push(a[0]);return n=Nb(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return eo(()=>{if(null==t)return null;if(!Array.isArray(t))throw new lb("`mask` should be an Array");if(!Array.isArray(e))throw new lb("`inputs` should be an Array");if(t.length!==e.length)throw new lb("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (".concat(e.length," vs ").concat(t.length,")"));if(t.every(e=>null==e))return null;let n=(t=t.map(e=>null==e?e:fl(e,0)))[0];for(let e=1;e<t.length-1;++e)n=ql(n,t[e]);return n})}},Ck=class extends Ok{constructor(e){super(e)}mergeFunction(e){return eo(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=fo(t,e[n]);return t})}};Ck.className="Add",Op.registerClass(Ck);var Ek=class extends Ok{constructor(e){super(e)}mergeFunction(e){return eo(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=bo(t,e[n]);return t})}};Ek.className="Multiply",Op.registerClass(Ek);var _k=class extends Ok{constructor(e){super(e)}mergeFunction(e){return eo(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=fo(t,e[n]);return bo(1/e.length,t)})}};_k.className="Average",Op.registerClass(_k);var Ak=class extends Ok{constructor(e){super(e)}mergeFunction(e){return eo(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=nu(t,e[n]);return t})}};Ak.className="Maximum",Op.registerClass(Ak);var Rk=class extends Ok{constructor(e){super(e)}mergeFunction(e){return eo(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ou(t,e[n]);return t})}};Rk.className="Minimum",Op.registerClass(Rk);var Dk=class extends Ok{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new lb("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let a of e)if(null!=a){t=!1;break}if(t)return;let n=[];for(let a=0;a<e.length;++a){let t=e[a].slice();t.splice(this.axis,1);let r=!1;for(let e of n)if(Nr.arraysEqual(e,t)){r=!0;break}r||n.push(t)}if(n.length>1)throw new lb("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return eo(()=>ly(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new lb("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(let r of t.slice(1)){if(null==n[a]||null==r[a]){n[a]=null;break}n[a]+=r[a]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new lb("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new lb("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new lb("Mismatch in the length of mask (".concat(t.length,") and the legnth of inputs (").concat(e.length,")"));return eo(()=>{let n=!0;if(t.forEach(e=>{null==e||(n=!1)}),n)return null;let a=[];for(let s=0;s<e.length;++s)null==t[s]?a.push(Vi(mu(e[s]),"bool")):t[s].rank<e[s].rank?a.push(fl(t[s],-1)):a.push(t[s]);let r=Jo(a,this.axis);return ko(r,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function Fk(e,t){for(;e<0;)e+=t;return e}Dk.className="Concatenate",Op.registerClass(Dk);var Mk=class extends Ok{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Nr.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new ub("Dot layer does not support tensors of 4D or higher rank yet.");let a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new lb("Dimension incompatibility: ".concat(t[a[0]]," !== ").concat(n[a[1]]))}mergeFunction(e){if(2!==e.length)throw new lb("A `Dot` layer must be called on exactly 2 inputs, but received ".concat(e.length," input(s)."));let t,n=e[0],a=e[1];return t=Array.isArray(this.axes)?this.axes.map((t,n)=>Fk(t,e[n].shape.length)):[Fk(this.axes,n.shape.length),Fk(this.axes,a.shape.length)],this.normalize&&(n=nx(n,t[0]),a=nx(a,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new ub("batchDot is not implemented for tensors of 4D or higher rank yet");if(Nr.assert(e.shape.length>=2,()=>"batchDot requires the rank of x to be >= 2, but got ".concat(e.shape.length)),Nr.assert(e.shape.length>=2,()=>"batchDot requires the rank of y to be >= 2, but got ".concat(t.shape.length)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new ub("batchDot is not implemented for complex64-type Tensors yet.");let a=e.shape.length,r=t.shape.length;null==n&&(n=[a-1,r-2]);let s=n;return eo(()=>{let n,i;if(a>r){n=a-r;let e=[];for(let t=0;t<n;++t)e.push(1);t=Xo(t,t.shape.concat(e))}else if(r>a){n=r-a;let t=[];for(let e=0;e<n;++e)t.push(1);e=Xo(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=s[0]===s[1]?ll(bo(e,t),s[0]):ll(bo(eh(e,[1,0]),t),s[1]);else{let n=s[0]!==e.shape.length-1,a=s[1]===t.shape.length-1;i=Qo(e,t,n,a)}if(n>0){let e;e=a>r?a+r-3:a-1;let t=[];for(let a=e;a<e+n;++a)t.push(a);i=Cd(i,t)}return 1===i.shape.length&&(i=fl(i,1)),i})}(n,a,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[Fk(this.axes,e.length),Fk(this.axes,t.length)],n}computeOutputShape(e){Nr.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new ub("Dot layer does not support tensors of 4D or higher rank yet.");let a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);let r=t.concat(n);return 1===r.length&&r.push(1),r}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};Mk.className="Dot",Op.registerClass(Mk);var jk=class extends nv{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return eo(()=>{this.invokeCallHook(e,t);let n=Gy(e);return vy(()=>fo(hy(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};jk.className="GaussianNoise",Op.registerClass(jk);var zk=class extends nv{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return eo(()=>{this.invokeCallHook(e,t);let n=Gy(e);return this.rate>0&&this.rate<1?vy(()=>{let e=Math.sqrt(this.rate/(1-this.rate));return bo(n,hy(n.shape,1,e))},()=>n,t.training||!1):n})}};zk.className="GaussianDropout",Op.registerClass(zk);var Lk=class extends nv{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Gy(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return eo(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return vy(()=>{let t=Gy(e),a=-1.7580993408473766,r=wl(Ju(n),this.rate);r=ay(r,"float32");let s=((1-this.rate)*(1+this.rate*a**2))**-.5,i=-s*a*this.rate,o=fo(bo(t,r),bo(fo(r,-1),a));return fo(bo(o,s),i)},()=>Gy(e),t.training||!1)}return e})}};function Pk(e,t,n,a,r){let s,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)s=ic(e,t,n,a,r,i);else if(3===e.rank)s=oc(e,t,n,a,r,i);else{if(4!==e.rank)throw new ub("batchNormalization is not implemented for array of rank ".concat(e.rank," yet"));s=cc(e,t,n,a,r,i)}return s}function Bk(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return eo(()=>{let s=uu(e,a),i=s.mean,o=s.variance;return[Pk(e,i,o,n,t,r),i,o]})}function Wk(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return eo(()=>{let s=uu(e,a),i=s.mean,o=s.variance,c=[];for(let t of ty(0,e.rank))-1!==a.indexOf(t)?c.push(1):c.push(e.shape[t]);let l=Xo(i,c),u=Xo(o,c),d=null==t?null:Xo(t,c),h=null==n?null:Xo(n,c);return[Pk(e,l,u,h,d,r),i,o]})}Lk.className="AlphaDropout",Op.registerClass(Lk);var Uk=class extends nv{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Wy(e.betaInitializer||"zeros"),this.gammaInitializer=Wy(e.gammaInitializer||"ones"),this.movingMeanInitializer=Wy(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Wy(e.movingVarianceInitializer||"ones"),this.betaConstraint=kv(e.betaConstraint),this.gammaConstraint=kv(e.gammaConstraint),this.betaRegularizer=Aw(e.betaRegularizer),this.gammaRegularizer=Aw(e.gammaRegularizer)}build(e){e=Hy(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new lb("Axis ".concat(t," of input tensor should have a defined dimension but the layer received an input with shape ").concat(JSON.stringify(e),"."));this.inputSpec=[new Jy({ndim:e.length,axes:{[t]:n}})];let a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return eo(()=>{let n=null!=t.training&&t.training,a=Gy(e),r=a.shape,s=r.length,i=ty(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let c=pb(1,s);c[o]=r[o];let l=i.slice();l.sort();let u=!Nr.arraysEqual(l,ty(0,s).slice(0,s-1));if(!n)return(()=>{if(u){let e=Xo(this.movingMean.read(),c),t=Xo(this.movingVariance.read(),c),n=this.center?Xo(this.beta.read(),c):null,r=this.scale?Xo(this.gamma.read(),c):null;return Pk(a,e,t,n,r,this.epsilon)}return Pk(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();let[d,h,p]=function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Nr.arraysEqual(a.slice().sort(),ty(0,e.rank-1))?Bk(e,t,n,a,r):Wk(e,t,n,a,r)}(a,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{eo(()=>{let a=1-n,r=e.read(),s=bo(Vl(r,t),a);e.write(Vl(r,s))})};return f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum),d})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:By(this.betaInitializer),gammaInitializer:By(this.gammaInitializer),movingMeanInitializer:By(this.movingMeanInitializer),movingVarianceInitializer:By(this.movingVarianceInitializer),betaRegularizer:Ew(this.betaRegularizer),gammaRegularizer:Ew(this.gammaRegularizer),betaConstraint:xv(this.betaConstraint),gammaConstraint:xv(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};Uk.className="BatchNormalization",Op.registerClass(Uk);var Vk=class extends nv{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, but received ".concat(JSON.stringify(this.axis)));for(let e of this.axis)if(!Number.isInteger(e))throw new Error("Expected axis to be an array of integers, but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Wy(e.betaInitializer||"zeros"),this.gammaInitializer=Wy(e.gammaInitializer||"ones"),this.betaRegularizer=Aw(e.betaRegularizer),this.gammaRegularizer=Aw(e.gammaRegularizer),this.supportsMasking=!0}build(e){let t=(e=Hy(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(let a of this.axis)if(a<0||a>=t)throw new Error("Invalid axis: ".concat(a));if(this.axis.length!==Nb(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));let n=this.axis.map(t=>e[t]);this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(e,t){let n=Gy(e),a=n.shape,r=a.length;return eo(()=>{let{mean:e,variance:t}=uu(n,this.axis,!0),s=pb(1,r);for(let n of this.axis)s[n]=a[n];let i=e=>null!=e&&e.shape.length!==r?Xo(e,s):e,o=this.scale?i(this.gamma.read()):null,c=this.center?i(this.beta.read()):null,l=[],u=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(l.push(a[n]),u.push(1)):(l.push(1),u.push(a[n]));return e=gl(e,l),t=gl(t,l),null!=o&&(o=gl(o,u)),null!=c&&(c=gl(c,u)),Pk(n,e,t,c,o,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:By(this.betaInitializer),gammaInitializer:By(this.gammaInitializer),betaRegularizer:Ew(this.betaRegularizer),gammaRegularizer:Ew(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};Vk.className="LayerNormalization",Op.registerClass(Vk);var Gk=class extends nv{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new lb("ZeroPadding2D expects padding to be a length-2 array, but received a length-".concat(e.padding.length," array."));let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new lb("ZeroPadding2D expects height padding to be a length-2 array, but received a length-".concat(e.padding[0].length," array."));if(t=e.padding[0],2!==e.padding[1].length)throw new lb("ZeroPadding2D expects width padding to be a length-2 array, but received a length-".concat(e.padding[1].length," array."));n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Jy({ndim:4})]}computeOutputShape(e){let t,n;return e=Hy(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return eo(()=>function(e,t,n){return eo(()=>{if(4!==e.rank)throw new lb("temporalPadding expects input tensor to be 4-D, but received a ".concat(e.rank,"-D tensor."));if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new lb("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new lb("Unknown data format: ".concat(n,". Supported data formats are 'channelsLast' and 'channelsFirst."));let a;return a="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],bu(e,a)})}(Gy(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};function Hk(e,t,n,a,r,s){return eo(()=>{Wb(r),Vb(s),Ub(a),null==n&&(n=[1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==s&&(s="max"),e=Ww(e,r);let i,o="same"===a?"same":"valid";return i="max"===s?$l(e,t,n,o):Zo(e,t,n,o),"channelsFirst"===r&&(i=eh(i,[0,3,1,2])),i})}function qk(e,t,n,a,r,s){return eo(()=>{Wb(r),Vb(s),Ub(a),null==n&&(n=[1,1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==s&&(s="max"),e=Uw(e,r);let i,o="same"===a?"same":"valid";return i="max"===s?eu(e,t,n,o):Yo(e,t,n,o),"channelsFirst"===r&&(i=eh(i,[0,4,1,2,3])),i})}Gk.className="ZeroPadding2D",Op.registerClass(Gk);var Kk=class extends nv{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new lb("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ".concat(JSON.stringify(e.poolSize)));this.poolSize=e.poolSize}if(Eb(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new lb("strides for 1D convolutional layer must be a number or an Array of a single number, but received ".concat(JSON.stringify(e.strides)));this.strides=e.strides}Eb(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,Ub(this.padding),this.inputSpec=[new Jy({ndim:3})]}computeOutputShape(e){let t=Pw((e=Hy(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return eo(()=>{this.invokeCallHook(e,t),e=ry(Gy(e),2);let n=this.poolingFunction(Gy(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Cd(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},Xk=class extends Kk{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Wb(r),Ub(a),Hk(e,t,n,a,r,"max")}};Xk.className="MaxPooling1D",Op.registerClass(Xk);var Zk=class extends Kk{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Wb(r),Ub(a),Hk(e,t,n,a,r,"avg")}};Zk.className="AveragePooling1D",Op.registerClass(Zk);var Yk=class extends nv{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new lb("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides];Eb(this.poolSize,"poolSize"),Eb(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Wb(this.dataFormat),Ub(this.padding),this.inputSpec=[new Jy({ndim:4})]}computeOutputShape(e){e=Hy(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=Pw(t,this.poolSize[0],this.padding,this.strides[0]),n=Pw(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return eo(()=>(this.invokeCallHook(e,t),this.poolingFunction(Gy(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},Jk=class extends Yk{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Wb(r),Ub(a),Hk(e,t,n,a,r,"max")}};Jk.className="MaxPooling2D",Op.registerClass(Jk);var Qk=class extends Yk{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Wb(r),Ub(a),Hk(e,t,n,a,r,"avg")}};Qk.className="AveragePooling2D",Op.registerClass(Qk);var $k=class extends nv{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new lb("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Eb(this.poolSize,"poolSize"),Eb(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Wb(this.dataFormat),Ub(this.padding),this.inputSpec=[new Jy({ndim:5})]}computeOutputShape(e){e=Hy(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[4]:e[3];return t=Pw(t,this.poolSize[0],this.padding,this.strides[0]),n=Pw(n,this.poolSize[1],this.padding,this.strides[1]),a=Pw(a,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return eo(()=>(this.invokeCallHook(e,t),this.poolingFunction(Gy(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},eI=class extends $k{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Wb(r),Ub(a),qk(e,t,n,a,r,"max")}};eI.className="MaxPooling3D",Op.registerClass(eI);var tI=class extends $k{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Wb(r),Ub(a),qk(e,t,n,a,r,"avg")}};tI.className="AveragePooling3D",Op.registerClass(tI);var nI=class extends nv{constructor(e){super(e),this.inputSpec=[new Jy({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new ub}},aI=class extends nI{constructor(e){super(e||{})}call(e,t){return eo(()=>{let t=Gy(e);return au(t,1)})}};aI.className="GlobalAveragePooling1D",Op.registerClass(aI);var rI=class extends nI{constructor(e){super(e||{})}call(e,t){return eo(()=>{let t=Gy(e);return al(t,1)})}};rI.className="GlobalMaxPooling1D",Op.registerClass(rI);var sI=class extends nv{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Wb(this.dataFormat),this.inputSpec=[new Jy({ndim:4})]}computeOutputShape(e){return e=e,"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new ub}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},iI=class extends sI{call(e,t){return eo(()=>{let t=Gy(e);return"channelsLast"===this.dataFormat?au(t,[1,2]):au(t,[2,3])})}};iI.className="GlobalAveragePooling2D",Op.registerClass(iI);var oI=class extends sI{call(e,t){return eo(()=>{let t=Gy(e);return"channelsLast"===this.dataFormat?al(t,[1,2]):al(t,[2,3])})}};oI.className="GlobalMaxPooling2D",Op.registerClass(oI);var cI=class extends nv{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=tx(t.layer,n);delete t.layer;let r={layer:a};return Object.assign(r,t),new e(r)}},lI=class extends cI{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Hy(e)).length<3)throw new lb("TimeDistributed layer expects an input shape >= 3D, but received input shape ".concat(JSON.stringify(e)));this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){let t=[(e=Hy(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return eo(()=>ak((e,n)=>[Gy(this.layer.call(e,t)),[]],e=Gy(e),[],!1,null,null,!1,!0)[1])}};lI.className="TimeDistributed",Op.registerClass(lI);var uI=class extends cI{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=tx(n),t.goBackwards=!0!==t.goBackwards;let a={};if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=tx(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function(e){Ob(Pb,"BidirectionalMergeMode",e)}(this.mergeMode),e.weights)throw new ub("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,a,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r,this.returnState&&(a=r.slice(1)),t=r[0],t=t,"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(a).concat(a.slice()):[t].concat(a).concat(a.slice()):gb(n)}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});let r=nk(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==a)return super.apply(e,t);let s=[],i=[];if(null!=n){let e=n.length;if(e%2>0)throw new lb("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let a=n.map(e=>new Jy({shape:e.shape}));this.forwardLayer.stateSpec=a.slice(0,e/2),this.backwardLayer.stateSpec=a.slice(e/2),i.push(...a)}if(null!=a)throw new ub("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof Qy;for(let c of s)if(c instanceof Qy!==o)throw new lb("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let n=[e].concat(s),a=this.inputSpec.concat(i),r=this.inputSpec;this.inputSpec=a;let o=super.apply(n,t);return this.inputSpec=r,o}return super.apply(e,t)}call(e,t){return eo(()=>{let n,a,r,s,i=t.initialState;if(null==i)n=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{let r=i.slice(0,i.length/2),s=i.slice(i.length/2);n=this.forwardLayer.call(e,Object.assign(t,{initialState:r})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:s}))}return this.returnState&&(Array.isArray(n)&&(r=n.slice(1).concat(a.slice(1))),n=n[0],a=a[0]),this.returnSequences&&(a=rd(a,1)),"concat"===this.mergeMode?s=ly([n,a]):"sum"===this.mergeMode?s=fo(n,a):"ave"===this.mergeMode?s=bo(.5,fo(n,a)):"mul"===this.mergeMode?s=bo(n,a):null==this.mergeMode&&(s=[n,a]),this.returnState?null==this.mergeMode?s.concat(r):[s].concat(r):s})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Hb(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Hb(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){let e=this.forwardLayer.states.map(e=>null);return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=tx(t.layer);if(delete t.layer,null!=t.numConstants)throw new ub("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let a=t;return a.layer=n,new e(a)}};uI.className="Bidirectional",Op.registerClass(uI);var dI=class extends nv{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return eo(()=>("float32"!==(e=Gy(e)).dtype&&(e=ay(e,"float32")),fo(bo(e,this.scale),this.offset)))}};dI.className="Rescaling",Op.registerClass(dI);var{resizeBilinear:hI,cropAndResize:pI}=kp,fI=class extends nv{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,a,r,s,i,o){return eo(()=>{let c,l=!1,u=[t/s,n/i,(a+t)/s,(r+n)/i],d=[];3===e.rank?(l=!0,c=Ed([e])):c=e;for(let e=0;e<c.shape[0];e++)d.push(u);let h=qs(d,[d.length,4]),p=$u(0,d.length,1,"int32"),f=pI(c,h,p,[a,r],"nearest");return ay(l?Gy(Xd(f)):f,o)})}upsize(e,t,n,a){return eo(()=>ay(hI(e,[t,n]),a))}call(e,t){return eo(()=>{let t=Gy(e),n=t.dtype,a=t.shape,r=a[a.length-3],s=a[a.length-2],i=0;r!==this.height&&(i=Math.floor((r-this.height)/2));let o=0;return s!==this.width&&(o=Math.floor((s-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,r,s,n):this.upsize(e,this.height,this.width,n)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=Hy(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};fI.className="CenterCrop",Op.registerClass(fI);var mI=class extends nv{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=Hy(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return eo(()=>{let n;if("int32"!==(e=Gy(e)).dtype&&(e=ay(e,"int32")),"undefined"!=typeof t.countWeights){if("count"!==this.outputMode)throw new lb("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(t.countWeights));n=Gy(t.countWeights)}let a=al(e),r=rl(e),s=xl(this.numTokens,a).bufferSync().get(0),i=wl(r,0).bufferSync().get(0);if(!s||!i)throw new lb("Input values must be between 0 < values <= numTokens with numTokens=".concat(this.numTokens));return function(e,t,n,a){let r=Gy(e);if("int32"!==r.dtype&&(r=ay(r,"int32")),"int"===t)return r;let s=r.shape;if(0===r.rank&&(r=fl(r,-1)),"oneHot"===t&&1!==r.shape[r.shape.length-1]&&(r=fl(r,-1)),r.rank>2)throw new lb("When outputMode is not int, maximum output rank is 2 Received outputMode ".concat(t," and input shape ").concat(s," which would result in output rank ").concat(r.rank,"."));let i,o=["multiHot","oneHot"].includes(t),c=r;if(i=Ac(c,"undefined"!=typeof a&&"count"===t?a:[],n,o),"tfIdf"!==t)return i;if(a)return bo(i,a);throw new lb("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)})}};mI.className="CategoryEncoding",Op.registerClass(mI);var gI=new Set(["bilinear","nearest"]),bI=class extends nv{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!gI.has(e.interpolation))throw new lb("Invalid interpolation parameter: ".concat(e.interpolation," is not implemented"));this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){let t=(e=Hy(e))[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return eo(()=>{let t=[this.height,this.width];if("bilinear"===this.interpolation)return kp.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return kp.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error("Interpolation is ".concat(this.interpolation," but only ").concat([...gI]," are supported"))})}};bI.className="Resizing",Op.registerClass(bI);var yI=class{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}};yI.className="RandomSeed";var vI=class extends nv{constructor(e){super(e),this.randomGenerator=new yI(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};vI.className="BaseRandomLayer";var xI=new Set(["bilinear","nearest"]),wI=class extends vI{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new lb("Invalid factor: ".concat(this.factor,". Must be positive number or tuple of 2 numbers"));this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new lb("factor must have values larger than -1. Got: ".concat(this.factor));if(this.widthUpper<this.widthLower)throw new lb("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(this.widthUpper,".\n        Got lower bound: ").concat(this.widthLower,"\n      "));if(n){if(!xI.has(n))throw new lb("Invalid interpolation parameter: ".concat(n," is not implemented"));this.interpolation=n}}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=Hy(e))[2];return[this.imgHeight,-1,t]}call(e,t){return eo(()=>{let t=Gy(e);this.imgHeight=t.shape[t.shape.length-3];let n=t.shape[t.shape.length-2];this.widthFactor=Ju([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*n;a=Math.round(a);let r=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return kp.resizeBilinear(e,r);case"nearest":return kp.resizeNearestNeighbor(e,r);default:throw new Error("Interpolation is ".concat(this.interpolation,"\n          but only ").concat([...xI]," are supported"))}})}};function kI(e){return new av(e)}function II(e){return new Mw(e)}function SI(e){return new Rw(e)}function NI(e){return new Dw(e)}function TI(e){return new Fw(e)}function OI(e){return new zw(e)}function CI(e){return new jw(e)}function EI(e){return new Qw(e)}function _I(e){return new qw(e)}function AI(e){return new Xw(e)}function RI(e){return new Kw(e)}function DI(e){return new Zw(e)}function FI(e){return new Jw(e)}function MI(e){return new $w(e)}function jI(e){return new ek(e)}function zI(e){return new tk(e)}function LI(e){return new wk(e)}function PI(e){return new vk(e)}function BI(e){return new bk(e)}function WI(e){return new yk(e)}function UI(e){return new xk(e)}function VI(e){return new kk(e)}function GI(e){return new Ik(e)}function HI(e){return new Sk(e)}function qI(e){return new Tk(e)}function KI(e){return new Ck(e)}function XI(e){return new _k(e)}function ZI(e){return new Dk(e)}function YI(e){return new Ak(e)}function JI(e){return new Rk(e)}function QI(e){return new Ek(e)}function $I(e){return new Mk(e)}function eS(e){return new Uk(e)}function tS(e){return new Vk(e)}function nS(e){return new Gk(e)}function aS(e){return new Zk(e)}function rS(e){return aS(e)}function sS(e){return aS(e)}function iS(e){return new Qk(e)}function oS(e){return iS(e)}function cS(e){return iS(e)}function lS(e){return new tI(e)}function uS(e){return lS(e)}function dS(e){return lS(e)}function hS(e){return new aI(e)}function pS(e){return new iI(e)}function fS(e){return new rI(e)}function mS(e){return new oI(e)}function gS(e){return new Xk(e)}function bS(e){return new Jk(e)}function yS(e){return new eI(e)}function vS(e){return new lk(e)}function xS(e){return new ck(e)}function wS(e){return new dk(e)}function kS(e){return new uk(e)}function IS(e){return new ok(e)}function SS(e){return new ik(e)}function NS(e){return new gk(e)}function TS(e){return new mk(e)}function OS(e){return new rk(e)}function CS(e){return new hk(e)}function ES(e){return new uI(e)}function _S(e){return new lI(e)}wI.className="RandomWidth",Op.registerClass(wI);var AS=fS,RS=mS,DS=gS,FS=bS;function MS(e){return new jk(e)}function jS(e){return new zk(e)}function zS(e){return new Lk(e)}function LS(e){return new Nk(e)}function PS(e){return new dI(e)}function BS(e){return new fI(e)}function WS(e){return new bI(e)}function US(e){return new mI(e)}function VS(e){return new wI(e)}var GS={};function HS(e,t){return hx(e,t)}function qS(e,t){return bx(e,t)}function KS(e,t){return yx(e,t)}function XS(e,t){return px(e,t)}function ZS(e,t){return vx(e,t)}function YS(e,t){return mx(e,t)}function JS(e,t){return gx(e,t)}function QS(e,t){return lx(e,t)}function $S(e,t){return rx(e,t)}function eN(e,t){return sx(e,t)}function tN(e,t){return sx(e,t)}function nN(e,t){return sx(e,t)}function aN(e,t){return ax(e,t)}function rN(e,t){return ax(e,t)}function sN(e,t){return ax(e,t)}y(GS,{MAPE:()=>tN,MSE:()=>rN,binaryAccuracy:()=>HS,binaryCrossentropy:()=>qS,categoricalAccuracy:()=>XS,categoricalCrossentropy:()=>ZS,cosineProximity:()=>QS,mape:()=>nN,meanAbsoluteError:()=>$S,meanAbsolutePercentageError:()=>eN,meanSquaredError:()=>aN,mse:()=>sN,precision:()=>YS,recall:()=>JS,sparseCategoricalAccuracy:()=>KS});var iN={};y(iN,{modelFromJSON:()=>ew});var oN={};function cN(e){return new Ow(e)}function lN(e){return function(e){return Nw(e),new Ow({l1:null!=e?e.l1:null,l2:0})}(e)}function uN(e){return function(e){return Nw(e),new Ow({l2:null!=e?e.l2:null,l1:0})}(e)}y(oN,{l1:()=>lN,l1l2:()=>cN,l2:()=>uN});var dN=class extends Kv{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Qx))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function hN(e,t){return e<t}function pN(e,t){return e>t}var fN=class extends dN{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new ub("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn("EarlyStopping mode '".concat(this.mode,"' is invalid. Falling back to mode 'auto'.")),this.mode="auto"),"min"===this.mode?this.monitorFunc=hN:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=pN:this.monitorFunc=hN,this.monitorFunc===hN&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===hN?1/0:-1/0}async onEpochEnd(e,t){await Hv(t);let n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log("Epoch ".concat(this.stoppedEpoch,": early stopping."))}getMonitorValue(e){null==e&&(e={});let t=e[this.monitor];return null==t&&console.warn("Metric for EarlyStopping ".concat(this.monitor," is not available. Available metrics are: ").concat(Object.keys(e))),t}};var mN,gN,bN={earlyStopping:function(e){return new fN(e)}};Ue().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(mN||(mN={})),function(e){let t;var n;(n=t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"}(gN||(gN={}));var yN={};function vN(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};yN[e]=n}function xN(e){return yN[e]}function wN(e){delete yN[e]}function kN(e,t,n,a,r){let s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){let e=s.inputIndexStart,i=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===s.type)return IN(t.inputNames[o],n,a,r);if("tensors"===s.type){let s=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter((e,t)=>{var n;return"NoOp"!==(null===(n=s[t])||void 0===n?void 0:n.op)}).map(e=>IN(e,n,a,r))}let c=IN(t.inputNames[o],n,a,r),l=c.dataSync();return"number"===s.type?l[0]:Nr.toNestedArray(c.shape,l)}let i=t.attrParams[e];return i&&i.value}function IN(e,t,n,a){let[r,s]=ON(e,n);if(null!=a){let e=a.getHashTableHandleByName(r);if(null!=e)return e}let i=n.currentContextIds.find(e=>!!t[TN(r,e)]);return void 0!==i?t[TN(r,i)][s]:void 0}function SN(e,t,n){return t[TN(e,n.currentContextId)]}function NN(e,t){let[n,a,r]=ON(e,t);return[TN(n,t&&t.currentContextId),a,r]}function TN(e,t){return t?"".concat(e,"-").concat(t):e}function ON(e,t){if(""===e)return["",0,void 0];let n=null!=t&&null!=t.parseNodeNameCache;if(n){let n=t.parseNodeNameCache.get(e);if(null!=n)return n}let a,r=e.split(":");if(1===r.length)a=[e,0,void 0];else{let e=r[0],t=3===r.length?r[1]:void 0;a=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,a),a}function CN(e,t,n){let a=kN("pad",e,t,n);if("explicit"===a){a=kN("explicitPaddings",e,t,n);let r=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)r[e][0]=a[2*e],r[e][1]=a[2*e+1];return r}return a}function EN(e){return e.kept?e:Gi(e)}var _N={};y(_N,{json:()=>AN});var AN=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],RN={};y(RN,{json:()=>DN});var DN=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],FN={};y(FN,{json:()=>MN});var MN=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],jN={};y(jN,{json:()=>zN});var zN=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],LN={};y(LN,{json:()=>PN});var PN=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],BN={};y(BN,{json:()=>WN});var WN=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],UN={};y(UN,{json:()=>VN});var VN=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],GN={};y(GN,{json:()=>HN});var HN=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],qN={};y(qN,{json:()=>KN});var KN=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],XN={};y(XN,{json:()=>ZN});var ZN=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],YN={};y(YN,{json:()=>JN});var JN=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],QN={};y(QN,{json:()=>$N});var $N=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],eT={};y(eT,{json:()=>tT});var tT=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],nT={};y(nT,{json:()=>aT});var aT=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],rT={};y(rT,{json:()=>sT});var sT=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],iT={};y(iT,{json:()=>oT});var oT=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],cT={};y(cT,{json:()=>lT});var lT=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],uT={};y(uT,{json:()=>dT});var dT=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],hT={};y(hT,{json:()=>pT});var pT=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],fT=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[].concat(...[_N,RN,FN,jN,LN,BN,UN,GN,qN,XN,YN,QN,eT,nT,rT,iT,cT,uT,hT].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e.node,a=[],r=[],s=[],i=n.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?a.push(e[t.name]):"Const"===t.op?r.push(e[t.name]):(null==t.input||0===t.input.length)&&s.push(e[t.name]),e),{}),o=[],c=[],l={},u={};null!=t&&(l=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach(e=>{let t=i[e];t.inputNames.forEach((e,n)=>{let[a,,r]=NN(e),s=i[a];if(null!=s.outputs){let e=s.outputs.indexOf(r);if(-1!==e){let r="".concat(a,":").concat(e);t.inputNames[n]=r}}t.inputs.push(s),s.children.push(t)})}),0===Object.keys(u).length?d.forEach(e=>{let t=i[e];0===t.children.length&&c.push(t)}):Object.keys(u).forEach(e=>{let[t]=NN(e),n=i[t];null!=n&&(n.signatureKey=u[e],c.push(n))}),Object.keys(l).length>0?Object.keys(l).forEach(e=>{let[t]=NN(e),n=i[t];n&&(n.signatureKey=l[e],o.push(n))}):o=a;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));let p={nodes:i,inputs:o,outputs:c,weights:r,placeholders:a,signature:t,functions:h};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=xN(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.slice(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce((t,n)=>{let a,r=n.type;switch(n.type){case"string":a=gT(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=gT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":a=TT(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=TT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":a=yT(e.attr,n.tfName,n.defaultValue||0),void 0===a&&n.tfDeprecatedName&&(a=yT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":a=NT(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=NT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":a=bT(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=bT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":a=CT(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=CT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":a=ST(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=ST(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":a=OT(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=OT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":a=wT(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=wT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":a=kT(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=kT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":a=xT(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=xT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: ".concat(n.type," for op: ").concat(e.op))}return t[n.name]={value:a,type:r},t},{})),n}mapFunction(e){let t=e.nodeDef,n=[],a={};null!=t&&(a=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e),{}));let r=[],s=[];e.signature.inputArg.forEach(e=>{let[t]=NN(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:vT(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,r.push(n),a[t]=n}),Object.keys(a).forEach(e=>{let t=a[e];t.inputNames.forEach((e,n)=>{let[r,,s]=NN(e),i=a[r];if(null!=i.outputs){let e=i.outputs.indexOf(s);if(-1!==e){let a="".concat(r,":").concat(e);t.inputNames[n]=a}}t.inputs.push(i),i.children.push(t)})});let i=e.ret;e.signature.outputArg.forEach(e=>{let[t,n]=NN(i[e.name]),r=a[t];null!=r&&(r.defaultOutput=n,s.push(r))});let o=this.mapArgsToSignature(e);return{nodes:a,inputs:r,outputs:s,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}};function mT(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){let t=Ue().global;if("undefined"!=typeof t.atob)return t.atob(e);if("undefined"!=typeof i)return new i(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function gT(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=e[t];return null!=r?mT(r.s,a):n}function bT(e,t,n){let a=e[t];return a?a.b:n}function yT(e,t,n){let a=e[t]||{},r=null!=a.i?a.i:null!=a.f?a.f:n;return"number"==typeof r?r:parseInt(r,10)}function vT(e){switch("string"==typeof e&&(e=mN[e]),e){case mN.DT_FLOAT:case mN.DT_HALF:return"float32";case mN.DT_INT32:case mN.DT_INT64:case mN.DT_INT8:case mN.DT_UINT8:return"int32";case mN.DT_BOOL:return"bool";case mN.DT_DOUBLE:return"float32";case mN.DT_STRING:return"string";default:return null}}function xT(e,t,n){let a=e[t];return a&&a.func?a.func.name:n}function wT(e,t,n){let a=e[t];return a&&a.type?vT(a.type):n}function kT(e,t,n){let a=e[t];return a&&a.list&&a.list.type?a.list.type.map(e=>vT(e)):n}function IT(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"==typeof e.size?e.size:parseInt(e.size,10)):[]}function ST(e,t,n){let a=e[t];return a&&a.shape?IT(a.shape):n}function NT(e,t,n){let a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map(e=>"number"==typeof e?e:parseInt(e,10)):n}function TT(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=e[t];return r&&r.list&&r.list.s?r.list.s.map(e=>mT(e,a)):n}function OT(e,t,n){let a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map(e=>IT(e)):n}function CT(e,t,n){let a=e[t];return a&&a.list&&a.list.b?a.list.b:n}var ET=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return IN(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(null!=n.tensor)return IN(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return yT(this.node.rawAttrs,e,t);if(null!=n.s)return gT(this.node.rawAttrs,e,t);if(null!=n.b)return bT(this.node.rawAttrs,e,t);if(null!=n.shape)return ST(this.node.rawAttrs,e,t);if(null!=n.type)return wT(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return NT(this.node.rawAttrs,e,t);if(null!=n.list.s)return TT(this.node.rawAttrs,e,t);if(null!=n.list.shape)return OT(this.node.rawAttrs,e,t);if(null!=n.list.b)return CT(this.node.rawAttrs,e,t);if(null!=n.list.type)return kT(this.node.rawAttrs,e,t)}return t}},_T={};y(_T,{OP_SCOPE_SUFFIX:()=>Us,abs:()=>yo,acos:()=>vo,acosh:()=>xo,add:()=>fo,addN:()=>wo,all:()=>ko,any:()=>Io,argMax:()=>So,argMin:()=>No,asin:()=>To,asinh:()=>Oo,atan:()=>Co,atan2:()=>Eo,atanh:()=>_o,avgPool:()=>Zo,avgPool3d:()=>Yo,basicLSTMCell:()=>nc,batchNorm:()=>sc,batchNorm2d:()=>ic,batchNorm3d:()=>oc,batchNorm4d:()=>cc,batchToSpaceND:()=>ac,bincount:()=>lc,bitwiseAnd:()=>uc,booleanMaskAsync:()=>$d,broadcastArgs:()=>dc,broadcastTo:()=>hc,buffer:()=>Ui,cast:()=>Vi,ceil:()=>pc,clipByValue:()=>mc,clone:()=>Gi,complex:()=>Gs,concat:()=>Jo,concat1d:()=>gc,concat2d:()=>bc,concat3d:()=>yc,concat4d:()=>vc,conv1d:()=>wc,conv2d:()=>xc,conv2dTranspose:()=>Ic,conv3d:()=>Sc,conv3dTranspose:()=>Tc,cos:()=>Oc,cosh:()=>Cc,cosineWindow:()=>ch,cumprod:()=>Ec,cumsum:()=>_c,denseBincount:()=>Ac,depthToSpace:()=>Rc,depthwiseConv2d:()=>Dc,diag:()=>Fc,dilation2d:()=>Mc,div:()=>go,divNoNan:()=>Vc,dot:()=>Gc,dropout:()=>ih,einsum:()=>Hc,elu:()=>qc,enclosingPowerOfTwo:()=>oh,ensureShape:()=>Kc,equal:()=>Bc,erf:()=>Xc,euclideanNorm:()=>hl,exp:()=>pl,expandDims:()=>fl,expm1:()=>ml,eye:()=>bl,fft:()=>kd,fill:()=>fc,floor:()=>yl,floorDiv:()=>mo,fused:()=>uh,gather:()=>vl,gatherND:()=>sh,greater:()=>xl,greaterEqual:()=>wl,ifft:()=>Id,imag:()=>kl,image:()=>kp,inTopKAsync:()=>lh,irfft:()=>Sd,isFinite:()=>Il,isInf:()=>Sl,isNaN:()=>Nl,leakyRelu:()=>Tl,less:()=>Ol,lessEqual:()=>Cl,linalg:()=>Ip,linspace:()=>El,localResponseNormalization:()=>_l,log:()=>Al,log1p:()=>Rl,logSigmoid:()=>Ul,logSoftmax:()=>Gl,logSumExp:()=>Hl,logicalAnd:()=>ql,logicalNot:()=>Kl,logicalOr:()=>Xl,logicalXor:()=>Zl,losses:()=>Sp,lowerBound:()=>Ql,matMul:()=>Qo,max:()=>al,maxPool:()=>$l,maxPool3d:()=>eu,maxPoolWithArgmax:()=>tu,maximum:()=>nu,mean:()=>au,meshgrid:()=>iu,min:()=>rl,minimum:()=>ou,mirrorPad:()=>cu,mod:()=>lu,moments:()=>uu,movingAverage:()=>th,mul:()=>bo,multiRNNCell:()=>du,multinomial:()=>hu,neg:()=>Bl,norm:()=>dl,notEqual:()=>pu,oneHot:()=>fu,ones:()=>su,onesLike:()=>mu,op:()=>Vs,outerProduct:()=>gu,pad:()=>bu,pad1d:()=>yu,pad2d:()=>vu,pad3d:()=>xu,pad4d:()=>wu,pool:()=>Iu,pow:()=>sl,prelu:()=>Su,print:()=>Hi,prod:()=>Nu,raggedGather:()=>Tu,raggedRange:()=>Ou,raggedTensorToTensor:()=>Cu,rand:()=>Eu,randomGamma:()=>Xu,randomNormal:()=>Zu,randomStandardNormal:()=>Yu,randomUniform:()=>Ju,randomUniformInt:()=>Qu,range:()=>$u,real:()=>ed,reciprocal:()=>td,relu:()=>nd,relu6:()=>ad,reshape:()=>Xo,reverse:()=>rd,reverse1d:()=>sd,reverse2d:()=>id,reverse3d:()=>od,reverse4d:()=>cd,rfft:()=>Td,round:()=>ld,rsqrt:()=>ud,scalar:()=>il,scatterND:()=>nh,searchSorted:()=>Jl,selu:()=>dd,separableConv2d:()=>hd,setdiff1dAsync:()=>pd,sigmoid:()=>$o,sign:()=>fd,signal:()=>wp,sin:()=>md,sinh:()=>gd,slice:()=>ec,slice1d:()=>bd,slice2d:()=>yd,slice3d:()=>vd,slice4d:()=>xd,softmax:()=>wd,softplus:()=>Wl,spaceToBatchND:()=>ku,sparse:()=>Np,sparseToDense:()=>rh,spectral:()=>xp,split:()=>Nd,sqrt:()=>ol,square:()=>cl,squaredDifference:()=>Od,squeeze:()=>Cd,stack:()=>Ed,step:()=>_d,stridedSlice:()=>Ad,string:()=>Tp,sub:()=>Vl,sum:()=>ll,tan:()=>Rd,tanh:()=>tc,tensor:()=>qs,tensor1d:()=>Dd,tensor2d:()=>Fd,tensor3d:()=>Md,tensor4d:()=>jd,tensor5d:()=>zd,tensor6d:()=>Ld,tensorScatterUpdate:()=>Vd,tile:()=>gl,topk:()=>Gd,transpose:()=>eh,truncatedNormal:()=>Hd,unique:()=>qd,unsortedSegmentSum:()=>Kd,unstack:()=>Xd,upperBound:()=>Zd,variable:()=>Yd,where:()=>Wc,whereAsync:()=>Qd,zeros:()=>ru,zerosLike:()=>Uc});var AT=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[a.add(kN("a",e,t,n),kN("b",e,t,n))];case"AddN":return[a.addN(kN("tensors",e,t,n))];case"FloorMod":case"Mod":return[a.mod(kN("a",e,t,n),kN("b",e,t,n))];case"Mul":return[a.mul(kN("a",e,t,n),kN("b",e,t,n))];case"RealDiv":case"Div":return[a.div(kN("a",e,t,n),kN("b",e,t,n))];case"DivNoNan":return[a.divNoNan(kN("a",e,t,n),kN("b",e,t,n))];case"FloorDiv":return[a.floorDiv(kN("a",e,t,n),kN("b",e,t,n))];case"Sub":return[a.sub(kN("a",e,t,n),kN("b",e,t,n))];case"Minimum":return[a.minimum(kN("a",e,t,n),kN("b",e,t,n))];case"Maximum":return[a.maximum(kN("a",e,t,n),kN("b",e,t,n))];case"Pow":return[a.pow(kN("a",e,t,n),kN("b",e,t,n))];case"SquaredDifference":return[a.squaredDifference(kN("a",e,t,n),kN("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},RT=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"Abs":case"ComplexAbs":return[a.abs(kN("x",e,t,n))];case"Acos":return[a.acos(kN("x",e,t,n))];case"Acosh":return[a.acosh(kN("x",e,t,n))];case"Asin":return[a.asin(kN("x",e,t,n))];case"Asinh":return[a.asinh(kN("x",e,t,n))];case"Atan":return[a.atan(kN("x",e,t,n))];case"Atan2":return[a.atan2(kN("x",e,t,n),kN("y",e,t,n))];case"Atanh":return[a.atanh(kN("x",e,t,n))];case"Ceil":return[a.ceil(kN("x",e,t,n))];case"Complex":return[a.complex(kN("real",e,t,n),kN("imag",e,t,n))];case"Cos":return[a.cos(kN("x",e,t,n))];case"Cosh":return[a.cosh(kN("x",e,t,n))];case"Elu":return[a.elu(kN("x",e,t,n))];case"Erf":return[a.erf(kN("x",e,t,n))];case"Exp":return[a.exp(kN("x",e,t,n))];case"Expm1":return[a.expm1(kN("x",e,t,n))];case"Floor":return[a.floor(kN("x",e,t,n))];case"Log":return[a.log(kN("x",e,t,n))];case"Log1p":return[a.log1p(kN("x",e,t,n))];case"Imag":return[a.imag(kN("x",e,t,n))];case"Neg":return[a.neg(kN("x",e,t,n))];case"Reciprocal":return[a.reciprocal(kN("x",e,t,n))];case"Real":return[a.real(kN("x",e,t,n))];case"Relu":return[a.relu(kN("x",e,t,n))];case"Round":return[a.round(kN("x",e,t,n))];case"Selu":return[a.selu(kN("x",e,t,n))];case"Sigmoid":return[a.sigmoid(kN("x",e,t,n))];case"Sin":return[a.sin(kN("x",e,t,n))];case"Sign":return[a.sign(kN("x",e,t,n))];case"Sinh":return[a.sinh(kN("x",e,t,n))];case"Softplus":return[a.softplus(kN("x",e,t,n))];case"Sqrt":return[a.sqrt(kN("x",e,t,n))];case"Square":return[a.square(kN("x",e,t,n))];case"Tanh":return[a.tanh(kN("x",e,t,n))];case"Tan":return[a.tan(kN("x",e,t,n))];case"ClipByValue":return[a.clipByValue(kN("x",e,t,n),kN("clipValueMin",e,t,n),kN("clipValueMax",e,t,n))];case"Relu6":return[a.relu6(kN("x",e,t,n))];case"Rsqrt":return[a.rsqrt(IN(e.inputNames[0],t,n))];case"LeakyRelu":return[a.leakyRelu(kN("x",e,t,n),kN("alpha",e,t,n))];case"Prelu":return[a.prelu(kN("x",e,t,n),kN("alpha",e,t,n))];case"IsNan":return[a.isNaN(IN(e.inputNames[0],t,n))];case"IsInf":return[a.isInf(IN(e.inputNames[0],t,n))];case"IsFinite":return[a.isFinite(IN(e.inputNames[0],t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function DT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!=typeof e&&"number"!=typeof t){Nr.assert(e.length===t.length,()=>n+" Shapes ".concat(e," and ").concat(t," must match"));for(let a=0;a<e.length;a++){let r=e[a],s=t[a];Nr.assert(r<0||s<0||r===s,()=>n+" Shapes ".concat(e," and ").concat(t," must match"))}}}function FT(e){return!("number"==typeof e||e.some(e=>e<0))}function MT(e,t,n){let a=jT(e,n),r=!FT(a);if(r&&0===t.length)throw new Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: ".concat(a));if(r&&t.forEach(e=>{a=jT(e.shape,a)}),!FT(a))throw new Error("Non-fully-defined elementShape: ".concat(a));return a}function jT(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error("Incompatible ranks during merge: ".concat(e," vs. ").concat(t));let n=[];for(let a=0;a<e.length;++a){let r=e[a],s=t[a];if(r>=0&&s>=0&&r!==s)throw new Error("Incompatible shape during merge: ".concat(e," vs. ").concat(t));n[a]=r>=0?r:s}return n}var zT=class{get id(){return this.idTensor.id}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach(e=>{if(n!==e.dtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(e.dtype));DT(t,e.shape,"TensorList shape mismatch: "),no(e)}),this.idTensor=il(0),this.maxNumElements=a,no(this.idTensor)}copy(){return new zT([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(null==e||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(-1!==n&&this.tensors.length!==n)throw new Error("Operation expected a list with ".concat(n," elements but got a list with ").concat(this.tensors.length," elements."));DT(e,this.elementShape,"TensorList shape mismatch: ");let a=MT(this.elementShape,this.tensors,e);return eo(()=>{let e=this.tensors.map(e=>Xo(e,a));return Ed(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(0===this.size())throw new Error("Trying to pop from an empty list.");let n=MT(this.elementShape,this.tensors,e),a=this.tensors.pop();return a.kept=!1,DT(a.shape,e,"TensorList shape mismatch: "),Xo(a,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(this.elementDtype));if(DT(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");no(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error("TensorListResize expects size to be non-negative. Got: ".concat(e));if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error("TensorListResize input size ".concat(e," is greater maxNumElement ").concat(this.maxNumElements,"."));let t=new zT([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(this.elementDtype));if(e<0||e>this.tensors.length)throw new Error("Trying to access element ".concat(e," in a list with ").concat(this.tensors.length," elements."));if(null==this.tensors[e])throw new Error("element at index ".concat(e," is null."));DT(this.tensors[e].shape,t,"TensorList shape mismatch: ");let a=MT(this.elementShape,this.tensors,t);return Xo(this.tensors[e],a)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t.dtype,", but list elements ").concat(this.elementDtype));if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error("Trying to set element ".concat(e," in a list with max ").concat(this.maxNumElements," elements."));DT(this.elementShape,t.shape,"TensorList shape mismatch: "),no(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));DT(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let a=MT(this.elementShape,this.tensors,n);return 0===e.length?qs([],[0].concat(a)):eo(()=>{let t=e.map(e=>Xo(this.tensors[e],a));return Ed(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error("TensorList dtype is ".concat(this.elementDtype," but concat requested dtype ").concat(e));DT(this.elementShape,t,"TensorList shape mismatch: ");let n=MT(this.elementShape,this.tensors,t);return 0===this.size()?qs([],[0].concat(n)):eo(()=>{let e=this.tensors.map(e=>Xo(e,n));return Jo(e,0)})}};var LT=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let a=kN("thenBranch",e,t,n),r=kN("elseBranch",e,t,n),s=kN("cond",e,t,n),i=kN("args",e,t,n);return(await s.data())[0]?n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let a=kN("body",e,t,n),r=kN("cond",e,t,n),s=kN("args",e,t,n),i=await n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(e=>e.id),c=await i[0].data();i.forEach(e=>{!e.kept&&-1===o.indexOf(e.id)&&e.dispose()});let l=s;for(;c[0];){let e=l;l=await n.functionMap[a].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);let t=l.map(e=>e.id);e.forEach(e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()});let s=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);c=await s[0].data(),s.forEach(e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()})}return l}case"LoopCond":return[EN(kN("pred",e,t,n))];case"Switch":{let a=kN("pred",e,t,n),r=kN("data",e,t,n);return r.kept||(r=EN(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{let a=e.inputNames.find(e=>void 0!==IN(e,t,n));if(a){return[EN(IN(a,t,n))]}return}case"Enter":{let a=kN("frameName",e,t,n),r=kN("tensor",e,t,n);return n.enterFrame(a),[EN(r)]}case"Exit":{let a=kN("tensor",e,t,n);return n.exitFrame(),[EN(a)]}case"NextIteration":{let a=kN("tensor",e,t,n);return n.nextIteration(),[EN(a)]}case"TensorArrayV3":{let a=kN("size",e,t,n),r=kN("dtype",e,t,n),s=kN("elementShape",e,t,n),i=kN("dynamicSize",e,t,n),o=kN("clearAfterRead",e,t,n),c=kN("identicalElementShapes",e,t,n),l=kN("name",e,t,n),u=new class{constructor(e,t,n,a,r,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=il(0),no(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(null==e||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||e>=this.size())throw new Error("Tried to read from index ".concat(e,", but array size is: ").concat(this.size()));let t=this.tensors[e];if(t.cleared)throw new Error("TensorArray ".concat(this.name,": Could not read index ").concat(e," twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?)."));return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error("Tried to write to index ".concat(e,", but array is not resizeable and size is: ").concat(this.maxSize));let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,",\n          because the value dtype is ").concat(t.dtype,", but TensorArray dtype is ").concat(this.dtype,"."));if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),DT(this.elementShape,t.shape,"TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,".")),n.read)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been read."));if(n.written)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been written."));n.tensor=t,no(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error("TensorArray ".concat(this.name,": could not write multiple tensors,because the index size: ").concat(e.length," is not the same as tensors size: ").concat(t.length,"."));e.forEach((e,n)=>this.write(e,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but gather requested dtype ").concat(t));if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return qs([],[0].concat(this.elementShape));let n=this.readMany(e);return DT(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Ed(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but concat requested dtype ").concat(e));if(0===this.size())return qs([],[0].concat(this.elementShape));let t=[];for(let a=0;a<this.size();a++)t.push(a);let n=this.readMany(t);return DT(this.elementShape,n[0].shape,"TensorArray shape mismatch: tensor array shape (".concat(this.elementShape,") vs first tensor shape (").concat(n[0].shape,")")),Jo(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));if(e.length!==t.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(e.length," vs. ").concat(t.shape[0]));let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error("Max index must be < array size (".concat(n,"  vs. ").concat(this.maxSize,")"));this.writeMany(e,Xd(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));let n=0,a=e.map(e=>(n+=e,n));if(n!==t.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(n,", and tensor's shape is: ").concat(t.shape));if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths (".concat(this.maxSize," vs. ").concat(e.length,"), and the TensorArray is not marked as dynamically resizeable"));let r=0===n?0:t.size/n,s=[];eo(()=>{t=Xo(t,[1,n,r]);for(let n=0;n<e.length;++n){let i=[0,0===n?0:a[n-1],0],o=[1,e[n],r];s[n]=Xo(ec(t,i,o),this.elementShape)}return s});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}}(l,r,a,s,c,i,o);return n.addTensorArray(u),[u.idTensor,il(1)]}case"TensorArrayWriteV3":{let a=kN("tensorArrayId",e,t,n),r=kN("index",e,t,n),s=kN("tensor",e,t,n),i=n.getTensorArray(a.id);return i.write(r,s),[i.idTensor]}case"TensorArrayReadV3":{let a=kN("tensorArrayId",e,t,n),r=kN("index",e,t,n);return[n.getTensorArray(a.id).read(r)]}case"TensorArrayGatherV3":{let a=kN("tensorArrayId",e,t,n),r=kN("indices",e,t,n),s=kN("dtype",e,t,n);return[n.getTensorArray(a.id).gather(r,s)]}case"TensorArrayScatterV3":{let a=kN("tensorArrayId",e,t,n),r=kN("indices",e,t,n),s=kN("tensor",e,t,n),i=n.getTensorArray(a.id);return i.scatter(r,s),[i.idTensor]}case"TensorArrayConcatV3":{let a=kN("tensorArrayId",e,t,n),r=n.getTensorArray(a.id),s=kN("dtype",e,t,n);return[r.concat(s)]}case"TensorArraySplitV3":{let a=kN("tensorArrayId",e,t,n),r=kN("tensor",e,t,n),s=kN("lengths",e,t,n),i=n.getTensorArray(a.id);return i.split(s,r),[i.idTensor]}case"TensorArraySizeV3":{let a=kN("tensorArrayId",e,t,n);return[il(n.getTensorArray(a.id).size(),"int32")]}case"TensorArrayCloseV3":{let a=kN("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{let a=kN("tensorListId",e,t,n),r=kN("index",e,t,n),s=kN("tensor",e,t,n),i=n.getTensorList(a.id);return i.setItem(r,s),[i.idTensor]}case"TensorListGetItem":{let a=kN("tensorListId",e,t,n),r=kN("index",e,t,n),s=kN("elementShape",e,t,n),i=kN("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(r,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let a=kN("indices",e,t,n),r=function(e,t,n,a){if(t.length!==e.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(t.length," vs. ").concat(e.shape[0]));let r=Math.max(...t);if(null!=a&&-1!==a&&r>=a)throw new Error("Max index must be < array size (".concat(r,"  vs. ").concat(a,")"));let s=new zT([],n,e.dtype,a),i=Xd(e,0);return t.forEach((e,t)=>{s.setItem(e,i[t])}),s}(kN("tensor",e,t,n),a,kN("elementShape",e,t,n),kN("numElements",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let a,r=kN("elementShape",e,t,n),s=kN("elementDType",e,t,n);a="TensorListReserve"===e.op?"numElements":"maxNumElements";let i=kN(a,e,t,n),o=function(e,t,n,a){return new zT([],e,t,a)}(r,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{let a=kN("tensorListId",e,t,n),r=kN("indices",e,t,n),s=kN("elementShape",e,t,n),i=kN("elementDType",e,t,n);return[n.getTensorList(a.id).gather(r,i,s)]}case"TensorListStack":{let a=kN("tensorListId",e,t,n),r=kN("elementShape",e,t,n),s=kN("elementDType",e,t,n),i=kN("numElements",e,t,n);return[n.getTensorList(a.id).stack(r,s,i)]}case"TensorListFromTensor":{let a=function(e,t,n){let a=e.dtype;if(e.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: ".concat(e.shape));if(e.dtype!==n)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(n));DT(e.shape.slice(1),t,"TensorList shape mismatch: ");let r=Xd(e);return new zT(r,t,a)}(kN("tensor",e,t,n),kN("elementShape",e,t,n),kN("elementDType",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let a=kN("tensorListId",e,t,n),r=n.getTensorList(a.id),s=kN("dtype",e,t,n),i=kN("elementShape",e,t,n);return[r.concat(s,i)]}case"TensorListPushBack":{let a=kN("tensorListId",e,t,n),r=kN("tensor",e,t,n),s=n.getTensorList(a.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{let a=kN("tensorListId",e,t,n),r=kN("elementShape",e,t,n),s=kN("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(r,s)]}case"TensorListSplit":{let a=kN("tensor",e,t,n),r=kN("elementShape",e,t,n),s=function(e,t,n){let a=0,r=t.map(e=>(a+=e,a));if(a!==e.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(a,", and tensor's shape is: ").concat(e.shape));let s=jT(e.shape.slice(1),n),i=0===a?0:e.size/a,o=eo(()=>{let n=[];e=Xo(e,[1,a,i]);for(let a=0;a<t.length;++a){let o=[0,0===a?0:r[a-1],0],c=[1,t[a],i];n[a]=Xo(ec(e,o,c),s)}return e.dispose(),n}),c=new zT([],n,e.dtype,t.length);for(let l=0;l<o.length;l++)c.setItem(l,o[l]);return c}(a,kN("lengths",e,t,n),r);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{let a=kN("tensorListId",e,t,n);return[il(n.getTensorList(a.id).size(),"int32")]}case"TensorListResize":{let a=kN("tensorListId",e,t,n),r=kN("size",e,t,n),s=n.getTensorList(a.id).resize(r);return n.addTensorList(s),[s.idTensor]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function PT(e,t,n){let[a,r]=kN("fusedOps",e,t,n),s="biasadd"===a,i=!s,o="prelu"===r,c="fusedbatchnorm"===a,l=kN("numArgs",e,t,n);if(s){if(o&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let u=kN("strides",e,t,n),d=CN(e,t,n),h=kN("dataFormat",e,t,n).toUpperCase(),p=kN("dilations",e,t,n),[f,m]=kN("args",e,t,n);return i&&(m=f,f=void 0),{stride:u,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:kN("leakyreluAlpha",e,t,n)}}var BT=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"Conv1D":{let r=kN("stride",e,t,n),s=kN("pad",e,t,n),i=kN("dataFormat",e,t,n).toUpperCase(),o=kN("dilation",e,t,n);return[a.conv1d(kN("x",e,t,n),kN("filter",e,t,n),r,s,i,o)]}case"Conv2D":{let r=kN("strides",e,t,n),s=CN(e,t,n),i=kN("dataFormat",e,t,n).toUpperCase(),o=kN("dilations",e,t,n);return[a.conv2d(kN("x",e,t,n),kN("filter",e,t,n),[r[1],r[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:d}=PT(e,t,n);return[a.fused.conv2d({x:kN("x",e,t,n),filter:kN("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:d}=PT(e,t,n);return[a.fused.depthwiseConv2d({x:kN("x",e,t,n),filter:kN("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let r=kN("outputShape",e,t,n),s=kN("strides",e,t,n),i=CN(e,t,n);return[a.conv2dTranspose(kN("x",e,t,n),kN("filter",e,t,n),r,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let r=kN("strides",e,t,n),s=CN(e,t,n),i=kN("dilations",e,t,n),o=kN("dataFormat",e,t,n).toUpperCase();return[a.depthwiseConv2d(kN("input",e,t,n),kN("filter",e,t,n),[r[1],r[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let r=kN("strides",e,t,n),s=kN("pad",e,t,n),i=kN("dataFormat",e,t,n).toUpperCase(),o=kN("dilations",e,t,n);return[a.conv3d(kN("x",e,t,n),kN("filter",e,t,n),[r[1],r[2],r[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let r=kN("strides",e,t,n),s=kN("pad",e,t,n),i=kN("kernelSize",e,t,n);return[a.avgPool(kN("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPool":{let r=kN("strides",e,t,n),s=kN("pad",e,t,n),i=kN("kernelSize",e,t,n);return[a.maxPool(kN("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{let r=kN("strides",e,t,n),s=kN("pad",e,t,n),i=kN("kernelSize",e,t,n),o=kN("includeBatchInIndex",e,t,n),{result:c,indexes:l}=a.maxPoolWithArgmax(kN("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s,o);return[c,l]}case"AvgPool3D":{let r=kN("strides",e,t,n),s=kN("pad",e,t,n),i=kN("kernelSize",e,t,n);return[a.avgPool3d(kN("x",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{let r=kN("strides",e,t,n),s=kN("pad",e,t,n),i=kN("kernelSize",e,t,n);return[a.maxPool3d(kN("x",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{let r=kN("strides",e,t,n),s=kN("pad",e,t,n),i=kN("dilations",e,t,n),o=r[1],c=r[2],l=i[1],u=i[2];return[a.dilation2d(kN("x",e,t,n),kN("filter",e,t,n),[o,c],s,[l,u],"NHWC")]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},WT=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"Fill":{let r=kN("shape",e,t,n),s=kN("dtype",e,t,n),i=kN("value",e,t,n);return[a.fill(r,i,s)]}case"LinSpace":{let r=kN("start",e,t,n),s=kN("stop",e,t,n),i=kN("num",e,t,n);return[a.linspace(r,s,i)]}case"Multinomial":{let r=kN("logits",e,t,n),s=kN("numSamples",e,t,n),i=kN("seed",e,t,n);return[a.multinomial(r,s,i)]}case"OneHot":{let r=kN("indices",e,t,n),s=kN("depth",e,t,n),i=kN("onValue",e,t,n),o=kN("offValue",e,t,n),c=kN("dtype",e,t,n);return[a.oneHot(r,s,i,o,c)]}case"Ones":return[a.ones(kN("shape",e,t,n),kN("dtype",e,t,n))];case"OnesLike":return[a.onesLike(kN("x",e,t,n))];case"RandomStandardNormal":return[a.randomStandardNormal(kN("shape",e,t,n),kN("dtype",e,t,n),kN("seed",e,t,n))];case"RandomUniform":return[a.randomUniform(kN("shape",e,t,n),kN("minval",e,t,n),kN("maxval",e,t,n),kN("dtype",e,t,n))];case"RandomUniformInt":return[a.randomUniformInt(kN("shape",e,t,n),kN("minval",e,t,n),kN("maxval",e,t,n),kN("seed",e,t,n))];case"Range":{let r=kN("start",e,t,n),s=kN("stop",e,t,n),i=kN("step",e,t,n);return[a.range(r,s,i,kN("dtype",e,t,n))]}case"TruncatedNormal":{let r=kN("shape",e,t,n),s=kN("mean",e,t,n),i=kN("stdDev",e,t,n),o=kN("seed",e,t,n);return[a.truncatedNormal(r,s,i,kN("dtype",e,t,n),o)]}case"Zeros":return[a.zeros(kN("shape",e,t,n),kN("dtype",e,t,n))];case"ZerosLike":return[a.zerosLike(kN("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function UT(e,t,n){return{boxes:kN("boxes",e,t,n),scores:kN("scores",e,t,n),maxOutputSize:kN("maxOutputSize",e,t,n),iouThreshold:kN("iouThreshold",e,t,n),scoreThreshold:kN("scoreThreshold",e,t,n),softNmsSigma:kN("softNmsSigma",e,t,n)}}var VT=async function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:_T;switch(e.op){case"NonMaxSuppressionV5":{let{boxes:a,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=UT(e,t,n),u=await r.image.nonMaxSuppressionWithScoreAsync(a,s,i,o,c,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:a,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=UT(e,t,n),l=kN("padToMaxOutputSize",e,t,n),u=await r.image.nonMaxSuppressionPaddedAsync(a,s,i,o,c,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:a,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=UT(e,t,n);return[await r.image.nonMaxSuppressionAsync(a,s,i,o,c)]}case"Where":{let a=r.cast(kN("condition",e,t,n),"bool"),s=[await r.whereAsync(a)];return a.dispose(),s}case"ListDiff":return r.setdiff1dAsync(kN("x",e,t,n),kN("y",e,t,n));default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},GT=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"LowerBound":{let r=kN("sortedSequence",e,t,n),s=kN("values",e,t,n);return[a.lowerBound(r,s)]}case"TopKV2":{let r=kN("x",e,t,n),s=kN("k",e,t,n),i=kN("sorted",e,t,n),o=a.topk(r,s,i);return[o.values,o.indices]}case"UpperBound":{let r=kN("sortedSequence",e,t,n),s=kN("values",e,t,n);return[a.upperBound(r,s)]}case"Unique":{let r=kN("x",e,t,n),s=a.unique(r);return[s.values,s.indices]}case"UniqueV2":{let r=kN("x",e,t,n),s=kN("axis",e,t,n),i=a.unique(r,s);return[i.values,i.indices]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},HT=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let r=kN("default",e,t,n);return[IN(e.name,t,n)||r];case"Placeholder":return[IN(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[EN(kN("x",e,t,n))];case"IdentityN":return kN("x",e,t,n).map(e=>EN(e));case"Snapshot":return[EN(kN("x",e,t,n))];case"Shape":return[a.tensor1d(kN("x",e,t,n).shape,"int32")];case"ShapeN":return kN("x",e,t,n).map(e=>a.tensor1d(e.shape));case"Size":return[a.scalar(kN("x",e,t,n).size,"int32")];case"Rank":return[a.scalar(kN("x",e,t,n).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":let s=kN("x",e,t,n),i=kN("data",e,t,n),o=kN("message",e,t,n),c=kN("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,c));return[s];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},qT=async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{let r=a.getHashTableHandleByName(e.name);if(null!=r)return[r];{let r=kN("keyDType",e,t,n),s=kN("valueDType",e,t,n),i=new class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=il(0),this.tensorMap=new Map,no(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return il(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),eo(()=>{let e=Xd(t),a=n.length,r=e.length;Nr.assert(a===r,()=>"The number of elements doesn't match, keys has ".concat(a," elements, the values has ").concat(r," elements."));for(let t=0;t<a;t++){let a=n[t],r=e[t];no(r),this.tensorMap.set(a,r)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return eo(()=>{let e=[];for(let a=0;a<n.length;a++){let r=n[a],s=this.findWithDefault(r,t);e.push(s)}return Ed(e)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error("Expect key dtype ".concat(this.keyDType,", but got ").concat(e.dtype));if(t.dtype!==this.valueDType)throw new Error("Expect value dtype ".concat(this.valueDType,", but got ").concat(t.dtype))}}(r,s);return a.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let r=kN("tableHandle",e,t,n,a),s=kN("keys",e,t,n),i=kN("values",e,t,n);return[await a.getHashTableById(r.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let r=kN("tableHandle",e,t,n,a),s=kN("keys",e,t,n),i=kN("defaultValue",e,t,n);return[await a.getHashTableById(r.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let r=kN("tableHandle",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},KT=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"ResizeBilinear":{let r=kN("images",e,t,n),s=kN("size",e,t,n),i=kN("alignCorners",e,t,n),o=kN("halfPixelCenters",e,t,n);return[a.image.resizeBilinear(r,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let r=kN("images",e,t,n),s=kN("size",e,t,n),i=kN("alignCorners",e,t,n),o=kN("halfPixelCenters",e,t,n);return[a.image.resizeNearestNeighbor(r,[s[0],s[1]],i,o)]}case"CropAndResize":{let r=kN("image",e,t,n),s=kN("boxes",e,t,n),i=kN("boxInd",e,t,n),o=kN("cropSize",e,t,n),c=kN("method",e,t,n),l=kN("extrapolationValue",e,t,n);return[a.image.cropAndResize(r,s,i,o,c,l)]}case"ImageProjectiveTransformV3":{let r=kN("images",e,t,n),s=kN("transforms",e,t,n),i=kN("outputShape",e,t,n),o=kN("fillValue",e,t,n),c=kN("interpolation",e,t,n),l=kN("fillMode",e,t,n);return[a.image.transform(r,s,c.toLowerCase(),l.toLowerCase(),o,i)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},XT=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"Equal":return[a.equal(kN("a",e,t,n),kN("b",e,t,n))];case"NotEqual":return[a.notEqual(kN("a",e,t,n),kN("b",e,t,n))];case"Greater":return[a.greater(kN("a",e,t,n),kN("b",e,t,n))];case"GreaterEqual":return[a.greaterEqual(kN("a",e,t,n),kN("b",e,t,n))];case"Less":return[a.less(kN("a",e,t,n),kN("b",e,t,n))];case"LessEqual":return[a.lessEqual(kN("a",e,t,n),kN("b",e,t,n))];case"LogicalAnd":return[a.logicalAnd(kN("a",e,t,n),kN("b",e,t,n))];case"LogicalNot":return[a.logicalNot(kN("a",e,t,n))];case"LogicalOr":return[a.logicalOr(kN("a",e,t,n),kN("b",e,t,n))];case"Select":case"SelectV2":return[a.where(kN("condition",e,t,n),kN("a",e,t,n),kN("b",e,t,n))];case"BitwiseAnd":return[a.bitwiseAnd(kN("a",e,t,n),kN("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},ZT=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul(kN("a",e,t,n),kN("b",e,t,n),kN("transposeA",e,t,n),kN("transposeB",e,t,n))];case"Einsum":return[a.einsum(kN("equation",e,t,n),...kN("tensors",e,t,n))];case"Transpose":return[a.transpose(kN("x",e,t,n),kN("perm",e,t,n))];case"_FusedMatMul":let[r,s]=kN("fusedOps",e,t,n),i="biasadd"===r,o="prelu"===s,c=kN("numArgs",e,t,n),l=kN("leakyreluAlpha",e,t,n);if(i){if(o&&2!==c)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==c)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,d]=kN("args",e,t,n);return[a.fused.matMul({a:kN("a",e,t,n),b:kN("b",e,t,n),transposeA:kN("transposeA",e,t,n),transposeB:kN("transposeB",e,t,n),bias:u,activation:s,preluActivationWeights:d,leakyreluAlpha:l})];case"MatrixBandPart":return[a.linalg.bandPart(kN("a",e,t,n),kN("numLower",e,t,n),kN("numUpper",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},YT=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"EuclideanNorm":return[a.euclideanNorm(kN("x",e,t,n),kN("axis",e,t,n),kN("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[a.batchNorm(kN("x",e,t,n),kN("mean",e,t,n),kN("variance",e,t,n),kN("offset",e,t,n),kN("scale",e,t,n),kN("epsilon",e,t,n))];case"LRN":return[a.localResponseNormalization(kN("x",e,t,n),kN("radius",e,t,n),kN("bias",e,t,n),kN("alpha",e,t,n),kN("beta",e,t,n))];case"Softmax":return[a.softmax(kN("x",e,t,n))];case"LogSoftmax":return[a.logSoftmax(kN("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},JT=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"RaggedGather":{let{outputNestedSplits:r,outputDenseValues:s}=a.raggedGather(kN("paramsNestedSplits",e,t,n),kN("paramsDenseValues",e,t,n),kN("indices",e,t,n),kN("outputRaggedRank",e,t,n));return r.concat(s)}case"RaggedRange":{let{rtNestedSplits:r,rtDenseValues:s}=a.raggedRange(kN("starts",e,t,n),kN("limits",e,t,n),kN("splits",e,t,n));return[r,s]}case"RaggedTensorToTensor":return[a.raggedTensorToTensor(kN("shape",e,t,n),kN("values",e,t,n),kN("defaultValue",e,t,n),kN("rowPartitionTensors",e,t,n),kN("rowPartitionTypes",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},QT=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"Max":{let r=kN("axis",e,t,n),s=kN("keepDims",e,t,n);return[a.max(kN("x",e,t,n),r,s)]}case"Mean":{let r=kN("axis",e,t,n),s=kN("keepDims",e,t,n);return[a.mean(kN("x",e,t,n),r,s)]}case"Min":{let r=kN("axis",e,t,n),s=kN("keepDims",e,t,n);return[a.min(kN("x",e,t,n),r,s)]}case"Sum":{let r=kN("axis",e,t,n),s=kN("keepDims",e,t,n);return[a.sum(kN("x",e,t,n),r,s)]}case"All":{let r=kN("axis",e,t,n),s=kN("keepDims",e,t,n);return[a.all(kN("x",e,t,n),r,s)]}case"Any":{let r=kN("axis",e,t,n),s=kN("keepDims",e,t,n);return[a.any(kN("x",e,t,n),r,s)]}case"ArgMax":{let r=kN("axis",e,t,n);return[a.argMax(kN("x",e,t,n),r)]}case"ArgMin":{let r=kN("axis",e,t,n);return[a.argMin(kN("x",e,t,n),r)]}case"Prod":{let r=kN("axis",e,t,n),s=kN("keepDims",e,t,n);return[a.prod(kN("x",e,t,n),r,s)]}case"Cumprod":{let r=kN("axis",e,t,n),s=kN("exclusive",e,t,n),i=kN("reverse",e,t,n);return[a.cumprod(kN("x",e,t,n),r,s,i)]}case"Cumsum":{let r=kN("axis",e,t,n),s=kN("exclusive",e,t,n),i=kN("reverse",e,t,n);return[a.cumsum(kN("x",e,t,n),r,s,i)]}case"Bincount":let r=kN("x",e,t,n),s=kN("weights",e,t,n),i=kN("size",e,t,n);return[a.bincount(r,s,i)];case"DenseBincount":{let r=kN("x",e,t,n),s=kN("weights",e,t,n),i=kN("size",e,t,n),o=kN("binaryOutput",e,t,n);return[a.denseBincount(r,s,i,o)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},$T=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"ConcatV2":case"Concat":{let r=kN("n",e,t,n),s=kN("axis",e,t,n),i=kN("tensors",e,t,n);return i=i.slice(0,r),[a.concat(i,s)]}case"Gather":{let r=kN("x",e,t,n),s=kN("indices",e,t,n);return[a.gather(r,a.cast(s,"int32"),0)]}case"GatherV2":{let r=kN("axis",e,t,n),s=kN("batchDims",e,t,n),i=kN("x",e,t,n),o=kN("indices",e,t,n);return[a.gather(i,a.cast(o,"int32"),r,s)]}case"Reverse":{let r=kN("dims",e,t,n),s=[];for(let e=0;e<r.length;e++)r[e]&&s.push(e);let i=kN("x",e,t,n);return[a.reverse(i,s)]}case"ReverseV2":{let r=kN("axis",e,t,n),s=kN("x",e,t,n);return[a.reverse(s,r)]}case"Slice":{let r=kN("begin",e,t,n),s=kN("size",e,t,n);return[a.slice(kN("x",e,t,n),r,s)]}case"StridedSlice":{let r=kN("begin",e,t,n),s=kN("end",e,t,n),i=kN("strides",e,t,n),o=kN("beginMask",e,t,n),c=kN("endMask",e,t,n),l=kN("ellipsisMask",e,t,n),u=kN("newAxisMask",e,t,n),d=kN("shrinkAxisMask",e,t,n),h=kN("x",e,t,n);return[a.stridedSlice(h,r,s,i,o,c,l,u,d)]}case"Pack":return eo(()=>{let r=kN("axis",e,t,n),s=kN("tensors",e,t,n),i=s[0].shape,o=a.squeeze(s[0]).shape,c=s.map(e=>{let t=Nr.arraysEqual(e.shape,i);if(!t&&!Nr.arraysEqual(a.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:a.reshape(e,i)});return[a.stack(c,r)]});case"Unpack":{let r=kN("axis",e,t,n),s=kN("tensor",e,t,n);return a.unstack(s,r)}case"Tile":{let r=kN("reps",e,t,n);return[a.tile(kN("x",e,t,n),r)]}case"Split":case"SplitV":{let r=kN("axis",e,t,n),s=kN("numOrSizeSplits",e,t,n),i=kN("x",e,t,n);return a.split(i,s,r)}case"ScatterNd":{let r=kN("indices",e,t,n),s=kN("values",e,t,n),i=kN("shape",e,t,n);return[a.scatterND(r,s,i)]}case"GatherNd":{let r=kN("x",e,t,n),s=kN("indices",e,t,n);return[a.gatherND(r,s)]}case"SparseToDense":{let r=kN("sparseIndices",e,t,n),s=kN("outputShape",e,t,n),i=kN("sparseValues",e,t,n),o=kN("defaultValue",e,t,n);return[a.sparseToDense(r,i,s,i.dtype===o.dtype?o:a.cast(o,i.dtype))]}case"TensorScatterUpdate":{let r=kN("indices",e,t,n),s=kN("values",e,t,n),i=kN("tensor",e,t,n);return[a.tensorScatterUpdate(i,r,s)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},eO=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:r,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=a.sparse.sparseFillEmptyRows(kN("indices",e,t,n),kN("values",e,t,n),kN("denseShape",e,t,n),kN("defaultValue",e,t,n));return[r,s,i,o]}case"SparseReshape":{let{outputIndices:r,outputShape:s}=a.sparse.sparseReshape(kN("inputIndices",e,t,n),kN("inputShape",e,t,n),kN("newShape",e,t,n));return[r,s]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean(kN("data",e,t,n),kN("indices",e,t,n),kN("segmentIds",e,t,n))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum(kN("data",e,t,n),kN("indices",e,t,n),kN("segmentIds",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},tO=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"FFT":return[a.fft(kN("x",e,t,n))];case"IFFT":return[a.ifft(kN("x",e,t,n))];case"RFFT":return[a.rfft(kN("x",e,t,n))];case"IRFFT":return[a.irfft(kN("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},nO=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"StaticRegexReplace":return[a.string.staticRegexReplace(kN("input",e,t,n),kN("pattern",e,t,n),kN("rewrite",e,t,n),kN("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:r,nGramsSplits:s}=a.string.stringNGrams(kN("data",e,t,n),kN("dataSplits",e,t,n),kN("separator",e,t,n),kN("nGramWidths",e,t,n),kN("leftPad",e,t,n),kN("rightPad",e,t,n),kN("padWidth",e,t,n),kN("preserveShortSequences",e,t,n));return[r,s]}case"StringSplit":{let{indices:r,values:s,shape:i}=a.string.stringSplit(kN("input",e,t,n),kN("delimiter",e,t,n),kN("skipEmpty",e,t,n));return[r,s,i]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast(kN("input",e,t,n),kN("numBuckets",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}},aO=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_T;switch(e.op){case"Cast":return[a.cast(kN("x",e,t,n),kN("dtype",e,t,n))];case"ExpandDims":{let r=kN("axis",e,t,n);return[a.expandDims(kN("x",e,t,n),r)]}case"Squeeze":{let r=kN("axis",e,t,n);return[a.squeeze(kN("x",e,t,n),r)]}case"Reshape":return[a.reshape(kN("x",e,t,n),kN("shape",e,t,n))];case"EnsureShape":return[a.ensureShape(kN("x",e,t,n),kN("shape",e,t,n))];case"MirrorPad":return[a.mirrorPad(kN("x",e,t,n),kN("padding",e,t,n),kN("mode",e,t,n))];case"PadV2":case"Pad":return[a.pad(kN("x",e,t,n),kN("padding",e,t,n),kN("constantValue",e,t,n))];case"SpaceToBatchND":{let r=kN("blockShape",e,t,n),s=kN("paddings",e,t,n);return[a.spaceToBatchND(kN("x",e,t,n),r,s)]}case"BatchToSpaceND":{let r=kN("blockShape",e,t,n),s=kN("crops",e,t,n);return[a.batchToSpaceND(kN("x",e,t,n),r,s)]}case"DepthToSpace":{let r=kN("blockSize",e,t,n),s=kN("dataFormat",e,t,n).toUpperCase();return[a.depthToSpace(kN("x",e,t,n),r,s)]}case"BroadcastTo":return[a.broadcastTo(kN("x",e,t,n),kN("shape",e,t,n))];case"BroadcastArgs":return[a.broadcastArgs(kN("s0",e,t,n),kN("s1",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function rO(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:eo,s=((e,t,n)=>{switch(e.category){case"arithmetic":return r(()=>AT(e,t,n));case"basic_math":return r(()=>RT(e,t,n));case"control":return LT(e,t,n);case"convolution":return r(()=>BT(e,t,n));case"creation":return r(()=>WT(e,t,n));case"dynamic":return VT(e,t,n);case"evaluation":return r(()=>GT(e,t,n));case"image":return r(()=>KT(e,t,n));case"graph":return r(()=>HT(e,t,n));case"logical":return r(()=>XT(e,t,n));case"matrices":return r(()=>ZT(e,t,n));case"normalization":return r(()=>YT(e,t,n));case"ragged":return r(()=>JT(e,t,n));case"reduction":return r(()=>QT(e,t,n));case"slice_join":return r(()=>$T(e,t,n));case"sparse":return r(()=>eO(e,t,n));case"spectral":return r(()=>tO(e,t,n));case"string":return r(()=>nO(e,t,n));case"transformation":return r(()=>aO(e,t,n));case"hash_table":return qT(e,t,n,a);case"custom":let s=xN(e.op);if(s&&s.customExecutor)return s.customExecutor(new ET(e,t,n));throw TypeError("Custom op ".concat(e.op," is not registered."));default:throw TypeError("Unknown op '".concat(e.op,"'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()"))}})(e,t,n);return Nr.isPromise(s)?s.then(e=>[].concat(e)):[].concat(s)}var sO=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":"".concat(e.frameName,"-").concat(e.iterationId)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function iO(e,t,n,a){let r=new Set,s=[],i=null,o=null,c=new Set,l=new Set(Object.keys(e).map(e=>ON(e)[0]));a=a||[];let u=new Set(a.map(e=>ON(e.name)[0])),d=[...t];for(;d.length>0;){let e=d.pop();if((hO(e)||pO(e)||fO(e))&&null==i&&(i=e,o=i.children.map(e=>e.name).filter(e=>r.has(e))),r.add(e.name),null==n[e.name]&&!l.has(e.name)&&!u.has(e.name)){if(0===e.inputs.length){s.push(e.name);continue}e.inputs.forEach(e=>{c.has(e.name)||(c.add(e.name),d.push(e))})}}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:i,syncInputs:o}}function oO(e,t){let{usedNodes:n,inputs:a}=t,r=Object.keys(a).map(e=>ON(e)[0]).map(t=>e.nodes[t]),s=e.initNodes||[],i=e=>n.has("string"==typeof e?e:e.name);function o(e){return[...new Map(e.map(e=>[e.name,e])).values()]}let c=o([...r,...e.weights,...s]).filter(i),l=o([...c,...Object.values(e.nodes)]).filter(i),u=new Map(l.map(e=>[e.name,e])),d={};for(let m of l){d[m.name]=d[m.name]||0;for(let e of m.children)i(e)||(d[e.name]=Number.POSITIVE_INFINITY),d[e.name]=(d[e.name]||0)+1}let h=Object.entries(d).filter(e=>{let[,t]=e;return 0===t}).map(e=>{let[t]=e;return t}),p=[...h];for(;h.length>0;){let e=h.pop(),t=u.get(e);for(let n of t.children.filter(i))0===--d[n.name]&&(p.push(n.name),h.push(n.name))}let f=function(e,t){let n=new Map(e.map(e=>[e.name,e])),a=t.map(e=>e.name),r=new Set(a);for(;a.length>0;){let e=a.pop(),t=n.get(e);for(let s of t.children)!n.has(s.name)||r.has(s.name)||(r.add(s.name),a.push(s.name))}return e.filter(e=>r.has(e.name))}(p.map(e=>u.get(e)),c);return function(e,t){let n=new Map(e.map((e,t)=>[e.name,t])),a=new Set(t.map(e=>e.name)),r=e=>a.has("string"==typeof e?e:e.name),s=new Set(e.map(e=>e.name)),i=e=>s.has("string"==typeof e?e:e.name);for(let o of e){for(let e of o.children.filter(i)){if(!n.has(e.name))throw new cO("Child ".concat(e.name," of node ").concat(o.name," is unreachable."));if(n.get(o.name)>n.get(e.name))throw new cO("Node ".concat(o.name," is scheduled to run after its child ").concat(e.name,"."))}if(!r(o))for(let e of o.inputs){if(!n.has(e.name))throw new cO("Input ".concat(e.name," of node ").concat(o.name," is unreachable."));if(n.get(e.name)>n.get(o.name))throw new cO("Node ".concat(o.name," is scheduled to run before its input ").concat(e.name,"."))}}}(f,c),f}var cO=class extends Error{constructor(e){super("NodesExecutionOrderError: ".concat(e))}};var lO=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),uO=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),dO=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function hO(e){return lO.has(e.op)}function pO(e){return uO.has(e.op)}function fO(e){return dO.has(e.op)}var mO=class{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?"".concat(t,":").concat(e.defaultOutput):t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new mO(e.functions[t],this)})}getCompilationKey(e,t){let n=e.map(e=>e.name).sort(),a=t.map(e=>e.name).sort();return n.join(this.SEPARATOR)+"--"+a.join(this.SEPARATOR)}compile(e,t){let n=iO(e,t,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:r,syncInputs:s}=n;if(null!=r)throw new Error("This execution contains the node '".concat(r.name,"', which has the dynamic op '").concat(r.op,"'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [").concat(s,"]"));if(a.length>0){let n=t.map(e=>e.name),r=Object.keys(e);throw new Error("Cannot compute the outputs [".concat(n,"] from the provided inputs [").concat(r,"]. Missing the following inputs: [").concat(a,"]"))}let i=oO(this.graph,n),o=function(e){let t=new Map(e.map((e,t)=>[e.name,t])),n=Number.MAX_SAFE_INTEGER,a=e.map((e,t)=>hO(e)?n:t),r=e=>{let n=a[t.get(e.name)];return null==n?-1:n},s=e.map((e,t)=>e.children.map(r).reduce((e,t)=>Math.max(e,t),a[t])),i=new Map;for(let o=0;o<e.length;++o){let t=s[o];if(t===n)continue;let a=e[o],r=e[t];i.has(r.name)||i.set(r.name,[]),i.get(r.name).push(a)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;let t=e.clone();return no(t),t}cloneTensorList(e){return e?e.map(e=>this.cloneAndKeepTensor(e)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]}))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let a=n.map(e=>this.graph.nodes[ON(e)[0]]),r=t.map(e=>ON(e)[0]),s=new Set(r),i=r.map(e=>this.graph.nodes[e]);0===i.length&&(i=this._outputs);let o=this.getCompilationKey(a,i),c=this.compiledMap.get(o);null==c&&(c=this.compile(e,i),this.compiledMap.set(o,c));try{this.keepIntermediateTensors=Ue().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let l={},u={};return eo(()=>{let n=new sO(this.weightMap,l,u,this.functionExecutorMap,this.parseNodeNameCache),a=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(t=>{let[r,s]=ON(t,n),i=[];i[s]=e[t],a[r]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[r]=this.cloneTensorList(i))});let r=this.getFrozenTensorIds(a),{orderedNodes:i,nodeLiveUntilMap:o}=c;for(let e of i){if(a[e.name])continue;let t=rO(e,a,n,this._resourceManager);if(Nr.isPromise(t))throw new Error("The execution of the op '".concat(e.op,"' returned a promise. Please use model.executeAsync() instead."));a[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,a,n,r,s,o.get(e.name))}return null==this.parent&&n.dispose(r),t.map(e=>IN(e,a,n))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,t,n,a,r,s,i){if(!hO(t)&&!s.has(e)){for(let a of n[e])null!=a&&(i[a.id]=(i[a.id]||0)+t.children.length);for(let e of t.inputs){if(hO(e))continue;let t=SN(e.name,n,a);if(null!=t)for(let e of t){if(!e||e.kept||r.has(e.id))continue;let t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,a,r,s){function i(e){return hO(e)||r.has(e.name)}if(!hO(e)&&null!=s)for(let o of s){if(i(o))continue;let e=SN(o.name,t,n);for(let t of e)!t||t.kept||a.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Ue().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let s=new sO(this.weightMap,a,r,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let i=await this.executeWithControlFlow(e,s,t,n),o=t.map(e=>IN(e,i,s)),c=o.map(e=>e.id),l=Object.keys(e).map(t=>e[t].id),u=new Set([...c,...l,...this.weightIds]);return Object.values(i).forEach(e=>{e.forEach(e=>{e&&!e.isDisposed&&!u.has(e.id)&&e.dispose()})}),null==this.parent&&s.dispose(u),o}async executeFunctionAsync(e,t,n){let a=e.reduce((e,t,n)=>(e[this.inputs[n].name]=t,e),{});return this._executeAsync(a,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,a){let r=Object.keys(e),s=r.map(e=>this.graph.nodes[ON(e)[0]]),i=n.map(e=>ON(e)[0]),o=new Set(i),c=i.map(e=>this.graph.nodes[e]);0===c.length&&(c=this._outputs);let{usedNodes:l,missingInputs:u,dynamicNode:d,syncInputs:h}=iO(e,c,this.weightMap,this._initNodes),p=[...s,...this.graph.weights,...this._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{let[n,a]=ON(t),r=[];r[a]=e[t],f[n]=r});let m={},g=this.getFrozenTensorIds(f),b={};for(;p.length>0;){let e=this.processStack(s,p,t,f,b,g,o,m,l);await Promise.all(e)}null==d&&!a&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let y=c.filter(e=>!hO(e)&&!IN(e.name,f,t)).map(e=>e.name);if(y.length>0){let e="";throw null!=d&&(e="Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [".concat(h,"]")),new Error("Cannot compute the outputs [".concat(y,"] from the provided inputs [").concat(r,"]. Consider providing the following inputs: [").concat(u,"]. ").concat(e))}return f}processStack(e,t,n,a,r,s,i,o,c){let l=[];for(;t.length>0;){let e=t.pop();n.currentContext=e.contexts;let u="";if("Enter"===e.node.op&&kN("isConstant",e.node,a,n)&&([u]=NN(e.node.name,n)),null==a[e.node.name]){let d=rO(e.node,a,n,this._resourceManager);u||([u]=NN(e.node.name,n));let h=n.currentContext;Nr.isPromise(d)?l.push(d.then(l=>(a[u]=l,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(l)),n.currentContext=h,this.checkTensorForDisposal(u,e.node,a,n,s,i,o),this.processChildNodes(e.node,t,n,a,r,c),l))):(a[u]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(d)),this.checkTensorForDisposal(u,e.node,a,n,s,i,o),this.processChildNodes(e.node,t,n,a,r,c))}else this.processChildNodes(e.node,t,n,a,r,c)}return l}processChildNodes(e,t,n,a,r,s){e.children.forEach(e=>{let[i]=NN(e.name,n);r[i]||!s.has(e.name)||("Merge"===e.op?e.inputNames.some(e=>!!IN(e,a,n))&&(r[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every(e=>!!IN(e,a,n))&&(r[i]=!0,t.push({contexts:n.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let n=e[t],[a]=ON(t),r=this.graph.nodes[a];if(r.attrParams.shape&&r.attrParams.shape.value){let e=r.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every((t,n)=>-1===e[n]||e[n]===t);Nr.assert(t,()=>"The shape of dict['".concat(r.name,"'] provided in model.execute(dict) must be [").concat(e,"], but was [").concat(n.shape,"]"))}r.attrParams.dtype&&r.attrParams.dtype.value&&Nr.assert(n.dtype===r.attrParams.dtype.value,()=>"The dtype of dict['".concat(r.name,"'] provided in model.execute(dict) must be ").concat(r.attrParams.dtype.value,", but was ").concat(n.dtype))})}mapInputs(e){var t,n;let a={};for(let r in e){let s=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[r];null!=s?a[s.name]=e[r]:a[r]=e[r]}return a}checkInputs(e){let t=Object.keys(e).filter(e=>{let[t]=ON(e);return null==this.graph.nodes[t]});if(t.length>0)throw new Error("The dict provided in model.execute(dict) has keys: [".concat(t,"] that are not part of graph"))}mapOutputs(e){return e.map(e=>{var t,n;let a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=a?a.name:e},{})}checkOutputs(e){e.forEach(e=>{let[t]=ON(e);if(!this.graph.nodes[t])throw new Error("The output '".concat(e,"' is not found in the graph"))})}},gO=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Bp;this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error("Found more than one (".concat(t.length,") load handlers for URL '").concat([e],"'"));this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return Nr.isPromise(e)?e.then(e=>this.loadSync(e)):this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){let e=this.artifacts.userDefinedMetadata;null!=e.signature&&(n=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}this.signature=n,this.version="".concat(t.versions.producer,".").concat(t.versions.minConsumer);let a=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new mO(fT.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(a),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let t=fT.Instance.transformGraph(e.modelInitializer);this.initializer=new mO(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){let t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new Error("Found more than one (".concat(t.length,") save handlers for URL '").concat(e,"'"));e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t={};return(e instanceof os?[e]:e).forEach((e,n)=>t[this.structuredOutputKeys[n]]=e),t}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof os)&&!Array.isArray(e)){let n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(let t in n){let a=n[t];null!=a.resourceId&&(e[t]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error("Input tensor count mismatch, the graph model has ".concat(this.inputNodes.length-n," non-resource placeholders, while there are ").concat(e.length," input tensors provided."));let a=0;return this.inputNodes.reduce((t,n)=>{var r,s,i;let o=null===(i=null===(s=null===(r=this.signature)||void 0===r?void 0:r.inputs)||void 0===s?void 0:s[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[a++],t},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let a=0;a<n.length;a++){let r=t[n[a]];this.resourceIdToCapturedInput[r.resourceId]=e[a]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&to(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function bO(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Bp;if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=vO(e));let a=new gO(e,t,n);return await a.load(),a}function yO(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[n,a]=e;if(!n)throw new Error("modelJSON must be the first element of the array");if(!a||!(a instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");let r=Bp.getWeightSpecs(n.weightsManifest),s=Bp.getModelArtifactsForJSONSync(n,r,a);t=Bp.fromMemorySync(s)}else if("load"in e)t=e;else{if(!("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e))throw new Error("Unknown model format");t=Bp.fromMemorySync(e)}let n=new gO(t);return n.load(),n}function vO(e){return e.endsWith("/")||(e+="/"),"".concat(e).concat("model.json").concat("?tfjs-format=file")}var xO="4.7.0",wO={};y(wO,{CSVDataset:()=>dC,Dataset:()=>$O,FileDataSource:()=>SC,TextLineDataset:()=>sC,URLDataSource:()=>NC,array:()=>tC,csv:()=>TC,func:()=>OC,generator:()=>CC,microphone:()=>_C,version_data:()=>AC,webcam:()=>EC,zip:()=>nC});var kO=v(A()),IO=v(A());function SO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(CO(e)){let r=Array.isArray(e)?[]:{};a.add(e);for(let s in e){let i=SO(e[s],t,n,a);r[s]=i}return a.delete(e),e.__proto__&&(r.__proto__=e.__proto__),r}throw new Error("Can't recurse into non-iterable type: ".concat(e))}return n.set(e,r.value),r.value}function NO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set,a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");let r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(CO(a)){let r=Array.isArray(a)?[]:{};n.add(a);for(let s in a){let a=NO(e.map(e=>e[s]),t,n);r[s]=a}return n.delete(a),r}throw new Error("Can't recurse into non-iterable type: ".concat(a))}return r.value}function TO(e){return null===e?null:CO(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function OO(e,t){let n=new Map;SO(e,t,n);for(let a of Array.from(n.keys())){let e=n.get(a);if(Nr.isPromise(e)){let t=await e;n.set(a,t)}}return SO(e,t,n)}function CO(e){let t=!1;if(Ue().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=R();t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof os)&&!(e instanceof Promise)&&!t)}function EO(e){return function(e,t){return SO(e,t)}(e,_O)}function _O(e){return e instanceof os?{value:e.clone(),recurse:!1}:CO(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var AO=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},RO=class extends AO{constructor(){super(RO.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=2*this.capacity,t=new Array(e),n=this.length();for(let a=0;a<n;a++)t[a]=this.get(this.wrap(this.begin+a));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};function DO(e){return new zO(e)}function FO(e){return new LO(e)}RO.INITIAL_CAPACITY=32;var MO,jO=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new HO(this,e)}filter(e){return new VO(this,e)}map(e){return new GO(this,e)}mapAsync(e){return new qO(this,e)}serialMapAsync(e){return new qO(this,e).serial()}flatmap(e){return new XO(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(e=>!0===e)}rowMajorBatch(e){return new UO(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:TO;return this.rowMajorBatch(e,t).map(e=>function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:TO;return NO(e,t)}(e,n))}concatenate(e,t){return new ZO(DO([this,e]),t)}take(e){return e<0||null==e?this:new WO(this,e)}skip(e){return e<0||null==e?this:new BO(this,e)}prefetch(e){return new JO(this,e)}shuffle(e,t){return new QO(this,e,t)}serial(){return new PO(this)}},zO=class extends jO{constructor(e){super(),this.items=e,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:EO(e),done:!1}}},LO=class extends jO{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(ds){throw ds.message="Error thrown while iterating through a dataset: ".concat(ds.message),ds}}},PO=class extends jO{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},BO=class extends jO{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;to(e.value)}return this.upstream.next()}},WO=class extends jO{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},UO=class extends jO{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},VO=class extends jO{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;to(e.value)}}},GO=class extends jO{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=gs.getTensorsInContainer(e.value),n=this.transform(e.value),a=gs.getTensorsInContainer(n);for(let r of t)gs.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},HO=class extends jO{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(ds){if(!this.handler(ds))return{value:null,done:!0}}}},qO=class extends jO{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=gs.getTensorsInContainer(e.value),n=await this.transform(e.value),a=gs.getTensorsInContainer(n);for(let r of t)gs.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},KO=class extends jO{constructor(){super(),this.outputQueue=new RO,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},XO=class extends KO{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=gs.getTensorsInContainer(e.value),n=this.transform(e.value),a=gs.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let r of t)gs.isTensorInList(r,a)||r.dispose();return!0}},ZO=class extends jO{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){let e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}};!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(MO||(MO={}));var YO=class extends jO{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:MO.FAIL;super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;let a=await OO(this.iterators,(function(e){return e instanceof jO?{value:e.next().then(e=>(t++,e.done&&n++,e.value)),recurse:!1}:{value:null,recurse:!0}}));if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case MO.FAIL:throw new Error("Zipped streams should have the same length. Mismatched at element ".concat(this.count,"."));case MO.SHORTEST:return{value:null,done:!0};case MO.LONGEST:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},JO=class extends jO{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new AO(t)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},QO=class extends JO{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=IO.alea(n||Nr.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}},$O=class{constructor(){this.size=null}batch(e){let t,n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],a=this;return Nr.assert(e>0,()=>"batchSize needs to be positive, but it is\n      ".concat(e)),t=this.size===1/0||null==this.size?this.size:n?Math.ceil(this.size/e):Math.floor(this.size/e),eC(async()=>(await a.iterator()).columnMajorBatch(e,n,aC),t)}concatenate(e){let t,n=this;return t=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,eC(async()=>(await n.iterator()).concatenate(await e.iterator()),t)}filter(e){let t,n=this;return t=this.size===1/0?1/0:null,eC(async()=>(await n.iterator()).filter(t=>eo(()=>e(t))),t)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return eC(async()=>(await t.iterator()).map(t=>eo(()=>e(t))),this.size)}mapAsync(e){let t=this;return eC(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return eC(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t,n=this;return t=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,eC(async()=>function(e,t){return new ZO(e,t)}(FO(async()=>({value:await n.iterator(),done:!1})).take(e)),t)}skip(e){let t,n=this;return t=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,eC(async()=>(await n.iterator()).skip(e),t)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size (".concat(this.size," elements)"));let a=this,r=kO.alea(t||Nr.now().toString());return eC(async()=>{let t=r.int32();return n&&(t+=r.int32()),(await a.iterator()).shuffle(e,t.toString())},this.size)}take(e){let t,n=this;return t=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,eC(async()=>(await n.iterator()).take(e),t)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function eC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends $O{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function tC(e){return eC(async()=>DO(e),e.length)}function nC(e){if(!CO(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return eC(async()=>function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:MO.FAIL;return new YO(e,t)}(await OO(e,e=>{if(e instanceof $O)return{value:e.iterator(),recurse:!1};if(CO(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}),MO.SHORTEST),t)}function aC(e){if(null===e)return null;return function(e){return null==e||function(e){return null===e||"object"!=typeof e&&"function"!=typeof e}(e)||Array.isArray(e)||"object"==typeof e&&e instanceof os||Nr.isTypedArray(e)}(e[0])?{value:rC(e),recurse:!1}:{value:null,recurse:!0}}function rC(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof os?Ed(e):qs(e)}$O.MAX_BUFFER_SIZE=1e4;var sC=class extends $O{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},iC=Symbol("out"),oC=Symbol("field"),cC=Symbol("quote"),lC=Symbol("quoteafterquote"),uC=Symbol("quoteinquote"),dC=class extends $O{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&Nr.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((e,t)=>(e[t]=e[t]+1||1,e),{}),n=Object.keys(t).filter(e=>t[e]>1);if(Nr.assert(0===n.length,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs)for(let a of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(a))throw new Error('The key "'+a+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new sC(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(Nr.assert(null==t.delimiter,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(e=>this.makeDataElement(e))}makeDataElement(e){let t=this.parseRow(e),n={},a={};for(let r=0;r<this.fullColumnNames.length;r++){let s=this.fullColumnNames[r],i=this.columnConfigs?this.columnConfigs[s]:null;if(!this.configuredColumnsOnly||i){let o=t[r],c=null;if(""===o)if(i&&void 0!==i.default)c=i.default;else{if(i&&(i.required||i.isLabel))throw new Error("Required column ".concat(s," is empty in this line: ").concat(e));c=void 0}else{let e=Number(o);if(isNaN(e))c=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":c=e;break;case"int32":c=Math.floor(e);break;case"bool":c=this.getBoolean(o);break;default:c=e}else c=e}i&&i.isLabel?a[s]=c:n[s]=c}}return 0===Object.keys(a).length?n:{xs:n,ys:a}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=[],a=0,r=e.length,s=iC;for(let i=0;i<r;i++)switch(s){case iC:switch(e.charAt(i)){case'"':a=i+1,s=cC;break;case this.delimiter:if(a=i+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),s=iC;break;default:s=oC,a=i}break;case oC:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(a,i)),s=iC,a=i+1}break;case cC:switch(e.charAt(i)){case'"':s=lC}break;case lC:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(a,i-1)),s=iC,a=i+1;break;case'"':s=cC;break;default:s=uC}break;case uC:switch(e.charAt(i)){case'"':s=cC}}if(s===lC?n.push(e.substring(a,r-1)):n.push(e.substring(a)),t&&n.length!==this.fullColumnNames.length)throw new Error("Invalid row in csv file. Should have ".concat(this.fullColumnNames.length," elements in a row, but got ").concat(n));return n}},hC=class extends jO{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error("Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ".concat(this.fftSize));if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!Ue().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let t=new hC(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(hJ){throw new Error("Error thrown while initializing video stream: ".concat(hJ.message))}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error("Mismatch in sampling rate: Expected: ".concat(this.sampleRateHz,"; Actual: ").concat(this.audioContext.sampleRate))}else this.sampleRateHz=this.audioContext.sampleRate;let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise(a=>{let r=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&a({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(r),a({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach((e,a)=>n.set(e,a*t)),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(Nr.sizeFromShape(t));return n.set(e,n.length-e.length),qs(n,t)}},pC=class extends jO{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Dd([0],"int32"),this.webcamConfig.centerCrop){let e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,a=(1-t)/2,r=n+e,s=t+a;this.cropBox=Fd([a,n,s,r],[1,4])}else this.cropBox=Fd([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!Ue().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new pC(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&Nr.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,()=>"Invalid webcam facing mode: ".concat(this.webcamConfig.facingMode,". Please provide 'user' or 'environment'"));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(ds){throw ds.message="Error thrown while initializing video stream: ".concat(ds.message),ds}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(ds){console.log(ds),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=lf.fromPixels(this.webcamVideoElement)}catch(t){throw new Error("Error thrown converting video to pixels: ".concat(JSON.stringify(t)))}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error("Error thrown cropping the video: ".concat(t.message))}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return eo(()=>{let t,n=fl(Vi(e,"float32"),0);t=kp.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let a=t.shape;return Xo(t,a.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(ds){console.log(ds),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},fC=class{},mC=class extends jO{split(e){return new gC(this,e)}},gC=class extends mC{constructor(e,t){super(),this.upstream=e,this.impl=new bC(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},bC=class extends KO{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return"".concat(this.upstream.summary()," -> Split('").concat(this.separator,"')")}async pump(){let e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},yC=class extends jO{decodeUTF8(){return new vC(this)}},vC=class extends mC{constructor(e){super(),this.upstream=e,this.impl=new xC(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},xC=class extends KO{constructor(e){if(super(),this.upstream=e,Ue().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=R();this.decoder=new e("utf8")}}summary(){return"".concat(this.upstream.summary()," -> Utf8")}async pump(){let e,t,n=await this.upstream.next();return!n.done&&(e=n.value,t=Ue().get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(i.from(e.buffer)),this.outputQueue.push(t),!0)}},wC=class extends yC{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.file=e,this.options=t,Nr.assert(e instanceof Uint8Array||!!Ue().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return"FileChunks ".concat(this.file)}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let a=new FileReader;a.onload=n=>{let r=a.result;if(r instanceof ArrayBuffer&&(r=new Uint8Array(r)),!(r instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(r)},a.onabort=e=>t(new Error("Aborted")),a.onerror=e=>t(new Error(e.type));let r=this.file.slice(this.offset,n);a.readAsArrayBuffer(r)}this.offset=n}),done:!1}}};var kC=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function IC(e){return"string"==typeof e&&"file://"===e.slice(0,7)}var SC=class extends fC{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.input=e,this.options=t}async iterator(){if(IC(this.input)&&Ue().get("IS_NODE")){let e=D();this.input=e.readFileSync(this.input.slice(7))}return new wC(this.input,this.options)}},NC=class extends fC{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.url=e,this.fileOptions=t}async iterator(){return IC(this.url)?new SC(this.url,this.fileOptions).iterator():async function(e){let t,n,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2?arguments[2]:void 0;"string"==typeof e?t=e:(t=e.url,n=kC(e));let s=await(r||Nr.fetch)(t,n);if(s.ok){let e=new Uint8Array(await s.arrayBuffer());return new wC(e,a)}throw new Error(s.statusText)}(this.url,this.fileOptions)}};function TC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new dC(new NC(e),t)}function OC(e){let t=FO(e);return eC(async()=>t)}function CC(e){return eC(async()=>{let t=await e();return FO(()=>t.next())})}async function EC(e,t){return pC.create(e,t)}async function _C(e){return hC.create(e)}var AC="4.7.0";function RC(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Nr.assert("complex64"!==e.dtype,()=>"".concat(t," does not support complex64 tensors in the CPU backend."))})}var DC=Xm.whereImpl,FC=class extends U{nextDataId(){return FC.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new W(this,Ji())}write(e,t,n){this.firstUse&&(this.firstUse=!1,Ue().get("IS_NODE")&&Hf.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:n,refCount:1}),a}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Nr.isString(n[0])){let r=n.map(e=>Nr.encodeString(e));a=this.write(r,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,a,r){this.data.set(e,{values:t,dtype:a,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){let e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return Hf.mergeRealAndImagArrays(e,t)}return Nr.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map(e=>Nr.decodeString(e));return Ui(e.shape,e.dtype,n)}catch(hJ){throw new Error("Failed to decode encoded string bytes into utf-8")}return Ui(e.shape,e.dtype,t)}makeOutput(e,t,n){return Ji().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=Nr.now();return e(),{kernelMs:Nr.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){RC([e],"where");let t=this.readSync(e.dataId);return DC(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};FC.nextDataId=0;var MC={};function jC(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}y(MC,{addImpl:()=>JC,bincountImpl:()=>tE,bincountReduceImpl:()=>nE,bitwiseAndImpl:()=>aE,castImpl:()=>qC,ceilImpl:()=>lE,concatImpl:()=>hE,equalImpl:()=>pE,expImpl:()=>gE,expm1Impl:()=>vE,floorDivImpl:()=>NE,floorImpl:()=>kE,gatherNdImpl:()=>CE,gatherV2Impl:()=>EE,greaterEqualImpl:()=>DE,greaterImpl:()=>_E,lessEqualImpl:()=>PE,lessImpl:()=>jE,linSpaceImpl:()=>UE,logImpl:()=>VE,maxImpl:()=>qE,maximumImpl:()=>KE,minimumImpl:()=>YE,multiplyImpl:()=>$E,negImpl:()=>a_,notEqualImpl:()=>s_,prodImpl:()=>d_,raggedGatherImpl:()=>g_,raggedRangeImpl:()=>y_,raggedTensorToTensorImpl:()=>I_,rangeImpl:()=>S_,rsqrtImpl:()=>N_,scatterImpl:()=>C_,sigmoidImpl:()=>E_,simpleAbsImpl:()=>jC,sliceImpl:()=>R_,sparseFillEmptyRowsImpl:()=>M_,sparseReshapeImpl:()=>j_,sparseSegmentReductionImpl:()=>z_,sqrtImpl:()=>L_,squaredDifferenceImpl:()=>W_,staticRegexReplaceImpl:()=>G_,stridedSliceImpl:()=>K_,stringNGramsImpl:()=>X_,stringSplitImpl:()=>Y_,stringToHashBucketFastImpl:()=>J_,subImpl:()=>Q_,tileImpl:()=>nA,topKImpl:()=>sA,transposeImpl:()=>c_,uniqueImpl:()=>iA});var zC={kernelName:Ke,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend;RC(t,"abs");let a=new Float32Array(Nr.sizeFromShape(t.shape));return a=jC(n.data.get(t.dataId).values),n.makeOutput(a,t.shape,t.dtype)}};function LC(e){return(t,n,a,r,s)=>{let i=Hf.assertAndGetBroadcastShape(t,n),o=i.length,c=Nr.computeStrides(i),l=Nr.sizeFromShape(i),u=Nr.getTypedArrayFromDType(s,l),d=t.length,h=n.length,p=Nr.computeStrides(t),f=Nr.computeStrides(n),m=Hf.getBroadcastDims(t,i),g=Hf.getBroadcastDims(n,i);if(m.length+g.length===0)for(let b=0;b<u.length;++b)u[b]=e(a[b%a.length],r[b%r.length]);else for(let b=0;b<u.length;++b){let t=Nr.indexToLoc(b,o,c),n=t.slice(-d);m.forEach(e=>n[e]=0);let s=Nr.locToIndex(n,d,p),i=t.slice(-h);g.forEach(e=>i[e]=0);let l=Nr.locToIndex(i,h,f);u[b]=e(a[s],r[l])}return[u,i]}}function PC(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=n.makeTensorInfo(a.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",s),imag:n.makeTensorInfo(r.shape,"float32",i)},o}var BC={kernelName:xt,backendName:"cpu",kernelFunc:PC};function WC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return PC({inputs:{real:WC(e,t,"float32"),imag:WC(e,t,"float32")},backend:e})}let a=Nr.makeZerosTypedArray(Nr.sizeFromShape(t),n);return e.makeTensorInfo(t,n,a)}function UC(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var VC={kernelName:un,backendName:"cpu",kernelFunc:UC};function GC(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var HC={kernelName:ca,backendName:"cpu",kernelFunc:GC};function qC(e,t,n,a){if("int32"===a){return[t,"int32",Int32Array.from(e)]}if("bool"===a){let a=Nr.toTypedArray([0],n),[r,s]=LC((e,t)=>e!==t?1:0)(t,[],e,a,"bool");return[s,"bool",r]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(a))}function KC(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if("complex64"===s){if("complex64"===r.dtype)return UC({inputs:{x:r},backend:n});let e=WC(n,r.shape,r.dtype),t=KC({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=PC({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===r.dtype){let e=GC({inputs:{input:r},backend:n}),t=KC({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!Nr.hasEncodingLoss(r.dtype,s)){let e=UC({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}let i=n.data.get(r.dataId).values,[o,c,l]=qC(i,r.shape,r.dtype,s);return n.makeTensorInfo(o,c,l)}var XC={kernelName:bt,backendName:"cpu",kernelFunc:KC};function ZC(e,t,n,a){return null==n?n=>{let{inputs:r,backend:s}=n,{a:i,b:o}=r,c=s;RC([i,o],e);let l=c.data.get(i.dataId).values,u=c.data.get(o.dataId).values,d="string"===i.dtype?Hf.fromUint8ToStringArray(l):l,h="string"===i.dtype?Hf.fromUint8ToStringArray(u):u,p=a||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return c.makeTensorInfo(m,p,f)}:e=>{let{inputs:r,backend:s}=e,{a:i,b:o}=r,c=s;if("complex64"===i.dtype||"complex64"===o.dtype){let e=KC({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),t=c.data.get(e.dataId),a=t.complexTensorInfos.real,r=t.complexTensorInfos.imag,s=c.data.get(a.dataId).values,l=c.data.get(r.dataId).values,u=KC({inputs:{x:o},backend:c,attrs:{dtype:"complex64"}}),d=c.data.get(u.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=c.data.get(h.dataId).values,m=c.data.get(p.dataId).values,[g,b,y]=n(i.shape,o.shape,s,l,f,m),v=c.makeTensorInfo(y,"float32",g),x=c.makeTensorInfo(y,"float32",b),w=PC({inputs:{real:v,imag:x},backend:c});return c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(v),c.disposeIntermediateTensorInfo(x),w}{let e=c.data.get(i.dataId).values,n=c.data.get(o.dataId).values,r=a||i.dtype,[s,l]=t(i.shape,o.shape,e,n,r);return c.makeTensorInfo(l,r,s)}}}function YC(e){return(t,n,a,r,s,i)=>{let o=Hf.assertAndGetBroadcastShape(t,n),c=Nr.sizeFromShape(o),l=o.length,u=Nr.computeStrides(o),d=Nr.getTypedArrayFromDType("float32",c),h=Nr.getTypedArrayFromDType("float32",c),p=Hf.getBroadcastDims(t,o),f=Hf.getBroadcastDims(n,o),m=Hf.mergeRealAndImagArrays(a,r),g=Hf.mergeRealAndImagArrays(s,i),b=t.length,y=Nr.computeStrides(t),v=n.length,x=Nr.computeStrides(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){let t=w%m.length,n=w%g.length,a=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=a.real,h[w]=a.imag}else for(let w=0;w<d.length;w++){let t=Nr.indexToLoc(w,l,u),n=t.slice(-b);p.forEach(e=>n[e]=0);let a=Nr.locToIndex(n,b,y),r=t.slice(-v);f.forEach(e=>r[e]=0);let s=Nr.locToIndex(r,v,x),i=e(m[2*a],m[2*a+1],g[2*s],g[2*s+1]);d[w]=i.real,h[w]=i.imag}return[d,h,o]}}var JC=LC((e,t)=>e+t),QC=YC((e,t,n,a)=>({real:e+n,imag:t+a})),$C=ZC(Ye,JC,QC),eE={kernelName:Ye,backendName:"cpu",kernelFunc:$C};function tE(e,t,n,a,r){let s=Nr.sizeFromShape(a),i=Nr.makeZerosTypedArray(r,n);for(let o=0;o<e.length;o++){let n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(i[n]+=s>0?t[o]:1)}return i}function nE(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=e.shape[0],s=e.shape[1],i=Ui([r,n],t.dtype);for(let o=0;o<r;o++)for(let r=0;r<s;r++){let s=e.get(o,r);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(a?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,r),o,s):i.set(i.get(o,s)+1,o,s))}return i}var aE=LC((e,t)=>e&t),rE=ZC(ft,aE),sE={kernelName:ft,backendName:"cpu",kernelFunc:rE};function iE(e){return(t,n,a)=>{let r=Nr.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)r[s]=e(t[s],a);return r}}function oE(e,t,n){return cE(e,iE(t),n)}function cE(e,t,n){return a=>{let{inputs:r,attrs:s,backend:i}=a,{x:o}=r;RC(o,e);let c,l=i,u=l.data.get(o.dataId).values;if("string"===o.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=Hf.fromUint8ToStringArray(u)}else c=u;let d=n||o.dtype,h=t(c,d,s);return l.makeTensorInfo(o.shape,d,h)}}var lE=iE(e=>Math.ceil(e)),uE=cE(yt,lE),dE={kernelName:yt,backendName:"cpu",kernelFunc:uE};function hE(e,t,n,a){let r=Nr.getArrayFromDType(n,Nr.sizeFromShape(t));if(a&&"string"!==n){let t=0;e.forEach(e=>{let n=Nr.sizeFromShape(e.shape);r.set(e.vals,t),t+=n})}else{let a=0;e.forEach(e=>{let s="string"===n?Hf.fromUint8ToStringArray(e.vals):e.vals,i=0;for(let n=0;n<e.shape[0];++n){let o=n*t[1]+a;for(let t=0;t<e.shape[1];++t)r[o+t]=s[i++]}a+=e.shape[1]})}return r}var pE=LC((e,t)=>e===t?1:0),fE=ZC(Zt,pE,null,"bool"),mE={kernelName:Zt,backendName:"cpu",kernelFunc:fE},gE=iE(e=>Math.exp(e)),bE=cE(Yt,gE,"float32"),yE={kernelName:Yt,backendName:"cpu",kernelFunc:bE},vE=iE(e=>Math.expm1(e)),xE=cE(Qt,vE),wE={kernelName:Qt,backendName:"cpu",kernelFunc:xE},kE=iE(e=>Math.floor(e)),IE=cE(nn,kE),SE={kernelName:nn,backendName:"cpu",kernelFunc:IE},NE=LC((e,t)=>Math.floor(e/t)),TE=ZC(an,NE,null,"int32"),OE={kernelName:an,backendName:"cpu",kernelFunc:TE};function CE(e,t,n,a,r,s,i,o,c){let l=Ui([a,s],n);for(let u=0;u<a;u++){let n=[],a=0;for(let t=0;t<r;t++){let s=e[u*r+t];a+=s*i[t],n.push(s)}if(a<0||a>=c/s)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(o));for(let e=0;e<s;e++)l.values[u*s+e]=t.get(...t.indexToLoc(a*s+e))}return l}function EE(e,t,n){let a=Ui(n,e.dtype);for(let r=0;r<a.size;++r){let n=a.indexToLoc(r).slice(),s=n[0],i=n[2],o=t.locToIndex([s,i]);n[2]=t.values[o];let c=e.locToIndex(n);0<=c&&c<e.values.length&&(a.values[r]=e.values[c])}return a}var _E=LC((e,t)=>e>t?1:0),AE=ZC(cn,_E,null,"bool"),RE={kernelName:cn,backendName:"cpu",kernelFunc:AE},DE=LC((e,t)=>e>=t?1:0),FE=ZC(ln,DE,null,"bool"),ME={kernelName:ln,backendName:"cpu",kernelFunc:FE},jE=LC((e,t)=>e<t?1:0),zE=ZC(bn,jE,null,"bool"),LE={kernelName:bn,backendName:"cpu",kernelFunc:zE},PE=LC((e,t)=>e<=t?1:0),BE=ZC(yn,PE,null,"bool"),WE={kernelName:yn,backendName:"cpu",kernelFunc:BE};function UE(e,t,n){let a=(t-e)/(n-1),r=Nr.makeZerosTypedArray(n,"float32");r[0]=e;for(let s=1;s<r.length;s++)r[s]=r[s-1]+a;return r}var VE=iE(e=>Math.log(e)),GE=cE(xn,VE),HE={kernelName:xn,backendName:"cpu",kernelFunc:GE};function qE(e,t,n,a){let r=Nr.getTypedArrayFromDType(a,Nr.sizeFromShape(n));for(let s=0;s<r.length;++s){let n=s*t,a=e[n];for(let r=0;r<t;++r){let t=e[n+r];(Number.isNaN(t)||t>a)&&(a=t)}r[s]=a}return r}var KE=LC((e,t)=>Math.max(e,t)),XE=ZC(Rn,KE),ZE={kernelName:Rn,backendName:"cpu",kernelFunc:XE},YE=LC((e,t)=>Math.min(e,t)),JE=ZC(Bn,YE),QE={kernelName:Bn,backendName:"cpu",kernelFunc:JE},$E=LC((e,t)=>e*t),e_=YC((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n})),t_=ZC(Gn,$E,e_),n_={kernelName:Gn,backendName:"cpu",kernelFunc:t_};function a_(e,t,n){let a=Nr.createScalarValue(-1,n);return $E([],t,a,e,n)}var r_={kernelName:Hn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:a}=t;RC(a,"neg");let r=n.data.get(a.dataId).values,[s,i]=a_(r,a.shape,a.dtype);return n.makeTensorInfo(i,a.dtype,s)}},s_=LC((e,t)=>e!==t?1:0),i_=ZC(qn,s_,null,"bool"),o_={kernelName:qn,backendName:"cpu",kernelFunc:i_};function c_(e,t,n,a,r){let s=t.length,i=Nr.sizeFromShape(t),o=Nr.computeStrides(t),c=Nr.computeStrides(r),l=Nr.getTypedArrayFromDType(n,Nr.sizeFromShape(r));for(let u=0;u<i;++u){let t=Nr.indexToLoc(u,s,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[a[e]];l[Nr.locToIndex(n,s,c)]=e[u]}return l}function l_(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:s}=n;RC(r,"transpose");let i=r.shape.length,o=new Array(i);for(let l=0;l<o.length;l++)o[l]=r.shape[s[l]];let c=c_(a.data.get(r.dataId).values,r.shape,r.dtype,s,o);return{dataId:a.write(c,o,r.dtype),shape:o,dtype:r.dtype}}var u_={kernelName:er,backendName:"cpu",kernelFunc:l_};function d_(e,t,n,a){let[r,s]=Hf.computeOutAndReduceShapes(e,a),i=ys(t,"int32"),o=Nr.makeZerosTypedArray(Nr.sizeFromShape(r),i),c=Nr.sizeFromShape(s);for(let l=0;l<o.length;++l){let e=l*c,t=1;for(let a=0;a<c;++a)t*=n[e+a];o[l]=t}return{outVals:o,outShape:r,outDtype:i}}var h_={kernelName:aa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;RC(r,"prod");let o=r.shape.length,c=Nr.parseAxisParam(s,r.shape),l=Hf.getAxesPermutation(c,o),u=c,d=r,h=[];null!=l&&(d=l_({inputs:{x:r},backend:n,attrs:{perm:l}}),h.push(d),u=Hf.getInnerMostAxes(u.length,o));let p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=d_(d.shape,d.dtype,p,u),b=m;return i&&(b=Hf.expandShapeToKeepDim(m,c)),h.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(b,g,f)}};function p_(e,t,n,a){let r=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);!function(e,t){for(let n=0;n<e.length;++n){let a=e[n],r=n===e.length-1?t:e[n+1].length;if(0===a.length)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let e=1;e<a.length;++e)if(a[e-1]>a[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,a);let c=1;for(let l=0;l<t.length-1;++l){c*=t[l];let e=t[l+1];for(let t=1;t<c+1;++t)o[l].push(t*e)}for(let l=0;l<e.length;++l){let a=e[l],i=e[l]+1;for(let e=0;e<n.length;++e){let r=n[e],s=e+t.length-1;if(s>=0){let e=o[s],t=e[e.length-1]-r[a];for(let n=a;n<i;++n)o[s].push(r[n+1]+t)}a=r[a],i=r[i]}i!==a&&(r.push([a,i]),s+=i-a)}return{outSplits:o,valueSlices:r,numValues:s}}function f_(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function m_(e,t,n,a,r){let s=t.slice();s[0]=r;let i=Nr.getArrayFromDType(n,Nr.sizeFromShape(s)),o=e.length;return function(e,t,n,a,r,s){let i=f_(t,2)[1],o=f_(s,2)[1],c=0;for(let l of n)for(let t=l[0];t<l[1];++t){for(let n=0;n<a;++n)r[c*o+n]=e[t*i+n];++c}}(e,t,a,0===o?0:o/t[0],i,s),[i,s]}function g_(e,t,n,a,r,s,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach((e,a)=>{if(e<0||e>=n){let r=Nr.indexToLoc(a,t.length,Nr.computeStrides(t)).join(",");throw new Error("indices[".concat(r,"] = ").concat(e," is not in [0, ").concat(n,")"))}})}(s,i,t[0][0]-1),0===a.length)throw new Error("params.rank must be nonzero");let c=a[0],{outSplits:l,valueSlices:u,numValues:d}=p_(s,i,e,c),h=function(e){let t=[];for(let n=0;n<e.length;++n){let a=e[n].length,r=Nr.getArrayFromDType("int32",a);t.push(r),e[n].forEach((e,t)=>r[t]=e)}return t}(l),p=m_(n,a,r,u,d);return[h,p[0],p[1]]}var b_=2147483647;function y_(e,t,n,a,r,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=0===t.length,c=0===r.length,l=0===i.length,u=[];o||u.push(t[0]),c||u.push(r[0]),l||u.push(i[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");let d=0===u.length?1:u[0],h=Nr.getArrayFromDType("int32",d+1);h[0]=0;for(let g=0;g<d;++g){let t,n=o?e[0]:e[g],r=c?a[0]:a[g],i=l?s[0]:s[g];if(0===i)throw new Error("Requires delta != 0");if(i>0&&r<n||i<0&&r>n)t=0;else if(t=Math.ceil(Math.abs((r-n)/i)),t>b_)throw new Error("Requires ((limit - start) / delta) <= ".concat(b_));h[g+1]=h[g]+t}let p=h[d],f=Nr.getArrayFromDType(n,p),m=0;for(let g=0;g<d;++g){let t=h[g+1]-h[g],n=o?e[0]:e[g],a=l?s[0]:s[g];for(let e=0;e<t;++e)f[m++]=n,n+=a}return[h,f]}var v_=Hf.RowPartitionType,x_=class{constructor(e,t,n,a,r,s,i,o,c,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=a,this.valuesDType=r,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=Hf.getRowPartitionTypesHelper(l),this.raggedRank=Hf.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===v_.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===v_.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case v_.VALUE_ROWIDS:return x_.getMaxWidthValueRowID(t);case v_.ROW_SPLITS:return x_.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type ".concat(v_[this.getRowPartitionTypeByDimension(e-1)]))}}static getMaxWidthRowSplit(e){let t=e.length;if(0===t||1===t)return 0;let n=0;for(let a=0;a<t-1;++a){let t=e[a+1]-e[a];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(0===t)return 0;let n=0,a=e[0],r=0;for(let s=1;s<t;++s){let t=e[s];t!==a&&(a=t,r=Math.max(s-n,r),n=s)}return Math.max(t-n,r)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return k_(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;Hf.validateDefaultValueShape(n,t);let a=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=Hf.combineRaggedTensorToTensorShapes(this.raggedRank,a,t);r[0]<0&&(r[0]=e);for(let s=1;s<=this.raggedRank;++s)r[s]<0&&(r[s]=this.getMaxWidth(s));return r}calculateFirstParentOutputIndex(e,t,n){let a=Math.min(e,n),r=[],s=0;for(let i=0;i<a;++i,s+=t)r.push(s);for(let i=a;i<e;++i)r.push(-1);return Nr.assert(r.length===e,()=>"Final length of result must be equal to firstDimension."),r}calculateOutputIndexRowSplit(e,t,n,a){let r=e.length,s=[];for(let i=0;i<r-1;++i){let r=e[i+1]-e[i],o=Math.min(a,r),c=t[i];-1===c&&(o=0);for(let e=0;e<o;++e)s.push(c),c+=n;for(let e=0;e<r-o;++e)s.push(-1)}if(r>0&&s.length!==e[r-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,a){let r=e.length,s=[];if(0===r)return[];let i=0,o=e[0];if(o>=t.length)throw new Error("Got currentValueRowId=".concat(o,", which is not less than ").concat(t.length));let c=t[o];s.push(c);for(let l=1;l<r;++l){let r=e[l];if(r===o)c>=0&&(++i,i<a?c+=n:c=-1);else{if(i=0,o=r,r>=t.length)throw new Error("Got nextValueRowId=".concat(r," which is not less than ").concat(t.length));c=t[r]}s.push(c)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,a){let r=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case v_.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,n,a);case v_.ROW_SPLITS:if(r.length-1>t.length)throw new Error("Row partition size is greater than output size: ".concat(r.length-1," > ").concat(t.length));return this.calculateOutputIndexRowSplit(r,t,n,a);default:throw new Error("Unsupported partition type: ".concat(v_[s]))}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case v_.FIRST_DIM_SIZE:return e[0];case v_.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case v_.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(v_[t]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*t[s+1];let a=k_(t,!1),r=Nr.getArrayFromDType(this.valuesDType,Nr.sizeFromShape(a));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)s=this.calculateOutputIndex(e-1,s,n[e],t[e]);this.setOutput(this.raggedRank,s,r,a)}return[a,r]}setOutput(e,t,n,a){if(0===n.length)return;let r=this.values,s=n,i=a.slice();i=i.slice(e+1);let o=Nr.sizeFromShape(i),c=t.length,l=this.defaultValue;if(l.length!==o&&1!==l.length){let e=this.defaultValueShape;eo(()=>{let t=Xo(l,e);l=hc(t,i).dataSync()})}let u=0,d=0,h=0;for(let p=0;p<=c;++p){let e=p<c?t[p]:-1;if(e!==h){if(d<h){let e=r.subarray(u*o);w_(s.subarray(d*o),e,(h-d)*o)}if(p>=c){let t=n.length;e=Math.floor(t/o)}if(e>h)if(1===this.defaultValue.length)s.subarray(h*o,e*o).fill(this.defaultValue[0]),h=e;else for(;e>h;){w_(s.slice(h*o),l,o),++h}e<0?(u=p+1,d=h):(u=p,d=h,h=d+1)}else++h}}};function w_(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function k_(e,t){let n=[];for(let a of e){if(a<0){if(!t)throw new Error("Dimension ".concat(a," must be >= 0"));if(a<-1)throw new Error("Dimension ".concat(a," must be >= -1"));a=-1}n.push(a)}return n}function I_(e,t,n,a,r,s,i,o,c,l){return new x_(e,t,n,a,r,s,i,o,c,l).compute()}function S_(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return Nr.makeZerosTypedArray(0,a);let r=Math.abs(Math.ceil((t-e)/n)),s=Nr.makeZerosTypedArray(r,a);t<e&&1===n&&(n=-1),s[0]=e;for(let i=1;i<s.length;i++)s[i]=s[i-1]+n;return s}var N_=iE(e=>1/Math.sqrt(e)),T_=cE(va,N_),O_={kernelName:va,backendName:"cpu",kernelFunc:T_};function C_(e,t,n,a,r,s,i,o,c,l){let u=[a/r,r],d=e.values,h=t.values;if(0===a)return Ui(n,t.dtype);let p=c instanceof rs?c:Ui(u,t.dtype);"string"==typeof c||"number"==typeof c?p.values.fill(c):"boolean"==typeof c&&p.values.fill(+c);for(let f=0;f<s;f++){let e=[],s=0;for(let t=0;t<i;t++){let n=d[f*i+t];e.push(n),s+=n*o[t]}if(s<0||s>=a/r)throw new Error("Invalid indices: ".concat(e," does not index into ").concat(n));for(let n=0;n<r;n++)l?p.values[s*r+n]+=h[f*r+n]:p.values[s*r+n]=0===t.rank?h[0]:h[f*r+n]}return p}var E_=iE(e=>1/(1+Math.exp(-e))),__=oE(Ea,e=>1/(1+Math.exp(-e))),A_={kernelName:Ea,backendName:"cpu",kernelFunc:__};function R_(e,t,n,a,r){let s=wf.isSliceContinous(a,t,n),i=Nr.sizeFromShape(n),o=Nr.computeStrides(a);if(s){let n=wf.computeFlatOffset(t,o);return"string"===r?e.slice(n,n+i):e.subarray(n,n+i)}let c=Ui(a,r,"string"===r?Hf.fromUint8ToStringArray(e):e),l=Ui(n,r);for(let u=0;u<l.size;++u){let e=l.indexToLoc(u),n=e.map((e,n)=>e+t[n]);l.set(c.get(...n),...e)}return"string"===r?Hf.fromStringArrayToUint8(l.values):l.values}function D_(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a;RC(r,"slice");let[o,c]=wf.parseSliceParams(r,s,i);wf.assertParamsValid(r,o,c);let l=R_(n.data.get(r.dataId).values,o,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,l)}var F_={kernelName:Na,backendName:"cpu",kernelFunc:D_};function M_(e,t,n,a,r,s,i){let o=t[0],c=s[0],l=new Array(c),u=new Array(o),d=t[1];if(0===c){if(0!==o)throw new Error(Hf.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));return[Nr.getArrayFromDType(n,0),[0,d],Nr.getArrayFromDType(r,0),l,u]}let h=!0,p=0,f=new Array(c).fill(0);for(let g=0;g<o;++g){let t=e[g*d];if(t<0)throw new Error(Hf.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,t));if(t>=c)throw new Error(Hf.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,t,c));++f[t],h=h&&t>=p,p=t}let m=!0;for(let g=0;g<c;++g){let e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){let t=e,n=a;for(let e=0;e<o;++e)u[e]=e;return[t,[o,d],n,l,u]}{let t=f[c-1],s=Nr.getArrayFromDType(n,t*d),h=Nr.getArrayFromDType(r,t),p=new Array(c).fill(0);for(let n=0;n<o;++n){let t=e[n*d],r=p[t],i=(0===t?0:f[t-1])+r;p[t]++;for(let a=0;a<d;++a)s[i*d+a]=e[n*d+a];h[i]=a[n],u[n]=i}for(let e=0;e<c;++e)if(0===p[e]){let t=0===e?0:f[e-1];s[t*d+0]=e;for(let e=1;e<d;++e)s[t*d+e]=0;h[t]=i}return[s,[t,d],h,l,u]}}function j_(e,t,n,a,r){let s=Nr.sizeFromShape(a),i=t[0],o=r.length,c=[],l=1,u=-1;for(let m=0;m<o;++m){let e=r[m];if(-1===e){if(-1!==u)throw new Error(Hf.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(u,m));u=m,c.push(1)}else{if(e<0)throw new Error(Hf.getSparseReshapeNegativeOutputDimErrorMessage(m,e));l*=e,c.push(e)}}if(-1!==u){if(l<=0)throw new Error(Hf.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let e=Math.trunc(s/l);if(l*e!==s)throw new Error(Hf.getSparseReshapeInputOutputMultipleErrorMessage(a,c));c[u]=e}if(Nr.sizeFromShape(c)!==s)throw new Error(Hf.getSparseReshapeInputOutputMismatchErrorMessage(a,c));let d=a.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*a[e+1]}let p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*c[e+1]}let f=Nr.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*h[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],c]}function z_(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=a.length,c=[t[0],e.length/t[0]],l=c[1],u=o>0?r[o-1]+1:0;if(u<0)throw new Error(Hf.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=u;let h=d.reduce((e,t)=>e*t,1),p=Nr.getArrayFromDType(n,h);if(0===o)return u>0&&p.fill(i),[p,d];if(u<=0)throw new Error(Hf.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,b=r[f];for(;;){let t=0;if(m<o){if(t=r[m],b===t){++m;continue}if(b>=t)throw new Error(Hf.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=u)throw new Error(Hf.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,u));b>g&&p.fill(i,g*l,b*l);for(let n=f;n<m;++n){let t=a[n];if(t<0||t>=c[0])throw new Error(Hf.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,a[n],c[0]));for(let n=0;n<l;n++)p[b*l+n]+=e[t*l+n]}if(s)for(let e=0;e<l;e++)p[b*l+e]/=m-f;if(f=m,++m,g=b+1,b=t,m>o)break}return g<u&&p.fill(i,g*l,u*l),[p,d]}var L_=iE(e=>Math.sqrt(e)),P_=oE(Aa,e=>Math.sqrt(e)),B_={kernelName:Aa,backendName:"cpu",kernelFunc:P_},W_=LC((e,t)=>{let n=e-t;return n*n}),U_=ZC(Wa,W_),V_={kernelName:Wa,backendName:"cpu",kernelFunc:U_},G_=iE((e,t)=>{let{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?"g":""),r)}),H_=cE(Va,G_),q_={kernelName:Va,backendName:"cpu",kernelFunc:H_};function K_(e,t,n,a){let r=Ui(e,t.dtype);for(let s=0;s<r.size;s++){let e=r.indexToLoc(s),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+a[t];r.set(t.get(...i),...e)}return r}function X_(e,t,n,a,r,s,i,o){return new class{constructor(e,t,n,a,r,s){this.separator=Nr.encodeString(e),this.nGramWidths=t,this.leftPad=Nr.encodeString(n),this.rightPad=Nr.encodeString(a),this.padWidth=r,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,s){for(let i=0;i<r;++i){let o=this.getPadWidth(s),c=Math.max(0,o-i),l=Math.max(0,o-(r-(i+1))),u=s-(c+l),d=t+(c>0?0:i-o),h=0;h+=c*this.leftPad.length;for(let t=0;t<u;++t)h+=e[d+t].length;h+=l*this.rightPad.length,h+=(c+l+u-1)*this.separator.length,n[a+i]=new Uint8Array(h);let p=n[a+i],f=0,m=e=>e.forEach(e=>p[f++]=e);for(let e=0;e<c;++e)m(this.leftPad),m(this.separator);for(let t=0;t<u-1;++t)m(e[d+t]),m(this.separator);if(u>0){m(e[d+u-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){let n=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got ".concat(e));for(let r=1;r<a;++r){let a=t[r]>=e;if(a=a&&t[r]<=n,!a)throw new Error("Invalid split value ".concat(t[r],", must be in [").concat(e,", ").concat(n,"]"));e=t[r]}if(e!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(e))}let r=a-1,s=Nr.getArrayFromDType("int32",a);if(0===n||0===a){let e=new Array(n);for(let t=0;t<=r;++t)s[t]=0;return[e,s]}s[0]=0;for(let o=1;o<=r;++o){let e=t[o]-t[o-1],n=0;this.nGramWidths.forEach(t=>{n+=this.getNumNGrams(e,t)}),this.preserveShort&&e>0&&0===n&&(n=1),s[o]=s[o-1]+n}let i=new Array(s[r]);for(let o=0;o<r;++o){let n=t[o],a=s[o];if(this.nGramWidths.forEach(r=>{let s=t[o+1]-t[o],c=this.getNumNGrams(s,r);this.createNGrams(e,n,i,a,c,r),a+=c}),this.preserveShort&&a===s[o]){let r=t[o+1]-t[o];if(0===r)continue;let s=r+2*this.padWidth,c=1;this.createNGrams(e,n,i,a,c,s)}}return[i,s]}}(n,a,r,s,i,o).compute(e,t)}function Z_(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){let r=t[0],s=e.indexOf(r);for(;-1!==s;){let t=e.subarray(0,s);(!n||0!==t.length)&&a.push(t),s=(e=e.subarray(s+1)).indexOf(r)}return void((!n||0!==e.length)&&a.push(e))}let r=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){let t=e.subarray(r,s);(!n||0!==t.length)&&a.push(t),r=s+1}}function Y_(e,t,n){let a=e.length,r=[],s=0,i=0,o=new Array(a);for(let h=0;h<a;++h){let a=r.length;Z_(e[h],t,n,r);let c=r.length-a;o[h]=c,s+=c,i=Math.max(i,c)}let c=Nr.getArrayFromDType("int32",2*s),l=new Array(s),u=[a,i],d=0;for(let h=0;h<a;++h)for(let e=0;e<o[h];++e)c[2*d]=h,c[2*d+1]=e,l[d]=r[d],++d;return[c,l,u]}function J_(e,t){let n=Nr.getArrayFromDType("int32",e.length);for(let a=0;a<e.length;++a)n[a]=Nr.fingerPrint64(e[a]).modulo(t).getLowBitsUnsigned();return n}var Q_=LC((e,t)=>e-t),$_=YC((e,t,n,a)=>({real:e-n,imag:t-a})),eA=ZC(Xa,Q_,$_),tA={kernelName:Xa,backendName:"cpu",kernelFunc:eA};function nA(e,t){let n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];let a=Ui(n,e.dtype);for(let r=0;r<a.values.length;++r){let t=a.indexToLoc(r),n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=t[a]%e.shape[a];let s=e.locToIndex(n);a.values[r]=e.values[s]}return a}var aA=(e,t)=>{let n=t.value-e.value;return 0===n?e.index-t.index:n};function rA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;a>n;){if(a-n>600){let r=a-n+1,s=t-n+1,i=Math.log(r),o=.5*Math.exp(2*i/3),c=.5*Math.sqrt(i*o*(r-o)/r)*Math.sign(s-r/2);rA(e,t,Math.max(n,Math.floor(t-s*o/r+c)),Math.min(a,Math.floor(t+(r-s)*o/r+c)))}let r=e[t],s=n,i=a;for(Nr.swap(e,n,t),aA(e[a],r)>0&&Nr.swap(e,n,a);s<i;){for(Nr.swap(e,s,i),s++,i--;aA(e[s],r)<0;)s+=1;for(;aA(e[i],r)>0;)i-=1}0===aA(e[n],r)?Nr.swap(e,n,i):(i+=1,Nr.swap(e,i,a)),i<=t&&(n=i+1),t<=i&&(a=i-1)}}function sA(e,t,n,a,r){let s=t[t.length-1],[i,o]=[e.length/s,s],c=Nr.getTypedArrayFromDType(n,i*a),l=Nr.getTypedArrayFromDType("int32",i*a);for(let d=0;d<i;d++){let t=d*o,n=e.subarray(t,t+o),s=new Array(n.length);n.forEach((e,t)=>s[t]={value:e,index:t}),a<s.length&&(rA(s,a),s=s.slice(0,a)),r&&s.sort(aA);let i=d*a,u=c.subarray(i,i+a),h=l.subarray(i,i+a);for(let e=0;e<a;e++)u[e]=s[e].value,h[e]=s[e].index}let u=t.slice();return u[u.length-1]=a,[Ui(u,n,c),Ui(u,"int32",l)]}function iA(e,t,n,a){let r=Nr.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let f=0;f<r;f++)s[0]*=n[f];s[1]=n[r];for(let f=r+1;f<n.length;f++)s[2]*=n[f];let i=new Map,o=new Int32Array(n[r]),c=new rs(s,a,e),l=[],u=1===s[0]&&1===s[2];for(let f=0;f<n[r];f++){let t;if(u)t=e[f].toString();else{let e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(c.get(t,f,n));t=e.join(",")}let n=i.get(t);if(null!=n)o[f]=n;else{let e=i.size;i.set(t,e),o[f]=e,l.push(f)}}let d=s.slice();d[1]=i.size;let h=new rs(d,a);l.forEach((e,t)=>{for(let n=0;n<s[0];n++)for(let a=0;a<s[2];a++)h.set(c.get(n,e,a),n,t,a)});let p=n.slice();return p[r]=d[1],{outputValues:h.values,outputShape:p,indices:o}}var oA="4.7.0";uo("cpu",()=>new FC,1);var cA=oE(qt,e=>e>=0?e:Math.exp(e)-1),lA={kernelName:qt,backendName:"cpu",kernelFunc:cA};function uA(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a;RC([r],"leakyRelu");let i=Nr.sizeFromShape(r.shape),o=n.data.get(r.dataId).values,c=Nr.getTypedArrayFromDType("float32",i);for(let l=0;l<o.length;l++)c[l]=o[l]<0?s*o[l]:o[l];return n.makeTensorInfo(r.shape,"float32",c)}var dA={kernelName:gn,backendName:"cpu",kernelFunc:uA},hA=LC((e,t)=>e<0?t*e:e);function pA(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t;RC([a,r],"prelu");let s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,[o,c]=hA(a.shape,r.shape,s,i,"float32");return n.makeTensorInfo(c,"float32",o)}var fA={kernelName:na,backendName:"cpu",kernelFunc:pA},mA=oE(ua,e=>Math.max(0,e)),gA={kernelName:ua,backendName:"cpu",kernelFunc:mA},bA=oE(ga,e=>Math.min(Math.max(0,e),6)),yA={kernelName:ga,backendName:"cpu",kernelFunc:bA};function vA(e,t,n,a,r){if("linear"===n)return UC({inputs:{x:t},backend:e});if("relu"===n)return mA({inputs:{x:t},backend:e});if("elu"===n)return cA({inputs:{x:t},backend:e});if("relu6"===n)return bA({inputs:{x:t},backend:e});if("prelu"===n)return pA({inputs:{x:t,alpha:a},backend:e});if("leakyrelu"===n)return uA({inputs:{x:t},backend:e,attrs:{alpha:r}});if("sigmoid"===n)return __({inputs:{x:t},backend:e});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function xA(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=Nr.sizeFromShape(r.shape),o=Nr.inferFromImplicitShape(s,i),c=Nr.sizeFromShape(o);Nr.assert(i===c,()=>"The new shape (".concat(o,") has ").concat(c," elements and the old shape (").concat(r.shape,") has ").concat(i," elements. The new shape and old shape must have the same number of elements.")),n.incRef(r.dataId);let l=n.data.get(r.dataId);if(null!=l.complexTensorInfos){let e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}var wA={kernelName:da,backendName:"cpu",kernelFunc:xA};function kA(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;RC([r,s],"matMul");let c=r.shape.length,l=s.shape.length,u=i?r.shape[c-2]:r.shape[c-1],d=o?s.shape[l-1]:s.shape[l-2],h=i?r.shape[c-1]:r.shape[c-2],p=o?s.shape[l-2]:s.shape[l-1],f=r.shape.slice(0,-2),m=s.shape.slice(0,-2),g=Nr.sizeFromShape(f),b=Nr.sizeFromShape(m),y=jc.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);Nr.assert(u===d,()=>"Error in matMul: inner shapes (".concat(u,") and (").concat(d,") of Tensors with shapes ").concat(r.shape," and ").concat(s.shape," and transposeA=").concat(i," and transposeB=").concat(o," must match."));let v=o?[b,p,d]:[b,d,p],x=xA({inputs:{x:r},backend:n,attrs:{shape:i?[g,u,h]:[g,h,u]}}),w=xA({inputs:{x:s},backend:n,attrs:{shape:v}}),k=i?x.shape[1]:x.shape[2],I=i?x.shape[2]:x.shape[1],S=o?w.shape[1]:w.shape[2],N=Math.max(g,b),T=n.data.get(x.dataId).values,O=n.data.get(w.dataId).values,C=Nr.computeStrides(x.shape),E=Nr.computeStrides(w.shape),[_,A,R]=i?[C[0],1,C[1]]:[C[0],C[1],1],[D,F,M]=o?[1,E[1],E[0]]:[E[1],1,E[0]],j=I*S,z=Ui([N,I,S],x.dtype),L=z.values,P=n.blockSize;for(let B=0;B<N;B++){let e=B%g,t=B%b;for(let n=0;n<I;n+=P){let a=Math.min(n+P,I);for(let r=0;r<S;r+=P){let s=Math.min(r+P,S);for(let i=0;i<k;i+=P){let o=Math.min(i+P,k);for(let c=n;c<a;c++)for(let n=r;n<s;n++){let a=0;for(let r=i;r<o;r++){a+=T[e*_+c*A+r*R]*O[r*D+n*F+t*M]}L[B*j+(c*S+n)]+=a}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(y,z.dtype,z.values)}var IA={kernelName:dt,backendName:"cpu",kernelFunc:kA};var SA={kernelName:lr,backendName:"cpu",kernelFunc:function(e){let t,n,a,{inputs:r,backend:s,attrs:i}=e,{a:o,b:c,bias:l,preluActivationWeights:u}=r,{transposeA:d,transposeB:h,activation:p,leakyreluAlpha:f}=i,m=[];t=kA({inputs:{a:o,b:c},attrs:{transposeA:d,transposeB:h},backend:s}),l&&(n=$C({inputs:{a:t,b:l},backend:s}),m.push(t),t=n),p&&(a=vA(s,t,p,u,f),m.push(t),t=a);for(let g of m)s.disposeIntermediateTensorInfo(g);return t}},NA=oE(Xe,e=>Math.acos(e)),TA={kernelName:Xe,backendName:"cpu",kernelFunc:NA},OA=oE(Ze,e=>Math.acosh(e)),CA={kernelName:Ze,backendName:"cpu",kernelFunc:OA};var EA={kernelName:Je,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,a=t;RC(t,"addN");let r=a.map(e=>n.data.get(e.dataId).values),s=Ui(a[0].shape,a[0].dtype),i=s.values;for(let o=0;o<a.length;o++){let e=r[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};var _A={kernelName:Qe,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;RC(r,"all");let o=Nr.parseAxisParam(s,r.shape),c=o,l=Hf.getAxesPermutation(c,r.shape.length),u=r;null!=l&&(u=l_({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Hf.getInnerMostAxes(c.length,r.shape.length)),Hf.assertAxesAreInnerMostDims("all",c,u.shape.length);let[d,h]=Hf.computeOutAndReduceShapes(u.shape,c),p=Nr.sizeFromShape(h),f=Nr.makeZerosTypedArray(Nr.sizeFromShape(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){let e=b*p,t=m[e];for(let n=0;n<p;++n){let a=m[e+n];t=t&&a}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(d,u.dtype,f);if(i){let e=xA({inputs:{x:g},backend:n,attrs:{shape:Hf.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var AA={kernelName:$e,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;RC(r,"any");let o=Nr.parseAxisParam(s,r.shape),c=o,l=Hf.getAxesPermutation(c,r.shape.length),u=r;null!=l&&(u=l_({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Hf.getInnerMostAxes(c.length,r.shape.length)),Hf.assertAxesAreInnerMostDims("any",c,u.shape.length);let[d,h]=Hf.computeOutAndReduceShapes(u.shape,c),p=Nr.sizeFromShape(h),f=Nr.makeZerosTypedArray(Nr.sizeFromShape(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){let e=b*p,t=m[e];for(let n=0;n<p;++n){let a=m[e+n];t=t||a}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(d,u.dtype,f);if(i){let e=xA({inputs:{x:g},backend:n,attrs:{shape:Hf.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var RA={kernelName:et,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;RC(r,"argMax");let i=Nr.parseAxisParam(s,r.shape),o=Hf.getAxesPermutation(i,r.shape.length),c=r,l=[];null!=o&&(c=l_({inputs:{x:r},backend:n,attrs:{perm:o}}),l.push(c),i=Hf.getInnerMostAxes(i.length,c.shape.length)),i=[i[0]],Hf.assertAxesAreInnerMostDims("argMax",i,c.shape.length);let[u,d]=Hf.computeOutAndReduceShapes(c.shape,i),h=Nr.sizeFromShape(u),p=Nr.makeZerosTypedArray(h,"int32"),f=Nr.sizeFromShape(d),m=n.data.get(c.dataId).values;for(let g=0;g<p.length;++g){let e=g*f,t=m[e],n=0;for(let a=0;a<f;++a){let r=m[e+a];r>t&&(t=r,n=a)}p[g]=n}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u,"int32",p)}};var DA={kernelName:tt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;RC(r,"argMin");let i=Nr.parseAxisParam(s,r.shape),o=Hf.getAxesPermutation(i,r.shape.length),c=r,l=[];null!=o&&(c=l_({inputs:{x:r},backend:n,attrs:{perm:o}}),l.push(c),i=Hf.getInnerMostAxes(i.length,c.shape.length)),i=[i[0]],Hf.assertAxesAreInnerMostDims("argMin",i,c.shape.length);let[u,d]=Hf.computeOutAndReduceShapes(c.shape,i),h=Nr.sizeFromShape(u),p=Nr.makeZerosTypedArray(h,"int32"),f=Nr.sizeFromShape(d),m=n.data.get(c.dataId).values;for(let g=0;g<p.length;++g){let e=g*f,t=m[e],n=0;for(let a=0;a<f;++a){let r=m[e+a];r<t&&(t=r,n=a)}p[g]=n}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u,"int32",p)}},FA=oE(nt,e=>Math.asin(e)),MA={kernelName:nt,backendName:"cpu",kernelFunc:FA},jA=oE(at,e=>Math.asinh(e)),zA={kernelName:at,backendName:"cpu",kernelFunc:jA},LA=oE(rt,e=>Math.atan(e)),PA={kernelName:rt,backendName:"cpu",kernelFunc:LA},BA=LC((e,t)=>Math.atan2(e,t)),WA=ZC(it,BA),UA={kernelName:it,backendName:"cpu",kernelFunc:WA},VA=oE(st,e=>Math.atanh(e)),GA={kernelName:st,backendName:"cpu",kernelFunc:VA};function HA(e,t,n,a,r,s){let i=r.strideHeight,o=r.strideWidth,c=r.dilationHeight,l=r.dilationWidth,u=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=r.padInfo.top,p=r.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Ui(r.outShape,n),g=m.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],y=r.outShape[2]*r.outShape[3],v=r.outShape[3];for(let x=0;x<r.batchSize;++x){let t=x*b,n=x*a[0];for(let m=0;m<r.inChannels;++m)for(let b=0;b<r.outHeight;++b){let x=b*i-h,w=Math.max(0,x),k=Math.min(r.inHeight,u+x),I=t+b*y;for(let t=0;t<r.outWidth;++t){let i=t*o-p,u=Math.max(0,i),h=Math.min(r.inWidth,d+i),b=f,y=0,x=0;for(let t=w;t<k;t+=c){let r=n+t*a[1];for(let t=u;t<h;t+=l){let n=e[r+t*a[2]+m];"max"===s&&n>b?b=n:"avg"===s&&(y+=n,x++)}if(isNaN(b))break}g[I+t*v+m]="avg"===s?y/x:b}}}return m}function qA(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=Ui(a.outShape,"int32"),o=a.strideHeight,c=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,d=a.effectiveFilterHeight,h=a.effectiveFilterWidth,p=a.padInfo.top,f=a.padInfo.left,m=Ui(t,n,e);for(let g=0;g<a.batchSize;++g)for(let e=0;e<a.inChannels;++e)for(let t=0;t<a.outHeight;++t){let n=t*o-p,b=n;for(;b<0;)b+=l;let y=Math.min(a.inHeight,d+n);for(let o=0;o<a.outWidth;++o){let d=o*c-f,p=d;for(;p<0;)p+=u;let v=Math.min(a.inWidth,h+d),x=Number.NEGATIVE_INFINITY,w=-1;for(let t=b;t<y;t+=l){let i=t-n;for(let n=p;n<v;n+=u){let o=n-d,c=m.get(g,t,n,e);c>x&&(x=c,w=r?s?((g*a.inHeight+t)*a.inWidth+n)*a.inChannels+e:(t*a.inWidth+n)*a.inChannels+e:i*h+o)}}i.set(w,g,t,o,e)}}return i}function KA(e,t,n,a,r,s){let i=r.strideDepth,o=r.strideHeight,c=r.strideWidth,l=r.dilationDepth,u=r.dilationHeight,d=r.dilationWidth,h=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,b=r.padInfo.left,y="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Ui(r.outShape,n),x=v.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],I=r.outShape[3]*r.outShape[4],S=r.outShape[4];for(let N=0;N<r.batchSize;++N){let t=N*w,n=N*a[0];for(let v=0;v<r.inChannels;++v)for(let w=0;w<r.outDepth;++w){let N=w*i-m,T=N;for(;T<0;)T+=l;let O=Math.min(r.inDepth,h+N),C=t+w*k;for(let t=0;t<r.outHeight;++t){let i=t*o-g,h=i;for(;h<0;)h+=u;let m=Math.min(r.inHeight,p+i),w=C+t*I;for(let t=0;t<r.outWidth;++t){let i=t*c-b,o=i;for(;o<0;)o+=d;let p=Math.min(r.inWidth,f+i),g=w+t*S,k=y,I=0,N=0;for(let t=T;t<O;t+=l){let r=n+t*a[1];for(let t=h;t<m;t+=u){let n=r+t*a[2];for(let t=o;t<p;t+=d){let r=e[n+t*a[3]+v];if("max"===s&&r>k?k=r:"avg"===s&&(I+=r,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===s?I/Math.max(N,1):k}}}}return v}var XA={kernelName:ot,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;RC(r,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:c}=a;Nr.assert(Hf.eitherStridesOrDilationsAreOne(i,1),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides ".concat(i," and dilations '").concat(1,"'"));let l,u=Hf.computePool2DInfo(r.shape,s,i,1,o,c);if(1===u.filterWidth&&1===u.filterHeight&&Nr.arraysEqual(u.inShape,u.outShape))l=UC({inputs:{x:r},backend:n});else{let e=n.data.get(r.dataId).values,t=Nr.computeStrides(r.shape),a=HA(e,r.shape,r.dtype,t,u,"avg");l=n.makeTensorInfo(u.outShape,r.dtype,a.values)}return l}};var ZA={kernelName:lt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:c,dataFormat:l}=a;RC(r,"avgPool3d");let u=Hf.computePool3DInfo(r.shape,s,i,1,o,c,l),d=KA(n.data.get(r.dataId).values,r.shape,r.dtype,Nr.computeStrides(r.shape),u,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};var YA={kernelName:ut,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=a;RC([r,s],"avgPool3DGrad");let u=Hf.computePool3DInfo(s.shape,i,o,1,c,l),d=u.strideDepth,h=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,b=u.dilationDepth,y=u.dilationHeight,v=u.dilationWidth,x=u.effectiveFilterDepth,w=u.effectiveFilterHeight,k=u.effectiveFilterWidth,I=x-1-u.padInfo.front,S=k-1-u.padInfo.left,N=w-1-u.padInfo.top,T=Ui(s.shape,"float32"),O=1/(f*m*g),C=n.bufferSync(r);for(let E=0;E<u.batchSize;++E)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){let r=t-I,s=n-N,i=a-S,o=0;for(let t=0;t<x;t+=b){let n=(r+t)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=y){let a=(s+t)/h;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let t=0;t<k;t+=v){let r=(i+t)/p;r<0||r>=u.outWidth||Math.floor(r)!==r||(o+=C.get(E,n,a,r,e))}}}T.set(o*O,E,t,n,a,e)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}};var JA={kernelName:ct,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;RC([r,s],"avgPoolGrad");let{filterSize:o,strides:c,pad:l}=a,u=Hf.computePool2DInfo(i.shape,o,c,1,l),d=u.strideHeight,h=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,b=u.effectiveFilterHeight,y=u.effectiveFilterWidth,v=y-1-u.padInfo.left,x=b-1-u.padInfo.top,w=Ui(i.shape,"float32"),k=1/(p*f),I=n.data.get(r.dataId).values,S=Ui(r.shape,"float32",I);for(let N=0;N<u.batchSize;++N)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inHeight;++t)for(let n=0;n<u.inWidth;++n){let a=t-x,r=n-v,s=0;for(let t=0;t<b;t+=m){let n=(a+t)/d;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let t=0;t<y;t+=g){let a=(r+t)/h;a<0||a>=u.outWidth||Math.floor(a)!==a||(s+=S.get(N,n,a,e))}}w.set(s*k,N,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};var QA={kernelName:rn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,scale:s,offset:i,mean:o,variance:c}=t;Nr.assert(o.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Nr.assert(null==i||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Nr.assert(null==s||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),RC([r,o,c,s,i],"batchNorm");let{varianceEpsilon:l}=a;null==l&&(l=.001);let u=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(c.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,b=p.length,y=h.length,v=d.length,x=0,w=0,k=0,I=0;for(let S=0;S<u.length;++S)m[S]=f[x++]+(u[S]-d[w++])*p[k++]/Math.sqrt(h[I++]+l),x>=g&&(x=0),w>=v&&(w=0),k>=b&&(k=0),I>=y&&(I=0);return n.makeTensorInfo(r.shape,r.dtype,m)}};var $A={kernelName:ht,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;RC([r],"batchToSpaceND");let o=s.reduce((e,t)=>e*t),c=Hf.getReshaped(r.shape,s,o),l=Hf.getPermuted(c.length,s.length),u=Hf.getReshapedPermuted(r.shape,s,o),d=Hf.getSliceBeginCoords(i,s.length),h=Hf.getSliceSize(u,i,s.length),p=xA({inputs:{x:r},backend:n,attrs:{shape:c}}),f=l_({inputs:{x:p},backend:n,attrs:{perm:l}}),m=xA({inputs:{x:f},backend:n,attrs:{shape:u}}),g=D_({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};var eR={kernelName:pt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=tE(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,o)}};var tR={kernelName:gt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=Hf.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},nR=oE(vt,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),aR={kernelName:vt,backendName:"cpu",kernelFunc:nR},rR={kernelName:wt,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend,a=new Float32Array(Nr.sizeFromShape(t.shape)),r=n.data.get(t.dataId),s=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,o=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values;for(let l=0;l<o.length;l++){let e=o[l],t=c[l];a[l]=Math.hypot(e,t)}return n.makeOutput(a,t.shape,"float32")}};function sR(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var iR={kernelName:hn,backendName:"cpu",kernelFunc:sR};function oR(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=Nr.parseAxisParam(r,t[0].shape)[0],i=t.map(e=>e.shape);Hf.assertParamsConsistent(i,s);let o=Hf.computeOutShape(t.map(e=>e.shape),s);if(0===Nr.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let c=t.filter(e=>Nr.sizeFromShape(e.shape)>0);if(1===c.length)return UC({inputs:{x:c[0]},backend:n});if("complex64"===c[0].dtype){let e=c.map(e=>GC({inputs:{input:e},backend:n})),t=c.map(e=>sR({inputs:{input:e},backend:n})),a=oR({inputs:e,backend:n,attrs:{axis:s}}),r=oR({inputs:t,backend:n,attrs:{axis:s}}),i=PC({inputs:{real:a,imag:r},backend:n});return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),t.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r),i}let l=c.map(e=>{let t=[-1,Nr.sizeFromShape(e.shape.slice(s))];return xA({inputs:{x:e},backend:n,attrs:{shape:t}})}),u=l.map(e=>({vals:n.data.get(e.dataId).values,shape:e.shape}));o=Hf.computeOutShape(l.map(e=>e.shape),1);let d=1===l[0].shape[0],h=hE(u,o,t[0].dtype,d),p=Hf.computeOutShape(c.map(e=>e.shape),s),f=n.makeTensorInfo(p,t[0].dtype,h);return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}var cR={kernelName:kt,backendName:"cpu",kernelFunc:oR};function lR(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:c,dilations:l,dimRoundingMode:u}=a;RC([r,s],"conv2d");let d=Hf.convertConv2DDataFormat(c),h=Hf.computeConv2DInfo(r.shape,s.shape,i,l,o,u,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,b=h.padInfo.left,y=h.padInfo.top,v="channelsLast"===h.dataFormat,x=new rs(h.outShape,r.dtype),w=Nr.computeStrides(r.shape),k=Nr.computeStrides(s.shape),I=w[0],S=v?w[1]:w[2],N=v?w[2]:1,T=v?1:w[1],O=x.strides[0],C=v?x.strides[1]:x.strides[2],E=v?x.strides[2]:1,_=v?1:x.strides[1],A=n.data.get(r.dataId).values,R=n.data.get(s.dataId).values,D=x.values;for(let F=0;F<h.batchSize;++F){let e=F*I,t=F*O;for(let n=0;n<h.outHeight;++n){let a=t+n*C,r=n*h.strideHeight-y;for(let t=0;t<p;++t){let n=r+t*m;if(n<0||n>=h.inHeight)continue;let s=t*k[0],i=e+n*S;for(let e=0;e<h.outWidth;++e){let t=a+e*E,n=e*h.strideWidth-b;for(let e=0;e<f;++e){let a=n+e*g;if(a<0||a>=h.inWidth)continue;let r=i+a*N,o=s+e*k[1];for(let e=0;e<h.inChannels;++e){let n=A[r+e*T];for(let e=0;e<h.outChannels;++e)D[t+e*_]+=n*R[o+e];o+=h.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,D)}var uR={kernelName:It,backendName:"cpu",kernelFunc:lR};var dR={kernelName:St,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:c,dimRoundingMode:l,filterShape:u}=a;RC([r,s],"conv2dBackpropFilter");let d=Hf.convertConv2DDataFormat(c),h=Hf.computeConv2DInfo(r.shape,u,i,1,o,l,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,b="channelsLast"===h.dataFormat,y=new rs(h.filterShape,"float32"),v=h.padInfo.left,x=h.padInfo.top,w=n.data.get(r.dataId).values,k=n.data.get(s.dataId).values,I=new rs(r.shape,r.dtype,w),S=new rs(s.shape,s.dtype,k);for(let N=0;N<m;++N){let e=Math.max(0,Math.ceil((x-N)/p)),t=Math.min(h.outHeight,(h.inHeight+x-N)/p);for(let n=0;n<g;++n){let a=Math.max(0,Math.ceil((v-n)/f)),r=Math.min(h.outWidth,(h.inWidth+v-n)/f);for(let s=0;s<h.inChannels;++s)for(let i=0;i<h.outChannels;++i){let o=0;for(let c=0;c<h.batchSize;++c)for(let l=e;l<t;++l){let e=N+l*p-x;for(let t=a;t<r;++t){let a=n+t*f-v;o+=b?I.get(c,e,a,s)*S.get(c,l,t,i):I.get(c,s,e,a)*S.get(c,i,l,t)}}y.set(o,N,n,s,i)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};var hR={kernelName:Nt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:c,dataFormat:l,dimRoundingMode:u}=a;RC([r,s],"conv2dBackpropInput");let d=Nr.computeStrides(s.shape),h=Nr.computeStrides(r.shape),p=Hf.convertConv2DDataFormat(l),f=Hf.computeConv2DInfo(i,s.shape,o,1,c,u,!1,p),m=new rs(f.inShape,"float32"),g=m.values,b=n.data.get(r.dataId).values,y=n.data.get(s.dataId).values,[v,x,w]=d,{batchSize:k,filterHeight:I,filterWidth:S,inChannels:N,inHeight:T,inWidth:O,outChannels:C,outHeight:E,outWidth:_,strideHeight:A,strideWidth:R}=f;p=f.dataFormat;let D=I-1-f.padInfo.top,F=S-1-f.padInfo.left,M="channelsLast"===p,j=m.strides[0],z=M?m.strides[1]:m.strides[2],L=M?m.strides[2]:1,P=M?1:m.strides[1],B=h[0],W=M?h[1]:h[2],U=M?h[2]:1,V=M?1:h[1];for(let G=0;G<k;++G)for(let e=0;e<N;++e)for(let t=0;t<T;++t){let n=t-D,a=Math.max(0,Math.ceil(n/A)),r=Math.min(E,(I+n)/A);for(let s=0;s<O;++s){let i=s-F,o=Math.max(0,Math.ceil(i/R)),c=Math.min(_,(S+i)/R),l=0;for(let t=a;t<r;++t){let a=t*A-n;for(let n=o;n<c;++n){let r=B*G+W*t+U*n,s=v*(I-1-a)+x*(S-1-(n*R-i))+w*e;for(let e=0;e<C;++e){l+=b[r+V*e]*y[s+e]}}}g[j*G+z*t+L*s+P*e]=l}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};var pR={kernelName:Tt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:c}=a;RC([r,s],"conv3d");let l=Hf.computeConv3DInfo(r.shape,s.shape,i,c,o),{filterDepth:u,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=l,b=g.front,y=g.left,v=g.top,x=new rs(l.outShape,r.dtype),w=n.data.get(r.dataId).values,k=n.data.get(s.dataId).values,I=x.values,S=Nr.computeStrides(r.shape),N=Nr.computeStrides(s.shape);for(let T=0;T<l.batchSize;++T){let e=T*S[0],t=T*x.strides[0];for(let n=0;n<l.outDepth;++n){let a=t+n*x.strides[1],r=n*l.strideDepth-b;for(let t=0;t<u;++t){let n=r+t*p;if(n<0||n>=l.inDepth)continue;let s=t*N[0],i=e+n*S[1];for(let e=0;e<l.outHeight;++e){let t=a+e*x.strides[2],n=e*l.strideHeight-v;for(let e=0;e<d;++e){let a=n+e*f;if(a<0||a>=l.inHeight)continue;let r=s+e*N[1],o=i+a*S[2];for(let e=0;e<l.outWidth;++e){let n=t+e*l.outChannels,a=e*l.strideWidth-y;for(let e=0;e<h;++e){let t=a+e*m;if(t<0||t>=l.inWidth)continue;let s=r+e*N[2],i=o+t*l.inChannels,c=s;for(let e=0;e<l.inChannels;++e){let t=w[i+e];for(let e=0;e<l.outChannels;++e)I[n+e]+=t*k[c+e];c+=l.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};var fR={kernelName:Ot,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:c}=a;RC([r,s],"conv3dBackpropFilterV2");let l=Nr.computeStrides(r.shape),u=Nr.computeStrides(s.shape),d=Hf.computeConv3DInfo(r.shape,c,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,b=d.filterWidth,y=new rs(d.filterShape,"float32"),v=y.values,[x,w,k,I]=y.strides,S=n.data.get(s.dataId).values,[N,T,O,C]=u,E=n.data.get(r.dataId).values,[_,A,R,D]=l,F=d.padInfo.front,M=d.padInfo.left,j=d.padInfo.top;for(let z=0;z<m;++z){let e=Math.max(0,Math.ceil((F-z)/h)),t=Math.min(d.outDepth,(d.inDepth+F-z)/h),n=z*x;for(let a=0;a<g;++a){let r=Math.max(0,Math.ceil((j-a)/p)),s=Math.min(d.outHeight,(d.inHeight+j-a)/p),i=a*w+n;for(let n=0;n<b;++n){let o=Math.max(0,Math.ceil((M-n)/f)),c=Math.min(d.outWidth,(d.inWidth+M-n)/f),l=n*k+i;for(let i=0;i<d.inChannels;++i){let u=i*I+l;for(let l=0;l<d.outChannels;++l){let m=0;for(let u=0;u<d.batchSize;++u){let d=u*_,g=u*N;for(let u=e;u<t;++u){let e=(z+u*h-F)*A+d,t=u*T+g;for(let u=r;u<s;++u){let r=(a+u*p-j)*R+e,s=u*O+t;for(let e=o;e<c;++e){let t=e*C+s;m+=E[(n+e*f-M)*D+r+i]*S[t+l]}}}}v[u+l]=m}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};var mR={kernelName:Ct,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:c}=a;RC([r],"conv3dBackpropInputV2");let l=Nr.computeStrides(r.shape),u=Nr.computeStrides(s.shape),d=Hf.computeConv3DInfo(c,s.shape,o,1,i),h=new rs(d.inShape,"float32"),p=h.values,[f,m,g,b]=h.strides,y=n.data.get(r.dataId).values,[v,x,w,k]=l,I=n.data.get(s.dataId).values,[S,N,T,O]=u,{batchSize:C,filterDepth:E,filterHeight:_,filterWidth:A,inChannels:R,inDepth:D,inHeight:F,inWidth:M,outChannels:j,outDepth:z,outHeight:L,outWidth:P,strideDepth:B,strideHeight:W,strideWidth:U}=d,V=E-1-d.padInfo.front,G=_-1-d.padInfo.top,H=A-1-d.padInfo.left;for(let q=0;q<C;++q)for(let e=0;e<R;++e)for(let t=0;t<D;++t){let n=t-V,a=Math.max(0,Math.ceil(n/B)),r=Math.min(z,(E+n)/B);for(let s=0;s<F;++s){let i=s-G,o=Math.max(0,Math.ceil(i/W)),c=Math.min(L,(_+i)/W);for(let l=0;l<M;++l){let u=l-H,d=Math.max(0,Math.ceil(u/U)),h=Math.min(P,(A+u)/U),C=0;for(let t=a;t<r;++t){let a=t*B-n;for(let n=o;n<c;++n){let r=n*W-i;for(let s=d;s<h;++s){let i=v*q+x*t+w*n+k*s,o=S*(E-1-a)+N*(_-1-r)+T*(A-1-(s*U-u))+O*e;for(let e=0;e<j;++e){C+=y[i+e]*I[o+e]}}}}p[f*q+m*t+g*s+b*l+e]=C}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},gR=oE(Et,e=>Math.cos(e)),bR={kernelName:Et,backendName:"cpu",kernelFunc:gR},yR=oE(_t,e=>Math.cosh(e)),vR={kernelName:_t,backendName:"cpu",kernelFunc:yR};var xR={kernelName:Dt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:c,extrapolationValue:l}=a,[u,d,h,p]=r.shape,f=s.shape[0],[m,g]=o,b=Ui([f,m,g,p],"float32"),y=n.data.get(s.dataId).values,v=n.data.get(i.dataId).values,x=n.data.get(r.dataId).values,w=Nr.computeStrides(r.shape),k=Nr.computeStrides(b.shape);for(let I=0;I<f;I++){let e=4*I,t=y[e],n=y[e+1],a=y[e+2],r=y[e+3],s=v[I];if(s>=u)continue;let i=m>1?(a-t)*(d-1)/(m-1):0,o=g>1?(r-n)*(h-1)/(g-1):0;for(let u=0;u<m;u++){let e=m>1?t*(d-1)+u*i:.5*(t+a)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){let n=e+t*k[2]+u*k[1]+I*k[0];b.values[n]=l}else if("bilinear"===c){let t=Math.floor(e),a=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){let c=g>1?n*(h-1)+e*o:.5*(n+r)*(h-1);if(c<0||c>h-1){for(let t=0;t<p;t++){let n=t+e*k[2]+u*k[1]+I*k[0];b.values[n]=l}continue}let d=Math.floor(c),f=Math.ceil(c),m=c-d;for(let n=0;n<p;n++){let r=n+d*w[2]+t*w[1]+s*w[0],o=x[r];r=n+f*w[2]+t*w[1]+s*w[0];let c=x[r];r=n+d*w[2]+a*w[1]+s*w[0];let l=x[r];r=n+f*w[2]+a*w[1]+s*w[0];let h=o+(c-o)*m,p=l+(x[r]-l)*m;r=n+e*k[2]+u*k[1]+I*k[0],b.values[r]=h+(p-h)*i}}}else for(let t=0;t<g;++t){let a=g>1?n*(h-1)+t*o:.5*(n+r)*(h-1);if(a<0||a>h-1){for(let e=0;e<p;e++){let n=e+t*k[2]+u*k[1]+I*k[0];b.values[n]=l}continue}let i=Math.round(a),c=Math.round(e);for(let e=0;e<p;e++){let n=e+i*w[2]+c*w[1]+s*w[0],a=e+t*k[2]+u*k[1]+I*k[0];b.values[a]=x[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};var wR={kernelName:At,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;RC(r,"cumprod");let c=Hf.getAxesPermutation([s],r.shape.length),l=r;null!=c&&(l=l_({inputs:{x:r},backend:n,attrs:{perm:c}}));let u=Hf.getInnerMostAxes(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most axis=".concat(l.shape.length-1," but got axis=").concat(u));let d=ys(l.dtype,"int32"),h=Nr.makeOnesTypedArray(Nr.sizeFromShape(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){let t=m(b,e);if(0===e)h[t]=i?1:p[t];else{let n=m(b,e-1);h[t]=i?p[n]*h[n]:p[t]*h[n]}}let g=n.makeTensorInfo(l.shape,d,h);if(null!=c){let e=l_({inputs:{x:g},backend:n,attrs:{perm:Hf.getUndoAxesPermutation(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};var kR={kernelName:Rt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;RC(r,"cumsum");let c=Hf.getAxesPermutation([s],r.shape.length),l=r;null!=c&&(l=l_({inputs:{x:r},backend:n,attrs:{perm:c}}));let u=Hf.getInnerMostAxes(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most axis=".concat(l.shape.length-1," but got axis=").concat(u));let d=ys(l.dtype,"int32"),h=Nr.makeZerosTypedArray(Nr.sizeFromShape(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){let t=m(b,e);if(0===e)h[t]=i?0:p[t];else{let n=m(b,e-1);h[t]=i?p[n]+h[n]:p[t]+h[n]}}let g=n.makeTensorInfo(l.shape,d,h);if(null!=c){let e=l_({inputs:{x:g},backend:n,attrs:{perm:Hf.getUndoAxesPermutation(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};var IR={kernelName:Ft,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(1===r.shape.length){let e=tE(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,e)}if(2===r.shape.length){let e=nE(n.bufferSync(r),n.bufferSync(s),i,o);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank".concat(r.shape.length,"."))}};var SR={kernelName:Mt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a;Nr.assert("NHWC"===i,()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(i));let o=r.shape[0],c=r.shape[1],l=r.shape[2],u=r.shape[3],d=c*s,h=l*s,p=u/(s*s),f=n.data.get(r.dataId).values,m=new Float32Array(o*d*h*p),g=0;for(let b=0;b<o;++b)for(let e=0;e<d;++e){let t=Math.floor(e/s),n=e%s;for(let e=0;e<h;++e){let a=Math.floor(e/s),r=(n*s+e%s)*p;for(let e=0;e<p;++e){let n=e+r+u*(a+l*(t+c*b));m[g++]=f[n]}}}return n.makeTensorInfo([o,d,h,p],r.dtype,m)}};function NR(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:c,dimRoundingMode:l}=a;RC([r,s],"depthwiseConv2DNative");let u=Nr.computeStrides(r.shape),d=Nr.computeStrides(s.shape),h=c;null==h&&(h=[1,1]),Nr.assert(Hf.eitherStridesOrDilationsAreOne(i,h),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ".concat(i," and dilations '").concat(h,"'"));let p=Hf.computeConv2DInfo(r.shape,s.shape,i,h,o,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=p,v=y.left,x=y.top,w=p.outChannels/p.inChannels,k=new rs(p.outShape,r.dtype),I=n.data.get(r.dataId).values,S=n.data.get(s.dataId).values,N=k.values;for(let T=0;T<p.batchSize;++T){let e=T*u[0],t=T*k.strides[0];for(let n=0;n<p.outHeight;++n){let a=t+n*k.strides[1],r=n*p.strideHeight-x;for(let t=0;t<f;++t){let n=r+t*g;if(n<0||n>=p.inHeight)continue;let s=t*d[0],i=e+n*u[1];for(let e=0;e<p.outWidth;++e){let t=a+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){let a=n+e*b;if(a<0||a>=p.inWidth)continue;let r=s+e*d[1],o=i+a*p.inChannels,c=t,l=r;for(let e=0;e<p.inChannels;++e){let t=I[o+e];for(let e=0;e<w;++e)N[c+e]+=t*S[l+e];c+=w,l+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var TR={kernelName:jt,backendName:"cpu",kernelFunc:NR};var OR={kernelName:zt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,filterShape:u}=a;RC([r,s],"depthwiseConv2dNativeBackpropFilter");let d=Hf.computeConv2DInfo(r.shape,u,i,o,c,l,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new rs(d.filterShape,"float32"),b=d.padInfo.left,y=d.padInfo.top,v=d.outChannels/d.inChannels,x=n.data.get(r.dataId).values,w=new rs(r.shape,r.dtype,x),k=n.data.get(s.dataId).values,I=new rs(s.shape,s.dtype,k);for(let S=0;S<f;++S){let e=Math.max(0,Math.ceil((y-S)/h)),t=Math.min(d.outHeight,(d.inHeight+y-S)/h);for(let n=0;n<m;++n){let a=Math.max(0,Math.ceil((b-n)/p)),r=Math.min(d.outWidth,(d.inWidth+b-n)/p);for(let s=0;s<d.outChannels;++s){let i=Math.trunc(s/v),o=s%v,c=0;for(let l=0;l<d.batchSize;++l)for(let o=e;o<t;++o){let e=S+o*h-y;for(let t=a;t<r;++t){let a=n+t*p-b;c+=w.get(l,e,a,i)*I.get(l,o,t,s)}}g.set(c,S,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};var CR={kernelName:Lt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,inputShape:u}=a;RC([r,s],"depthwiseConv2DNativeBackpropInput");let d=Nr.computeStrides(r.shape),h=Nr.computeStrides(s.shape),p=Hf.computeConv2DInfo(u,s.shape,i,o,c,l,!0),f=new rs(p.inShape,"float32"),m=f.values,[g,b,y]=f.strides,v=n.data.get(r.dataId).values,[x,w,k]=d,I=n.data.get(s.dataId).values,[S,N,T]=h,{batchSize:O,filterHeight:C,filterWidth:E,inChannels:_,inHeight:A,inWidth:R,outChannels:D,outHeight:F,outWidth:M,strideHeight:j,strideWidth:z}=p,L=C-1-p.padInfo.top,P=E-1-p.padInfo.left,B=D/_;for(let W=0;W<O;++W)for(let e=0;e<_;++e)for(let t=0;t<A;++t){let n=t-L,a=Math.max(0,Math.ceil(n/j)),r=Math.min(F,(C+n)/j);for(let s=0;s<R;++s){let i=s-P,o=Math.max(0,Math.ceil(i/z)),c=Math.min(M,(E+i)/z),l=0;for(let t=a;t<r;++t){let a=t*j-n;for(let n=o;n<c;++n){let r=x*W+w*t+k*n,s=S*(C-1-a)+N*(E-1-(n*z-i))+T*e;for(let t=0;t<B;++t){l+=v[r+(e*B+t)]*I[s+t]}}}m[g*W+b*t+y*s+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};var ER={kernelName:Pt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:a}=t,r=Nr.sizeFromShape(a.shape),s=n.data.get(a.dataId).values,i=Ui([r,r],a.dtype),o=i.values;for(let l=0;l<s.length;l++)o[l*r+l]=s[l];let c=[...a.shape,...a.shape];return n.makeTensorInfo(c,i.dtype,i.values)}},_R={kernelName:Bt,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:c}=a,l=n,u=l.data.get(r.dataId).values,d=r.shape.length,h=l.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:b,outHeight:y,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:I,filterWidth:S,dilationHeight:N,dilationWidth:T,outShape:O}=Hf.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",c),C=Nr.sizeFromShape(O),E=O.length,_=Nr.getArrayFromDType(r.dtype,C);for(let A=0;A<f;++A)for(let e=0;e<y;++e){let t=e*w-x.top;for(let n=0;n<v;++n){let a=n*k-x.left;for(let i=0;i<b;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<I;++e){let n=t+e*N;if(n>=0&&n<m)for(let t=0;t<S;++t){let c=a+t*T;if(c>=0&&c<g){let a=Nr.locToIndex([A,n,c,i],d,Nr.computeStrides(r.shape)),l=Nr.locToIndex([e,t,i],p,Nr.computeStrides(s.shape)),f=u[a]+h[l];f>o&&(o=f)}}}_[Nr.locToIndex([A,e,n,i],E,Nr.computeStrides(O))]=o}}}return{dataId:l.write(Nr.toTypedArray(_,r.dtype),O,r.dtype),shape:O,dtype:r.dtype}}},AR={kernelName:Ut,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:c,dilations:l}=a,u=n,d=Nr.toNestedArray(r.shape,u.data.get(r.dataId).values),h=Nr.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:T}=Hf.computeDilation2DInfo(r.shape,s.shape,o,c,"NHWC",l);Nr.assert(i.rank===T.length,()=>"Error in ".concat(Ut,", dy must have the same rank as output ").concat(T.length,", but got ").concat(i.rank));let O=Nr.toNestedArray(T,u.data.get(i.dataId).values),C=Nr.makeZerosNestedTypedArray(s.shape,s.dtype);for(let E=0;E<p;++E)for(let e=0;e<b;++e){let t=e*x-v.top;for(let n=0;n<y;++n){let a=n*w-v.left;for(let r=0;r<g;++r){let s=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<k;++e){let n=t+e*S;if(n>=0&&n<f)for(let t=0;t<I;++t){let c=a+t*N;if(c>=0&&c<m){let a=d[E][n][c][r]+h[e][t][r];a>s&&(s=a,i=e,o=t)}}}C[i][o][r]+=O[E][e][n][r]}}}return{dataId:u.write(Nr.toTypedArray(C,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},RR={kernelName:Wt,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:c,dilations:l}=a,u=n,d=Nr.toNestedArray(r.shape,u.data.get(r.dataId).values),h=Nr.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:T}=Hf.computeDilation2DInfo(r.shape,s.shape,o,c,"NHWC",l);Nr.assert(i.rank===T.length,()=>"Error in ".concat(Wt,", dy must have the same rank as output ").concat(T.length,", but got ").concat(i.rank));let O=Nr.toNestedArray(T,u.data.get(i.dataId).values),C=Nr.makeZerosNestedTypedArray(r.shape,r.dtype);for(let E=0;E<p;++E)for(let e=0;e<b;++e){let t=e*x-v.top;for(let n=0;n<y;++n){let a=n*w-v.left;for(let r=0;r<g;++r){let s=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=a<0?0:a;for(let e=0;e<k;++e){let n=t+e*S;if(n>=0&&n<f)for(let t=0;t<I;++t){let c=a+t*N;if(c>=0&&c<m){let a=d[E][n][c][r]+h[e][t][r];a>s&&(s=a,i=n,o=c)}}}C[E][i][o][r]+=O[E][e][n][r]}}}return{dataId:u.write(Nr.toTypedArray(C,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};var DR={kernelName:Vt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:s,options:i}=a,{contextOptions:o,imageOptions:c}=i||{},l=(null==c?void 0:c.alpha)||1,u=(null==o?void 0:o.contextType)||"2d";if("2d"!==u)throw new Error("Context type ".concat(o.contextType," is not supported by the CPU backend."));let d=s.getContext(u,(null==o?void 0:o.contextAttributes)||{});if(null==d)throw new Error("Could not get the context with ".concat(u," type."));let[h,p]=r.shape.slice(0,2),f=2===r.shape.length?1:r.shape[2],m=n.data.get(r.dataId).values,g="float32"===r.dtype?255:1,b=new Uint8ClampedArray(p*h*4);for(let v=0;v<h*p;++v){let e=[0,0,0,255*l];for(let n=0;n<f;n++){let t=m[v*f+n];if("float32"===r.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===r.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ".concat(t,"."));1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}let t=4*v;b[t+0]=Math.round(e[0]),b[t+1]=Math.round(e[1]),b[t+2]=Math.round(e[2]),b[t+3]=Math.round(e[3])}s.width=p,s.height=h;let y=new ImageData(b,p,h);return d.putImageData(y,0,0),r}};function FR(e){let t,{inputs:n,backend:a,attrs:r}=e,{x:s}=n,{axis:i,keepDims:o}=r;RC(s,"sum"),t="bool"===s.dtype?KC({inputs:{x:s},backend:a,attrs:{dtype:"int32"}}):UC({inputs:{x:s},backend:a});let c=t.shape.length,l=Nr.parseAxisParam(i,t.shape),u=Hf.getAxesPermutation(l,c),d=l,h=t;null!=u&&(h=l_({inputs:{x:t},backend:a,attrs:{perm:u}}),d=Hf.getInnerMostAxes(d.length,c)),Hf.assertAxesAreInnerMostDims("sum",d,h.shape.length);let[p,f]=Hf.computeOutAndReduceShapes(h.shape,d),m=WC(a,p,Hf.upcastType(h.dtype,"int32")),g=Nr.sizeFromShape(f),b=a.data.get(m.dataId).values,y=a.data.get(h.dataId).values;for(let v=0;v<b.length;++v){let e=v*g,t=0;for(let n=0;n<g;++n)t+=y[e+n];b[v]=t}if(o){let e=m;m=xA({inputs:{x:m},backend:a,attrs:{shape:Hf.expandShapeToKeepDim(m.shape,l)}}),a.disposeIntermediateTensorInfo(e)}return a.disposeIntermediateTensorInfo(t),null!=u&&a.disposeIntermediateTensorInfo(h),m}var MR={kernelName:Ra,backendName:"cpu",kernelFunc:FR};var jR={kernelName:Ht,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:c}=Hf.decodeEinsumEquation(r,s.length);Hf.checkEinsumDimSizes(i.length,c,s);let{path:l,steps:u}=Hf.getEinsumComputePath(o,c),d=u.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let e of u[m]){let t,{permutationIndices:a,expandDims:r}=Hf.getEinsumPermutation(p,c[e]);Hf.isIdentityPermutation(a)?t=s[e]:(t=l_({inputs:{x:s[e]},backend:n,attrs:{perm:a}}),f.push(t));let i=t.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Nr.arraysEqual(t.shape,i)||(t=xA({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===h?h=t:(h=t_({inputs:{a:t,b:h},backend:n}),f.push(h))}m<d-1&&(l[m]>=0&&(h=FR({inputs:{x:h},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}};var zR={kernelName:Kt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t;RC([a,r],"eluGrad");let s=new Float32Array(Nr.sizeFromShape(r.shape)),i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values;for(let c=0;c<i.length;++c){let e=i[c];s[c]=e>=0?o[c]:o[c]*(e+1)}return n.makeTensorInfo(r.shape,"float32",s)}},LR=Hf.ERF_P,PR=Hf.ERF_A1,BR=Hf.ERF_A2,WR=Hf.ERF_A3,UR=Hf.ERF_A4,VR=Hf.ERF_A5,GR=oE(Xt,e=>{let t=Math.sign(e),n=Math.abs(e),a=1/(1+LR*n);return t*(1-((((VR*a+UR)*a+WR)*a+BR)*a+PR)*a*Math.exp(-n*n))}),HR={kernelName:Xt,backendName:"cpu",kernelFunc:GR};function qR(e){let{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:s}=a,i=r.shape.length,o=r.shape.slice(),c=s;return s<0&&(Nr.assert(-(i+1)<=s,()=>"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]")),c=i+s+1),o.splice(c,0,1),xA({inputs:{x:r},backend:n,attrs:{shape:o}})}var KR={kernelName:Jt,backendName:"cpu",kernelFunc:qR},XR=LC((e,t)=>e/t),ZR=ZC(Gt,XR),YR={kernelName:Gt,backendName:"cpu",kernelFunc:ZR};function JR(e,t,n){let a=e.shape,r=a[0],s=a[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,c=i.complexTensorInfos.imag,l=[r,s],u=Nr.sizeFromShape(l),d=Nr.getTypedArrayFromDType("float32",u),h=Nr.getTypedArrayFromDType("float32",u);for(let g=0;g<r;g++){let e=D_({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),a=D_({inputs:{x:c},backend:n,attrs:{begin:[g,0],size:[1,s]}}),r=PC({inputs:{real:e,imag:a},backend:n}),{real:i,imag:l}=QR(r,t,n),u=Hf.mergeRealAndImagArrays(i,l);for(let t=0;t<s;t++){let e=Hf.getComplexWithIndex(u,t);d[g*s+t]=e.real,h[g*s+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r)}let p=n.makeTensorInfo(l,"float32",d),f=n.makeTensorInfo(l,"float32",h),m=PC({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function QR(e,t,n){let a=Nr.sizeFromShape(e.shape),r=n.data.get(e.dataId),s=n.data.get(r.complexTensorInfos.real.dataId).values,i=n.data.get(r.complexTensorInfos.imag.dataId).values;if(function(e){return 0===(e&e-1)}(a)){let r=function e(t,n,a,r,s){if(1===a)return{real:t,imag:n};let i=Hf.mergeRealAndImagArrays(t,n),o=a/2,c=Hf.complexWithEvenIndex(i),l=c.real,u=c.imag,d=[l.length],h=s.makeTensorInfo(d,"float32",l),p=s.makeTensorInfo(d,"float32",u),f=PC({inputs:{real:h,imag:p},backend:s}),m=Hf.complexWithOddIndex(i),g=m.real,b=m.imag,y=[g.length],v=s.makeTensorInfo(y,"float32",g),x=s.makeTensorInfo(y,"float32",b),w=PC({inputs:{real:v,imag:x},backend:s}),k=e(l,u,o,r,s),I=k.real,S=k.imag,N=[I.length],T=s.makeTensorInfo(N,"float32",I),O=s.makeTensorInfo(N,"float32",S),C=PC({inputs:{real:T,imag:O},backend:s}),E=e(g,b,o,r,s),_=E.real,A=E.imag,R=[_.length],D=s.makeTensorInfo(R,"float32",_),F=s.makeTensorInfo(R,"float32",A),M=PC({inputs:{real:D,imag:F},backend:s}),j=Hf.exponents(a,r),z=[j.real.length],L=s.makeTensorInfo(z,"float32",j.real),P=s.makeTensorInfo(z,"float32",j.imag),B=PC({inputs:{real:L,imag:P},backend:s}),W=t_({inputs:{a:B,b:M},backend:s}),U=$C({inputs:{a:C,b:W},backend:s}),V=eA({inputs:{a:C,b:W},backend:s}),G=GC({inputs:{input:U},backend:s}),H=GC({inputs:{input:V},backend:s}),q=sR({inputs:{input:U},backend:s}),K=sR({inputs:{input:V},backend:s}),X=oR({inputs:[G,H],backend:s,attrs:{axis:0}}),Z=oR({inputs:[q,K],backend:s,attrs:{axis:0}}),Y=s.data.get(X.dataId).values,J=s.data.get(Z.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(X),s.disposeIntermediateTensorInfo(Z),{real:Y,imag:J}}(s,i,a,t,n),o=[e.shape[0],e.shape[1]];if(t){let e=n.makeTensorInfo(o,"float32",r.real),t=n.makeTensorInfo(o,"float32",r.imag),s=n.makeTensorInfo([],"float32",Nr.createScalarValue(a,"float32")),i=UC({inputs:{x:s},backend:n}),c=YR.kernelFunc({inputs:{a:e,b:s},backend:n}),l=YR.kernelFunc({inputs:{a:t,b:i},backend:n}),u=n.data.get(c.dataId).values,d=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),{real:u,imag:d}}return r}{let e=function(e,t,n){let a=new Float32Array(2*t);for(let r=0;r<t;r++){let s=0,i=0;for(let a=0;a<t;a++){let o=Hf.exponent(r*a,t,n),c=Hf.getComplexWithIndex(e,a);s+=c.real*o.real-c.imag*o.imag,i+=c.real*o.imag+c.imag*o.real}n&&(s/=t,i/=t),Hf.assignToTypedArray(a,s,i,r)}return a}(Hf.mergeRealAndImagArrays(s,i),a,t);return Hf.splitRealAndImagArrays(e)}}var $R={kernelName:$t,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:a}=t,r=Nr.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],i=xA({inputs:{x:a},backend:n,attrs:{shape:[r/s,s]}}),o=JR(i,!1,n),c=xA({inputs:{x:o},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),c}};function eD(e){let{backend:t,attrs:n}=e,{shape:a,value:r,dtype:s}=n,i=s||Nr.inferDtype(r),o=Nr.getArrayFromDType(i,Nr.sizeFromShape(a));return function(e,t,n){e.fill(t)}(o,r),t.makeTensorInfo(a,i,o)}var tD={kernelName:en,backendName:"cpu",kernelFunc:eD};var nD={kernelName:tn,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e,{image:r}=t,s=a,i=Nr.getTypedArrayFromDType(r.dtype,Nr.sizeFromShape(r.shape)),[o,c,l,u]=r.shape,d=s.data.get(r.dataId).values;for(let h=0;h<o;h++){let e=h*l*c*u;for(let t=0;t<c;t++){let n=t*(l*u);for(let t=0;t<l;t++){let a=t*u;for(let r=0;r<u;r++){let s=Math.round(l-t-1),o=e+n+a+r,c=d[o];if(s>=0&&s<l){c=d[e+n+s*u+r]}i[o]=c}}}}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};var aD={kernelName:ur,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a,m=lR({inputs:{x:r,filter:s},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(i){let e=m;if("NCHW"===u&&1===i.shape.length&&1!==i.shape[0]){let e=xA({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=$C({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=$C({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){let e=m;if("NCHW"===u&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){let e=xA({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=vA(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=vA(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};var rD={kernelName:dr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=a,m=NR({inputs:{x:r,filter:s},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(i){let e=m;m=$C({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){let e=m;m=vA(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};var sD={kernelName:on,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=Nr.sizeFromShape(a.shape),i=r.shape,o=i[i.length-1],[c,l,u,d]=Hf.prepareAndValidate(a,r);if(0===l)return n.makeTensorInfo(c,a.dtype,[]);let h=CE(n.data.get(r.dataId).values,n.bufferSync(a),a.dtype,l,o,u,d,a.shape,s);return n.makeTensorInfo(c,a.dtype,h.values)}};var iD={kernelName:sn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a;RC([r,s],"gatherV2");let c=Nr.parseAxisParam(i,r.shape)[0],l=n.data.get(s.dataId).values,u=r.shape[c];for(let v=0;v<l.length;++v){let e=l[v];Nr.assert(e<=u-1&&e>=0,()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(u-1,"]"))}let d=o;null==o&&(d=0);let h=Nr.sizeFromShape(s.shape),p=Hf.segment_util.collectGatherOpShapeInfo(r,s,c,d),f=xA({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=xA({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],b=n.bufferSync(m),y=EE(n.bufferSync(f),b,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}};var oD={kernelName:dn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:a}=t,r=Nr.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],i=xA({inputs:{x:a},backend:n,attrs:{shape:[r/s,s]}}),o=JR(i,!0,n),c=xA({inputs:{x:o},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),c}},cD=oE(pn,e=>Number.isFinite(e)?1:0,"bool"),lD={kernelName:pn,backendName:"cpu",kernelFunc:cD},uD=oE(fn,e=>Math.abs(e)===1/0?1:0,"bool"),dD={kernelName:fn,backendName:"cpu",kernelFunc:uD},hD=oE(mn,e=>Number.isNaN(e)?1:0,"bool"),pD={kernelName:mn,backendName:"cpu",kernelFunc:hD};var fD={kernelName:vn,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=UE(a,r,s);return t.makeTensorInfo([i.length],"float32",i)}},mD=oE(wn,e=>Math.log1p(e)),gD={kernelName:wn,backendName:"cpu",kernelFunc:mD},bD=LC((e,t)=>e&&t),yD=ZC(kn,bD,null,"bool"),vD={kernelName:kn,backendName:"cpu",kernelFunc:yD},xD=oE(In,e=>e?0:1,"bool"),wD={kernelName:In,backendName:"cpu",kernelFunc:xD},kD=LC((e,t)=>e||t),ID=ZC(Sn,kD,null,"bool"),SD={kernelName:Sn,backendName:"cpu",kernelFunc:ID};var ND={kernelName:Cn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:c}=a;RC(r,"LRN");let l=r.shape[3],u=l-1,d=n.data.get(r.dataId).values,h=Nr.sizeFromShape(r.shape),p=new Float32Array(h);function f(e){let t=e%l,n=e-t+Math.max(0,t-s),a=e-t+Math.min(t+s,u),r=0;for(;n<=a;n++){let e=d[n];r+=e*e}return r}for(let m=0;m<h;m++){let e=f(m),t=d[m]*Math.pow(i+o*e,-c);p[m]=t}return n.makeTensorInfo(r.shape,r.dtype,p)}};var TD={kernelName:En,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:c,alpha:l,beta:u}=a;RC(i,"LRNGrad");let d=Nr.sizeFromShape(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(d),b=d;for(let y=0;y<b;y++){let e=y%h,t=y-e+Math.max(0,e-o),n=y-e+Math.min(h,e+o+1),a=0;for(let r=t;r<n;r++)a+=Math.pow(f[r],2);a=l*a+c;for(let r=t;r<n;r++){let e=-2*l*u*f[r]*m[y]/a;y===r&&(e+=Math.pow(a,-u)),e*=p[y],g[r]+=e}}return n.makeTensorInfo(i.shape,r.dtype,g)}};function OD(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=n,c=r.shape,l=c.length,u=Nr.parseAxisParam(s,c),d=u,h=Hf.getAxesPermutation(d,l),p=o.data.get(r.dataId).values;if(null!=h){let e=new Array(l);for(let t=0;t<e.length;t++)e[t]=c[h[t]];p=c_(p,c,r.dtype,h,e),d=Hf.getInnerMostAxes(d.length,l),c=e}RC(r,"max"),Hf.assertAxesAreInnerMostDims("max",d,l);let[f,m]=Hf.computeOutAndReduceShapes(c,d),g=qE(p,Nr.sizeFromShape(m),f,r.dtype),b=o.write(g,f,r.dtype),y=f;return i&&(y=Hf.expandShapeToKeepDim(f,u)),{dataId:b,shape:y,dtype:r.dtype}}var CD={kernelName:An,backendName:"cpu",kernelFunc:OD};var ED={kernelName:Dn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;RC(r,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:c}=a;Nr.assert(Hf.eitherStridesOrDilationsAreOne(i,1),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(i," and dilations '").concat(1,"'"));let l,u=Hf.computePool2DInfo(r.shape,s,i,1,o,c);if(1===u.filterWidth&&1===u.filterHeight&&Nr.arraysEqual(u.inShape,u.outShape))l=UC({inputs:{x:r},backend:n});else{let e=n.data.get(r.dataId).values,t=Nr.computeStrides(r.shape),a=HA(e,r.shape,r.dtype,t,u,"max");l=n.makeTensorInfo(u.outShape,r.dtype,a.values)}return l}};var _D={kernelName:Mn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:c,dataFormat:l}=a;RC(r,"maxPool3d");let u=Hf.computePool3DInfo(r.shape,s,i,1,o,c,l),d=KA(n.data.get(r.dataId).values,r.shape,r.dtype,Nr.computeStrides(r.shape),u,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};var AD={kernelName:jn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=a;RC([r,s],"maxPool3DGrad");let u=Hf.computePool3DInfo(s.shape,i,o,1,c,l),d=function(e,t){let n=Ui(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){let y=b*a-h,v=y;for(;v<0;)v+=i;let x=Math.min(t.inDepth,l+y);for(let a=0;a<t.outHeight;++a){let l=a*r-p,h=l;for(;h<0;)h+=o;let w=Math.min(t.inHeight,u+l);for(let r=0;r<t.outWidth;++r){let p=r*s-f,k=p;for(;k<0;)k+=c;let I=Math.min(t.inWidth,d+p),S=Number.NEGATIVE_INFINITY,N=-1;for(let t=v;t<x;t+=i){let n=t-y;for(let a=h;a<w;a+=o){let r=a-l;for(let s=k;s<I;s+=c){let i=s-p,o=e.get(m,t,a,s,g);o>=S&&(S=o,N=n*u*d+r*u+i)}}}n.set(N,m,b,a,r,g)}}}return n}(n.bufferSync(s),u),h=u.strideDepth,p=u.strideHeight,f=u.strideWidth,m=u.dilationDepth,g=u.dilationHeight,b=u.dilationWidth,y=u.effectiveFilterDepth,v=u.effectiveFilterHeight,x=u.effectiveFilterWidth,w=y-1-u.padInfo.front,k=x-1-u.padInfo.left,I=v-1-u.padInfo.top,S=Ui(s.shape,"float32"),N=n.bufferSync(r);for(let T=0;T<u.batchSize;++T)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){let r=t-w,s=n-I,i=a-k,o=0;for(let t=0;t<y;t+=m){let n=(r+t)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let a=0;a<v;a+=g){let r=(s+a)/p;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let s=0;s<x;s+=b){let c=(i+s)/f;if(c<0||c>=u.outWidth||Math.floor(c)!==c)continue;let l=y*v*x-1-d.get(T,n,r,c,e)===t*v*x+a*x+s?1:0;0!==l&&(o+=N.get(T,n,r,c,e)*l)}}}S.set(o,T,t,n,a,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};var RD={kernelName:Fn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;RC([s,i],"maxPoolGrad");let{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=a,h=Hf.computePool2DInfo(o.shape,c,l,1,u,d),p=n.data.get(o.dataId).values,f=Ui(h.outShape,o.dtype,qA(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,b=h.dilationHeight,y=h.dilationWidth,v=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,k=v-1-h.padInfo.top,I=Ui(o.shape,"float32"),S=n.data.get(r.dataId).values,N=Ui(r.shape,"float32",S);for(let T=0;T<h.batchSize;++T)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){let a=t-k,r=n-w,s=0;for(let t=0;t<v;t+=b){let n=(a+t)/m;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let a=0;a<x;a+=y){let i=(r+a)/g;if(i<0||i>=h.outWidth||Math.floor(i)!==i)continue;let o=v*x-1-f.get(T,n,i,e)===t*x+a?1:0;0!==o&&(s+=N.get(T,n,i,e)*o)}}I.set(s,T,t,n,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};var DD={kernelName:zn,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:c}=n,l=a;RC(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,d=Hf.computePool2DInfo(r.shape,s,i,[1,1],o),[h,p]=function(e,t,n,a,r){let s=HA(e,0,n,Nr.computeStrides(t),r,"max"),i=qA(e,t,n,r,!0,a);return[s.values,i.values]}(u,r.shape,r.dtype,c,d),f=l.write(h,d.outShape,r.dtype),m=l.write(p,d.outShape,r.dtype);return[{dataId:f,shape:d.outShape,dtype:r.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};var FD={kernelName:Ln,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=Nr.parseAxisParam(s,r.shape),c=Hf.computeOutAndReduceShapes(r.shape,o)[1],l=Nr.sizeFromShape(c),u=[],d=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(d);let h=KC({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});u.push(h);let p=ZR({inputs:{a:h,b:d},backend:n});u.push(p);let f=FR({inputs:{x:p},backend:n,attrs:{axis:s,keepDims:i}});return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}};var MD={kernelName:Pn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;RC(r,"min");let o=Nr.parseAxisParam(s,r.shape),c=o,l=Hf.getAxesPermutation(c,r.shape.length),u=r;null!=l&&(u=l_({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Hf.getInnerMostAxes(c.length,r.shape.length)),Hf.assertAxesAreInnerMostDims("min",c,u.shape.length);let[d,h]=Hf.computeOutAndReduceShapes(u.shape,c),p=Nr.sizeFromShape(h),f=Nr.makeZerosTypedArray(Nr.sizeFromShape(d),u.dtype),m=n.data.get(u.dataId).values;for(let b=0;b<f.length;++b){let e=b*p,t=m[e];for(let n=0;n<p;++n){let a=m[e+n];(Number.isNaN(a)||a<t)&&(t=a)}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(d,u.dtype,f);if(i){let e=xA({inputs:{x:g},backend:n,attrs:{shape:Hf.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var jD={kernelName:Wn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,mode:i}=a;RC(r,"mirrorPad");let o=s.map((e,t)=>e[0]+r.shape[t]+e[1]),c=s.map(e=>e[0]),l=s.map((e,t)=>e[0]+r.shape[t]),u="reflect"===i?0:1,d=n.data.get(r.dataId).values,h=r.shape.length,p=Nr.computeStrides(r.shape),f=Nr.sizeFromShape(o),m=o.length,g=Nr.computeStrides(o),b=Nr.getTypedArrayFromDType(r.dtype,f);for(let y=0;y<f;y++){let e=Nr.indexToLoc(y,m,g);for(let n=0;n<m;n++)e[n]<c[n]?e[n]=2*c[n]-e[n]-u:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+u);e=e.map((e,t)=>e-c[t]);let t=Nr.locToIndex(e,h,p);b[y]=d[t]}return{dataId:n.write(b,o,r.dtype),shape:o,dtype:r.dtype}}},zD=LC((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),LD=ZC(Un,zD),PD={kernelName:Un,backendName:"cpu",kernelFunc:LD},BD=v(A());function WD(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=r.shape.length,o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank ".concat(i," and dim was ").concat(o));let c=Nr.parseAxisParam([o],r.shape),l=OD({inputs:{x:r},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),u=Hf.expandShapeToKeepDim(l.shape,c),d=xA({inputs:{x:l},backend:n,attrs:{shape:u}}),h=eA({inputs:{a:r,b:d},backend:n}),p=bE({inputs:{x:h},backend:n}),f=FR({inputs:{x:p},backend:n,attrs:{axis:c,keepDims:!1}}),m=xA({inputs:{x:f},backend:n,attrs:{shape:u}}),g=ZR({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var UD={kernelName:Ma,backendName:"cpu",kernelFunc:WD};var VD={kernelName:Vn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a;RC(r,"multinomial");let c=o?r:WD({inputs:{logits:r},backend:n,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],d=n.data.get(c.dataId).values,h=[l,s],p=Nr.makeZerosTypedArray(Nr.sizeFromShape(h),"int32");for(let f=0;f<l;++f){let e=f*u,t=new Float32Array(u-1);t[0]=d[e];for(let r=1;r<t.length;++r)t[r]=t[r-1]+d[e+r];let n=BD.alea(i.toString()),a=f*s;for(let r=0;r<s;++r){let e=n();p[a+r]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[a+r]=n;break}}}return o||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(h,"int32",p)}},GD=Xm.nonMaxSuppressionV3Impl;var HD={kernelName:Kn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=a;RC(r,"NonMaxSuppression");let l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:d}=GD(l,u,i,o,c);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},qD=Xm.nonMaxSuppressionV4Impl;var KD={kernelName:Xn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,padToMaxOutputSize:l}=a;RC(r,"NonMaxSuppressionPadded");let u=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:h,validOutputs:p}=qD(u,d,i,o,c,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},XD=Xm.nonMaxSuppressionV5Impl;var ZD={kernelName:Zn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=a;RC(r,"NonMaxSuppressionWithScore");let u=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,h=i,p=o,f=c,m=l,{selectedIndices:g,selectedScores:b}=XD(u,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};var YD={kernelName:Jn,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:c}=a;RC(r,"oneHot");let l=Nr.sizeFromShape(r.shape),u=new Float32Array(l*i);u.fill(c);let d=n.data.get(r.dataId).values;for(let h=0;h<l;++h)d[h]>=0&&d[h]<i&&(u[h*i+d[h]]=o);return n.makeTensorInfo([...r.shape,i],s,u)}};function JD(e){let{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){let e=GC({inputs:{input:a},backend:n}),t=JD({inputs:{x:e},backend:n}),r=sR({inputs:{input:a},backend:n}),s=JD({inputs:{x:r},backend:n}),i=PC({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}return eD({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}var QD={kernelName:sr,backendName:"cpu",kernelFunc:JD};var $D={kernelName:Yn,backendName:"cpu",kernelFunc:function e(t){let{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){let t=GC({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),s=sR({inputs:{input:r},backend:a}),i=JD({inputs:{x:s},backend:a}),o=PC({inputs:{real:n,imag:i},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(i),o}return eD({backend:a,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function eF(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return qR({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(e=>{Nr.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),Nr.assert(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],c=oR({inputs:t.map(e=>{let t=qR({inputs:{input:e},backend:n,attrs:{dim:r}});return o.push(t),t}),backend:n,attrs:{axis:r}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}var tF={kernelName:Qn,backendName:"cpu",kernelFunc:eF};var nF={kernelName:$n,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;RC(r,"pad");let o=s.map((e,t)=>e[0]+r.shape[t]+e[1]),c=s.map(e=>e[0]),l=n.data.get(r.dataId).values,u=Nr.sizeFromShape(r.shape),d=r.shape.length,h=Nr.computeStrides(r.shape),p=Nr.sizeFromShape(o),f=o.length,m=Nr.computeStrides(o),g=Nr.getTypedArrayFromDType(r.dtype,p);0!==i&&g.fill(i);for(let b=0;b<u;b++){let e=Nr.indexToLoc(b,d,h).map((e,t)=>e+c[t]);g[Nr.locToIndex(e,f,m)]=l[b]}return{dataId:n.write(g,o,r.dtype),shape:o,dtype:r.dtype}}},aF=LC((e,t)=>Math.pow(e,t)),rF=ZC(ta,aF),sF={kernelName:ta,backendName:"cpu",kernelFunc:rF};var iF={kernelName:ra,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,c=r.map(e=>n.data.get(e.dataId).values),l=r.map(e=>e.shape),u=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=g_(c,l,u,s.shape,s.dtype,d,i.shape),m=h.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};var oF={kernelName:sa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,[l,u]=y_(i,a.shape,a.dtype,o,r.shape,c,s.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};var cF={kernelName:ia,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:c}=a,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,h=o.map(e=>n.data.get(e.dataId).values),p=o.map(e=>e.shape),[f,m]=I_(l,r.shape,u,s.shape,s.dtype,d,i.shape,h,p,c);return n.makeTensorInfo(f,s.dtype,m)}};var lF={kernelName:oa,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:a,stop:r,dtype:s,step:i}=n,o=S_(a,r,i,s);return t.makeTensorInfo([o.length],s,o)}},uF=oE(la,e=>1/e),dF={kernelName:la,backendName:"cpu",kernelFunc:uF};var hF={kernelName:fa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;RC(r,"resizeBilinear");let c=Nr.computeStrides(r.shape),[l,u]=o,[d,h,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(Nr.sizeFromShape([d,l,u,f])),b=[s&&l>1?h-1:h,s&&u>1?p-1:p],y=[s&&l>1?l-1:l,s&&u>1?u-1:u],v=0,x=b[0]/y[0],w=b[1]/y[1];for(let k=0;k<d;k++)for(let e=0;e<l;e++){let t;t=i?x*(e+.5)-.5:x*e;let n=Math.max(0,Math.floor(t)),a=t-n,r=Math.min(h-1,Math.ceil(t)),s=k*c[0]+n*c[1],o=k*c[0]+r*c[1];for(let e=0;e<u;e++){let t;t=i?w*(e+.5)-.5:w*e;let n=Math.max(0,Math.floor(t)),r=t-n,l=Math.min(p-1,Math.ceil(t)),u=s+n*c[2],d=o+n*c[2],h=s+l*c[2],b=o+l*c[2];for(let e=0;e<f;e++){let t=m[u+e],n=m[d+e],s=t+(m[h+e]-t)*r,i=s+(n+(m[b+e]-n)*r-s)*a;g[v++]=i}}}return n.makeTensorInfo([d,l,u,f],"float32",g)}};var pF={kernelName:ma,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;RC([s,r],"resizeBilinearGrad");let o=Nr.computeStrides(r.shape),[c,l,u,d]=r.shape,[,h,p]=s.shape,f=new Float32Array(c*l*u*d),m=[i&&h>1?l-1:l,i&&p>1?u-1:u],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],b=m[0]/g[0],y=m[1]/g[1],v=n.data.get(s.dataId).values,x=0;for(let w=0;w<c;w++){let e=w*o[0];for(let t=0;t<h;t++){let n=t*b,a=Math.floor(n),r=Math.min(Math.ceil(n),l-1),s=e+a*o[1],i=e+r*o[1],c=n-a,h=1-c;for(let e=0;e<p;e++){let t=e*y,n=Math.floor(t),a=Math.min(Math.ceil(t),u-1),r=t-n,l=1-r,p=s+n*o[2],m=s+a*o[2],g=i+n*o[2],b=i+a*o[2],w=h*l,k=h*r,I=c*l,S=c*r;for(let e=0;e<d;e++){let t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*I,f[b+e]+=t*S}}}}return n.makeTensorInfo([c,u,l,d],"float32",f)}};var fF={kernelName:ha,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;RC(r,"resizeNearestNeighbor");let c=Nr.computeStrides(r.shape),[l,u]=o,[d,h,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(d*l*u*f),b=[s&&l>1?h-1:h,s&&u>1?p-1:p],y=[s&&l>1?l-1:l,s&&u>1?u-1:u],v=b[0]/y[0],x=b[1]/y[1],w=0;for(let k=0;k<d;k++){let e=k*c[0];for(let t=0;t<l;t++){let n=i?v*(t+.5):v*t,a=Math.min(h-1,s?Math.round(n):Math.floor(n));i&&(a=Math.max(0,a));let r=e+a*c[1];for(let e=0;e<u;e++){let t=i?x*(e+.5):x*e,n=Math.min(p-1,s?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));let a=r+n*c[2];for(let e=0;e<f;e++){let t=m[a+e];g[w++]=t}}}}return n.makeTensorInfo([d,l,u,f],r.dtype,g)}};var mF={kernelName:pa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;RC([s,r],"resizeNearestNeighborGrad");let o=Nr.computeStrides(r.shape),c=Nr.computeStrides(s.shape),[l,u,d,h]=r.shape,[,p,f]=s.shape,m=new Float32Array(l*u*d*h),g=n.data.get(s.dataId).values,b=[i&&p>1?u-1:u,i&&f>1?d-1:d],y=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=b[0]/y[0],x=b[1]/y[1],w=1/v,k=1/x,I=2*Math.ceil(w)+2,S=2*Math.ceil(k)+2;for(let N=0;N<l;N++){let e=N*o[0];for(let t=0;t<u;t++){let n=e+t*o[1],a=Math.floor(t*w),r=Math.floor(a-I/2);for(let s=0;s<d;s++){let a=n+s*o[2],l=Math.floor(s*k),b=Math.floor(l-S/2);for(let n=0;n<h;n++){let o=0;for(let a=0;a<I;a++){let l=a+r;if(l<0||l>=p)continue;let h=e+l*c[1],m=l*v;if(t===Math.min(u-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<S;e++){let t=e+b;if(t<0||t>=f)continue;let a=h+t*c[2],r=t*x;s===Math.min(d-1,i?Math.round(r):Math.floor(r))&&(o+=g[a+n])}}m[a+n]=o}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}};var gF={kernelName:ba,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a;RC(r,"reverse");let i=r.shape.length,o=Nr.parseAxisParam(s,r.shape);if(0===i)return UC({inputs:{x:r},backend:n});let c=new rs(r.shape,r.dtype),l=n.bufferSync(r);for(let u=0;u<c.size;u++){let e=c.indexToLoc(u),t=e.slice();o.forEach(e=>t[e]=r.shape[e]-1-t[e]),c.set(l.get(...t),...e)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}},bF={kernelName:cr,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e,{image:r}=t,{radians:s,fillValue:i,center:o}=n,c=a,l=Nr.getTypedArrayFromDType(r.dtype,Nr.sizeFromShape(r.shape)),[u,d,h,p]=r.shape,[f,m]=Hf.getImageCenter(o,d,h),g=Math.sin(s),b=Math.cos(s),y=c.data.get(r.dataId).values;for(let v=0;v<u;v++){let e=v*h*d*p;for(let t=0;t<d;t++){let n=t*(h*p);for(let a=0;a<h;a++){let r=a*p;for(let s=0;s<p;s++){let o=[u,t,a,s],c=o[2],v=o[1],x=(c-f)*b-(v-m)*g,w=(c-f)*g+(v-m)*b;x=Math.round(x+f),w=Math.round(w+m);let k=i;if("number"!=typeof i&&(k=3===s?255:i[s]),x>=0&&x<h&&w>=0&&w<d){k=y[e+w*(h*p)+x*p+s]}l[e+n+r+s]=k}}}}return{dataId:c.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},yF=oE(ya,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),vF={kernelName:ya,backendName:"cpu",kernelFunc:yF};var xF={kernelName:xa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=Hf.calculateShapes(s,r,i),h=C_(n.bufferSync(r),n.bufferSync(s),i,d,l,c,o,u,0,!0);return n.makeTensorInfo(i,h.dtype,h.values)}};function wF(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function kF(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}var IF={kernelName:ka,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=function(e,t,n,a,r,s){let i=Nr.getArrayFromDType("int32",n*r);for(let o=0;o<n;++o){let n=e.slice(o*a,(o+1)*a),c=o*r;for(let e=0;e<r;++e)i[c+e]="left"===s?wF(n,t[e+c]):kF(n,t[e+c])}return i}(n.data.get(r.dataId).values,n.data.get(s.dataId).values,r.shape[0],r.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",o)}};var SF={kernelName:Ia,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t;RC([a,r,s],"select");let i=a.shape.length,o=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=ys(r.dtype,s.dtype),d=Nr.makeZerosTypedArray(Nr.sizeFromShape(r.shape),u),h=0,p=0===i||i>1||1===r.shape.length?1:Nr.sizeFromShape(r.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?d[h++]=c[f]:d[h++]=l[f];return n.makeTensorInfo(r.shape,u,d)}},NF=Hf.SELU_SCALEALPHA,TF=Hf.SELU_SCALE,OF=oE(Sa,e=>e>=0?TF*e:NF*(Math.exp(e)-1)),CF={kernelName:Sa,backendName:"cpu",kernelFunc:OF},EF=oE(Ca,e=>e<0?-1:e>0?1:0),_F={kernelName:Ca,backendName:"cpu",kernelFunc:EF},AF=oE(Ta,e=>Math.sin(e)),RF={kernelName:Ta,backendName:"cpu",kernelFunc:AF},DF=oE(Oa,e=>Math.sinh(e)),FF={kernelName:Oa,backendName:"cpu",kernelFunc:DF},MF=Math.log(1.1920928955078125e-7)+2,jF=oE(_a,e=>{let t,n=e>-MF,a=e<MF,r=Math.exp(e);return t=a?r:n?e:Math.log(1+r),t}),zF={kernelName:_a,backendName:"cpu",kernelFunc:jF};var LF={kernelName:Da,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;RC([r],"spaceToBatchND");let o=Nr.sizeFromShape(s),c=[[0,0]];c.push(...i);for(let g=1+s.length;g<r.shape.length;++g)c.push([0,0]);let l=nF.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),u=Hf.getReshaped(l.shape,s,o,!1),d=Hf.getPermuted(u.length,s.length,!1),h=Hf.getReshapedPermuted(l.shape,s,o,!1),p=xA({inputs:{x:l},backend:n,attrs:{shape:u}}),f=l_({inputs:{x:p},backend:n,attrs:{perm:d}}),m=xA({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};var PF={kernelName:ja,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(s.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(r.shape));if(0!==i.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));let o=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values[0],[d,h,p,f,m]=M_(o,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(h,a.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};var BF={kernelName:za,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(r.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));let i=Array.from(n.data.get(r.dataId).values),o=n.data.get(a.dataId).values,c=Array.from(n.data.get(s.dataId).values),[l,u,d]=j_(o,a.shape,a.dtype,i,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};var WF={kernelName:La,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(s.shape));if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,[l,u]=z_(i,a.shape,a.dtype,o,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};var UF={kernelName:Pa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(s.shape));if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,[l,u]=z_(i,a.shape,a.dtype,o,c);return n.makeTensorInfo(u,a.dtype,l)}};var VF={kernelName:Ba,backendName:"cpu",kernelFunc:function(e){let t,{inputs:n,backend:a,attrs:r}=e,{sparseIndices:s,sparseValues:i,defaultValue:o}=n,{outputShape:c}=r,{sliceRank:l,numUpdates:u,sliceSize:d,strides:h,outputSize:p}=Hf.calculateShapes(i,s,c),f=a.bufferSync(s);switch(i.dtype){case"bool":t=C_(f,a.bufferSync(i),c,p,d,u,l,h,!!a.data.get(o.dataId).values[0],!1);break;case"float32":case"int32":t=C_(f,a.bufferSync(i),c,p,d,u,l,h,a.data.get(o.dataId).values[0],!1);break;case"string":t=C_(f,a.bufferSync(i),c,p,d,u,l,h,Nr.decodeString(a.data.get(o.dataId).values[0]),!1);break;default:throw new Error("Unsupported type ".concat(i.dtype))}return a.makeTensorInfo(c,t.dtype,t.values)}};var GF={kernelName:Fa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=Nr.parseAxisParam(i,r.shape)[0],c=Hf.prepareSplitSize(r,s,o),l=new Array(r.shape.length).fill(0),u=r.shape.slice();return c.map(e=>{let t=[...u];t[o]=e;let a=D_({inputs:{x:r},backend:n,attrs:{begin:l,size:t}});return l[o]+=e,a})}},HF={kernelName:Ua,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e,{x:a}=t,r=n;RC(a,"square");let s=r.data.get(a.dataId).values,i=new Float32Array(s.length);for(let o=0;o<s.length;++o){let e=s[o];i[o]=e*e}return{dataId:r.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},qF=oE(ir,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),KF={kernelName:ir,backendName:"cpu",kernelFunc:qF};var XF={kernelName:Ga,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=a;RC(r,"stridedSlice");let p,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:y,begin:v,end:x,strides:w}=wf.sliceInfo(r.shape,s,i,o,c,l,u,d,h);if(g)p=xA({inputs:{x:r},backend:n,attrs:{shape:m}});else if(b||y){Nr.assert(r.shape.length>=1,()=>"Input must have rank at least 1, got: ".concat(r.shape.length));let e=wf.computeOutShape(v,x,w),t=D_({inputs:{x:r},backend:n,attrs:{begin:v,size:e}});p=xA({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{let e=K_(f,n.bufferSync(r),w,v);p=n.makeTensorInfo(m,e.dtype,e.values)}return p}};var ZF={kernelName:Ha,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,h=n.data.get(u.dataId).values,p=n.data.get(d.dataId).values,[f,m]=X_(h,p,r,s,i,o,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};var YF={kernelName:qa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));let o=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values[0],[l,u,d]=Y_(o,c,r),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};var JF={kernelName:Ka,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");let i=J_(n.data.get(s.dataId).values,r);return n.makeTensorInfo(s.shape,"int32",i)}},QF=oE(Za,e=>Math.tan(e)),$F={kernelName:Za,backendName:"cpu",kernelFunc:QF},eM=oE(Ya,e=>Math.tanh(e));function tM(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{let e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Nr.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{let e=t-1;n-=t*Math.trunc(n/e)}return Nr.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return Nr.clamp(0,e,t-1)}(e,t);case"constant":default:return function(e,t){return e}(e)}}function nM(e,t,n,a,r,s,i,o,c,l,u){return 0<=o&&o<t&&0<=c&&c<n?e[i*a+o*r+c*s+l]:u}function aM(e,t,n,a,r,s,i,o,c,l,u){return nM(e,t,n,a,r,s,i,Math.round(o),Math.round(c),l,u)}function rM(e,t,n,a,r,s,i,o,c,l,u){let d=Math.floor(o),h=Math.floor(c),p=d+1,f=h+1;return(p-o)*((f-c)*nM(e,t,n,a,r,s,i,d,h,l,u)+(c-h)*nM(e,t,n,a,r,s,i,d,f,l,u))+(o-d)*((f-c)*nM(e,t,n,a,r,s,i,p,h,l,u)+(c-h)*nM(e,t,n,a,r,s,i,p,f,l,u))}var sM=[SA,zC,TA,CA,eE,EA,_A,AA,RA,DA,MA,zA,PA,UA,GA,XA,ZA,YA,JA,IA,QA,$A,eR,sE,tR,XC,dE,aR,BC,rR,cR,uR,dR,hR,pR,fR,mR,bR,vR,xR,wR,kR,IR,SR,TR,OR,CR,ER,_R,AR,RR,DR,jR,lA,zR,mE,HR,yE,KR,wE,$R,tD,nD,SE,OE,aD,rD,sD,iD,RE,ME,VC,oD,iR,lD,dD,pD,dA,LE,WE,fD,HE,gD,vD,wD,SD,ND,TD,CD,ZE,ED,_D,AD,RD,DD,FD,MD,QE,jD,PD,VD,n_,r_,HD,KD,ZD,o_,YD,$D,tF,nF,sF,fA,h_,iF,oF,cF,lF,HC,YR,dF,gA,yA,wA,hF,pF,fF,mF,gF,bF,vF,O_,xF,IF,SF,CF,A_,_F,RF,FF,F_,UD,zF,LF,PF,BF,WF,UF,VF,GF,B_,HF,V_,q_,KF,XF,ZF,YF,JF,tA,MR,$F,{kernelName:Ya,backendName:"cpu",kernelFunc:eM},{kernelName:wa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:c,strides:l,outputSize:u}=Hf.calculateShapes(s,r,a.shape),d=n.bufferSync(r),h=n.bufferSync(s),p=n.bufferSync(a),f=C_(d,h,a.shape,u,c,o,i,l,p,!1);return n.makeTensorInfo(a.shape,f.dtype,f.values)}},{kernelName:Ja,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;RC(r,"tile");let i=nA(n.bufferSync(r),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:Qa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a;RC(r,"topk");let o=n.data.get(r.dataId).values,[c,l]=sA(o,r.shape,r.dtype,s,i);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}},{kernelName:$a,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:c,outputShape:l}=n,[u,d,h,p]=r.shape,[f,m]=null!=l?l:[d,h],g=[u,f,m,p],b=Nr.computeStrides(r.shape),y=b[0],v=b[1],x=b[2],w=Nr.computeStrides(g),k=w[0],I=w[1],S=w[2],N=Nr.getTypedArrayFromDType(r.dtype,Nr.sizeFromShape(g));N.fill(c);let T=a.data.get(r.dataId).values,O=a.data.get(s.dataId).values;for(let C=0;C<u;++C){let e=1===s.shape[0]?O:O.subarray(8*C,8*C+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let a=0;a<p;++a){let r,s=e[6]*n+e[7]*t+1;if(0===s)continue;let l=(e[0]*n+e[1]*t+e[2])/s,u=(e[3]*n+e[4]*t+e[5])/s,p=tM(l,h,o),f=tM(u,d,o);switch(i){case"nearest":r=aM(T,d,h,y,v,x,C,f,p,a,c);break;case"bilinear":r=rM(T,d,h,y,v,x,C,f,p,a,c);break;default:throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got ".concat(i))}N[C*k+t*I+n*S+a]=r}return a.makeTensorInfo(g,r.dtype,N)}return{dataId:a.write(N,g,r.dtype),shape:r.shape,dtype:r.dtype}}},u_,{kernelName:tr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;RC(s,"unique");let i=a.data.get(s.dataId).values,{outputValues:o,outputShape:c,indices:l}=iA(i,r,s.shape,s.dtype);return[a.makeTensorInfo(c,s.dtype,o),a.makeTensorInfo([l.length],"int32",l)]}},{kernelName:nr,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r.shape.length,o=r.shape[s],c=new Array(i-1),l=0;for(let p=0;p<i;p++)p!==s&&(c[l++]=r.shape[p]);let u=new Array(i).fill(0),d=r.shape.slice();d[s]=1;let h=new Array(o);for(let p=0;p<h.length;p++){u[s]=p;let e=D_({inputs:{x:r},backend:n,attrs:{begin:u,size:d}});h[p]=xA({inputs:{x:e},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(e)}return h}},{kernelName:ar,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a;RC(r,"unsortedSegmentSum");let o=[],c=[],l=r.shape.length-s.shape.length,u=s;for(let h=0;h<l;++h){let e=qR({inputs:{input:u},backend:n,attrs:{dim:h+1}});u=e,c.push(e)}for(let h=0;h<i;++h){let e=Nr.createScalarValue(h,"int32"),t=n.makeTensorInfo([],"int32",e),a=fE({inputs:{a:t,b:u},backend:n}),s=KC({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),i=t_({inputs:{a:s,b:r},backend:n}),l=FR({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(l),c.push(t),c.push(a),c.push(s),c.push(i),c.push(l)}let d=eF({inputs:o,backend:n,attrs:{axis:0}});return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}},QD];for(let t of sM)vr(t);var iM={};y(iM,{assertNotComplex:()=>pj,bindCanvasToFramebuffer:()=>VM,bindColorTextureToFramebuffer:()=>GM,bindTextureToProgramUniformSampler:()=>UM,bindTextureUnit:()=>LM,bindVertexBufferToProgramAttribute:()=>zM,callAndCheck:()=>yM,canBeRepresented:()=>vM,createFragmentShader:()=>IM,createFramebuffer:()=>jM,createProgram:()=>CM,createStaticIndexBuffer:()=>RM,createStaticVertexBuffer:()=>AM,createTexture:()=>FM,createVertexShader:()=>kM,getBatchDim:()=>YM,getExtensionOrThrow:()=>wM,getFramebufferErrorMessage:()=>KM,getMaxTexturesInShader:()=>sj,getNumChannels:()=>DM,getProgramUniformLocation:()=>WM,getProgramUniformLocationOrThrow:()=>BM,getRowsCols:()=>JM,getShapeAs3D:()=>QM,getTextureShapeFromLogicalShape:()=>$M,getWebGLDisjointQueryTimerVersion:()=>ij,getWebGLErrorMessage:()=>xM,getWebGLMaxTextureSize:()=>nj,hasExtension:()=>oj,isCapableOfRenderingToFloatTexture:()=>lj,isDownloadFloatTextureEnabled:()=>uj,isReshapeFree:()=>tj,isWebGLFenceEnabled:()=>hj,isWebGLVersionEnabled:()=>cj,linkProgram:()=>EM,logShaderSourceAndInfoLog:()=>OM,resetMaxTextureSize:()=>aj,resetMaxTexturesInShader:()=>rj,unbindColorTextureFromFramebuffer:()=>HM,unbindTextureUnit:()=>PM,validateFramebuffer:()=>qM,validateProgram:()=>_M,validateTextureSize:()=>MM});var oM,cM,lM,uM={},dM={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function hM(e,t){uM[e]=t}function pM(e,t){if(!(e in uM)||null!=t){let n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=null==t?function(e){if(!Ue().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;return n.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete uM[e]},!1),Ue().getBool("SOFTWARE_WEBGL_ENABLED")&&(dM.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",dM)||n.getContext("experimental-webgl",dM):n.getContext("webgl2",dM)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;uM[e]=n}let n=uM[e];return null==n||n.isContextLost()?(delete uM[e],pM(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),uM[e])}function fM(e,t){return[t,e]}function mM(e){let t=Nr.sizeFromShape(e),n=Math.ceil(t/4);return Nr.sizeToSquarishShape(n)}function gM(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function bM(e,t){let n,a,r,s,i,o,c,l,u,d,h=e;return 2===Ue().getNumber("WEBGL_VERSION")?(n=h.R32F,a=h.R16F,r=h.RGBA16F,s=h.RGBA32F,i=h.RED,c=4,l=1,u=h.HALF_FLOAT,d=h.FLOAT,o=h.RGBA8):(n=e.RGBA,a=e.RGBA,r=e.RGBA,s=h.RGBA,i=e.RGBA,c=4,l=4,u=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,o=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:o,downloadUnpackNumChannels:c,defaultNumChannels:l,textureTypeHalfFloat:u,textureTypeFloat:d}}function yM(e,t){let n=t();return Ue().getBool("DEBUG")&&function(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+xM(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(oM||(oM={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(cM||(cM={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(lM||(lM={}));function vM(e){return!!(Ue().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function xM(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(t)}}function wM(e,t){return XM(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function kM(e,t){let n=XM(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(yM(e,()=>e.shaderSource(n,t)),yM(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function IM(e,t){let n=XM(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(yM(e,()=>e.shaderSource(n,t)),yM(e,()=>e.compileShader(n)),Ue().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw OM(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var SM,NM,TM=/ERROR: [0-9]+:([0-9]+):/g;function OM(e,t){let n=TM.exec(t);if(null==n)return console.log("Couldn't parse line number in error: ".concat(t)),void console.log(e);let a=+n[1],r=e.split("\n"),s=r.length.toString().length+2,i=r.map((e,t)=>Nr.rightPad((t+1).toString(),s)+e),o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);let c=i.slice(0,a-1),l=i.slice(a-1,a),u=i.slice(a);console.log(c.join("\n")),console.log(t.split("\n")[0]),console.log("%c ".concat(Nr.rightPad(l[0],o)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function CM(e){return XM(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function EM(e,t){if(yM(e,()=>e.linkProgram(t)),!Ue().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function _M(e,t){if(yM(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function AM(e,t){let n=XM(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return yM(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),yM(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function RM(e,t){let n=XM(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return yM(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),yM(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function DM(){return 2===Ue().getNumber("WEBGL_VERSION")?1:4}function FM(e){return XM(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function MM(e,t){let n=Ue().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let n="[".concat(e,"x").concat(t,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){let a="[".concat(e,"x").concat(t,"]"),r="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}function jM(e){return XM(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function zM(e,t,n,a,r,s,i){let o=e.getAttribLocation(t,n);return-1!==o&&(yM(e,()=>e.bindBuffer(e.ARRAY_BUFFER,a)),yM(e,()=>e.vertexAttribPointer(o,r,e.FLOAT,!1,s,i)),yM(e,()=>e.enableVertexAttribArray(o)),!0)}function LM(e,t,n){ZM(e,n),yM(e,()=>e.activeTexture(e.TEXTURE0+n)),yM(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function PM(e,t){ZM(e,t),yM(e,()=>e.activeTexture(e.TEXTURE0+t)),yM(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function BM(e,t,n){return XM(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function WM(e,t,n){return e.getUniformLocation(t,n)}function UM(e,t,n,a){yM(e,()=>LM(e,t,a)),yM(e,()=>e.uniform1i(n,a))}function VM(e){yM(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),yM(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),yM(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function GM(e,t,n){yM(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),yM(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function HM(e,t){yM(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),yM(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function qM(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+KM(e,t))}function KM(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(t)}}function XM(e,t,n){let a=yM(e,()=>t());if(null==a)throw new Error(n);return a}function ZM(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){let e="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(e,"."))}}function YM(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Nr.sizeFromShape(e.slice(0,e.length-t))}function JM(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function QM(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[YM(e),...JM(e)]),t}function $M(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=Ue().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=Ue().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");a===1/0&&Ue().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n*=2,a*=2,1===(e=e.map((t,n)=>n>=e.length-2?Nr.nearestLargerEven(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length&&(e=Nr.squeezeShape(e).newShape);let r=Nr.sizeFromShape(e),s=null;e.length<=1&&r<=n?s=[1,r]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=null!=s&&Math.max(...s)>a&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||i)if(t){let t=YM(e),n=2,a=2;e.length&&([n,a]=JM(e)),r=t*(n/2)*(a/2),s=Nr.sizeToSquarishShape(r).map(e=>2*e)}else s=Nr.sizeToSquarishShape(r);return s}function ej(e){return e%2===0}function tj(e,t){if(e=e.slice(-2),t=t.slice(-2),Nr.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let n=e[e.length-1],a=t[t.length-1];if(n===a||ej(n)&&ej(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&ej(e[0])&&ej(t[0])}function nj(e){if(null==SM){let t=pM(e);SM=t.getParameter(t.MAX_TEXTURE_SIZE)}return SM}function aj(){SM=null}function rj(){NM=null}function sj(e){if(null==NM){let t=pM(e);NM=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,NM)}function ij(e){if(0===e)return 0;let t,n=pM(e);return t=oj(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:oj(n,"EXT_disjoint_timer_query")?1:0,t}function oj(e,t){return null!=e.getExtension(t)}function cj(e){try{if(null!=pM(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function lj(e){if(0===e)return!1;let t=pM(e);if(1===e){if(!oj(t,"OES_texture_float"))return!1}else if(!oj(t,"EXT_color_buffer_float"))return!1;return dj(t)}function uj(e){if(0===e)return!1;let t=pM(e);if(1!==e){if(oj(t,"EXT_color_buffer_float"))return dj(t);let e="EXT_color_buffer_half_float";if(oj(t,e)){let n=t.getExtension(e);return function(e,t){let n=bM(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(r),s}(t,n)}return!1}return!(!oj(t,"OES_texture_float")||!oj(t,"WEBGL_color_buffer_float"))&&dj(t)}function dj(e){let t=bM(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function hj(e){return 2===e&&null!=pM(e).fenceSync}function pj(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Nr.assert("complex64"!==e.dtype,()=>"".concat(t," does not support complex64 tensors in the WebGL backend."))})}var fj=Ue();function mj(){let e,t,n,a,r,s,i,o,c,l;return 2===Ue().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",r="texture",s="outputColor",i="out vec4 outputColor;",o=Ue().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",c="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",r="texture2D",s="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:c,defineRound:l}}function gj(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",a=Nr.computeStrides(t);return a.map((t,r)=>{let s="int ".concat(e[r]," = ").concat(n," / ").concat(t),i=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * ").concat(t):"index -= ".concat(e[r]," * ").concat(t);return"".concat(s,"; ").concat(i,";")}).join("")}function bj(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",a=Nr.computeStrides(t);return a.map((t,r)=>{let s="int ".concat(e[r]," = ").concat(n," / outShapeStrides[").concat(r,"]"),i=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * outShapeStrides[").concat(r,"]"):"index -= ".concat(e[r]," * outShapeStrides[").concat(r,"]");return"".concat(s,"; ").concat(i,";")}).join("")}function yj(e,t){let n=e.length,a=e.map(e=>"".concat(t,"[").concat(e,"]")),r=new Array(n-1);r[n-2]=a[n-1];for(let s=n-3;s>=0;--s)r[s]="(".concat(r[s+1]," * ").concat(a[s+1],")");return r}function vj(e){let t=Nr.computeStrides(e).map(e=>e.toString());return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0]," + coords.y * ").concat(t[1]," + coords.z;\n  }\n")}fj.registerFlag("HAS_WEBGL",()=>fj.getNumber("WEBGL_VERSION")>0),fj.registerFlag("WEBGL_VERSION",()=>cj(2)?2:cj(1)?1:0),fj.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),fj.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===fj.get("WEBGL_VERSION")),fj.registerFlag("WEBGL_CPU_FORWARD",()=>!0),fj.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),fj.registerFlag("WEBGL_PACK",()=>fj.getBool("HAS_WEBGL")),fj.registerFlag("WEBGL_PACK_NORMALIZATION",()=>fj.getBool("WEBGL_PACK")),fj.registerFlag("WEBGL_PACK_CLIP",()=>fj.getBool("WEBGL_PACK")),fj.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>fj.getBool("WEBGL_PACK")),fj.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>fj.getBool("WEBGL_PACK")),fj.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>fj.getBool("WEBGL_PACK")),fj.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>fj.getBool("WEBGL_PACK")),fj.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>fj.getBool("WEBGL_PACK")),fj.registerFlag("WEBGL_PACK_REDUCE",()=>fj.getBool("WEBGL_PACK")),fj.registerFlag("WEBGL_LAZILY_UNPACK",()=>fj.getBool("WEBGL_PACK")),fj.registerFlag("WEBGL_CONV_IM2COL",()=>fj.getBool("WEBGL_PACK")),fj.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>nj(fj.getNumber("WEBGL_VERSION"))),fj.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>sj(fj.getNumber("WEBGL_VERSION"))),fj.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=fj.getNumber("WEBGL_VERSION");return 0===e?0:ij(e)}),fj.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>fj.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Ds.isMobile()),fj.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>lj(fj.getNumber("WEBGL_VERSION"))),fj.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!fj.getBool("WEBGL_FORCE_F16_TEXTURES")&&fj.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),fj.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>uj(fj.getNumber("WEBGL_VERSION"))),fj.registerFlag("WEBGL_FENCE_API_ENABLED",()=>hj(fj.getNumber("WEBGL_VERSION"))),fj.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>fj.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),fj.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ".concat(e,"."))}),fj.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Ds.isMobile()?1:-1,e=>{if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ".concat(e,"."))}),fj.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),fj.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),fj.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),fj.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),fj.registerFlag("WEBGL_EXP_CONV",()=>!1),fj.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>fj.getBool("IS_TEST")),fj.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),fj.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),fj.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),fj.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);var xj="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:wj}=Hf;function kj(e,t,n){let a=[];if(e.forEach(e=>{let t=Nr.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push("uniform float ".concat(e.name).concat(t>1?"[".concat(t,"]"):"",";")):(a.push("uniform sampler2D ".concat(e.name,";")),a.push("uniform int offset".concat(e.name,";"))),n.enableShapeUniforms){let{uniformShape:t}=Wj(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:a.push("uniform int ".concat(e.name,"Shape;"));break;case 2:a.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:a.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:a.push("uniform ivec4 ".concat(e.name,"Shape;"))}a.push("uniform ivec2 ".concat(e.name,"TexShape;"))}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(e=>{a.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))});let r,s,i=a.join("\n"),o=e.map(e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0,r="";r+=n?Sj(e,a):Ij(e,a);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(r+=n?Lj(e,t):Pj(e,t)),r}(e,t,n.packedInputs,n.enableShapeUniforms)).join("\n"),c=t.texShape,l=mj(),u=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(l),d=function(e){return"".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(Nj,"\n    ").concat(Tj,"\n    ").concat(Oj,"\n  ")}(l);return t.isPacked?(r=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===a[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(a[1],".0);\n      }\n    "):1===a[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(a[0],".0);\n      }\n    "):n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      return 2 * (resTexRC.x * ").concat(a[1]," + resTexRC.y);\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Nr.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(a[0],", ").concat(a[1],"));\n      }\n    ");let r=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2),i=s,o="",c="b, r, c";for(let l=2;l<e.length-1;l++)i*=e[e.length-l-1],o="\n      int b".concat(l," = index / ").concat(i,";\n      index -= b").concat(l," * ").concat(i,";\n    ")+o,c="b".concat(l,", ")+c;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      ").concat(o,"\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec").concat(e.length,"(").concat(c,");\n    }\n  ")}(e,t,n)}}(t.logicalShape,c,n.enableShapeUniforms),s=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(l)):(r=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1],".0);\n      }\n    "):1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0],".0);\n      }\n    "):n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return resTexRC.x * ").concat(t[1]," + resTexRC.y;\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){return Nr.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    "):1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    "):1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    "):n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(bj(["r","c","d"],e),"\n    return ivec3(r, c, d);\n  }\n");let a=gj(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,t,n);case 4:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(bj(["r","c","d","d2"],e),"\n      return ivec4(r, c, d, d2);\n    }\n  ");let a=gj(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,t,n);case 5:return function(e,t){let n=gj(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0],",\n                             ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,t);case 6:return function(e,t){let n=gj(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,t);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(t.logicalShape,c,n.enableShapeUniforms),s=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(l)),n.packedInputs&&(d+=Cj),[d,u,s,i,r,o,n.userCode].join("\n")}function Ij(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=e.shapeInfo.logicalShape;switch(n.length){case 0:return _j(e,t);case 1:return Aj(e,t);case 2:return Rj(e,t);case 3:return Dj(e,t);case 4:return Fj(e,t);case 5:return Mj(e);case 6:return jj(e);default:throw new Error("".concat(n.length,"-D input sampling is not yet supported"))}}function Sj(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=mj();return"\n    vec4 ".concat(n,"() {\n      return ").concat(a.texture2D,"(").concat(t,", halfCR);\n    }\n  ")}(e);case 1:return function(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,s=mj();if(t)return"\n    vec4 ".concat(a,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ");let i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return"\n    vec4 ".concat(a,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(i[0],", ").concat(i[1],", index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],c=mj();if(null!=s&&Nr.arraysEqual(n,s))return t?"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    "):"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(o,".0, ").concat(i,".0);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    ");if(t)return"\n    vec4 ".concat(r,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ");let l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(l[0],", ").concat(l[1],", row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){let a=n.slice(1),s=[1,2],i=Uj(e,a),o=["b","row","col"];return"\n        ".concat(Sj(i,t),"\n        vec4 ").concat(r,"(int b, int row, int col) {\n          return ").concat(r,"(").concat(Vj(o,s),");\n        }\n      ")}let o=mj();if(t)return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(o.texture2D,"(").concat(a,", uv);\n    }\n  ");let c=i[0],l=i[1],u=Math.ceil(n[2]/2),d=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(c,", ").concat(l,", ").concat(d,", ").concat(u,", b, row, col);\n      return ").concat(o.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);default:return function(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=mj();if(t)return"\n    vec4 ".concat(a,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ");let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=c[0],u=c[1],d=Math.ceil(s[i-1]/2),h=d*Math.ceil(s[i-2]/2),p="int b, int row, int col",f="b * ".concat(h," + (row / 2) * ").concat(d," + (col / 2)");for(let m=2;m<i-1;m++)p="int b".concat(m,", ")+p,h*=s[i-m-1],f="b".concat(m," * ").concat(h," + ")+f;return"\n    vec4 ".concat(a,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(l,");\n      return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t)}}var Nj="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Tj="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Oj="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Cj="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Ej(e){return"offset".concat(e)}function _j(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(a,"() {return ").concat(n,";}");let[r,s]=e.shapeInfo.texShape;if(1===r&&1===s)return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");let i=Ej(n);if(t)return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");let[o,c]=e.shapeInfo.texShape;return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(o,", ").concat(c,", ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}function Aj(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int index) {\n        ").concat(zj(e),"\n      }\n    ");let r=e.shapeInfo.texShape,s=r[0],i=r[1];if(1===i&&1===s)return"\n      float ".concat(a,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");let o=Ej(n);return 1===i?t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o,") + 0.5) / ").concat(s,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):1===s?t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(o,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(o,") + 0.5) / ").concat(i,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):t?"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  "):"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(s,", ").concat(i,", index + ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}function Rj(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape;if(null!=s&&Nr.arraysEqual(n,s)){if(t)return"\n      float ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");let e=s[0],n=s[1];return"\n    float ".concat(r,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(e,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}let{newShape:i,keptDims:o}=Nr.squeezeShape(n),c=i;if(c.length<n.length){let n=Uj(e,c),a=["row","col"];return"\n      ".concat(Ij(n,t),"\n      float ").concat(r,"(int row, int col) {\n        return ").concat(r,"(").concat(Vj(a,o),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(zj(e),"\n      }\n    ");let l=s[0],u=s[1],d=Ej(a);return 1===u?t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(a,"TexShape[0]));\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(l,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  "):1===l?t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(a,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(a,", uv);\n    }\n  "):t?"\n      float ".concat(r,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a,"Shape[1] + col + ").concat(d,";\n        vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n  float ".concat(r,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(d,";\n    vec2 uv = uvFromFlat(").concat(l,", ").concat(u,", index);\n    return sampleTexture(").concat(a,", uv);\n  }\n")}function Dj(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:c}=Nr.squeezeShape(n),l=o;if(l.length<n.length){let n=Uj(e,l),a=["row","col","depth"];return"\n        ".concat(Ij(n,t),"\n        float ").concat(r,"(int row, int col, int depth) {\n          return ").concat(r,"(").concat(Vj(a,c),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(s,", ").concat(i,", 1)));\n        ").concat(zj(e),"\n      }\n    ");let u=e.shapeInfo.texShape,d=u[0],h=u[1],p=e.shapeInfo.flatOffset;if(h===s&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        int stride1 = ").concat(a,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n        float ".concat(r,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(i,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(h,".0, ").concat(d,".0);\n          return sampleTexture(").concat(a,", uv);\n        }\n      ");if(h===i&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(a,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(h,".0, ").concat(d,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");let f=Ej(a);return t?"\n    float ".concat(r,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(a,"Shape[1] * ").concat(a,"Shape[2];\n      int stride1 = ").concat(a,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n      return sampleTexture(").concat(a,", uv);\n    }\n    "):"\n      float ".concat(r,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(s," + col * ").concat(i," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(d,", ").concat(h,", index);\n        return sampleTexture(").concat(a,", uv);\n      }\n  ")}function Fj(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:c,keptDims:l}=Nr.squeezeShape(n);if(c.length<n.length){let n=Uj(e,c),a=["row","col","depth","depth2"];return"\n      ".concat(Ij(n,t),"\n      float ").concat(r,"(int row, int col, int depth, int depth2) {\n        return ").concat(r,"(").concat(Vj(a,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(o,", ").concat(i,", ").concat(s,", 1)));\n        ").concat(zj(e),"\n      }\n    ");let u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f="int stride2 = ".concat(a,"Shape[3];"),m="int stride1 = ".concat(a,"Shape[2] * stride2;"),g="int stride0 = ".concat(a,"Shape[1] * stride1;");if(p===o&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(m,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(i,", ").concat(s,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");if(p===s&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(a,"Shape[1] * ").concat(a,"Shape[2], ").concat(a,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");let b=Ej(a);return t?"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(m,"\n      ").concat(g,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index + ").concat(b,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  "):"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(o," + col * ").concat(i," +\n          depth * ").concat(s," + depth2;\n      vec2 uv = uvFromFlat(").concat(h,", ").concat(p,", index + ").concat(b,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}function Mj(e){let t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],s=t[3]*r,i=t[2]*s,o=t[1]*i,{newShape:c,keptDims:l}=Nr.squeezeShape(t);if(c.length<t.length){let t=Uj(e,c),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(Ij(t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(Vj(n,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(o,", ").concat(i,", ").concat(s,", ").concat(r,")) +\n          depth3;\n        ").concat(zj(e),"\n      }\n    ");let u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(i,", ").concat(s,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===r&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");let f=Ej(n);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(o," + col * ").concat(i," + depth * ").concat(s," +\n          depth2 * ").concat(r," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(h,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}function jj(e){let t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:s}=Nr.squeezeShape(t);if(r.length<t.length){let t=Uj(e,r),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(Ij(t),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(Vj(n,s),");\n      }\n    ")}let i=t[5],o=t[4]*i,c=t[3]*o,l=t[2]*c,u=t[1]*l;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(l,", ").concat(c,", ").concat(o,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(i,", 1)));\n        ").concat(zj(e),"\n      }\n    ");let d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===u&&null==d)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(l,", ").concat(c,", ").concat(o,", ").concat(i,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===i&&null==d)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");let m=Ej(n);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(l," + depth * ").concat(c," +\n          depth2 * ").concat(o," + depth3 * ").concat(i," + depth4 + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}function zj(e){let t=e.name,n=Nr.sizeFromShape(e.shapeInfo.logicalShape);return n<2?"return ".concat(t,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(t,"[i];\n      }\n    }\n  ")}function Lj(e,t){let n,a=e.name,r=a.charAt(0).toUpperCase()+a.slice(1),s="get"+r+"AtOutCoords",i=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,c=wj(e.shapeInfo.logicalShape,t.logicalShape),l=Bj(o),u=o-i,d=["x","y","z","w","u","v"];n=0===i?"":o<2&&c.length>=1?"coords = 0;":c.map(e=>"coords.".concat(d[e+u]," = 0;")).join("\n");let h="";h=o<2&&i>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>"coords.".concat(d[t+u])).join(", ");let p="return outputValue;",f=1===Nr.sizeFromShape(e.shapeInfo.logicalShape),m=1===Nr.sizeFromShape(t.logicalShape);if(1!==i||f||m){if(f&&!m)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(c.length){let e=i-2,t=i-1;c.indexOf(e)>-1&&c.indexOf(t)>-1?p="return vec4(outputValue.x);":c.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":c.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(s,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(n,"\n      vec4 outputValue = get").concat(r,"(").concat(h,");\n      ").concat(p,"\n    }\n  ")}function Pj(e,t){let n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===c&&null==e.shapeInfo.flatOffset&&Nr.arraysEqual(i,s))return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");let l,u=Bj(c),d=wj(e.shapeInfo.logicalShape,t.logicalShape),h=c-o,p=["x","y","z","w","u","v"];l=0===o?"":c<2&&d.length>=1?"coords = 0;":d.map(e=>"coords.".concat(p[e+h]," = 0;")).join("\n");let f="";return f=c<2&&o>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>"coords.".concat(p[t+h])).join(", "),"\n    float ".concat(r,"() {\n      ").concat(u," coords = getOutputCoords();\n      ").concat(l,"\n      return get").concat(a,"(").concat(f,");\n    }\n  ")}function Bj(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function Wj(e,t,n){let{newShape:a,keptDims:r}=Nr.squeezeShape(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):a,c=!e&&s>1&&!Nr.arraysEqual(t,n)&&a.length<s||i;return{useSqueezeShape:c,uniformShape:c?o:t,keptDims:r}}function Uj(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Vj(e,t){return t.map(t=>e[t]).join(", ")}function Gj(e,t,n){let a,r,s,i=[],o=[],c=null,l=null;l=e.getUniformLocation(n,"NAN",!1),1===Ue().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));let u=!1;for(let d of t.variableNames){let a={name:d,uniform:e.getUniformLocation(n,d,u),offset:e.getUniformLocation(n,"offset".concat(d),u)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,"".concat(d,"Shape"),u),a.texShape=e.getUniformLocation(n,"".concat(d,"TexShape"),u)),i.push(a)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",u),s=e.getUniformLocation(n,"outShapeStrides",u),r=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(let d of t.customUniforms)o.push(e.getUniformLocation(n,d.name,u));return{variablesLocations:i,customUniformLocations:o,infLoc:c,nanLoc:l,outShapeLocation:a,outShapeStridesLocation:s,outTexShapeLocation:r}}function Hj(e,t){if(e.length!==t.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but was executed with ").concat(t.length," inputs"));e.forEach((e,n)=>{let a=e.logicalShape,r=t[n],s=r.shape;if(!Nr.arraysEqual(a,s))throw Error("Binary was compiled with different shapes than the current args. Shapes ".concat(a," and ").concat(s," must match"));if(e.isUniform&&r.isUniform)return;let i=e.texShape,o=r.isUniform?null:r.texData.texShape;if(!Nr.arraysEqual(i,o))throw Error("Binary was compiled with different texture shapes than the current args. Shape ".concat(i," and ").concat(o," must match"))})}function qj(e){return Ue().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var Kj={R:0,G:1,B:2,A:3},Xj=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let a=mj();this.outputShape=e,this.enableShapeUniforms=qj(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){let e=n[i];s+="\n          if(offset == ".concat(i,") {\n            result = values[").concat(Kj[e],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":vj(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(a.texture2D,"(A, uv);\n          ").concat(s,"\n        }\n        ").concat(a.output," = vec4(").concat(r,", 0., 0., 0.);\n      }\n    ")}},Zj={};function Yj(e){let t=mj();return kM(e,"".concat(t.version,"\n    precision highp float;\n    ").concat(t.attribute," vec3 clipSpacePos;\n    ").concat(t.attribute," vec2 uv;\n    ").concat(t.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function Jj(e){return AM(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function Qj(e){return RM(e,new Uint16Array([0,1,2,2,1,3]))}function $j(e,t,n,a,r,s){MM(t,n);let i=FM(e),o=e.TEXTURE_2D;return yM(e,()=>e.bindTexture(o,i)),yM(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),yM(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),yM(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),yM(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),1===Ue().getNumber("WEBGL_VERSION")?yM(e,()=>e.texImage2D(o,0,a,t,n,0,r,s,null)):yM(e,()=>e.texStorage2D(o,1,a,t,n)),yM(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function ez(e){return e.internalFormatFloat}function tz(e,t,n,a){let[r,s]=fM(t,n);return $j(e,r,s,ez(a),a.textureFormatFloat,e.FLOAT)}function nz(e){return e.internalFormatHalfFloat}function az(e,t,n,a){let[r,s]=fM(t,n);return $j(e,r,s,nz(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function rz(e){return e.downloadTextureFormat}function sz(e,t,n,a){let[r,s]=fM(t,n);return $j(e,r,s,rz(a),e.RGBA,e.UNSIGNED_BYTE)}function iz(e){return e.internalFormatPackedFloat}function oz(e,t,n,a){let[r,s]=gM(t,n);return $j(e,r,s,iz(a),e.RGBA,e.FLOAT)}function cz(e){return e.internalFormatPackedHalfFloat}function lz(e,t,n,a){let[r,s]=gM(t,n);return $j(e,r,s,cz(a),e.RGBA,a.textureTypeHalfFloat)}function uz(e,t,n){return yM(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),zM(e,t,"clipSpacePos",n,3,20,0)&&zM(e,t,"uv",n,2,20,12)}function dz(e,t,n,a,r,s){let i,o,c;yM(e,()=>e.bindTexture(e.TEXTURE_2D,t)),r instanceof Uint8Array?(i=new Uint8Array(n*a*4),o=e.UNSIGNED_BYTE,c=e.RGBA):(i=new Float32Array(n*a*4),o=e.FLOAT,c=s.internalFormatPackedFloat),i.set(r),2===Ue().getNumber("WEBGL_VERSION")?yM(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,o,i)):yM(e,()=>e.texImage2D(e.TEXTURE_2D,0,c,n,a,0,e.RGBA,o,i)),yM(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function hz(e,t,n){yM(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?2===Ue().getNumber("WEBGL_VERSION")?yM(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):yM(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):2===Ue().getNumber("WEBGL_VERSION")?yM(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):yM(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),yM(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function pz(e,t,n,a){let r=e.createBuffer();yM(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));let s=16*t*n;return yM(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),yM(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),yM(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}function fz(e,t,n){let a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}function mz(e,t,n,a){let[r,s]=fM(t,n),i=new Uint8Array(function(e,t){return e*t}(t*n,4));return yM(e,()=>e.readPixels(0,0,r,s,a.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function gz(e,t,n,a,r,s,i,o){let c=e,l=new Float32Array(function(e,t){let[n,a]=gM(e,t);return n*a*4}(s,i));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}function bz(e,t,n){let a=new Float32Array(t*n*4);return yM(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a)),a}y(Zj,{bindVertexProgramAttributeStreams:()=>uz,createBufferFromOutputTexture:()=>pz,createFloat16MatrixTexture:()=>az,createFloat16PackedMatrixTexture:()=>lz,createFloat32MatrixTexture:()=>tz,createIndexBuffer:()=>Qj,createPackedMatrixTexture:()=>oz,createUnsignedBytesMatrixTexture:()=>sz,createVertexBuffer:()=>Jj,createVertexShader:()=>Yj,downloadByteEncodedFloatMatrixFromOutputTexture:()=>mz,downloadFloat32MatrixFromBuffer:()=>fz,downloadMatrixFromPackedOutputTexture:()=>bz,downloadPackedMatrixFromBuffer:()=>gz,getInternalFormatForFloat16MatrixTexture:()=>nz,getInternalFormatForFloat16PackedMatrixTexture:()=>cz,getInternalFormatForFloat32MatrixTexture:()=>ez,getInternalFormatForPackedMatrixTexture:()=>iz,getInternalFormatForUnsignedBytesMatrixTexture:()=>rz,uploadDenseMatrixToTexture:()=>dz,uploadPixelDataToTexture:()=>hz});var yz=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=Ue().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,hM(t,e)):this.gl=pM(t),e=this.gl,2===Ue().getNumber("WEBGL_VERSION")){let t=e;this.createVertexArray=()=>yM(t,()=>t.createVertexArray()),this.bindVertexArray=e=>yM(t,()=>t.bindVertexArray(e)),this.deleteVertexArray=e=>yM(t,()=>t.deleteVertexArray(e)),this.getVertexArray=()=>yM(t,()=>t.getParameter(t.VERTEX_ARRAY_BINDING))}else if(null!=e){let t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>yM(e,()=>t.createVertexArrayOES()),this.bindVertexArray=n=>yM(e,()=>t.bindVertexArrayOES(n)),this.deleteVertexArray=n=>yM(e,()=>t.deleteVertexArrayOES(n)),this.getVertexArray=()=>yM(e,()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Ue().getNumber("WEBGL_VERSION")){let e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=wM(this.gl,e),oj(this.gl,t))this.textureHalfFloatExtension=wM(this.gl,t);else if(Ue().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),oj(this.gl,a))this.colorBufferHalfFloatExtension=wM(this.gl,a);else if(Ue().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",oj(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!oj(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=Jj(this.gl),this.indexBuffer=Qj(this.gl),this.framebuffer=jM(this.gl),this.textureConfig=bM(this.gl,this.textureHalfFloatExtension)}get debug(){return Ue().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;yM(e,()=>e.finish()),yM(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),yM(e,()=>e.deleteFramebuffer(this.framebuffer)),yM(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),yM(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),yM(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),tz(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),az(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),sz(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),hz(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),dz(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),lz(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),oz(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(HM(this.gl,this.framebuffer),this.outputTexture=null),yM(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>mz(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,a,r,s){return gz(this.gl,e,0,0,0,r,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return fz(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let a=pz(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Ue().getBool("WEBGL_FENCE_API_ENABLED")){let a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let e=a.clientWaitSync(r,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=r}else Ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>bz(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=Yj(t));let n=CM(t);yM(t,()=>t.attachShader(n,this.vertexShader)),yM(t,()=>t.attachShader(n,e)),EM(t,n);let a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&_M(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;yM(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),uz(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(yM(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&_M(this.gl,this.program),yM(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?BM(this.gl,e,t):WM(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),yM(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),UM(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[a,r]=gM(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&_M(this.gl,this.program),qM(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}yM(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),yM(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=wM(this.gl,2===Ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Nr.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,Ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){let t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{let t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{let t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Ue().platform&&(n=Ue().platform.setTimeoutCustom.bind(Ue().platform)),Nr.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),GM(this.gl,e,this.framebuffer),this.debug&&qM(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(GM(this.gl,this.outputTexture,this.framebuffer),this.debug&&qM(this.gl)):HM(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let a=this.gl;GM(a,e,this.framebuffer),this.debug&&qM(a),this.outputTexture=e,yM(a,()=>a.viewport(0,0,t,n)),yM(a,()=>a.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),yM(this.gl,()=>this.gl.scissor(e,t,n,a))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}};var{addImpl:vz,bincountImpl:xz,bincountReduceImpl:wz,bitwiseAndImpl:kz,castImpl:Iz,ceilImpl:Sz,concatImpl:Nz,equalImpl:Tz,expImpl:Oz,expm1Impl:Cz,floorImpl:Ez,gatherNdImpl:_z,gatherV2Impl:Az,greaterImpl:Rz,greaterEqualImpl:Dz,lessImpl:Fz,lessEqualImpl:Mz,linSpaceImpl:jz,logImpl:zz,maxImpl:Lz,maximumImpl:Pz,minimumImpl:Bz,multiplyImpl:Wz,negImpl:Uz,notEqualImpl:Vz,prodImpl:Gz,raggedGatherImpl:Hz,raggedRangeImpl:qz,raggedTensorToTensorImpl:Kz,rangeImpl:Xz,rsqrtImpl:Zz,scatterImpl:Yz,sigmoidImpl:Jz,simpleAbsImpl:Qz,sliceImpl:$z,sparseFillEmptyRowsImpl:eL,sparseReshapeImpl:tL,sparseSegmentReductionImpl:nL,sqrtImpl:aL,staticRegexReplaceImpl:rL,stridedSliceImpl:sL,stringNGramsImpl:iL,stringSplitImpl:oL,stringToHashBucketFastImpl:cL,subImpl:lL,tileImpl:uL,topKImpl:dL,transposeImpl:hL,uniqueImpl:pL}=MC;function fL(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>"".concat(e,".").concat(t))}function mL(e,t){return 1===t?[e]:fL(e,t)}var gL=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=qj(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+="\n        ".concat(e,"\n        ").concat(a>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(a,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(a>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e,t){return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(t?function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",a=e.map((e,t)=>t),r=yj(a,t);return r.map((t,a)=>{let s="int ".concat(e[a]," = ").concat(n," / ").concat(r[a]),i=a===r.length-1?"int ".concat(e[a+1]," = ").concat(n," - ").concat(e[a]," * ").concat(r[a]):"index -= ".concat(e[a]," * ").concat(r[a]);return"".concat(s,"; ").concat(i,";")}).join("")}(["r","c","d"],"inputShape"):gj(["r","c","d"],e),"\n      return ivec3(r, c, d);\n    }\n  ")}(t,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":vj(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}};function bL(e,t,n,a,r){let s,i=function(e,t){switch(e){case lM.PACKED_2X2_FLOAT32:return iz(t);case lM.PACKED_2X2_FLOAT16:return cz(t);case lM.UNPACKED_FLOAT32:return ez(t);case lM.UNPACKED_FLOAT16:return nz(t);case lM.PACKED_4X1_UNSIGNED_BYTE:return rz(t);default:throw new Error("Unknown physical texture type ".concat(e))}}(t,a);if(r){let[t,n]=gM(e[0],e[1]);s=t*n}else{let[t,n]=fM(e[0],e[1]);s=t*n}return s*function(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(t))}(n,i)}function yL(e,t){if(e===cM.UPLOAD)return lM.PACKED_2X2_FLOAT32;if(e===cM.RENDER||null==e)return function(e){return Ue().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?lM.PACKED_2X2_FLOAT32:lM.UNPACKED_FLOAT32:e?lM.PACKED_2X2_FLOAT16:lM.UNPACKED_FLOAT16}(t);if(e===cM.DOWNLOAD||e===cM.PIXELS)return lM.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function vL(e,t,n){return"".concat(e[0],"_").concat(e[1],"_").concat(t,"_").concat(n)}var xL=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=qj(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}},wL="if (isnan(x)) return x;",kL="return x;",IL="return abs(x);",SL="return (x >= 0.0) ? x : (exp(x) - 1.0);",NL=wL+"\n  return (x < 0.0) ? 0.0 : x;\n",TL=wL+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",OL="return x;",CL="return 1.0 / (1.0 + exp(-1.0 * x));",EL="return x;",_L="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",AL="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",RL="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",DL="return 1.0 / (1.0 + exp(-1.0 * x));",FL=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=qj(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}},ML=Xm.whereImpl,jL={};var zL=Ue().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");var LL=class extends U{nextDataId(){return LL.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ue().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof yz)t=e;else{let n=pM(Ue().getNumber("WEBGL_VERSION"),e);t=new yz(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let e=pM(Ue().getNumber("WEBGL_VERSION"));t=new yz(e),this.binaryCache=function(e){return e in jL||(jL[e]={}),jL[e]}(Ue().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let a=yL(t,n),r=vL(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);let s,i=bL(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let e=this.freeTextures[r].pop();return this.usedTextures[r].push(e),e}return a===lM.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===lM.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===lM.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===lM.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===lM.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(s),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),s}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;let r=yL(n,a),s=vL(t,r,a);s in this.freeTextures||(this.freeTextures[s]=[]);let i=bL(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),o=Ue().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let c=this.usedTextures[s],l=c&&c.indexOf(e);if(null==l||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[l]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));let t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*t),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}(this.gpgpu),this.numMBBeforeWarning=null==Ue().global.screen?1024:Ue().global.screen.height*Ue().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new W(this,Ji())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,a,r,s){let i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[a,r]},o.texShape=[a,r];let c=QM(t),l=new Xj(c,!1,s),u=this.runWebGLProgram(l,[i],n,[[a,r]]);return u.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),u.dataId}write(e,t,n){if((Ue().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ue().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:cM.UPLOAD,refCount:1}),a}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,a,r){if(Ue().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:cM.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:a,complexTensorInfos:r,slice:s,shape:i,isPacked:o}=t;if(null!=s){let t;t=o?new FL(i,OL):new xL(i,OL);let n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:a}],a),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;let c,l,u=null!=this.activeTimers;if(u&&(c=Nr.now()),"complex64"===a){let e=this.readSync(r.real.dataId),t=this.readSync(r.imag.dataId);l=Hf.mergeRealAndImagArrays(e,t)}else l=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=Nr.now()-c),this.convertAndCacheOnCPU(e,l)}async read(e){if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}let t=this.texData.get(e),{values:n,shape:a,slice:r,dtype:s,complexTensorInfos:i,isPacked:o}=t;if(null!=r){let t;t=o?new FL(a,OL):new xL(a,OL);let n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:s}],s),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if(Ue().getBool("DEBUG")&&!Ue().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Ue().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,l,u=null;if("complex64"!==s&&Ue().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);let t=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...mM(a))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){let e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),t=e[0],n=e[1];l=Hf.mergeRealAndImagArrays(t,n)}else if(null==u)l=this.getValuesFromTexture(e);else{let e=Nr.sizeFromShape(a);l=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=u){let e=this.gpgpu.gl;yM(e,()=>e.deleteBuffer(u))}let d=this.convertAndCacheOnCPU(e,l),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(e=>e(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ji().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=this.texData.get(e),{values:a,shape:r,slice:s,dtype:i,isPacked:o,texture:c}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new FL(r,OL):new xL(r,OL);let a=this.runWebGLProgram(n,[{dataId:e,shape:r,dtype:i}],i),s=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),s}if(null==c)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let l=this.decode(e,t.customTexShape),u=Ji().makeTensorFromTensorInfo(l),d=this.texData.get(l.dataId);return Object.assign({tensorRef:u},d.texture)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map(e=>Nr.decodeString(e));return Ui(e.shape,e.dtype,n)}catch(hJ){throw new Error("Failed to decode encoded string bytes into utf-8")}return Ui(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){let n=e[t];if(!vM(n))throw Ue().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error("The value ".concat(n," cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'")):Error("The value ".concat(n," cannot be represented on this device."))}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:a}=this.texData.get(e),r=Nr.sizeFromShape(t);if(Ue().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let n=this.decode(e),a=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...mM(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),s}let s=Ue().getBool("WEBGL_PACK")&&!0===a,i=s?QM(t):t,o=s?new class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=cM.DOWNLOAD;let t=mj();this.outputShape=e,this.userCode="\n      ".concat(xj,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}(i):new class{constructor(e){this.variableNames=["A"],this.outTexUsage=cM.DOWNLOAD;let t=mj();this.outputShape=e,this.userCode="\n      ".concat(xj,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}(i),c=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),l=this.texData.get(c.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(c),u}timerAvailable(){return Ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();let r=Nr.flatten(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),s=Nr.flatten(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,a&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let e=await Promise.all(r);i.kernelMs=Nr.sum(e),i.getExtraProfileInfo=()=>e.map((e,t)=>({name:s[t],ms:e})).map(e=>"".concat(e.name,": ").concat(e.ms)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Nr.now(),endMs:null}}endTimer(e){return Ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Nr.now(),e)}async getQueryTime(e){if(Ue().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:a,usage:r,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,c=this.dataRefCount.get(o);c>1?this.dataRefCount.set(o,c-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,r,s)));let l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:zL;return Ue().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&Nr.sizeFromShape(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Hf.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return ML(e.shape,t)}packedUnaryOp(e,t,n){let a=new FL(e.shape,t),r=this.compileAndRun(a,[e],n);return Ji().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let t=Qz(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Ue().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,IL,e.dtype);let t=new xL(e.shape,IL),n=this.compileAndRun(t,[e]);return Ji().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Nr.isString(n[0])){let r=n.map(e=>Nr.encodeString(e));a=this.write(r,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){return Ji().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=qj(this.outputShape.length);let t=e.length,n=mL("rc",t),a=Bj(t),r=function(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),i=t<=1?"rc":"vec2(".concat(s.join(","),")");this.userCode="\n      void main() {\n        ".concat(a," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(r,");\n\n        setOutput(getChannel(packedInput, ").concat(i,"));\n      }\n    ")}}(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=qj(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{let e=mL("rc",this.rank),t=Bj(this.rank),n=this.getOutOfBoundsCondition(e),a=this.getSetup(e),r=this.getOutput(e);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(a,"\n\n            setOutput(vec4(").concat(r,"));\n          }\n        }\n      ")}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r="".concat(0===n?"r":"rp1",", ").concat(0===a?"c":"cp1");for(let t=2;t<this.rank;t++)r="".concat(e[e.length-1-t],",")+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+="".concat(e[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],a=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(t[0],";\n      int c = ").concat(t[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(a,";\n    ")}getOutput(e){let t=this.getSourceCoordsArr(e);return 1===this.rank?"getA(rc), (rc + 1 >= ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]," ? 0. : getA(rc + 1)), 0, 0"):"getA(".concat(t[0],"),\n            cEdge ? 0. : getA(").concat(t[1],"),\n            rEdge ? 0. : getA(").concat(t[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(t[3],")")}}(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){let n=[YM(e.shape),...JM(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},r=[YM(t),...JM(t)],s=new gL(r,n),i=[n],o=this.runWebGLProgram(s,[a],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:a,shape:r,dtype:s}=n;if(null!=t){let e=Nr.sizeFromShape(r),n=t[0]*t[1]*4;Nr.assert(e<=n,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let i,o=QM(r);i=a?new class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=oM.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=mj();this.outputShape=e,this.enableShapeUniforms=qj(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?bj(["r","c","d"],e):gj(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}(o):new class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=oM.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=mj();this.outputShape=e,this.enableShapeUniforms=qj(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?bj(["r","c","d"],e):gj(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}(o);let c=[null!=t?t:mM(o)];return{dtype:s,shape:r,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,c,!0,t).dataId}}runWebGLProgram(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0,i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===oM.DENSE){let t=null!=s?s:mM(e.outputShape);o.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===Nr.sizeFromShape(i.shape))return o.values=Nr.getTypedArrayFromDType(i.dtype,0),i;let c=[],l=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Nr.sizeFromShape(t.shape)<=Ue().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!tj(n.shape,t.shape)){let e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),c.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(i.dataId);let u,d={shape:i.shape,texData:o,isUniform:!1},h=function(e,t,n){let a="";t.concat(n).forEach(t=>{let r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let s=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:c}=Wj(e.packedInputs,t.shape,s),l="",u="",d="";if(1===o.length&&e.packedInputs){let e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];l="".concat(e[0]>1,"_").concat(e[1]>1)}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){let e=Nr.computeStrides(o);d="".concat(e[0]===s[1],"_").concat(e[e.length-1]===s[1])}}else u="".concat(o[0]>1,"_").concat(o[1]>1);let h=t.shape.length,p=2===o.length&&Nr.arraysEqual(t.shape,s),f=1===Nr.sizeFromShape(t.shape),m=Hf.getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&Nr.arraysEqual(s,n.texData.texShape),b=e.packedInputs||o.length>2?"":"".concat(s[0]>1,"_").concat(s[1]>1);a+="".concat(h,"_").concat(g,"_").concat(i?c:"","_").concat(o.length,"_").concat(f,"_").concat(m,"_").concat(p,"_").concat(l,"_").concat(u,"_").concat(d,"_").concat(b,"_").concat(r)}else{let e=t.isUniform?"uniform":t.texData.texShape;a+="".concat(t.shape,"_").concat(e,"_").concat(r)}});let r=e.userCode,s=e.constructor.name;return s+="_"+a+"_"+r+"".concat(Ue().getNumber("WEBGL_VERSION")),s}(e,l,d),p=this.getAndSaveBinary(h,()=>function(e,t,n,a){let r=n.map((e,n)=>{let a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}}),s=r.map(e=>e.shapeInfo),i={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},o=kj(r,i,t),c=IM(e.gl,o),l=e.createProgram(c);return Ue().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:o,webGLProgram:l,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:t,fragmentShader:c,source:o,webGLProgram:l,inShapeInfos:s,outShapeInfo:i},Gj(e,t,l)))}(this.gpgpu,e,l,d)),f=null!=this.activeTimers;f&&(u=this.startTimer()),Ue().get("ENGINE_COMPILE_ONLY")||function(e,t,n,a,r){t.program.enableShapeUniforms||(Hj(t.inShapeInfos,n),Hj([t.outShapeInfo],[a]));let s=a.texData.texture,i=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===Ue().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<n.length;++c){let a=n[c],{uniform:r,offset:s,shape:i,texShape:o}=t.variablesLocations[c];if(i){let{uniformShape:n}=Wj(t.program.packedInputs,a.shape,a.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,a.texData.texShape[0],a.texData.texShape[1]),null!=r){if(a.isUniform){if(Nr.sizeFromShape(a.shape)<2)e.gl.uniform1f(r,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(r,t)}continue}null!=a.texData.slice&&null!=s&&e.gl.uniform1i(s,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,r,c)}}let o=t.outShapeLocation;if(o)switch(a.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(a.shape))}if(t.outShapeStridesLocation){let n=Nr.computeStrides(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let c=0;c<t.program.customUniforms.length;++c){let n=t.program.customUniforms[c],a=t.customUniformLocations[c],s=r[c];if("float"===n.type)e.gl.uniform1fv(a,s);else if("vec2"===n.type)e.gl.uniform2fv(a,s);else if("vec3"===n.type)e.gl.uniform3fv(a,s);else if("vec4"===n.type)e.gl.uniform4fv(a,s);else if("int"===n.type)e.gl.uniform1iv(a,s);else if("ivec2"===n.type)e.gl.uniform2iv(a,s);else if("ivec3"===n.type)e.gl.uniform3iv(a,s);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));e.gl.uniform4iv(a,s)}}e.executeProgram()}(this.gpgpu,p,l,d,a),c.forEach(e=>this.disposeIntermediateTensorInfo(e)),f&&(u=this.endTimer(u),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(u)}));let m=Ue().get("WEBGL_FLUSH_THRESHOLD");if(m>0){let e=Nr.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Ue().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===r){let e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,a,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ue().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=eo(()=>{if(!Ue().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=Ue().getBool("DEBUG");Ue().set("DEBUG",!1);let t=this.abs(il(1e-8)).dataSync()[0];if(Ue().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:a,values:r,texture:s,usage:i,isPacked:o}=t;if(null!=s)return;let c,l=null!=this.activeTimers;l&&(c=Nr.now());let u=t.texShape;if(null==u&&(u=$M(n,o),t.texShape=u),null!=r){let e,s=QM(n),i=u[1],d=u[0],h=r instanceof Uint8Array||r instanceof Uint8ClampedArray;(o||!h)&&([i,d]=gM(u[0],u[1])),e=o?new class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=mj();this.outputShape=e,this.enableShapeUniforms=qj(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){let r=2*s+t;a+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(t," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(t,";\n          if (localCoords[1] + ").concat(s," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(s,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(r,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(r,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(r,"] = values[2];\n            } else {\n              result[").concat(r,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":vj(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a,"\n\n          ").concat(n.output," = ").concat(r,";\n        }\n    ")}}(s,h):new Xj(s,h);let p=h?[d,i]:u,f=this.makeTensorInfo(p,a),m=this.texData.get(f.dataId);m.usage=h?cM.PIXELS:cM.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,r);let g=[[d,i]],b=!0,y=this.runWebGLProgram(e,[f],a,g,b),v=this.texData.get(y.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,Ue().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=Nr.now()-c)}else{let e=this.acquireTexture(u,i,a,o);t.texture=e}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:a}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype ".concat(t))}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(e," MB, most likely due to a memory leak"))}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*Nr.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise(e=>{try{this.checkCompletion_(t),e(!0)}catch(uY){throw uY}});e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Vf(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(OM(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:t,customUniformLocations:n,infLoc:a,nanLoc:r,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=Gj(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=r,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";let{texture:a,height:r,width:s,channels:i}=e,o=Ji().backend;if(!o.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let c=o.writeTexture(a,t,n,r,s,i);return Ji().makeTensorFromDataId(c,t,n,o)}};LL.nextDataId=0;var PL="4.7.0";function BL(){Ue().set("WEBGL_FORCE_F16_TEXTURES",!0)}Ds.isBrowser()&&uo("webgl",()=>new LL,2);var WL={forceHalfFloat:BL},UL=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Hf.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=qj(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}},VL="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n",GL=class{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Hf.assertAndGetBroadcastShape(t,n);let r=this.outputShape.length;this.enableShapeUniforms=qj(r);let s="";if(a)if(0===r||1===Nr.sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s="\n          ".concat(Bj(r)," coords = getOutputCoords();\n        "),1===r)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{let e=mL("coords",r);this.enableShapeUniforms?s+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= outShape[").concat(r," - 2];\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= outShape[").concat(r," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):s+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= ").concat(this.outputShape[r-2],";\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= ").concat(this.outputShape[r-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(s,"\n\n        setOutput(result);\n      }\n    ")}};function HL(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var qL={kernelName:un,backendName:"webgl",kernelFunc:HL};function KL(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.makeTensorInfo(a.shape,"complex64"),i=n.texData.get(s.dataId),o=HL({inputs:{x:a},backend:n}),c=HL({inputs:{x:r},backend:n});return i.complexTensorInfos={real:o,imag:c},s}var XL={kernelName:xt,backendName:"webgl",kernelFunc:KL},ZL="return (a < 0.) ? b * a : a;",YL="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var JL={kernelName:gn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a,i=n.makeTensorInfo([],"float32",Nr.createScalarValue(s,"float32")),o=Ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new GL(YL,r.shape,i.shape):new UL(ZL,r.shape,i.shape),c=n.runWebGLProgram(o,[r,i],"float32");return n.disposeIntermediateTensorInfo(i),c}},QL="return (a < 0.) ? b * a : a;",$L="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var eP={kernelName:na,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=Ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new GL($L,a.shape,r.shape):new UL(QL,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],"float32")}};function tP(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:a,dtype:r}=e;return e=>{let s,{inputs:i,backend:o}=e,{x:c}=i,l=o,u=r||c.dtype;if(l.shouldExecuteOnCPU([c])&&null!=a){let e=l.texData.get(c.dataId),t=a(e.values,u);return l.makeTensorInfo(c.shape,u,t)}return s=Ue().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new FL(c.shape,n):new xL(c.shape,t),l.runWebGLProgram(s,[c],u)}}function nP(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:a=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}=e;return e=>{let{inputs:o,backend:c}=e,{a:l,b:u}=o,d=c;if(r&&"complex64"===l.dtype){let e=d.texData.get(l.dataId),n=d.texData.get(u.dataId),[a,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(e=>{let[n,a]=e,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:a.dataId,dtype:a.dtype,shape:u.shape},i=new UL(t,l.shape,u.shape);return d.runWebGLProgram(i,[r,s],ys(n.dtype,a.dtype))}),s=KL({inputs:{real:a,imag:r},backend:d});return d.disposeIntermediateTensorInfo(a),d.disposeIntermediateTensorInfo(r),s}let h,p=i||ys(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||d.shouldExecuteOnCPU([l,u]))&&null!=s){let e=d.texData.get(l.dataId).values,t=d.texData.get(u.dataId).values,n="string"===l.dtype?Hf.fromUint8ToStringArray(e):e,a="string"===l.dtype?Hf.fromUint8ToStringArray(t):t,[r,i]=s(l.shape,u.shape,n,a,p),o=d.makeTensorInfo(i,p);return d.texData.get(o.dataId).values=r,o}return h=Ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new GL(n,l.shape,u.shape,a):new UL(t,l.shape,u.shape),d.runWebGLProgram(h,[l,u],p)}}function aP(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?EL:kL;if("relu"===e)return t?AL:NL;if("elu"===e)return t?_L:SL;if("relu6"===e)return t?RL:TL;if("prelu"===e)return t?$L:QL;if("leakyrelu"===e)return t?YL:ZL;if("sigmoid"===e)return t?DL:CL;throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}var rP=class{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=qj(this.outputShape.length);let l=a?e[1]:e[2],u=Math.ceil(l/2),d=a?"i * 2, rc.y":"rc.y, i * 2",h=r?"rc.z, i * 2":"i * 2, rc.z",p=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(m=o?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(i,"\n        }"):c?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(i,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(i,"\n        }"),g="result = activation(result);");let b=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let y="rc.x",v="rc.x";e[0]<t[0]?y="imod(rc.x, ".concat(e[0],")"):t[0]<e[0]&&(v="imod(rc.x, ".concat(t[0],")")),this.userCode="\n      ".concat(m,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(y,";\n        int batchB = ").concat(v,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(d,");\n          vec4 b = getMatrixB(batchB, ").concat(h,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(b,"\n\n        ").concat(g,"\n\n        setOutput(result);\n      }\n    ")}},sP="return areal * breal - aimag * bimag;",iP="return areal * bimag + aimag * breal;",oP=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Hf.assertAndGetBroadcastShape(t,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}},cP="return a * b;";function lP(e){let t,{inputs:n,backend:a}=e,{a:r,b:s}=n,i=Hf.upcastType(r.dtype,s.dtype);if("complex64"===r.dtype){let e=a.texData.get(r.dataId),t=a.texData.get(s.dataId),n=new oP(sP,r.shape,s.shape),i=new oP(iP,r.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],c=a.runWebGLProgram(n,o,"float32"),l=a.runWebGLProgram(i,o,"float32"),u=KL({inputs:{real:c,imag:l},backend:a});return a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(l),u}if(a.shouldExecuteOnCPU([r,s])){let e=a.texData.get(r.dataId),t=a.texData.get(s.dataId),[n,o]=Wz(r.shape,s.shape,e.values,t.values,i),c=a.makeTensorInfo(o,i);return a.texData.get(c.dataId).values=n,c}return t=Ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new GL(cP,r.shape,s.shape):new UL(cP,r.shape,s.shape),a.runWebGLProgram(t,[r,s],i)}var uP={kernelName:Gn,backendName:"webgl",kernelFunc:lP};function dP(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=n,o=Nr.sizeFromShape(r.shape),c=Nr.inferFromImplicitShape(s,o),l=Nr.sizeFromShape(c);Nr.assert(o===l,()=>"The new shape (".concat(c,") has ").concat(l," elements and the old shape (").concat(r.shape,") has ").concat(o," elements. The new shape and old shape must have the same number of elements."));let u=i.texData.get(r.dataId);return!u.isPacked||tj(r.shape,c)||null!==u.texture&&tj(u.shape,c)?(i.incRef(r.dataId),{dataId:r.dataId,shape:c,dtype:r.dtype}):function(e,t,n){let a=[YM(e.shape),...JM(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},s=[YM(t),...JM(t)],i=new gL(s,a),o=[a],c=n.runWebGLProgram(i,[r],e.dtype,o,!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(r,c,i)}var hP={kernelName:da,backendName:"webgl",kernelFunc:dP},pP=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let i=4*Math.floor(n/4),o=n%4,c="sumValue += dot(values, ones);";if(null!=t){let e=1/t;c="sumValue += dot(values * ".concat(Nr.isInt(e)?e.toPrecision(2):e,", ones);")}let l="";r%n>0&&(l="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(l,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===o,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(2===o,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(3===o,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(c,"\n        }\n        setOutput(sumValue);\n      }\n    ")}},fP=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let c="".concat(t,"(").concat(t,"(").concat(t,"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])");"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");let l=4*Math.floor(n/4),u=n%4,d="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(o,"(values, minMaxValue);\n        if (").concat("min"===t," || ").concat("max"===t,") {\n          minMaxValue = ").concat(o,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";r%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(i,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(i,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(l,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(d,"\n        }\n\n        int inIdx = inOffset + ").concat(l,";\n        if (").concat(1===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(2===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(3===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(d,"\n        }\n        setOutput(").concat(c,");\n      }\n    ")}};function mP(e,t,n,a){let r=function(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let n=t.length?t[t.length-1].outSize:e[1],a=Hf.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}(e.shape),s=e;for(let i=0;i<r.length;i++){let o,c,{inSize:l,windowSize:u,outSize:d}=r[i];o="mean"===n?0===i?new pP({windowSize:u,inSize:l,batchSize:e.shape[0],outSize:d},l):new pP({windowSize:u,inSize:l,batchSize:e.shape[0],outSize:d}):new fP({windowSize:u,inSize:l,batchSize:e.shape[0],outSize:d},n),c=s,s=a.runWebGLProgram(o,[s],t),c.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(c)}return s}function gP(e,t,n){let a=Ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));let a=Bj(this.rank),r=fL("rc",this.rank),s=new Array(this.rank);for(let l=0;l<t.length;l++)s[t[l]]=r[l];let i="vec2(".concat(s.slice(-2).join(),")"),o="++".concat(r[this.rank-1]," < ").concat(n[this.rank-1]),c="getChannel(getA(".concat(s.join(),"), ").concat(i,")");this.userCode="\n    void main() {\n      ".concat(a," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(c,";\n      if(").concat(o,") {\n        result[1] = ").concat(c,";\n      }\n      --").concat(r[this.rank-1],";\n      if(++").concat(r[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(c,";\n        if(").concat(o,") {\n          result[3] = ").concat(c,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}(e.shape,t):new class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let a=Bj(this.rank),r=function(e){let t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}(t);this.userCode="\n    void main() {\n      ".concat(a," resRC = getOutputCoords();\n      setOutput(getA(").concat(r,"));\n    }\n    ")}}(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function bP(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;return function(e,t,n,a){let r=t,s=e.shape.length,i=Nr.parseAxisParam(r,e.shape),o=i,c=Hf.getAxesPermutation(o,s),l=null!=c,u=e;l&&(u=gP(e,c,a),o=Hf.getInnerMostAxes(o.length,s)),Hf.assertAxesAreInnerMostDims("sum",o,s);let[d,h]=Hf.computeOutAndReduceShapes(u.shape,o),p=d;n&&(p=Hf.expandShapeToKeepDim(d,i));let f=Nr.sizeFromShape(h),m=dP({inputs:{x:u},attrs:{shape:[Nr.sizeFromShape(e.shape)/f,f]},backend:a}),g=mP(m,vs(e.dtype),"sum",a),b=dP({inputs:{x:g},attrs:{shape:p},backend:a});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),l&&a.disposeIntermediateTensorInfo(u),b}(r,s,i,n)}var yP={kernelName:Ra,backendName:"webgl",kernelFunc:bP};function vP(e){let t,{inputs:n,backend:a,attrs:r}=e,{x:s}=n,{perm:i}=r,o=a,c=s.shape.length,l=new Array(c);for(let u=0;u<l.length;u++)l[u]=s.shape[i[u]];if(o.shouldExecuteOnCPU([s])){let e=o.texData.get(s.dataId).values,n=hL(e,s.shape,s.dtype,i,l);t=o.makeTensorInfo(l,s.dtype),o.texData.get(t.dataId).values=n}else t=gP(s,i,o);return t}var xP={kernelName:er,backendName:"webgl",kernelFunc:vP};function wP(e){let{a:t,b:n,transposeA:a,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:c=0,activation:l=null}=e,u=t.shape.length,d=n.shape.length,h=a?t.shape[u-2]:t.shape[u-1],p=r?n.shape[d-1]:n.shape[d-2],f=a?t.shape[u-1]:t.shape[u-2],m=r?n.shape[d-2]:n.shape[d-1],g=t.shape.slice(0,-2),b=n.shape.slice(0,-2),y=Nr.sizeFromShape(g),v=Nr.sizeFromShape(b),x=jc.assertAndGetBroadcastShape(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);Nr.assert(h===p,()=>"Error in matMul: inner shapes (".concat(h,") and (").concat(p,") of Tensors with shapes ").concat(t.shape," and ").concat(n.shape," and transposeA=").concat(a," and transposeB=").concat(r," must match."));let w,k=a?[y,h,f]:[y,f,h],I=r?[v,m,p]:[v,p,m],S=dP({inputs:{x:t},backend:s,attrs:{shape:k}}),N=dP({inputs:{x:n},backend:s,attrs:{shape:I}}),T=[S,N],O=Math.max(y,v),C=a?S.shape[1]:S.shape[2],E=null!=i,_=null!=o,A="leakyrelu"===l,R=null!=l?aP(l,!0):null;if((1===f||1===m)&&C>1e3&&!1===(E||_||A||null!=R)){let e=S,t=N;a&&(e=vP({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),T.push(e)),r&&(t=vP({inputs:{x:N},backend:s,attrs:{perm:[0,2,1]}}),T.push(t));let n=1===m,i=e;1!==m&&(i=dP({inputs:{x:e},backend:s,attrs:{shape:[O,C,1]}}),T.push(i));let o=1===m?2:1,c=t;n&&(c=dP({inputs:{x:t},backend:s,attrs:{shape:[O,1,C]}}),T.push(c));let l=lP({inputs:{a:i,b:c},backend:s});w=bP({inputs:{x:l},backend:s,attrs:{axis:o,keepDims:!0}}),T.push(l)}else{let e=ys(t.dtype,n.dtype),l=new rP(k,I,[O,f,m],a,r,E,R,_,A),u=[S,N];if(null!=i&&u.push(i),_&&u.push(o),A){let e=s.makeTensorInfo([],"float32",Nr.createScalarValue(c,"float32"));u.push(e),T.push(e)}w=s.runWebGLProgram(l,u,e)}let D=dP({inputs:{x:w},backend:s,attrs:{shape:x}});T.push(w);for(let F of T)s.disposeIntermediateTensorInfo(F);return D}var kP={kernelName:lr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=a;return wP({a:r,b:s,transposeA:c,transposeB:l,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:u})}},IP="return abs(x);";var SP={kernelName:Ke,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:a}=e,{x:r}=n;if(a.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){let e=a.texData.get(r.dataId),t=Qz(e.values);return a.makeTensorInfo(r.shape,r.dtype,t)}return t=Ue().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new FL(r.shape,IP):new xL(r.shape,IP),a.runWebGLProgram(t,[r],r.dtype)}},NP=tP({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),TP={kernelName:Xe,backendName:"webgl",kernelFunc:NP},OP=tP({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),CP={kernelName:Ze,backendName:"webgl",kernelFunc:OP},EP="return a + b;",_P=nP({opSnippet:EP,packedOpSnippet:EP,supportsComplex:!0,cpuKernelImpl:vz}),AP={kernelName:Ye,backendName:"webgl",kernelFunc:_P};var RP={kernelName:Je,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:a}=t,r=n;if(1===r.length)return HL({inputs:{x:r[0]},backend:a});if(r.length>Ue().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let t=Math.floor(r.length/2),n=e({inputs:r.slice(0,t),backend:a}),s=e({inputs:r.slice(t),backend:a});return e({inputs:[n,s],backend:a})}let s=r.map(e=>e.dtype).reduce((e,t)=>ys(e,t)),i=r.map(e=>e.shape),o=Ue().getBool("WEBGL_PACK")?new class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>"T".concat(t));let n=[];this.variableNames.forEach(e=>{n.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))});let a=this.variableNames.map(e=>"v".concat(e)).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}(r[0].shape,i):new class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>"T".concat(t));let n=[];this.variableNames.forEach(e=>{n.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))});let a=this.variableNames.map(e=>"v".concat(e)).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}(r[0].shape,i);return a.runWebGLProgram(o,r,s)}};var DP={kernelName:Qe,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,c=Nr.parseAxisParam(s,r.shape),l=c,u=Hf.getAxesPermutation(l,o),d=r;null!=u&&(d=vP({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Hf.getInnerMostAxes(l.length,o)),Hf.assertAxesAreInnerMostDims("all",l,o);let h,[p,f]=Hf.computeOutAndReduceShapes(d.shape,l),m=dP({inputs:{x:d},backend:n,attrs:{shape:[-1,Nr.sizeFromShape(f)]}}),g=mP(m,m.dtype,"all",n);if(i){h=dP({inputs:{x:g},backend:n,attrs:{shape:Hf.expandShapeToKeepDim(p,c)}})}else h=dP({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(d),h}};var FP={kernelName:$e,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,c=Nr.parseAxisParam(s,r.shape),l=c,u=Hf.getAxesPermutation(l,o),d=r;null!=u&&(d=vP({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Hf.getInnerMostAxes(l.length,o)),Hf.assertAxesAreInnerMostDims("any",l,o);let h,[p,f]=Hf.computeOutAndReduceShapes(d.shape,l),m=dP({inputs:{x:d},backend:n,attrs:{shape:[-1,Nr.sizeFromShape(f)]}}),g=mP(m,m.dtype,"any",n);if(i){h=dP({inputs:{x:g},backend:n,attrs:{shape:Hf.expandShapeToKeepDim(p,c)}})}else h=dP({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(d),h}},MP=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:a,batchSize:r,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,s];let i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          int inIdx = ").concat(o,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(i," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}},jP=class{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Nr.assert(e.length>2,()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2."));let r=e[e.length-1],s=Math.ceil(r/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),a||this.variableNames.push("bestIndicesA");let i,o,c=this.outputShape,l=c.length,u=Bj(l),d=mL("coords",l);if(1===s){o=l+1;let e=Bj(o);i="\n        ".concat(e," sourceLocR = ").concat(e,"(").concat(d.join(),", 0);\n        ++").concat(d[l-1],";\n        ").concat(e," sourceLocG = ").concat(e,"(").concat(d.join(),", 0);\n        ++").concat(d[l-2],";\n        ").concat(e," sourceLocA = ").concat(e,"(").concat(d.join(),", 0);\n        --").concat(d[l-1],";\n        ").concat(e," sourceLocB = ").concat(e,"(").concat(d.join(),", 0);\n        --").concat(d[l-2],";")}else o=l,i="\n        ".concat(u," sourceLocR = coords;\n        ++").concat(d[l-1],";\n        ").concat(u," sourceLocG = coords;\n        ++").concat(d[l-2],";\n        ").concat(u," sourceLocA = coords;\n        --").concat(d[l-1],";\n        ").concat(u," sourceLocB = coords;\n        --").concat(d[l-2],";");let h=["x","y","z","w","u","v"].slice(0,o),p="."+h[o-1],f=h.map(e=>"int "+e),m=mL("sourceLocR",o-1).concat("inIdx.r"),g=mL("sourceLocG",o-1).concat("inIdx.g"),b=mL("sourceLocB",o-1).concat("inIdx.b"),y=mL("sourceLocA",o-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=a?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),")));"),w="vec4(\n            getAChannel(".concat(m.join(),"),\n            hasNextCol ? getAChannel(").concat(g.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(b.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(y.join(),") : 0.)"),k=a?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(h.join(),"),\n                                          vec2(").concat(h.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(h.join(),"),\n                               vec2(").concat(h.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(u," coords = getOutputCoords();\n        bool hasNextCol = ").concat(d[l-1]," < ").concat(c[l-1]-1,";\n        bool hasNextRow = ").concat(d[l-2]," < ").concat(c[l-2]-1,";\n        ").concat(i,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(x,"\n          vec4 candidate = ").concat(w,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(v,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}};function zP(e,t,n,a){let r=[n];if(Hf.assertAxesAreInnerMostDims("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!Ue().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let n=[],s=e.texData.get(t.dataId),i=t;null!==s&&s.isPacked&&(i=e.unpackTensor(t),n.push(i));let[o,c]=Hf.computeOutAndReduceShapes(i.shape,r),l=Nr.sizeFromShape(c),u=dP({inputs:{x:i},backend:e,attrs:{shape:[-1,l]}});n.push(u);let d=function e(t,n,a){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=n.shape[0],i=n.shape[1];null!=r&&(s=r.shape[0],i=r.shape[1]);let o=Hf.computeOptimalWindowSize(i),c={windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},l=new MP(c,a,null==r),u=[n];null!=r&&u.push(r);let d=t.runWebGLProgram(l,u,"int32");if(1===d.shape[1])return d;let h=e(t,n,a,d);return t.disposeIntermediateTensorInfo(d),h}(e,u,a);n.push(d);let h=dP({inputs:{x:d},backend:e,attrs:{shape:o}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),h}return function e(t,n,a){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=null!=r?r.shape:n.shape,i=s[s.length-1],o=Hf.computeOptimalWindowSize(i),c=new jP(s,o,a,null==r),l=null==r?[n]:[n,r],u=t.runWebGLProgram(c,l,"int32");if(u.shape.length===n.shape.length){let r=e(t,n,a,u);return t.disposeIntermediateTensorInfo(u),r}return u}(e,t,a)}var LP={kernelName:et,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a,i=Nr.parseAxisParam(s,r.shape),o=Hf.getAxesPermutation(i,r.shape.length),c=r,l=[];null!=o&&(c=vP({inputs:{x:r},backend:n,attrs:{perm:o}}),l.push(c),i=Hf.getInnerMostAxes(i.length,c.shape.length)),Hf.assertAxesAreInnerMostDims("argMax",[i[0]],c.shape.length);let u=zP(n,c,i[0],"max");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}};var PP={kernelName:tt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a,i=Nr.parseAxisParam(s,r.shape),o=Hf.getAxesPermutation(i,r.shape.length),c=r,l=[];null!=o&&(c=vP({inputs:{x:r},backend:n,attrs:{perm:o}}),l.push(c),i=Hf.getInnerMostAxes(i.length,c.shape.length)),Hf.assertAxesAreInnerMostDims("argMin",[i[0]],c.shape.length);let u=zP(n,c,i[0],"min");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}},BP=tP({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),WP={kernelName:nt,backendName:"webgl",kernelFunc:BP},UP=tP({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),VP={kernelName:at,backendName:"webgl",kernelFunc:UP},GP=tP({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),HP={kernelName:rt,backendName:"webgl",kernelFunc:GP},qP=nP({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),KP={kernelName:it,backendName:"webgl",kernelFunc:qP},XP=tP({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),ZP={kernelName:st,backendName:"webgl",kernelFunc:XP},YP=class{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;let f="avg"===t,m="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),g="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),b="0.0";if(f||(b="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(i,", ").concat(o,");\n        const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(c,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(l,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(t," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a?r?m:g:"wR * ".concat(d," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let y="".concat(t,"(").concat(t,"(").concat(t,"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])");"avg"===t&&(y="avgValue / max(count, 1.0)");let v=4*Math.floor(s/4),x=s%4,w="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(i,", ").concat(o,");\n      const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n      const float initializationValue = ").concat(b,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(b,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(c,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(v,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              getValue(batch, xR, xC + 3 * ").concat(l,", d)\n            );\n\n            ").concat(w,"\n          }\n\n          int xC = xCCorner + ").concat(v,";\n          if (").concat(1===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(2===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(3===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              initializationValue\n            );\n\n            ").concat(w,"\n          }\n        }\n        setOutput(").concat(y,");\n      }\n    ")}},JP=class{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;let y="avg"===t,v="0.0";if(y||(v="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(i,", ").concat(o,", ").concat(c,");\n        const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(b,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(h,";\n              wD += ").concat(l,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(d,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(t," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a?r?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let x="".concat(t,"(").concat(t,"(").concat(t,"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])");"avg"===t&&(x="avgValue / max(count, 1.0)");let w=4*Math.floor(s/4),k=s%4,I="\n      if (".concat(y,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(i,", ").concat(o,", ").concat(c,");\n      const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(b,");\n      const float initializationValue = ").concat(v,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(v,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(h,";\n            wD += ").concat(l,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(d,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(d,", ch)\n              );\n\n              ").concat(I,"\n            }\n\n            int xC = xCCorner + ").concat(w,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                initializationValue\n              );\n\n              ").concat(I,"\n            }\n          }\n        }\n        setOutput(").concat(x,");\n      }\n    ")}};var QP={kernelName:ot,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;pj(r,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:c}=a;Nr.assert(Hf.eitherStridesOrDilationsAreOne(i,1),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides ".concat(i," and dilations '").concat(1,"'"));let l=Hf.computePool2DInfo(r.shape,s,i,1,o,c);if(1===l.filterWidth&&1===l.filterHeight&&Nr.arraysEqual(l.inShape,l.outShape))return HL({inputs:{x:r},backend:n});let u=new YP(l,"avg",!1);return n.runWebGLProgram(u,[r],"float32")}};var $P={kernelName:lt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:c,dataFormat:l}=a,u=Hf.computePool3DInfo(r.shape,s,i,[1,1,1],o,c,l),d=new JP(u,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}};var eB={kernelName:ut,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=a,d=Hf.computePool3DInfo(i.shape,o,c,[1,1,1],l,u),h=new class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*a);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(m,");\n      const float avgMultiplier = float(").concat(g,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(o,") {\n          float dyD = float(dyDCorner + wD) / ").concat(r,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(d,";\n              wR += ").concat(c,") {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(l,") {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}(d);return n.runWebGLProgram(h,[r],i.dtype)}};var tB={kernelName:ct,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;pj([r,s],"avgPoolGrad");let{filterSize:o,strides:c,pad:l}=a,u=Hf.computePool2DInfo(i.shape,o,c,1,l),d=new class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=o-1-e.padInfo.top,u=c-1-e.padInfo.left,d=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(l,", ").concat(u,");\n      const float avgMultiplier = float(").concat(d,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(o,";\n            wR += ").concat(s,") {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(c,";\n            wC+= ").concat(i,") {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}(u);return n.runWebGLProgram(d,[r],i.dtype)}};var nB={kernelName:dt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;return wP({a:r,b:s,transposeA:i,transposeB:o,backend:n})}},aB={kernelName:rn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r,mean:s,variance:i,offset:o,scale:c}=t;Nr.assert(s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Nr.assert(null==o||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Nr.assert(null==c||s.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=a;null==l&&(l=.001);let u=[r,s,i],d=null;null!=o&&(d=o.shape,u.push(o));let h=null;null!=c&&(h=c.shape,u.push(c));let p=Ue().getBool("WEBGL_PACK_NORMALIZATION")?new class{constructor(e,t,n,a,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Hf.assertAndGetBroadcastShape(e,t),Hf.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";null!=a&&(Hf.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=r&&(Hf.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(i,";\n        vec4 scale = ").concat(o,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(s,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}(r.shape,s.shape,i.shape,d,h,l):new class{constructor(e,t,n,a,r,s){this.outputShape=[],this.variableNames=["x","mean","variance"],Hf.assertAndGetBroadcastShape(e,t),Hf.assertAndGetBroadcastShape(e,n);let i="0.0";null!=a&&(Hf.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=r&&(Hf.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(i,";\n        float scale = ").concat(o,";\n        float inv = scale * inversesqrt(variance + float(").concat(s,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}(r.shape,s.shape,i.shape,d,h,l);return n.runWebGLProgram(p,u,u[0].dtype)}},rB=["x","y","z","w","u","v"];function sB(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a,[o,c]=wf.parseSliceParams(r,s,i);if(wf.assertParamsValid(r,o,c),0===Nr.sizeFromShape(c))return n.makeTensorInfo(c,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){let e=n.texData.get(r.dataId),t=$z(e.values,o,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,t)}let{isPacked:l}=n.texData.get(r.dataId),u=wf.isSliceContinous(r.shape,o,c);if(l||!u){let e=Ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=Bj(this.rank),n=mL("coords",this.rank),a=mL("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":"vec2(".concat(a.slice(-2).join(),")"),s="getChannel(getSource(".concat(a.join(),"), ").concat(r,")"),i="\n      result.x = ".concat(s,";\n      if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(a[this.rank-1],";\n        result.y = ").concat(s,";\n        --").concat(a[this.rank-1],";\n      }\n    "),o=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(a[this.rank-2],";\n        result.z = ").concat(s,";\n        if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(a[this.rank-1],";\n          result.w = ").concat(s,";\n        }\n      }\n    "),c=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(e.map((e,t)=>"start[".concat(t,"]")).join(),");"):e.map((e,t)=>"".concat(a[t]," = ").concat(n[t]," + start[").concat(t,"];")).join("\n");this.userCode="\n      void main() {\n        ".concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(c,"\n        vec4 result = vec4(0.);\n        ").concat(i,"\n        ").concat(o,"\n        setOutput(result);\n      }\n    ")}}(c):new class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=Bj(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n,a=function(e){if(1===e)return"sourceLoc";if(e<=6)return rB.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank),r=e.map((e,t)=>"sourceLoc.".concat(rB[t]," = start[").concat(t,"] + coords.").concat(rB[t],";"));n="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(r.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(n,"\n        setOutput(getSource(").concat(a,"));\n      }\n    ")}}(c),t=[o];return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),function(e,t,n,a){let r=a.texData.get(e.dataId),s=a.makeTensorInfo(n,e.dtype),i=a.texData.get(s.dataId);Object.assign(i,r),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=wf.computeFlatOffset(t,Nr.computeStrides(e.shape));r.slice&&(o+=r.slice.flatOffset),i.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||e.dataId};let c=a.dataRefCount.get(i.slice.origDataId)||1;return a.dataRefCount.set(i.slice.origDataId,c+1),s}(r,o,c,n)}var iB={kernelName:Na,backendName:"webgl",kernelFunc:sB},oB={kernelName:ht,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;Nr.assert(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((e,t)=>e*t),c=Hf.getReshaped(r.shape,s,o),l=Hf.getPermuted(c.length,s.length),u=Hf.getReshapedPermuted(r.shape,s,o),d=Hf.getSliceBeginCoords(i,s.length),h=Hf.getSliceSize(u,i,s.length),p=[],f=dP({inputs:{x:r},backend:n,attrs:{shape:c}}),m=vP({inputs:{x:f},backend:n,attrs:{perm:l}}),g=dP({inputs:{x:m},backend:n,attrs:{shape:u}}),b=sB({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}};var cB={kernelName:pt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.readSync(r.dataId),c=n.readSync(s.dataId),l=xz(o,c,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,l)}};var lB={kernelName:ft,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:a}=e,{a:r,b:s}=n,i=Ue().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Ue().getNumber("WEBGL_VERSION");if(a.shouldExecuteOnCPU([r,s])||1===o){let e=a.texData.get(r.dataId).values,t=a.texData.get(s.dataId).values,[n,i]=kz(r.shape,s.shape,e,t,r.dtype),o=a.makeTensorInfo(i,r.dtype);return a.texData.get(o.dataId).values=n,o}return t=i?new GL("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,s.shape,!1):new UL("\n  return float(int(a.r) & int(b.r));\n",r.shape,s.shape),a.runWebGLProgram(t,[r,s],r.dtype)}};var uB={kernelName:gt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.readSync(a.dataId),i=n.readSync(r.dataId),o=Hf.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},dB=nP({opSnippet:"return float(a != b);",cpuKernelImpl:Vz,dtype:"bool"}),hB={kernelName:qn,backendName:"webgl",kernelFunc:dB};function pB(e){let{inputs:t,backend:n}=e,{input:a}=t;return HL({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}var fB={kernelName:ca,backendName:"webgl",kernelFunc:pB};var mB={kernelName:bt,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:a,attrs:r}=t,{x:s}=n,{dtype:i}=r;if("complex64"===i){if("complex64"===s.dtype)return HL({inputs:{x:s},backend:a});let t=ru(s.shape),n=e({inputs:{x:s},backend:a,attrs:{dtype:"float32"}}),r=KL({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeIntermediateTensorInfo(n),r}if("complex64"===s.dtype){let t=pB({inputs:{input:s},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:i}});return a.disposeIntermediateTensorInfo(t),n}if(!Nr.hasEncodingLoss(s.dtype,i)){let e=HL({inputs:{x:s},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(a.shouldExecuteOnCPU([s])){let e=a.texData.get(s.dataId).values,[t,n,r]=Iz(e,s.shape,s.dtype,i);return a.makeTensorInfo(t,n,r)}if("int32"===i)return function(e,t){let n=new xL(e.shape,"return float(int(x));"),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(s,a);if("bool"===i){let e=a.makeTensorInfo([],"bool",Nr.getTypedArrayFromDType("bool",1)),t=dB({inputs:{a:s,b:e},backend:a});return a.disposeIntermediateTensorInfo(e),t}throw new Error("Error in Cast: failed to cast ".concat(s.dtype," to ").concat(i))}},gB="return ceil(x);",bB=tP({opSnippet:gB,packedOpSnippet:gB,cpuKernelImpl:Sz}),yB={kernelName:yt,backendName:"webgl",kernelFunc:bB};var vB={kernelName:vt,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:a,attrs:r}=e,{x:s}=n,{clipValueMin:i,clipValueMax:o}=r;t=Ue().getBool("WEBGL_PACK_CLIP")?new class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}(s.shape):new class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}(s.shape);let c=[[i],[o]];return a.runWebGLProgram(t,[s],s.dtype,c)}};function xB(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}var wB={kernelName:wt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),s=new class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}(a.shape),i=[xB(a,r.complexTensorInfos.real),xB(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}};function kB(e,t,n){let a=e.indexOf(t);return e.map((e,t)=>t===a?"".concat(e," - ").concat(n):e).join()}function IB(e){let{inputs:t,backend:n}=e,{input:a}=t;return HL({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}var SB={kernelName:hn,backendName:"webgl",kernelFunc:IB};function NB(e,t,n){let a=e[0].dtype;if("complex64"===a){let a=e.map(e=>pB({inputs:{input:e},backend:n})),r=e.map(e=>IB({inputs:{input:e},backend:n})),s=NB(a,t,n),i=NB(r,t,n),o=KL({inputs:{real:s,imag:i},backend:n});return a.forEach(e=>n.disposeIntermediateTensorInfo(e)),r.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}let r=n.shouldExecuteOnCPU(e);if("string"===a&&(r=!0),r){let r=e.map(e=>{let a=[-1,Nr.sizeFromShape(e.shape.slice(t))];return dP({inputs:{x:e},backend:n,attrs:{shape:a}})}),s=r.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),i=Hf.computeOutShape(r.map(e=>e.shape),1),o=1===r[0].shape[0],c=Nz(s,i,a,o),l=Hf.computeOutShape(e.map(e=>e.shape),t),u=n.makeTensorInfo(l,a,c);return r.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}let s=e.filter(e=>Nr.sizeFromShape(e.shape)>0),i=Ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){let t=i?new xL(e[0].shape,OL):new FL(e[0].shape,OL);return n.runWebGLProgram(t,e,a)}let o=Ue().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let e=[];for(let r=0;r<s.length;r+=o){let a=s.slice(r,r+o);e.push(NB(a,t,n))}let a=NB(e,t,n);for(let t of e)n.disposeIntermediateTensorInfo(t);return a}if(i){let e=new class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Hf.computeOutShape(e,t);let n=this.outputShape,a=n.length,r=Bj(a),s=mL("coords",a),i=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map((e,t)=>"T".concat(t));let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let c=i[t],l=i.slice(-2),u=i.join(),d="if (".concat(c," < ").concat(o[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(l.join(),"));\n        }");for(let f=1;f<o.length;f++){let e=o[f-1];d+="\n        if (".concat(c," < ").concat(o[f],"  && ").concat(c," >= ").concat(o[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(kB(i,c,e),"),\n            vec2(").concat(kB(l,c,e),"));\n        }")}let h=o.length,p=o[o.length-1];d+="\n        return getChannel(\n          getT".concat(h,"(").concat(kB(i,c,p),"),\n          vec2(").concat(kB(l,c,p),"));"),this.userCode="\n      float getValue(".concat(i.map(e=>"int "+e),") {\n        ").concat(d,"\n      }\n\n      void main() {\n        ").concat(r," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(s,"), 0., 0., 0.);\n\n        ").concat(s[a-1]," = ").concat(s[a-1]," + 1;\n        if (").concat(s[a-1]," < ").concat(n[a-1],") {\n          result.g = getValue(").concat(s,");\n        }\n\n        ").concat(s[a-2]," = ").concat(s[a-2]," + 1;\n        if (").concat(s[a-2]," < ").concat(n[a-2],") {\n          result.a = getValue(").concat(s,");\n        }\n\n        ").concat(s[a-1]," = ").concat(s[a-1]," - 1;\n        if (").concat(s[a-2]," < ").concat(n[a-2]," &&\n            ").concat(s[a-1]," < ").concat(n[a-1],") {\n          result.b = getValue(").concat(s,");\n        }\n        setOutput(result);\n      }\n    ")}}(s.map(e=>e.shape),t);return n.runWebGLProgram(e,s,a)}let{tensors2D:c,outShape:l}=function(e,t,n){let a=Hf.computeOutShape(e.map(e=>e.shape),t);return{tensors2D:e.map(e=>dP({inputs:{x:e},attrs:{shape:[-1,Nr.sizeFromShape(e.shape.slice(t))]},backend:n})),outShape:a}}(s,t,n),u=new class{constructor(e){this.outputShape=[],this.outputShape=Hf.computeOutShape(e,1),this.variableNames=e.map((e,t)=>"T".concat(t));let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")];for(let s=1;s<t.length;s++){let e=t[s-1];n.push("else if (yC < ".concat(t[s],") setOutput(getT").concat(s,"(yR, yC-").concat(e,"));"))}let a=t.length,r=t[t.length-1];n.push("else setOutput(getT".concat(a,"(yR, yC-").concat(r,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}(c.map(e=>e.shape)),d=n.runWebGLProgram(u,c,a);c.forEach(e=>n.disposeIntermediateTensorInfo(e));let h=dP({inputs:{x:d},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(d),h}function TB(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=Nr.parseAxisParam(r,t[0].shape)[0],i=t.map(e=>e.shape);Hf.assertParamsConsistent(i,s);let o=Hf.computeOutShape(t.map(e=>e.shape),s);if(0===Nr.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let c=t.filter(e=>Nr.sizeFromShape(e.shape)>0);return 1===c.length?HL({inputs:{x:c[0]},backend:n}):NB(c,s,n)}var OB={kernelName:kt,backendName:"webgl",kernelFunc:TB},CB=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,b=m?2:3,y=m?3:1,v="",x="";n&&(v=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),x="result = activation(result);");let w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(v,"\n\n      const ivec2 strides = ivec2(").concat(o,", ").concat(c,");\n      const ivec2 pads = ivec2(").concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(y,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(g,"], coords[").concat(b,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(d,"; wR++) {\n          int xR = xRCorner + wR * ").concat(l,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(h,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(m,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(m,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(m,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(m,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w,"\n        ").concat(x,"\n        setOutput(result);\n      }\n    ")}},EB=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=qj(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,u=l,d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<l;m++)d+="\n           vec4 xTexelC".concat(2*m,";\n           int xTexelC").concat(2*m,"Ready;\n           vec4 xTexelC").concat(2*m+1,";\n           int xTexelC").concat(2*m+1,"Ready;\n           vec4 xC").concat(m,";");d+="\n     for (int r = 0; r < ".concat(c,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(let m=0;m<l;m++)d+="\n           xTexelC".concat(2*m," = vec4(0.0);\n           xTexelC").concat(2*m,"Ready = 0;\n           xTexelC").concat(2*m+1," = vec4(0.0);\n           xTexelC").concat(2*m+1,"Ready = 0;\n           xC").concat(m," = vec4(0.0);");d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(u+1)/2;m++){let t=2*m;if(d+="\n           xC = xCCorner + ".concat(t*o,";\n           "),1===i){if(t<l&&(s%2===1?(d+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n               "),d+=1===o&&t>0?"\n                 xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                   } else {\n                     xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                   }\n                   ")):d+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xC").concat(t," = xTexelC").concat(t,";\n                 "),t+1<l)){let e=s%2===0?Nr.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(d+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                     xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(t+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(t+1,"Ready = 1;\n                   }\n                   "),d+=o>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                     } else {\n                      xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                     }\n                     "):"\n                     xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                     ")):d+=1===e?"\n                     xC".concat(t+1," = xTexelC").concat(t,";\n                     "):"\n                     xCOffset = xC + ".concat(e,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                       xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(t+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(t+1,"Ready = 1;\n                     }\n\n                     xC").concat(t+1," = xTexelC").concat(t+1,";\n                     ")}}else t<l&&(s%2===1?(d+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n               "),t+1<l&&(d+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                 "))):(d+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(\n                   xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n               "),t+1<l&&(d+="\n                   xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                 "))));t<l&&(d+="\n             wTexel = getW(r, ".concat(t,", d1, d2);\n             dotProd += xC").concat(t,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(t,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),t+1<l&&(d+="\n               wTexel = getW(r, ".concat(t+1,", d1, d2);\n               dotProd += xC").concat(t+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(t+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=a?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):r?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(h,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(d,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}};function _B(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function AB(e){let t,{x:n,filter:a,convInfo:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:c=0,activation:l=null}=e,u=n.shape,d=s.texData.get(n.dataId),h=r.inChannels,p=u[0]*u[1]*u[2],f=r.outChannels,m="channelsLast"===r.dataFormat,g=[];if(null!=o){let e=_B(o.shape,m);null!=e&&(o=dP({inputs:{x:o},backend:s,attrs:{shape:e}}),g.push(o))}if(null!=i){let e=_B(i.shape,m);null!=e&&(i=dP({inputs:{x:i},backend:s,attrs:{shape:e}}),g.push(i))}if((1!==p&&1!==f||!(h>1e3))&&d.isPacked&&m&&null!=d.texture&&u[2]%2!==0&&Nr.arraysEqual(d.shape.slice(-3),u.slice(-3))){let e=u[0]*u[1]*(u[2]+1),h={dataId:n.dataId,shape:[1,e,r.inChannels],dtype:n.dtype},p=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,Nr.assert(tj(d.shape,h.shape),()=>"packed reshape ".concat(d.shape," to ").concat(h.shape," isn't free"));let f=dP({inputs:{x:a},backend:s,attrs:{shape:[1,r.inChannels,r.outChannels]}});g.push(f);let m=wP({a:h,b:f,backend:s,transposeA:!1,transposeB:!1,bias:i,activation:l,preluActivationWeights:o,leakyreluAlpha:c}),b=s.texData.get(m.dataId);Nr.assert(b.isPacked,()=>"batchMatMul result is expected to be packed"),d.shape=p,b.shape=r.outShape,t=HL({inputs:{x:m},backend:s}),t.shape=r.outShape,g.push(m)}else{let e=r.outHeight*r.outWidth,u=dP({inputs:{x:n},backend:s,attrs:{shape:m?[r.batchSize,e,r.inChannels]:[r.batchSize,r.inChannels,e]}}),d=dP({inputs:{x:a},backend:s,attrs:{shape:[1,r.inChannels,r.outChannels]}}),h=wP({a:m?u:d,b:m?d:u,transposeA:!m,transposeB:!1,backend:s,bias:i,activation:l,preluActivationWeights:o,leakyreluAlpha:c});t=dP({inputs:{x:h},backend:s,attrs:{shape:r.outShape}}),g.push(u),g.push(d),g.push(h)}for(let b of g)s.disposeIntermediateTensorInfo(b);return t}function RB(e){let{x:t,filter:n,convInfo:a,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:c=null}=e,{filterWidth:l,filterHeight:u,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=a,m="channelsLast"===f,g=l*u*d,b=p*h,y=[a.batchSize,g,b],v=[];if(null!=i){let e=_B(i.shape,m);null!=e&&(i=dP({inputs:{x:i},backend:r,attrs:{shape:e}}),v.push(i))}if(null!=s){let e=_B(s.shape,m);null!=e&&(s=dP({inputs:{x:s},backend:r,attrs:{shape:e}}),v.push(s))}let x=dP({inputs:{x:n},backend:r,attrs:{shape:[1,g,Nr.sizeFromShape(n.shape)/g]}});v.push(x);let w=new class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=qj(this.outputShape.length);let{dataFormat:n}=t,a=mj(),r="channelsLast"===n,s=r?1:2,i=r?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {"),c="";for(let l=0;l<=1;l++)for(let e=0;e<=1;e++)c+="\n          blockIndex = rc.z + ".concat(e,";\n          pos = rc.y + ").concat(l,";\n\n          ").concat(o,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(s,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(i,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(r,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(c,"\n\n        ").concat(a.output," = result;\n      }\n    ")}}(y,a),k=[t.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],I=r.runWebGLProgram(w,[t],"float32",k),S=dP({inputs:{x:I},backend:r,attrs:{shape:y}});v.push(I),v.push(S);let N=null!=s,T=null!=i,O="leakyrelu"===c,C=c?aP(c,!0):null,E=new rP(m?S.shape:x.shape,m?x.shape:S.shape,m?[a.batchSize,b,a.outChannels]:[a.batchSize,a.outChannels,b],!0,!1,N,C,T,O),_=m?[S,x]:[x,S];if(s&&_.push(s),T&&_.push(i),O){let e=r.makeTensorInfo([],"float32",Nr.createScalarValue(o,"float32"));_.push(e),v.push(e)}let A=r.runWebGLProgram(E,_,"float32"),R=dP({inputs:{x:A},backend:r,attrs:{shape:a.outShape}});v.push(A);for(let D of v)r.disposeIntermediateTensorInfo(D);return R}var DB={kernelName:It,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:a,attrs:r}=e,{x:s,filter:i}=n,{strides:o,pad:c,dataFormat:l,dilations:u,dimRoundingMode:d}=r,h=Hf.convertConv2DDataFormat(l),p=Hf.computeConv2DInfo(s.shape,i.shape,o,u,c,d,!1,h);if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(p.strideWidth<=2&&"channelsLast"===h&&Ue().getBool("WEBGL_EXP_CONV")){let e=new EB(p),n=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];t=a.runWebGLProgram(e,[s,i],"float32",n)}else if(Ue().getBool("WEBGL_CONV_IM2COL"))t=RB({x:s,filter:i,convInfo:p,backend:a});else{let e=new CB(p);t=a.runWebGLProgram(e,[s,i],"float32")}else t=AB({x:s,filter:i,convInfo:p,backend:a});let f=dP({inputs:{x:t},backend:a,attrs:{shape:p.outShape}});return a.disposeIntermediateTensorInfo(t),f}};var FB={kernelName:St,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:c,dimRoundingMode:l,filterShape:u}=a,d=Hf.convertConv2DDataFormat(c),h=Hf.computeConv2DInfo(r.shape,u,i,1,o,l,!1,d),p=new class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              ").concat(s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}(h);return n.runWebGLProgram(p,[r,s],"float32")}};var MB={kernelName:Nt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:c,dataFormat:l,dimRoundingMode:u}=a,d=Hf.convertConv2DDataFormat(l),h=Hf.computeConv2DInfo(i,s.shape,o,1,c,u,!1,d);if(Ue().getBool("WEBGL_PACK")&&"channelsLast"===d){let e=[[h.strideHeight,h.strideWidth]],t=new class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=qj(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(a,", ").concat(r,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(e.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(e.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}(h);return n.runWebGLProgram(t,[r,s],"float32",e)}{let e=new class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,c=s?1:2,l=s?2:3,u=s?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(c,"], coords[").concat(l,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(s,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}(h);return n.runWebGLProgram(e,[r,s],"float32")}}};var jB={kernelName:Tt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:c}=a,l=Hf.computeConv3DInfo(r.shape,s.shape,i,c,o),u=new class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(r,", ").concat(s,", ").concat(i,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(n,", ").concat(a,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(o,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(d,"; wR++) {\n            int xR = xRCorner + wR * ").concat(c,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,"; wC++) {\n              int xC = xCCorner + wC * ").concat(l,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}(l);return n.runWebGLProgram(u,[r,s],"float32")}};var zB={kernelName:Ot,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:c}=a,l=Hf.computeConv3DInfo(r.shape,c,i,1,o),u=new class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(r,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(s,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(a," - ").concat(i,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}(l);return n.runWebGLProgram(u,[r,s],"float32")}};var LB,PB={kernelName:Ct,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:c}=a,l=Hf.computeConv3DInfo(c,s.shape,o,1,i),u=new class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,c=n-1-e.padInfo.top,l=a-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(o,", ").concat(c,", ").concat(l,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(r,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}(l);return n.runWebGLProgram(u,[r,s],"float32")}},BB=tP({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(VL,"\n  return result;\n")}),WB={kernelName:Et,backendName:"webgl",kernelFunc:BB},UB=tP({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),VB={kernelName:_t,backendName:"webgl",kernelFunc:UB},GB={kernelName:Dt,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:c,extrapolationValue:l}=a,u=new class{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,c]=e,[l]=t,[u,d]=n;this.outputShape=[l,u,d,c];let h="bilinear"===a?1:0,[p,f]=["".concat(i-1,".0"),"".concat(o-1,".0")],[m,g,b]=u>1?["".concat((i-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[y,v,x]=d>1?["".concat((o-1)/(d-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(m,");\n      const float width_ratio = float(").concat(y,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(s,") {\n          return;\n        }\n\n        float height_scale = ").concat(g,";\n        float width_scale = ").concat(v,";\n\n        float in_y = ").concat(b,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n        float in_x = ").concat(x,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(h," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}(r.shape,s.shape,o,c,l);return n.runWebGLProgram(u,[r,s,i],"float32")}};!function(e){e.Prod="*",e.Sum="+"}(LB||(LB={}));var HB=class{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let r=this.outputShape.length,s=this.op===LB.Prod?"1.0":"0.0",i=n?s:"getX(".concat(qB(r,"coords",this.op),")"),o=this.outputShape[this.outputShape.length-1],c="",l="";n?(c=a?"end != ".concat(o-1):"end != 0",l=a?"end + 1":"end - 1"):(c=a?"end + pow2 < ".concat(o):"end >= pow2",l=a?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(Bj(r)," coords = getOutputCoords();\n        int end = ").concat(KB(r,"coords",this.op),";\n        float val = ").concat(i,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c,") {\n          int idx = ").concat(l,";\n          ").concat(KB(r,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(qB(r,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}};function qB(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function KB(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function XB(e,t,n,a,r,s){let i=t.shape.length,o=Hf.getAxesPermutation([a],i),c=t;null!=o&&(c=vP({inputs:{x:t},backend:n,attrs:{perm:o}}));let l=Hf.getInnerMostAxes(1,i)[0];if(l!==i-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length-1," but got axis=").concat(a));let u=c.shape[l],d=HL({inputs:{x:c},backend:n});for(let h=0;h<=Math.ceil(Math.log2(u))-1;h++){let t=new HB(e,c.shape,!1,s),a=[[h]],r=d;d=n.runWebGLProgram(t,[d],d.dtype,a),n.disposeIntermediateTensorInfo(r)}if(r){let t=new HB(e,c.shape,r,s),a=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(a)}if(null!=o){let e=vP({inputs:{x:d},backend:n,attrs:{perm:Hf.getUndoAxesPermutation(o)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),e}return d}var ZB={kernelName:At,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return XB(LB.Prod,r,n,s,i,o)}};var YB={kernelName:Rt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return XB(LB.Sum,r,n,s,i,o)}};var JB={kernelName:Ft,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(1===r.shape.length){let e=n.readSync(r.dataId),t=n.readSync(s.dataId),a=xz(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,a)}if(2===r.shape.length){let e=n.bufferSync(r),t=n.bufferSync(s),a=wz(e,t,i,o);return n.makeTensorInfo(a.shape,s.dtype,a.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank".concat(r.shape.length,"."))}};var QB={kernelName:Mt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a,o=r.shape[0],c=("NHWC"===i?r.shape[1]:r.shape[2])*s,l=("NHWC"===i?r.shape[2]:r.shape[3])*s,u=("NHWC"===i?r.shape[3]:r.shape[1])/(s*s),d="NHWC"===i?[o,c,l,u]:[o,u,c,l],h=new class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}(d,s,i);return n.runWebGLProgram(h,[r],r.dtype)}},$B=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=qj(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,c="",l="";n&&(c=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),l="result = activation(result);");let u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(c,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o,";\n        int q = d2 - d1 * ").concat(o,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(s,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(i,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(l,"\n        setOutput(result);\n      }\n    ")}},eW=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=qj(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,d=u,h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)h+="\n          vec4 xTexelC".concat(2*g,";\n          int xTexelC").concat(2*g,"Ready;\n          vec4 xTexelC").concat(2*g+1,";\n          int xTexelC").concat(2*g+1,"Ready;\n          vec4 xC").concat(g,";");h+="\n    for (int r = 0; r < ".concat(l,"; r++) {\n      ");for(let g=0;g<u;g++)h+="\n          xTexelC".concat(2*g," = vec4(0.0);\n          xTexelC").concat(2*g,"Ready = 0;\n          xTexelC").concat(2*g+1," = vec4(0.0);\n          xTexelC").concat(2*g+1,"Ready = 0;\n          xC").concat(g," = vec4(0.0);");h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){let e=2*g;if(h+="\n          xC = xCCorner + ".concat(e*c,";\n          "),1===o){if(e<u&&(i%2===1?(h+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n              "),h+=1===c&&e>0?"\n                xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                  } else {\n                    xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                  }\n                  ")):h+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xC").concat(e," = xTexelC").concat(e,";\n                "),e+1<u)){let t=i%2===0?Nr.nearestLargerEven(c):c;c%2===0&&i%2===1||c%2!==0&&i%2!==1?(h+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                    xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(e+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(e+1,"Ready = 1;\n                  }\n                  "),h+=c>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                    } else {\n                     xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                    }\n                    "):"\n                    xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                    ")):h+=1===t?"\n                    xC".concat(e+1," = xTexelC").concat(e,";\n                    "):"\n                    xCOffset = xC + ".concat(t,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                      xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(e+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(e+1,"Ready = 1;\n                    }\n\n                    xC").concat(e+1," = xTexelC").concat(e+1,";\n                    ")}}else e<u&&(i%2===1?(h+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n              "),e+1<u&&(h+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                "))):(h+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(\n                  xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n              "),e+1<u&&(h+="\n                  xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                "))));e<u&&(h+="\n            wTexel = getW(r, ".concat(e,", d1, q);\n            dotProd += xC").concat(e," * vec4(wTexel.xz, wTexel.xz);\n          "),e+1<u&&(h+="\n              wTexel = getW(r, ".concat(e+1,", d1, q);\n              dotProd += xC").concat(e+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=a?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(s,";\n        int q = d2 - d1 * ").concat(s,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(h,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(m,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}};var tW={kernelName:jt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:c,dimRoundingMode:l}=a,u=c;null==u&&(u=[1,1]),Nr.assert(Hf.eitherStridesOrDilationsAreOne(i,u),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ".concat(i," and dilations '").concat(u,"'"));let d,h=Hf.computeConv2DInfo(r.shape,s.shape,i,u,o,l,!0);d=Ue().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new eW(h):new $B(h);let p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[r,s],"float32",p)}};var nW={kernelName:zt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,filterShape:u}=a,d=Hf.computeConv2DInfo(r.shape,u,i,o,c,l,!0),h=new class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(s," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}(d);return n.runWebGLProgram(h,[r,s],"float32")}};var aW={kernelName:Lt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:c,dimRoundingMode:l,inputShape:u}=a,d=Hf.computeConv2DInfo(u,s.shape,i,o,c,l,!0),h=new class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(o,"; dm++) {\n              int d2 = d1 * ").concat(o," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}(d);return n.runWebGLProgram(h,[r,s],"float32")}};var rW={kernelName:Pt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],s=Nr.sizeFromShape(a.shape),i=dP({inputs:{x:a},backend:n,attrs:{shape:[s]}}),o=new class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}(s),c=n.runWebGLProgram(o,[i],i.dtype),l=dP({inputs:{x:c},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),l}};var sW={kernelName:Bt,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:a,attrs:r}=e,{x:s,filter:i}=n,{strides:o,pad:c,dilations:l}=r,u=Hf.computeDilation2DInfo(s.shape,i.shape,o,c,"NHWC",l),d=new class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:c,dilationWidth:l}=e,{top:u,left:d}=a;this.userCode="\n      const ivec2 strides = ivec2(".concat(r,", ").concat(s,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(d,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(i,"; h++) {\n          int hIn = hBeg + h * ").concat(c,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(o,"; w++) {\n              int wIn = wBeg + w * ").concat(l,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}(u);t=a.runWebGLProgram(d,[s,i],"float32");let h=dP({inputs:{x:t},backend:a,attrs:{shape:u.outShape}});return a.disposeIntermediateTensorInfo(t),h}};var iW={kernelName:Ht,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:c}=Hf.decodeEinsumEquation(r,s.length);Hf.checkEinsumDimSizes(i.length,c,s);let{path:l,steps:u}=Hf.getEinsumComputePath(o,c),d=u.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let e of u[m]){let t,{permutationIndices:a,expandDims:r}=Hf.getEinsumPermutation(p,c[e]);Hf.isIdentityPermutation(a)?t=s[e]:(t=vP({inputs:{x:s[e]},backend:n,attrs:{perm:a}}),f.push(t));let i=t.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Nr.arraysEqual(t.shape,i)||(t=dP({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===h?h=t:(h=lP({inputs:{a:t,b:h},backend:n}),f.push(h))}m<d-1&&(l[m]>=0&&(h=bP({inputs:{x:h},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}},oW=tP({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),cW={kernelName:qt,backendName:"webgl",kernelFunc:oW},lW={kernelName:Kt,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=Ue().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new GL("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,r.shape):new UL("return (b >= 0.0) ? a : a * (b + 1.0);",a.shape,r.shape);return n.runWebGLProgram(s,[a,r],a.dtype)}},uW=nP({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Tz}),dW={kernelName:Zt,backendName:"webgl",kernelFunc:uW},hW=tP({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(Hf.ERF_P,";\n  float a1 = ").concat(Hf.ERF_A1,";\n  float a2 = ").concat(Hf.ERF_A2,";\n  float a3 = ").concat(Hf.ERF_A3,";\n  float a4 = ").concat(Hf.ERF_A4,";\n  float a5 = ").concat(Hf.ERF_A5,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),pW={kernelName:Xt,backendName:"webgl",kernelFunc:hW},fW=tP({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Oz,dtype:"float32"}),mW={kernelName:Yt,backendName:"webgl",kernelFunc:fW};function gW(e){let{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),c=r;return r<0&&(Nr.assert(-(i+1)<=r,()=>"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]")),c=i+r+1),o.splice(c,0,1),dP({inputs:{x:s},backend:a,attrs:{shape:o}})}var bW={kernelName:Jt,backendName:"webgl",kernelFunc:gW},yW="return exp(x) - 1.0;",vW=tP({opSnippet:yW,packedOpSnippet:yW,cpuKernelImpl:Cz}),xW={kernelName:Qt,backendName:"webgl",kernelFunc:vW},wW=class{constructor(e,t,n){this.variableNames=["real","imag"];let a=t[1];this.outputShape=t;let r,s=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),i=n?"".concat(a,".0"):"1.0";if("real"===e)r="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '.concat(e,"."));r="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(s,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(r,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(a,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(i,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}};function kW(e,t,n){let a=n.texData.get(e.dataId),r=Nr.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=dP({inputs:{x:e},backend:n,attrs:{shape:[r/s,s]}}),o=i.shape,c=new wW("real",o,t),l=new wW("imag",o,t),u=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:o},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:o}],d=n.runWebGLProgram(c,u,"float32"),h=n.runWebGLProgram(l,u,"float32"),p=KL({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);let f=dP({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}var IW={kernelName:$t,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:a}=t;return kW(a,!1,n)}};function SW(e){let{backend:t,attrs:n}=e,{shape:a,value:r}=n,{dtype:s}=n;if(s=s||Nr.inferDtype(r),"string"===s){let e=Nr.getArrayFromDType(s,Nr.sizeFromShape(a));return e.fill(r),t.makeTensorInfo(a,s,e)}{let e=new class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}(a,r),n=[[r]];return t.runWebGLProgram(e,[],s,n)}}var NW,TW={kernelName:en,backendName:"webgl",kernelFunc:SW},OW={kernelName:tn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{image:a}=t,r=n,s=new class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}(a.shape);return r.runWebGLProgram(s,[a],a.dtype)}},CW="return floor(x);",EW=tP({opSnippet:CW,packedOpSnippet:CW,cpuKernelImpl:Ez}),_W={kernelName:nn,backendName:"webgl",kernelFunc:EW},AW=nP({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),RW={kernelName:an,backendName:"webgl",kernelFunc:AW},DW={kernelName:or,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{pixels:r}=t,{numChannels:s}=a,i="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,[c,l]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[l,c],d=[l,c,s];if(o||i){let e=Ue().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==NW||e!==FW)&&(FW=e,NW=document.createElement("canvas").getContext("2d",{willReadFrequently:FW})),NW.canvas.width=c,NW.canvas.height=l,NW.drawImage(r,0,0,c,l),r=NW.canvas}let h=n.makeTensorInfo(u,"int32");n.texData.get(h.dataId).usage=cM.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),r);let p=Ue().getBool("WEBGL_PACK")?new class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=mj(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(a,".0, ").concat(n,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}(d):new class{constructor(e){this.variableNames=["A"];let t=mj(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(a,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}},FW=Ue().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");var MW={kernelName:ur,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:a,attrs:r}=e,{x:s,filter:i,bias:o,preluActivationWeights:c}=n,{strides:l,pad:u,dataFormat:d,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=r,g=Hf.convertConv2DDataFormat(d),b=Hf.computeConv2DInfo(s.shape,i.shape,l,h,u,p,!1,g),y=[],v=null!=o,x=null!=c,w="leakyrelu"===f,k=()=>{let e=[s,i],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){let t=dP({inputs:{x:e},backend:a,attrs:{shape:[e.shape[0],1,1]}});return y.push(t),t}return e};if(v&&e.push(t(o,d)),x&&e.push(t(c,d)),w){let t=a.makeTensorInfo([],"float32",Nr.createScalarValue(m,"float32"));e.push(t),y.push(t)}return e};if(1!==b.filterHeight||1!==b.filterWidth||1!==b.dilationHeight||1!==b.dilationWidth||1!==b.strideHeight||1!==b.strideWidth||"SAME"!==b.padInfo.type&&"VALID"!==b.padInfo.type)if(b.strideWidth<=2&&"channelsLast"===g&&Ue().getBool("WEBGL_EXP_CONV")){let e=f?aP(f,!0):null,n=new EB(b,v,e,x,w),r=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],s=k();t=a.runWebGLProgram(n,s,"float32",r)}else if(Ue().getBool("WEBGL_CONV_IM2COL"))t=RB({x:s,filter:i,convInfo:b,backend:a,bias:o,activation:f,preluActivationWeights:c,leakyreluAlpha:m});else{let e=f?aP(f,!1):null,n=new CB(b,v,e,x,w),r=k();t=a.runWebGLProgram(n,r,"float32")}else t=AB({x:s,filter:i,convInfo:b,backend:a,bias:o,activation:f,preluActivationWeights:c,leakyreluAlpha:m});let I=dP({inputs:{x:t},backend:a,attrs:{shape:b.outShape}});return y.push(t),y.forEach(e=>a.disposeIntermediateTensorInfo(e)),I}};var jW={kernelName:dr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dilations:u,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=a,f=[],m=u;null==m&&(m=[1,1]),Nr.assert(Hf.eitherStridesOrDilationsAreOne(c,m),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ".concat(c," and dilations '").concat(m,"'"));let g,b=Hf.computeConv2DInfo(r.shape,s.shape,c,m,l,d,!0),y=Ue().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels===1,v=h?aP(h,y):null,x=[r,s],w=null!=i,k=null!=o,I="leakyrelu"===h;if(w&&x.push(i),k&&x.push(o),I){let e=n.makeTensorInfo([],"float32",Nr.createScalarValue(p,"float32"));x.push(e),f.push(e)}g=y?new eW(b,w,v,k,I):new $B(b,w,v,k,I);let S=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],N=n.runWebGLProgram(g,x,"float32",S);return f.forEach(e=>n.disposeIntermediateTensorInfo(e)),N}};var zW={kernelName:on,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=r.shape,i=s[s.length-1],o=Nr.sizeFromShape(a.shape),[c,l,u,d]=Hf.prepareAndValidate(a,r),h=dP({inputs:{x:r},backend:n,attrs:{shape:[l,i]}}),p=dP({inputs:{x:a},backend:n,attrs:{shape:[Nr.sizeFromShape(a.shape)/u,u]}});if(n.shouldExecuteOnCPU([a,r])||"string"===a.dtype){let e=n.readSync(r.dataId),t=n.bufferSync(a),s=_z(e,t,a.dtype,l,i,u,d,a.shape,o);return n.makeTensorInfo(c,a.dtype,s.values)}let f=new class{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;let r=Bj(n.length),s="\n    int index;";for(let i=0;i<this.sliceDim;i++)s+="\n          index = round(getIndices(coords[0], ".concat(i,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[i],";\n          flattenIndex += index * ").concat(this.strides[i],";");this.userCode="\n         void main() {\n          ".concat(r," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(s,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}(i,d,[l,u],a.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=dP({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};function LW(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a,c=Nr.parseAxisParam(i,r.shape)[0];if(Ue().get("DEBUG")){let e=n.readSync(s.dataId),t=r.shape[c];for(let n=0;n<e.length;++n){let a=e[n];Nr.assert(a<=t-1&&a>=0,()=>"GatherV2: the index value ".concat(a," is not in [0, ").concat(t-1,"]"))}}let l=Hf.segment_util.collectGatherOpShapeInfo(r,s,c,o),u=Nr.sizeFromShape(s.shape),d=[],h=dP({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=dP({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});d.push(h),d.push(p);let f=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){let e=n.bufferSync(p),t=n.bufferSync(h),a=Az(t,e,f);return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(l.outputShape,a.dtype,a.values)}let m=new class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=Bj(this.rank),a=function(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)2===r?a.push("index"):a.push("".concat(n[r]));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a,"));\n      }\n    ")}}(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);let b=dP({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}var PW={kernelName:sn,backendName:"webgl",kernelFunc:LW},BW=nP({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Rz,dtype:"bool"}),WW={kernelName:cn,backendName:"webgl",kernelFunc:BW},UW=nP({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Dz}),VW={kernelName:ln,backendName:"webgl",kernelFunc:UW};var GW={kernelName:dn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:a}=t;return kW(a,!0,n)}},HW=tP({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),qW={kernelName:pn,backendName:"webgl",kernelFunc:HW},KW=tP({opSnippet:"return float(isinf(x));",dtype:"bool"}),XW={kernelName:fn,backendName:"webgl",kernelFunc:KW},ZW=tP({opSnippet:"return float(isnan(x));",dtype:"bool"}),YW={kernelName:mn,backendName:"webgl",kernelFunc:ZW},JW=nP({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Fz,dtype:"bool"}),QW={kernelName:bn,backendName:"webgl",kernelFunc:JW},$W=nP({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Mz,dtype:"bool"}),eU={kernelName:yn,backendName:"webgl",kernelFunc:$W};var tU={kernelName:vn,backendName:"webgl",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=jz(a,r,s);return t.makeTensorInfo([i.length],"float32",i)}},nU=tP({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:zz}),aU={kernelName:xn,backendName:"webgl",kernelFunc:nU},rU=tP({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),sU={kernelName:wn,backendName:"webgl",kernelFunc:rU},iU=nP({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),oU={kernelName:kn,backendName:"webgl",kernelFunc:iU},cU=tP({opSnippet:"return float(!(x >= 1.0));"}),lU={kernelName:In,backendName:"webgl",kernelFunc:cU},uU=nP({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),dU={kernelName:Sn,backendName:"webgl",kernelFunc:uU},hU={kernelName:Cn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:c}=a,l=Ue().getBool("WEBGL_PACK_NORMALIZATION")?new class{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,c="float(".concat(n,") + float(").concat(a,") * sum");o=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(s,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(s,"; j <= ").concat(s,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(i,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(o,";\n        setOutput(result);\n      }\n    ")}}(r.shape,s,i,o,c):new class{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,c="float(".concat(n,") + float(").concat(a,") * sum");o=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(s,"; j <= ").concat(s,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(i,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(o,";\n        setOutput(val);\n      }\n    ")}}(r.shape,s,i,o,c);return n.runWebGLProgram(l,[r],r.dtype)}},pU={kernelName:En,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:c,alpha:l,beta:u}=a,d=new class{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a,")\n                * float(").concat(r,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(r,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}(r.shape,o,c,l,u);return n.runWebGLProgram(d,[r,s,i],r.dtype)}};function fU(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=r.shape.length,c=Nr.parseAxisParam(s,r.shape),l=c,u=Hf.getAxesPermutation(l,o),d=null!=u,h=n.shouldExecuteOnCPU([r]),p=r;if(d){if(h){let e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=r.shape[u[n]];let a=hL(e,r.shape,r.dtype,u,t);p=n.makeTensorInfo(t,r.dtype),n.texData.get(p.dataId).values=a}else p=gP(r,u,n);l=Hf.getInnerMostAxes(l.length,o)}Hf.assertAxesAreInnerMostDims("max",l,o);let f,[m,g]=Hf.computeOutAndReduceShapes(p.shape,l),b=m;if(i&&(b=Hf.expandShapeToKeepDim(m,c)),h){let e=n.texData.get(p.dataId).values,t=Lz(e,Nr.sizeFromShape(g),b,r.dtype);f=n.makeTensorInfo(b,r.dtype),n.texData.get(f.dataId).values=t}else f=function(e,t,n,a){let r=Nr.sizeFromShape(t),s=dP({inputs:{x:e},attrs:{shape:[Nr.sizeFromShape(e.shape)/r,r]},backend:a}),i=mP(s,e.dtype,"max",a),o=dP({inputs:{x:i},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(i),o}(p,g,b,n);return d&&n.disposeIntermediateTensorInfo(p),f}var mU={kernelName:An,backendName:"webgl",kernelFunc:fU},gU=nP({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Pz}),bU={kernelName:Rn,backendName:"webgl",kernelFunc:gU};var yU={kernelName:Dn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;pj(r,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:c}=a;Nr.assert(Hf.eitherStridesOrDilationsAreOne(i,1),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(i," and dilations '").concat(1,"'"));let l=Hf.computePool2DInfo(r.shape,s,i,1,o,c);if(1===l.filterWidth&&1===l.filterHeight&&Nr.arraysEqual(l.inShape,l.outShape))return HL({inputs:{x:r},backend:n});let u=new YP(l,"max",!1);return n.runWebGLProgram(u,[r],r.dtype)}};var vU={kernelName:Mn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dataFormat:c,dimRoundingMode:l}=a,u=Hf.computePool3DInfo(r.shape,s,i,[1,1,1],o,l,c),d=new JP(u,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}};var xU={kernelName:jn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=a,d=Hf.computePool3DInfo(i.shape,o,c,[1,1,1],l,u),h=new JP(d,"max",!0),p=n.runWebGLProgram(h,[i],i.dtype),f=new class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.front,d=c-1-e.padInfo.top,h=l-1-e.padInfo.left,p=o*c*l-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(d,", ").concat(h,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(o,";\n           wD += ").concat(r,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(c,";\n              wR += ").concat(s,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(l,";\n                wC += ").concat(i,") {\n              float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(c," * ").concat(l," +\n                  wR * ").concat(l," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}(d),m=n.runWebGLProgram(f,[r,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};var wU={kernelName:Fn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;pj([s,i],"maxPoolGrad");let{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=a,h=Hf.computePool2DInfo(o.shape,c,l,1,u,d),p=new YP(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=r-1-e.padInfo.top,o=s-1-e.padInfo.left,c=r*s-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(r,";\n          wR += ").concat(a,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(s,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(c," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(s," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}(h),g=n.runWebGLProgram(m,[r,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};var kU={kernelName:zn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:c}=n,l=a;Nr.assert(4===r.shape.length,()=>"Error in maxPool: input must be rank 4 but got rank ".concat(r.shape.length,"."));let u=[1,1];Nr.assert(Hf.eitherStridesOrDilationsAreOne(i,u),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(i," and dilations '").concat(u,"'"));let d=Hf.computePool2DInfo(r.shape,s,i,u,o),[h,p]=function(e,t,n,a){let r=new YP(n,"max",!1),s=a.runWebGLProgram(r,[e],"float32");return r=new YP(n,"max",!0,!0,t),[s,a.runWebGLProgram(r,[e],"float32")]}(r,c,d,l);return[h,p]}};var IU={kernelName:Ln,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{keepDims:s,axis:i}=n,o=a,c=r.shape.length,l=Nr.parseAxisParam(i,r.shape),u=l,d=Hf.getAxesPermutation(u,c),h=null!=d,p=o.shouldExecuteOnCPU([r]),f=[],m=r;if(h){if(p){let e=o.texData.get(m.dataId).values,t=new Array(c);for(let a=0;a<t.length;a++)t[a]=r.shape[d[a]];let n=hL(e,r.shape,r.dtype,d,t);m=o.makeTensorInfo(t,r.dtype),o.texData.get(m.dataId).values=n}else m=gP(r,d,o);f.push(m),u=Hf.getInnerMostAxes(u.length,c)}Hf.assertAxesAreInnerMostDims("sum",u,c);let[g,b]=Hf.computeOutAndReduceShapes(m.shape,u),y=g;s&&(y=Hf.expandShapeToKeepDim(g,l));let v=function(e,t,n,a){let r=Nr.sizeFromShape(t),s=dP({inputs:{x:e},attrs:{shape:[Nr.sizeFromShape(e.shape)/r,r]},backend:a}),i=mP(s,"float32","mean",a),o=dP({inputs:{x:i},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(i),o}(m,b,y,o);for(let x of f)o.disposeIntermediateTensorInfo(x);return v}};var SU={kernelName:Pn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,c=Nr.parseAxisParam(s,r.shape),l=c,u=Hf.getAxesPermutation(l,o),d=r;null!=u&&(d=vP({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Hf.getInnerMostAxes(l.length,r.shape.length)),Hf.assertAxesAreInnerMostDims("min",l,o);let h,[p,f]=Hf.computeOutAndReduceShapes(d.shape,l),m=dP({inputs:{x:d},backend:n,attrs:{shape:[-1,Nr.sizeFromShape(f)]}}),g=mP(m,m.dtype,"min",n);if(i){h=dP({inputs:{x:g},backend:n,attrs:{shape:Hf.expandShapeToKeepDim(p,c)}})}else h=dP({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(d),h}},NU=nP({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Bz}),TU={kernelName:Bn,backendName:"webgl",kernelFunc:NU},OU={kernelName:Wn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,mode:i}=a,o=Ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);let a=e.length,r=Bj(a),s=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=mL("rc",a),c=mL("source",a),l="".concat(o[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),d="reflect"===n?0:1,h="";if(1===a){let e="\n        ".concat(r," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(d,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(d,";\n        }\n        source -= start;\n      ");h="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(o[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ")}else{let e="\n        ".concat(r," source = rc;\n        ").concat(r," lt = ").concat(r,"(lessThan(source, start));\n        ").concat(r," gte = ").concat(r,"(greaterThanEqual(source, end));\n        ").concat(r," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(d,") +\n                gte * ((end - 1) * 2 - source + ").concat(d,");\n        source -= start;\n      ");h="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(o[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(o[a-2]," += 1;\n        if(").concat(o[a-2]," < ").concat(this.outputShape[a-2],") {\n          ").concat(e,"\n          result[2] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          ").concat(o[a-1]," += 1;\n          if(").concat(l,") {\n            ").concat(e,"\n            result[3] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(s,");\n      const ").concat(r," end = ").concat(r,"(").concat(i,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(h,"\n        setOutput(result);\n      }\n    ")}}(r.shape,s,i):new class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);let a=e.length,r=Bj(a),s=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),c="reflect"===n?0:1;this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(s,");\n      ").concat(r," end = ").concat(r,"(").concat(i,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(c,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(c,";\n          }\n        }\n        ").concat(r," coords = outC - start;\n        setOutput(getX(").concat(o,"));\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(c,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(c,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}(r.shape,s,i);return n.runWebGLProgram(o,[r],r.dtype)}},CU=nP({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),EU={kernelName:Un,backendName:"webgl",kernelFunc:CU},_U=nP({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),AU={kernelName:Gt,backendName:"webgl",kernelFunc:_U},RU="return a - b;",DU=nP({opSnippet:RU,packedOpSnippet:RU,supportsComplex:!0,cpuKernelImpl:lL}),FU={kernelName:Xa,backendName:"webgl",kernelFunc:DU};function MU(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=Nr.parseAxisParam([s],r.shape),o=fU({inputs:{x:r},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),c=Hf.expandShapeToKeepDim(o.shape,i),l=dP({inputs:{x:o},backend:n,attrs:{shape:c}}),u=DU({inputs:{a:r,b:l},backend:n}),d=fW({inputs:{x:u},backend:n}),h=bP({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=dP({inputs:{x:h},backend:n,attrs:{shape:c}}),f=_U({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}var jU={kernelName:Ma,backendName:"webgl",kernelFunc:MU};var zU={kernelName:Vn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a,c=o?r:MU({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=c.shape[0],u=c.shape[1],d=new class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}}(l,u,s),h=[[i]],p=n.runWebGLProgram(d,[c],"int32",h);return o||n.disposeIntermediateTensorInfo(c),p}};var LU={kernelName:Hn,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:a}=e,{x:r}=n;if(a.shouldExecuteOnCPU([r])){let e=a.texData.get(r.dataId),[t,n]=Uz(e.values,r.shape,r.dtype);return a.makeTensorInfo(n,r.dtype,t)}return t=Ue().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new FL(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new xL(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),a.runWebGLProgram(t,[r],r.dtype)}},PU=Xm.nonMaxSuppressionV3Impl;var BU={kernelName:Kn,backendName:"webgl",kernelFunc:function(e){Hf.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c}=a,l=n.readSync(r.dataId),u=n.readSync(s.dataId),{selectedIndices:d}=PU(l,u,i,o,c);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},WU=Xm.nonMaxSuppressionV4Impl;var UU={kernelName:Xn,backendName:"webgl",kernelFunc:function(e){Hf.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,padToMaxOutputSize:l}=a,u=n.readSync(r.dataId),d=n.readSync(s.dataId),{selectedIndices:h,validOutputs:p}=WU(u,d,i,o,c,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},VU=Xm.nonMaxSuppressionV5Impl;var GU={kernelName:Zn,backendName:"webgl",kernelFunc:function(e){Hf.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=a,u=n.readSync(r.dataId),d=n.readSync(s.dataId),h=i,p=o,f=c,m=l,{selectedIndices:g,selectedScores:b}=VU(u,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},HU={kernelName:Jn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:c}=a,l=Nr.sizeFromShape(r.shape),u=new class{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}(l,i,o,c),d=dP({inputs:{x:r},backend:n,attrs:{shape:[l]}}),h=n.runWebGLProgram(u,[d],s);n.disposeIntermediateTensorInfo(d);let p=dP({inputs:{x:h},backend:n,attrs:{shape:[...r.shape,i]}});return n.disposeIntermediateTensorInfo(h),p}};function qU(e){let{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){let e=pB({inputs:{input:a},backend:n}),t=qU({inputs:{x:e},backend:n}),r=IB({inputs:{input:a},backend:n}),s=qU({inputs:{x:r},backend:n}),i=KL({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}return SW({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}var KU={kernelName:sr,backendName:"webgl",kernelFunc:qU};var XU={kernelName:Yn,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){let t=pB({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),s=IB({inputs:{input:r},backend:a}),i=qU({inputs:{x:s},backend:a}),o=KL({inputs:{real:n,imag:i},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(i),o}return SW({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}};var ZU={kernelName:Qn,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return gW({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(e=>{Nr.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),Nr.assert(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],c=TB({inputs:t.map(e=>{let t=gW({inputs:{input:e},backend:n,attrs:{dim:r}});return o.push(t),t}),backend:n,attrs:{axis:r}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},YU=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;if(0===Nr.sizeFromShape(r.shape)){return SW({backend:n,attrs:{shape:s.map((e,t)=>e[0]+r.shape[t]+e[1]),value:i,dtype:r.dtype}})}let o=Ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);let a=e.length,r=Bj(a),s=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=mL("rc",a),c=mL("source",a),l="".concat(o[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),d=["".concat(r," rc = outputLoc;"),"".concat(o[a-1]," += 1;\n       if(").concat(l,") {\n      "),1===a?"":"}\n       rc = outputLoc;\n       ".concat(o[a-2]," += 1;\n       if(").concat(o[a-2]," < ").concat(this.outputShape[a-2],") {"),1===a?"":"  ".concat(o[a-1]," += 1;\n         if(").concat(l,") {")],h=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",p="";for(let f=0,m=1===a?2:4;f<m;f++)p+="\n        ".concat(d[f],"\n        if (").concat(h,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(r," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ");p+=1===a?"} ":"}}",this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(s,");\n      const ").concat(r," end = ").concat(r,"(").concat(i,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}(r.shape,s,i):new class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);let a=e.length,r=Bj(a),s=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(s,");\n      ").concat(r," end = ").concat(r,"(").concat(i,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(r," coords = outC - start;\n          setOutput(getX(").concat(o,"));\n        }\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}(r.shape,s,i),c=[[i]];return n.runWebGLProgram(o,[r],r.dtype,c)},JU={kernelName:$n,backendName:"webgl",kernelFunc:YU},QU=nP({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),$U={kernelName:ta,backendName:"webgl",kernelFunc:QU};var eV={kernelName:aa,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:a,attrs:r}=e,{x:s}=n,{axis:i,keepDims:o}=r,c=s.shape.length,l=[],u=Nr.parseAxisParam(i,s.shape),d=u,h=Hf.getAxesPermutation(d,c),p=s;if(null!=h&&(p=vP({inputs:{x:s},backend:a,attrs:{perm:h}}),d=Hf.getInnerMostAxes(d.length,c),l.push(p)),Hf.assertAxesAreInnerMostDims("prod",d,c),a.shouldExecuteOnCPU([p])){let e=a.texData.get(p.dataId).values,{outVals:n,outShape:r,outDtype:s}=Gz(p.shape,p.dtype,e,d);t=a.makeTensorInfo(r,s,n)}else{let[e,n]=Hf.computeOutAndReduceShapes(p.shape,d),r=Nr.sizeFromShape(n),i=dP({inputs:{x:p},backend:a,attrs:{shape:[-1,r]}}),o=mP(i,vs(s.dtype),"prod",a);t=dP({inputs:{x:o},backend:a,attrs:{shape:e}}),l.push(i),l.push(o)}if(o){l.push(t);let e=Hf.expandShapeToKeepDim(t.shape,u);t=dP({inputs:{x:t},backend:a,attrs:{shape:e}})}return l.forEach(e=>a.disposeIntermediateTensorInfo(e)),t}};var tV={kernelName:ra,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,c=r.map(e=>n.readSync(e.dataId)),l=r.map(e=>e.shape),u=n.readSync(s.dataId),d=n.readSync(i.dataId),[h,p,f]=Hz(c,l,u,s.shape,s.dtype,d,i.shape,o),m=h.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};var nV={kernelName:sa,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.readSync(a.dataId),o=n.readSync(r.dataId),c=n.readSync(s.dataId),[l,u]=qz(i,a.shape,a.dtype,o,r.shape,c,s.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};var aV={kernelName:ia,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:c}=a,l=n.readSync(r.dataId),u=n.readSync(s.dataId),d=n.readSync(i.dataId),h=o.map(e=>n.readSync(e.dataId)),p=o.map(e=>e.shape),[f,m]=Kz(l,r.shape,u,s.shape,s.dtype,d,i.shape,h,p,c);return n.makeTensorInfo(f,s.dtype,m)}},rV=e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=Xz(a,r,s,i);return t.makeTensorInfo([o.length],i,o)},sV={kernelName:oa,backendName:"webgl",kernelFunc:rV},iV=tP({opSnippet:"return 1.0 / x;"}),oV={kernelName:la,backendName:"webgl",kernelFunc:iV},cV=tP({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),lV={kernelName:ua,backendName:"webgl",kernelFunc:cV},uV=tP({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),dV={kernelName:ga,backendName:"webgl",kernelFunc:uV};var hV={kernelName:fa,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[c,l]=o,u=Ue().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new class{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,c]=e;this.outputShape=[s,t,n,c];let l,u=[a&&t>1?i-1:i,a&&n>1?o-1:o],d=[a&&t>1?t-1:t,a&&n>1?n-1:n];l=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(u[0]/d[0],",\n          ").concat(u[1]/d[1],",\n          ").concat(u[1]/d[1],");\n      const vec3 inputShapeRC = vec3(").concat(i,".0, ").concat(o,".0,\n                                     ").concat(o,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(l,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}(r.shape,c,l,s,i):new class{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];let[s,i,o,c]=e;this.outputShape=[s,t,n,c];let l,u=[a&&t>1?i-1:i,a&&n>1?o-1:o],d=[a&&t>1?t-1:t,a&&n>1?n-1:n];l=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(u[0]/d[0],",\n          ").concat(u[1]/d[1],");\n      const vec2 inputShapeRC = vec2(").concat(i,".0, ").concat(o,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(l,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}(r.shape,c,l,s,i);return n.runWebGLProgram(u,[r],"float32")}};var pV={kernelName:ma,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],c=[n&&s>1?s-1:s,n&&i>1?i-1:i],l=o[0]/c[0],u=o[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(a-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(r-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}};var fV={kernelName:ha,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[c,l]=o,u=Ue().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new class{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,c]=e;this.outputShape=[s,t,n,c];let l,u=[a&&t>1?i-1:i,a&&n>1?o-1:o],d=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0";l=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(u[0]/d[0],",\n          ").concat(u[1]/d[1],",\n          ").concat(u[1]/d[1],");\n      const vec3 inputShapeRC = vec3(").concat(i,".0, ").concat(o,".0,\n                                     ").concat(o,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(l,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}(r.shape,c,l,s,i):new class{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];let[s,i,o,c]=e;this.outputShape=[s,t,n,c];let l,u=[a&&t>1?i-1:i,a&&n>1?o-1:o],d=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0";l=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(u[0]/d[0],",\n          ").concat(u[1]/d[1],");\n      const vec2 inputShapeRC = vec2(").concat(i,".0, ").concat(o,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(l,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}(r.shape,c,l,s,i);return n.runWebGLProgram(u,[r],r.dtype)}};var mV={kernelName:pa,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],c=[n&&s>1?s-1:s,n&&i>1?i-1:i],l=o[0]/c[0],u=o[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(o[0],") *\n                (float(dyR) / float(").concat(c[0],"));\n\n            float sourceFracCol =\n                float(").concat(o[1],") *\n                  (float(dyC) / float(").concat(c[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}};var gV={kernelName:ba,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=r.shape.length,o=Nr.parseAxisParam(s,r.shape);if(0===i)return HL({inputs:{x:r},backend:n});let c=Ue().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=e;let a=mL("rc",n),r="".concat(a[n-1]," + 1 < ").concat(this.outputShape[n-1]),s="".concat(a[n-2]," + 1 < ").concat(this.outputShape[n-2]),i=Bj(n);var o;function c(n){let a=e.map((a,r)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - ").concat(a[n]," - 1"):"".concat(a[n])}(r,n)),r=a.join(","),s=a.slice(-2).join(",");return"getChannel(getX(".concat(r,"), vec2(").concat(s,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(r,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(i," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat((o=a.slice(),c(o)),";\n          if(").concat(r,"){\n            result.g = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",c(e)}(a.slice()),";\n          }\n          if(").concat(s,") {\n            result.b = ").concat(function(e){return e[n-2]="("+e[n-2]+" + 1)",c(e)}(a.slice()),";\n            if(").concat(r,") {\n              result.a = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",c(e)}(a.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}(r.shape,o):new class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=e,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      "));let a=e.map((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(a)).join(","),r=Bj(n);this.userCode="\n      void main() {\n        ".concat(r," coords = getOutputCoords();\n        setOutput(getX(").concat(a,"));\n      }\n    ")}}(r.shape,o);return n.runWebGLProgram(c,[r],r.dtype)}},bV={kernelName:cr,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e,{image:r}=t,{radians:s,fillValue:i,center:o}=n,c=a,l=new class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],a=e[2];this.outputShape=e;let r="";r="number"==typeof t?"float outputValue = ".concat(t.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(t.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(r,"\n          if(coordX >= 0 && coordX < ").concat(a," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}(r.shape,i),[u,d]=Hf.getImageCenter(o,r.shape[1],r.shape[2]),h=[[u,d,Math.sin(s),Math.cos(s)]];return c.runWebGLProgram(l,[r],r.dtype,h)}},yV=tP({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),vV={kernelName:ya,backendName:"webgl",kernelFunc:yV},xV=tP({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Zz}),wV={kernelName:va,backendName:"webgl",kernelFunc:xV},kV=class{constructor(e,t,n,a,r,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let o=Bj(r.length),c=Bj(s.length),l="";1===n?l="i":2===n&&(l="i, j");let u="getIndices(".concat(l,")"),d="";1===a?d="i":2===a&&(d="i, coords[1]");let h="getUpdates(".concat(d,")"),p="";i&&(p="coords[0], coords[1]");let f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(o," strides = ").concat(o,"(").concat(r,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(u,");\n              flattenedIndex += index * ").concat(m,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(h,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}};var IV={kernelName:xa,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=Hf.calculateShapes(s,r,i),h=[d/l,l];if(0===d)return n.makeTensorInfo(i,r.dtype);let p,f=dP({inputs:{x:r},backend:n,attrs:{shape:[c,o]}}),m=dP({inputs:{x:s},backend:n,attrs:{shape:[c,l]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));p=Ue().getBool("WEBGL_PACK")?new class{constructor(e,t,n,a,r,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let o=Bj(r.length),c=Bj(s.length),l="";1===n?l="i":2===n&&(l="i, j");let u="getIndices(".concat(l,")"),d="";1===a?d="i":2===a&&(d="i, coords[1]");let h="getUpdates(".concat(d,")"),p="";i&&(p="coords[0], coords[1]");let f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(o," strides = ").concat(o,"(").concat(r,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(e,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(t,"; j+=2) {\n              ivec4 index = round(").concat(u,");\n              flattenedIndex += index.xz * ").concat(m,";\n              if (j + 1 < ").concat(t,") {\n                flattenedIndex += index.yw * ").concat(g,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(h,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}(c,o,f.shape.length,m.shape.length,u,h):new kV(c,o,f.shape.length,m.shape.length,u,h);let b=n.runWebGLProgram(p,[m,f,g],m.dtype),y=dP({inputs:{x:b},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),y}};var SV={kernelName:ka,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=new class{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let r="for (int i = 0; i < ".concat(Math.ceil(Math.log2(t+1)),"; ++i) { if (left >= right) break;"),s=2===Ue().getNumber("WEBGL_VERSION")?"while (left < right) {":r,i="left"===a?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(s,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(i," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}(r.shape[0],r.shape[1],s.shape[1],i),c=[[r.shape[1]]];return n.runWebGLProgram(o,[r,s],"int32",c)}};var NV={kernelName:Ia,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=new class{constructor(e,t,n){let a,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)r="resRC",a="resRC";else{let n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let a=0;a<t.length;a++)i.push("".concat(n[a])),a<e&&s.push("".concat(n[a]));a=s.join(),r=i.join()}let s=Bj(n);this.userCode="\n      void main() {\n        ".concat(s," resRC = getOutputCoords();\n        float cVal = getC(").concat(a,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(r,"));\n        } else {\n          setOutput(getB(").concat(r,"));\n        }\n      }\n    ")}}(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(i,[a,r,s],ys(r.dtype,s.dtype))}},TV=tP({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(Hf.SELU_SCALEALPHA,";\n  float scale = ").concat(Hf.SELU_SCALE,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),OV={kernelName:Sa,backendName:"webgl",kernelFunc:TV},CV=tP({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Jz}),EV={kernelName:Ea,backendName:"webgl",kernelFunc:CV},_V=tP({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),AV={kernelName:Ca,backendName:"webgl",kernelFunc:_V},RV=tP({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(VL,"\n  return result;\n")}),DV={kernelName:Ta,backendName:"webgl",kernelFunc:RV},FV=tP({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),MV={kernelName:Oa,backendName:"webgl",kernelFunc:FV},jV=tP({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),zV={kernelName:_a,backendName:"webgl",kernelFunc:jV},LV={kernelName:Da,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;Nr.assert(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((e,t)=>e*t),c=[[0,0]];c.push(...i);for(let b=1+s.length;b<r.shape.length;++b)c.push([0,0]);let l=[],u=YU({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),d=Hf.getReshaped(u.shape,s,o,!1),h=Hf.getPermuted(d.length,s.length,!1),p=Hf.getReshapedPermuted(u.shape,s,o,!1),f=dP({inputs:{x:u},backend:n,attrs:{shape:d}}),m=vP({inputs:{x:f},backend:n,attrs:{perm:h}}),g=dP({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(u),l.push(f),l.push(m),l.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}};var PV={kernelName:ja,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(s.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(r.shape));if(0!==i.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));let o=n.readSync(a.dataId),c=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(i.dataId)[0],[d,h,p,f,m]=eL(o,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(h,a.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};var BV={kernelName:za,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(r.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));let i=Array.from(n.readSync(r.dataId)),o=n.readSync(a.dataId),c=Array.from(n.readSync(s.dataId)),[l,u,d]=tL(o,a.shape,a.dtype,i,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};var WV={kernelName:La,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(s.shape));let i=n.readSync(a.dataId),o=n.readSync(r.dataId),c=n.readSync(s.dataId),[l,u]=nL(i,a.shape,a.dtype,o,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};var UV={kernelName:Pa,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(s.shape));let i=n.readSync(a.dataId),o=n.readSync(r.dataId),c=n.readSync(s.dataId),[l,u]=nL(i,a.shape,a.dtype,o,c);return n.makeTensorInfo(u,a.dtype,l)}};var VV={kernelName:Ba,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=Hf.calculateShapes(s,r,o);if("string"===s.dtype){let e=n.bufferSync(r),t=n.bufferSync(s),a=Nr.decodeString(n.readSync(i.dataId)[0]),p=Yz(e,t,o,h,u,l,c,d,a,!1);return n.makeTensorInfo(o,p.dtype,p.values)}let p=new kV(l,c,r.shape.length,s.shape.length,d,[h,1],!1),f=n.runWebGLProgram(p,[s,r,i],s.dtype),m=dP({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),m}};var GV={kernelName:Fa,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=Nr.parseAxisParam(i,r.shape)[0],c=Hf.prepareSplitSize(r,s,o),l=r.shape.length,u=new Array(l).fill(0),d=r.shape.slice();return c.map(e=>{let t=[...d];t[o]=e;let a=sB({inputs:{x:r},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,a})}},HV="return sqrt(x);",qV=tP({opSnippet:HV,packedOpSnippet:HV,cpuKernelImpl:aL}),KV={kernelName:Aa,backendName:"webgl",kernelFunc:qV},XV=tP({opSnippet:"return x * x;"}),ZV={kernelName:Ua,backendName:"webgl",kernelFunc:XV},YV="return (a - b) * (a - b);",JV=nP({opSnippet:YV,packedOpSnippet:YV}),QV={kernelName:Wa,backendName:"webgl",kernelFunc:JV};var $V={kernelName:Va,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");let s=n.readSync(r.dataId),i=Hf.fromUint8ToStringArray(s),o=rL(i,"string",a);return n.makeTensorInfo(r.shape,"string",o)}};var eG={kernelName:ir,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,s=wL+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),i=new xL(r.shape,s);return a.runWebGLProgram(i,[r],r.dtype)}};var tG={kernelName:Ga,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:a,attrs:r}=e,{x:s}=n,{begin:i,end:o,strides:c,beginMask:l,endMask:u,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=r,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:y,begin:v,end:x,strides:w}=wf.sliceInfo(s.shape,i,o,c,l,u,d,h,p);if(g)t=dP({inputs:{x:s},backend:a,attrs:{shape:m}});else if(b||y){Nr.assert(s.shape.length>=1,()=>"Input must have rank at least 1, got: ".concat(s.shape.length));let e=wf.computeOutShape(v,x,w),n=sB({inputs:{x:s},backend:a,attrs:{begin:v,size:e}});t=dP({inputs:{x:n},backend:a,attrs:{shape:m}}),a.disposeIntermediateTensorInfo(n)}else if(a.shouldExecuteOnCPU([s])){let e=a.readSync(s.dataId),n=Ui(s.shape,s.dtype,e),r=sL(f,n,w,v);t=a.makeTensorInfo(m,s.dtype,r.values)}else{let e=new class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let a=n.length,r=Bj(n.length),s=Bj(n.length),i="";if(1===a)i="coords * strides + begin";else{let e=0;i=n.map((t,a)=>(e++,1===n.length?"coords * strides[".concat(a,"] + begin[").concat(a,"]"):"coords[".concat(e-1,"] * strides[").concat(a,"] + begin[").concat(a,"]"))).join(",")}this.userCode="\n      ".concat(r," begin = ").concat(r,"(").concat(e,");\n      ").concat(r," strides = ").concat(r,"(").concat(t,");\n\n      void main() {\n        ").concat(s," coords = getOutputCoords();\n        setOutput(getX(").concat(i,"));\n      }\n    ")}}(v,w,f);t=a.runWebGLProgram(e,[s],s.dtype)}let k=dP({inputs:{x:t},backend:a,attrs:{shape:m}});return a.disposeIntermediateTensorInfo(t),k}};var nG={kernelName:Ha,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:d}=t,h=n.readSync(u.dataId),p=n.readSync(d.dataId),[f,m]=iL(h,p,r,s,i,o,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};var aG={kernelName:qa,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));let o=n.readSync(s.dataId),c=n.readSync(i.dataId)[0],[l,u,d]=oL(o,c,r),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};var rG={kernelName:Ka,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=cL(i,r);return n.makeTensorInfo(s.shape,"int32",o)}},sG=tP({opSnippet:"return tan(x);"}),iG={kernelName:Za,backendName:"webgl",kernelFunc:sG},oG=tP({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),cG={kernelName:Ya,backendName:"webgl",kernelFunc:oG};var lG={kernelName:wa,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=t,{}=a,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=Hf.calculateShapes(i,s,r.shape),h=[d/l,l];if(0===d)return n.makeTensorInfo(r.shape,s.dtype);let p=dP({inputs:{x:s},backend:n,attrs:{shape:[c,o]}}),f=dP({inputs:{x:i},backend:n,attrs:{shape:[c,l]}}),m=dP({inputs:{x:r},backend:n,attrs:{shape:h}}),g=new kV(c,o,p.shape.length,f.shape.length,u,h,!1,!0),b=n.runWebGLProgram(g,[f,p,m],m.dtype),y=dP({inputs:{x:b},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),y}};function uG(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;if("string"===r.dtype||r.shape.length>5){let e=n.readSync(r.dataId),t="string"===r.dtype?e.map(e=>Nr.decodeString(e)):e,a=Ui(r.shape,r.dtype,t),i=uL(a,s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}let i=new class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let a=Bj(this.rank),r=function(e){let t=e.length;if(t>5)throw Error("Tile for rank ".concat(t," is not yet supported"));if(1===t)return"imod(resRC, ".concat(e[0],")");let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push("imod(".concat(n[r],", ").concat(e[r],")"));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(a," resRC = getOutputCoords();\n        setOutput(getA(").concat(r,"));\n      }\n    ")}}(r.shape,s);return n.runWebGLProgram(i,[r],r.dtype)}var dG={kernelName:Ja,backendName:"webgl",kernelFunc:uG},hG=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};function pG(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function fG(e){let t=1;for(;t<e;)t*=2;return t}var mG={kernelName:Qa,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a,o=Ue().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=Ue().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=r.shape,u=l[l.length-1];if(n.shouldExecuteOnCPU([r])||u<o||s>c){let e=n.readSync(r.dataId),[t,a]=dL(e,l,r.dtype,s,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===s)return l[l.length-1]=0,[n.makeTensorInfo(l,r.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===u)return[r,SW({attrs:{shape:l,dtype:"int32",value:0},backend:n})];let d=n.texData.get(r.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(r):r,f=Nr.sizeFromShape(l)/u,m=dP({inputs:{x:p},attrs:{shape:[f,u]},backend:n});h&&pG(n,p);let g=fG(s),b=fG(u),y=null,v=()=>null===y?[m,m]:[m,y],x=(e,t,a)=>{let r=v(),s=new class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}(a),i=[[u],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=y;y=n.runWebGLProgram(s,r,"int32",i),pG(n,o)};for(let N=1;N<g;N*=2){let e=2*N;for(let t=N;t>=1;t/=2)x(e,t,[f,b])}for(let N=b;N>g;N/=2){let e=v(),t=new hG([f,N/2]),a=[[u],[null===y?1:0],[g]],r=y;y=n.runWebGLProgram(t,e,"int32",a),pG(n,r);let s=g/2,i=2*s;for(let n=s;n>=1;n/=2)x(i,n,y.shape)}let w=y;y=sB({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,s]}}),pG(n,w);let k=LW({inputs:{x:m,indices:y},backend:n,attrs:{axis:1,batchDims:1}});pG(n,m);let I=l.slice(0,-1);I.push(s),w=y,y=dP({inputs:{x:y},attrs:{shape:I},backend:n}),pG(n,w);let S=k;return k=dP({inputs:{x:k},attrs:{shape:I},backend:n}),pG(n,S),[k,y]}};var gG={kernelName:$a,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:c,outputShape:l}=a,[u,d,h,p]=r.shape,[f,m]=null!=l?l:[d,h],g=[u,f,m,p],b=new class{constructor(e,t,n,a,r,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i,o="nearest"===n?1:2;switch(a){case"constant":i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4;break;default:i=1}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(i," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(t,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(r,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(r,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat(o," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}(d,h,i,o,c,g);return n.runWebGLProgram(b,[r,s],"float32")}};var bG={kernelName:tr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;pj(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=a.readSync(s.dataId),{outputValues:o,outputShape:c,indices:l}=pL(i,r,s.shape,s.dtype);return[a.makeTensorInfo(c,s.dtype,o),a.makeTensorInfo([l.length],"int32",l)]}};var yG={kernelName:nr,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r,o=i.shape.length,c=r.shape[s],l=new Array(o-1),u=0;for(let m=0;m<o;m++)m!==s&&(l[u++]=i.shape[m]);let d=[],h=new Array(o).fill(0),p=i.shape.slice();p[s]=1;let f=new Array(c);for(let m=0;m<f.length;m++){h[s]=m;let e=sB({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),t=dP({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,d.push(e)}return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}};var vG,xG,wG,kG=[kP,SP,TP,CP,AP,RP,DP,FP,LP,PP,WP,VP,HP,KP,ZP,QP,$P,eB,tB,nB,aB,oB,cB,lB,uB,mB,yB,vB,XL,wB,OB,DB,FB,MB,jB,zB,PB,WB,VB,GB,ZB,YB,JB,QB,tW,nW,aW,rW,sW,iW,cW,lW,dW,pW,mW,bW,xW,IW,TW,OW,_W,RW,DW,MW,jW,zW,PW,WW,VW,qL,GW,SB,qW,XW,YW,JL,QW,eU,tU,aU,sU,oU,lU,dU,hU,pU,mU,bU,yU,vU,xU,wU,kU,IU,SU,TU,OU,EU,zU,uP,LU,BU,UU,GU,hB,HU,XU,ZU,JU,$U,eP,eV,tV,nV,aV,sV,fB,AU,oV,lV,dV,hP,hV,pV,fV,mV,gV,bV,vV,wV,IV,SV,NV,OV,EV,AV,DV,MV,iB,jU,zV,LV,PV,BV,WV,UV,VV,GV,KV,ZV,QV,$V,eG,tG,nG,aG,rG,FU,yP,iG,cG,lG,dG,mG,gG,xP,bG,yG,{kernelName:ar,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a,o=r.shape.length,c=[],l=0,u=Hf.getAxesPermutation([l],o),d=r;null!=u&&(d=vP({inputs:{x:r},backend:n,attrs:{perm:u}}),c.push(d),l=Hf.getInnerMostAxes(1,o)[0]);let h=Hf.segment_util.computeOutShape(d.shape,l,i),p=Nr.sizeFromShape([d.shape[l]]),f=dP({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});c.push(f);let m=vs(r.dtype),g=(e,t,a,r,s)=>{let i=e.shape[0],o=e.shape[1],l=Hf.segment_util.segOpComputeOptimalWindowSize(o,s),u={windowSize:l,inSize:o,batchSize:i,numSegments:s},d=new class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,a=e.batchSize,r=e.inSize,s=e.numSegments,i=s*Math.ceil(r/n);this.outputShape=[a,i];let o=4*Math.floor(n/4),c=n%4,l="\n        sumValue += dot(values, segFilter);\n    ",u="";r%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      "));let d="";r%n>0&&(d="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(d,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(s,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(s,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(o,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(o,";\n        if (").concat(1===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(l,"\n        } else if (").concat(2===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(l,"\n        } else if (").concat(3===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(l,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}(u,t),h=n.compileAndRun(d,[e,a],r);if(c.push(h),h.shape[1]===s)return h;let p=rV({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),f=uG({inputs:{x:p},backend:n,attrs:{reps:[o/l]}});return c.push(p),c.push(f),g(h,t,f,r,s)},b=dP({inputs:{x:g(f,"unsortedSegmentSum",s,m,i)},backend:n,attrs:{shape:h}}),y=b;if(null!=u){c.push(b);let e=Hf.getUndoAxesPermutation(u);y=vP({inputs:{x:y},backend:n,attrs:{perm:e}})}return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}},KU];for(let t of kG)vr(t);!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(vG||(vG={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(xG||(xG={}));var IG={kernelName:lr,backendName:"wasm",setupFunc:function(e){wG=e.wasm.cwrap(lr,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t;if("float32"!==r.dtype||"float32"!==s.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=a,h=n.dataIdMap.get(r.dataId).id,p=n.dataIdMap.get(s.dataId).id,f=0;if(null!=i){let e=n.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error("_FusedMatMul only supports rank-1 bias but got rank ".concat(e.shape.length,"."));f=e.id}let m=null==o?0:n.dataIdMap.get(o.dataId).id,g=xG[u];if(null==g)throw new Error("".concat(u," activation not yet supported for FusedConv2D in the wasm backend."));let b=c?r.shape[2]:r.shape[1],y=l?s.shape[1]:s.shape[2],v=jc.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)),x=n.makeOutput([...v,b,y],r.dtype),w=n.dataIdMap.get(x.dataId).id,k=new Uint8Array(new Int32Array(r.shape).buffer),I=new Uint8Array(new Int32Array(s.shape).buffer);return wG(h,k,r.shape.length,p,I,s.shape.length,c,l,g,f,m,d||0,w),x}};function SG(e,t){let n;return{kernelName:e,backendName:"wasm",setupFunc:function(t){n=t.wasm.cwrap(e,null,["number","number","number"])},kernelFunc:function(e){let{backend:a,inputs:{x:r}}=e,s=a.dataIdMap.get(r.dataId).id,i=a.makeOutput(r.shape,t||r.dtype),o=a.dataIdMap.get(i.dataId).id;return 0===Nr.sizeFromShape(i.shape)||n(s,vG[r.dtype],o),i}}}var NG=SG(Ke),TG=SG(Xe),OG=SG(Ze);function CG(e,t,n){let a;return{kernelName:e,backendName:"wasm",setupFunc:function(t){a=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:r}=e,{a:s,b:i}=r,o=t.dataIdMap.get(s.dataId).id,c=t.dataIdMap.get(i.dataId).id,l=null!=n?n:s.dtype,u=Hf.assertAndGetBroadcastShape(s.shape,i.shape),d=t.makeOutput(u,l);if(0===Nr.sizeFromShape(u))return d;let h=new Uint8Array(new Int32Array(s.shape).buffer),p=new Uint8Array(new Int32Array(i.shape).buffer),f=t.dataIdMap.get(d.dataId).id;return a(o,h,s.shape.length,c,p,i.shape.length,vG[s.dtype],f),d}}}var EG,_G=CG(Ye);var AG={kernelName:Je,backendName:"wasm",setupFunc:function(e){EG=e.wasm.cwrap(Je,null,["array","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,a=n.makeOutput(t[0].shape,t[0].dtype);if(0===Nr.sizeFromShape(a.shape))return a;let r=t.map(e=>n.dataIdMap.get(e.dataId).id),s=new Uint8Array(new Int32Array(r).buffer),i=n.dataIdMap.get(a.dataId).id;return EG(s,r.length,vG[a.dtype],i),a}};function RG(e){let{inputs:{x:t},backend:n}=e;if("string"===t.dtype)return qs(n.readSync(t.dataId),t.shape,t.dtype);let a=n.makeOutput(t.shape,t.dtype),r=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(a).set(r),a}var DG,FG={kernelName:un,backendName:"wasm",kernelFunc:RG};function MG(e){let{inputs:t,backend:n,attrs:a}=e,[r,s]=function(e,t){let n=[],a=[];for(let r=0;r<e.length;++r)1!==e[r]&&n.push(e[r]),1!==e[t[r]]&&a.push(t[r]);for(let r=0;r<a.length;++r){let e=-1;for(let t=0;t<a.length;++t)a[t]>=r&&(-1===e||a[e]>a[t])&&(e=t);a[e]=r}return[n,a]}(t.x.shape,a.perm),i=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(i=!1);let o=function(e,t){let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];return n}(t.x.shape,a.perm),c={dataId:t.x.dataId,shape:r,dtype:t.x.dtype};if(i){let e=RG({inputs:t,backend:n});return e.shape=o,e}let l=n.makeOutput(o,c.dtype),u=n.dataIdMap.get(c.dataId).id,d=n.dataIdMap.get(l.dataId).id,h=new Uint8Array(new Int32Array(s).buffer),p=new Uint8Array(new Int32Array(c.shape).buffer);return DG(u,p,c.shape.length,vG[c.dtype],d,h,s.length),l}var jG,zG={kernelName:er,backendName:"wasm",kernelFunc:MG,setupFunc:function(e){DG=e.wasm.cwrap(er,null,["number","array","number","number","number","array","number"])}};function LG(e,t,n){let a=e.shape,r=e.shape.length,s=Nr.parseAxisParam(t,a),i=s,o=Hf.getAxesPermutation(i,r),c=null,l=!1;if(null!=o){let t=new Array(r);for(let e=0;e<t.length;e++)t[e]=a[o[e]];i=Hf.getInnerMostAxes(i.length,r),c=MG({inputs:{x:e},attrs:{perm:o},backend:n});let s=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(c.dataId).id!==s&&(l=!0)}return{transposed:c,originalAxes:s,axes:i,inputWasTransposed:l}}var PG,BG={kernelName:Qe,backendName:"wasm",setupFunc:function(e){jG=e.wasm.cwrap(Qe,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,c=i,{transposed:l,axes:u,originalAxes:d,inputWasTransposed:h}=LG(i,r,t);if(h){c=l,o=t.dataIdMap.get(l.dataId).id}let p=c.shape.length;Hf.assertAxesAreInnerMostDims("all",u,p);let[f,m]=Hf.computeOutAndReduceShapes(c.shape,u),g=Nr.sizeFromShape(m),b=t.makeOutput(f,i.dtype);if(0!==Nr.sizeFromShape(c.shape)){let e=t.dataIdMap.get(b.dataId).id;jG(o,g,e)}if(h&&t.disposeData(l.dataId),s){let e=Hf.expandShapeToKeepDim(b.shape,d);b.shape=e}return b}};var WG={kernelName:$e,backendName:"wasm",setupFunc:function(e){PG=e.wasm.cwrap($e,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,c=i,{transposed:l,axes:u,originalAxes:d,inputWasTransposed:h}=LG(i,r,t);if(h){c=l,o=t.dataIdMap.get(l.dataId).id}let p=c.shape.length;Hf.assertAxesAreInnerMostDims("any",u,p);let[f,m]=Hf.computeOutAndReduceShapes(c.shape,u),g=Nr.sizeFromShape(m),b=t.makeOutput(f,i.dtype);if(0!==Nr.sizeFromShape(c.shape)){let e=t.dataIdMap.get(b.dataId).id;PG(o,g,e)}if(h&&t.disposeData(l.dataId),s){let e=Hf.expandShapeToKeepDim(b.shape,d);b.shape=e}return b}};function UG(e){let t;return{kernelName:e,backendName:"wasm",setupFunc:function(n){t=n.wasm.cwrap(e,null,["number","number","number","number","number"])},kernelFunc:function(e){let{backend:n,inputs:a,attrs:r}=e,{axis:s}=r,{x:i}=a,o=n.dataIdMap.get(i.dataId).id,c=o,l=i,{transposed:u,axes:d,inputWasTransposed:h}=LG(i,s,n);if(h){let e=n.dataIdMap.get(u.dataId).id;e!==o&&(l=u,c=e)}let p=l.shape.slice(0,-1),f=n.makeOutput(p,"int32"),m=n.dataIdMap.get(f.dataId).id,g=Nr.sizeFromShape(f.shape),b=l.shape[d[0]];return t(c,vG[l.dtype],g,b,m),h&&n.disposeData(u.dataId),f}}}var VG,GG=UG(et),HG=UG(tt),qG=SG(nt),KG=SG(at),XG=SG(rt),ZG=CG(it),YG=SG(st);var JG,QG={kernelName:ot,backendName:"wasm",setupFunc:function(e){VG=e.wasm.cwrap(ot,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id,{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=n,u=Hf.computePool2DInfo(r.shape,i,o,1,c,l),d=u.filterHeight,h=u.filterWidth,p=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,g=u.padInfo.left,b=u.strideHeight,y=u.strideWidth,v=u.inChannels;if("channelsLast"!==u.dataFormat)throw new Error("wasm backend does not support dataFormat:'".concat(u.dataFormat,"'. Please use 'channelsLast'."));if(1!==u.dilationWidth||1!==u.dilationHeight)throw new Error("was backend only supports average pooling with dilation = [1, 1], got [".concat(u.dilationHeight,", ").concat(u.dilationWidth,"]."));let x=a.makeOutput(u.outShape,"float32"),w=a.dataIdMap.get(x.dataId).id;return VG(s,r.shape[0],r.shape[1],r.shape[2],d,h,p,f,m,g,b,y,v,w),x}};var $G,eH={kernelName:lt,backendName:"wasm",setupFunc:function(e){JG=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:c,dataFormat:l}=a,u=Hf.computePool3DInfo(r.shape,s,i,1,o,c,l),d=n.makeOutput(u.outShape,r.dtype);return JG(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),d}};var tH,nH={kernelName:ut,backendName:"wasm",setupFunc:function(e){$G=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=a,u=Hf.computePool3DInfo(s.shape,i,o,1,c,l),d=n.makeOutput(s.shape,s.dtype);return $G(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left,u.filterDepth,u.filterHeight,u.filterWidth),d}};var aH={kernelName:ct,backendName:"wasm",setupFunc:function(e){tH=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:c}=a,l=Hf.computePool2DInfo(s.shape,i,o,1,c),u=n.makeOutput(s.shape,s.dtype);return tH(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(u.dataId).id,l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.top,l.padInfo.left,l.filterHeight,l.filterWidth),u}};function rH(e){let{inputs:t,attrs:n}=e,{x:a}=t,{shape:r}=n,s=Nr.sizeFromShape(a.shape),i=Nr.inferFromImplicitShape(r,s);return Nr.assert(s===Nr.sizeFromShape(i),()=>"new shape: ".concat(i,", old shape: ").concat(a.shape,". New shape and old shape must have the same number of elements.")),e.backend.incRef(a.dataId),{dataId:a.dataId,shape:i,dtype:a.dtype}}var sH,iH={kernelName:da,backendName:"wasm",kernelFunc:rH};var oH={kernelName:dt,backendName:"wasm",setupFunc:function(e){sH=e.wasm.cwrap(dt,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;if("float32"!==r.dtype||"float32"!==s.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let c=r.shape.length,l=s.shape.length,u=i?r.shape[c-2]:r.shape[c-1],d=o?s.shape[l-1]:s.shape[l-2],h=i?r.shape[c-1]:r.shape[c-2],p=o?s.shape[l-2]:s.shape[l-1],f=r.shape.slice(0,-2),m=s.shape.slice(0,-2),g=Nr.sizeFromShape(f),b=Nr.sizeFromShape(m),y=jc.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);Nr.assert(u===d,()=>"Error in matMul: inner shapes (".concat(u,") and (").concat(d,") of Tensors with shapes ").concat(r.shape," and ").concat(s.shape," and transposeA=").concat(i," and transposeB=").concat(o," must match."));let v=o?[b,p,d]:[b,d,p],x=rH({inputs:{x:r},backend:n,attrs:{shape:i?[g,u,h]:[g,h,u]}}),w=rH({inputs:{x:s},backend:n,attrs:{shape:v}}),k=n.dataIdMap.get(x.dataId).id,I=n.dataIdMap.get(w.dataId).id,S=i?x.shape[2]:x.shape[1],N=o?w.shape[1]:w.shape[2],T=Math.max(g,b),O=n.makeOutput([T,S,N],x.dtype),C=n.dataIdMap.get(O.dataId).id,E=new Uint8Array(new Int32Array(x.shape).buffer),_=new Uint8Array(new Int32Array(w.shape).buffer);return sH(k,E,x.shape.length,I,_,w.shape.length,i,o,C),n.disposeData(x.dataId),n.disposeData(w.dataId),O.shape=y,O}};function cH(e){let{inputs:{x:t},attrs:{begin:n,size:a},backend:r}=e,[s,i]=wf.parseSliceParams(t,n,a),o=wf.isSliceContinous(t.shape,s,i),c=r.readSync(t.dataId),l=r.makeOutput(i,t.dtype),u=Nr.computeStrides(t.shape),d=r.dataIdMap.get(l.dataId);if(o){let e=wf.computeFlatOffset(s,u);return"string"===t.dtype?d.stringBytes=c.slice(e,e+Nr.sizeFromShape(i)):r.typedArrayFromHeap(l).set(c.subarray(e,e+Nr.sizeFromShape(i))),l}if("string"===t.dtype){let e=R_(c,s,i,t.shape,t.dtype);return d.stringBytes=e,l}let h=r.typedArrayFromHeap(l),p=t.shape.length;if(2===p)!function(e,t,n,a,r){let s=0,i=a[0],o=a[1],c=i+r[0];for(let l=i;l<c;l++){let a=l*t+o;n.set(e.subarray(a,a+r[1]),s),s+=r[1]}}(c,u[0],h,s,i);else if(3===p)!function(e,t,n,a,r,s){let i=0,o=r[0],c=r[1],l=r[2],u=o+s[0],d=c+s[1];for(let h=o;h<u;h++)for(let r=c;r<d;r++){let o=h*t+r*n+l;a.set(e.subarray(o,o+s[2]),i),i+=s[2]}}(c,u[0],u[1],h,s,i);else if(4===p)!function(e,t,n,a,r,s,i){let o=0,c=s[0],l=s[1],u=s[2],d=c+i[0],h=l+i[1],p=u+i[2],f=s[3];for(let m=c;m<d;m++)for(let s=l;s<h;s++)for(let c=u;c<p;c++){let l=m*t+s*n+c*a+f;r.set(e.subarray(l,l+i[3]),o),o+=i[3]}}(c,u[0],u[1],u[2],h,s,i);else{let e=R_(c,s,i,t.shape,t.dtype);h.set(e)}return l}var lH={kernelName:Na,backendName:"wasm",kernelFunc:cH};var uH,dH={kernelName:ht,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a,o=s.reduce((e,t)=>e*t),c=Hf.getReshaped(r.shape,s,o),l=Hf.getPermuted(c.length,s.length),u=Hf.getReshapedPermuted(r.shape,s,o),d=Hf.getSliceBeginCoords(i,s.length),h=Hf.getSliceSize(u,i,s.length),p=rH({inputs:{x:r},backend:n,attrs:{shape:c}}),f=MG({inputs:{x:p},backend:n,attrs:{perm:l}}),m=cH({inputs:{x:rH({inputs:{x:f},backend:n,attrs:{shape:u}})},backend:n,attrs:{begin:d,size:h}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(p.dataId),m}};var hH={kernelName:pt,backendName:"wasm",setupFunc:function(e){uH=e.wasm.cwrap(pt,null,["number","number","boolean","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i}=a,o=0!==s.shape.reduce((e,t)=>e*t,1),c=1===r.shape.length?[i]:[r.shape[0],i],l=t.makeOutput(c,s.dtype);function u(e){return t.dataIdMap.get(e.dataId).id}return uH(u(r),i,o,u(s),vG[s.dtype],u(l)),l}},pH=CG(ft);var fH={kernelName:gt,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.typedArrayFromHeap(a),i=n.typedArrayFromHeap(r),o=Hf.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}};function mH(e){let{inputs:{x:t},attrs:{dtype:n},backend:a}=e,r=a.makeOutput(t.shape,n),s=a.typedArrayFromHeap(t);return a.typedArrayFromHeap(r).set(s),r}var gH,bH={kernelName:bt,backendName:"wasm",kernelFunc:mH},yH=SG(yt);var vH={kernelName:vt,backendName:"wasm",setupFunc:function(e){gH=e.wasm.cwrap(vt,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=a,o=n.dataIdMap.get(r.dataId).id,c=n.makeOutput(r.shape,r.dtype),l=n.dataIdMap.get(c.dataId).id;return gH(o,s,i,l),c}};function xH(e){let{inputs:t,backend:n}=e,a=Nr.parseAxisParam(e.attrs.axis,t[0].shape)[0],r=t.map(e=>e.shape);Hf.assertParamsConsistent(r,a);let s=Hf.computeOutShape(t.map(e=>e.shape),a),i=t.filter(e=>Nr.sizeFromShape(e.shape)>0);if(1===i.length)return RG({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(0===Nr.sizeFromShape(s))return o;if("string"===i[0].dtype){let e=i.map(e=>{let t=[-1,Nr.sizeFromShape(e.shape.slice(a))];return rH({inputs:{x:e},backend:n,attrs:{shape:t}})}),r=e.map(e=>({vals:n.readSync(e.dataId),shape:e.shape}));s=Hf.computeOutShape(e.map(e=>e.shape),1);let c=1===e[0].shape[0],l=hE(r,s,t[0].dtype,c),u=Hf.computeOutShape(i.map(e=>e.shape),a);return o.shape=u,n.dataIdMap.get(o.dataId).stringBytes=Hf.fromStringArrayToUint8(l),e.forEach(e=>n.disposeData(e.dataId)),o}let c=Nr.sizeFromShape(i[0].shape.slice(0,a)),l=0,u=i.map(e=>{let t=Nr.sizeFromShape(e.shape.slice(a));return l+=t,t}),d=i.map(e=>n.typedArrayFromHeap(e)),h=n.typedArrayFromHeap(o);for(let p=0;p<c;p++){let e=p*l;for(let t=0;t<d.length;t++){let n=u[t],a=p*n,r=d[t].subarray(a,a+n);h.set(r,e),e+=n}}return o}var wH,kH={kernelName:kt,backendName:"wasm",kernelFunc:xH};var IH,SH={kernelName:It,backendName:"wasm",setupFunc:function(e){wH=e.wasm.cwrap(It,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(s.dataId).id,{strides:c,dilations:l,pad:u,dimRoundingMode:d,dataFormat:h}=n,p=Hf.convertConv2DDataFormat(h),f=Hf.computeConv2DInfo(r.shape,s.shape,c,l,u,d,!1,p),m=f.filterHeight,g=f.filterWidth,b=f.padInfo.top,y=f.padInfo.right,v=f.padInfo.bottom,x=f.padInfo.left,w=f.dilationHeight,k=f.dilationWidth,I=f.strideHeight,S=f.strideWidth,N=f.inChannels,T=f.outChannels,O="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error("wasm backend Conv2D does not support dataFormat:'".concat(f.dataFormat,"'. Please use 'channelsLast'."));let C=a.makeOutput(f.outShape,"float32"),E=a.dataIdMap.get(C.dataId).id;return wH(i,r.shape[0],r.shape[1],r.shape[2],o,m,g,b,y,v,x,O,w,k,I,S,N,T,E),C}};var NH,TH={kernelName:Nt,backendName:"wasm",setupFunc:function(e){IH=e.wasm.cwrap(Nt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{dy:r,filter:s}=n,{strides:i,pad:o,dataFormat:c,dimRoundingMode:l,inputShape:u}=a,d=Hf.convertConv2DDataFormat(c),h=Hf.computeConv2DInfo(u,s.shape,i,1,o,l,!1,d),{batchSize:p,filterHeight:f,filterWidth:m,inChannels:g,inHeight:b,inWidth:y,outChannels:v,outHeight:x,outWidth:w,strideHeight:k,strideWidth:I}=h,S=f-1-h.padInfo.top,N=m-1-h.padInfo.left,T="channelsLast"===h.dataFormat,O=Nr.computeStrides(h.inShape),C=Nr.computeStrides(r.shape),[E,_,A]=Nr.computeStrides(s.shape),R=O[0],D=T?O[1]:O[2],F=T?O[2]:1,M=T?1:O[1],j=C[0],z=T?C[1]:C[2],L=T?C[2]:1,P=T?1:C[1],B=t.makeOutput(h.inShape,"float32"),W=t.dataIdMap.get(B.dataId).id,U=t.dataIdMap.get(r.dataId).id,V=t.dataIdMap.get(s.dataId).id;return IH(U,V,p,f,m,b,y,g,x,w,v,k,I,S,N,E,_,A,R,D,F,M,j,z,L,P,W),B}};var OH,CH={kernelName:Tt,backendName:"wasm",setupFunc:function(e){NH=e.wasm.cwrap(Tt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:c}=a;if("float32"!==r.dtype)throw new Error("Tensor x must have dtype float32, got ".concat(r.dtype));if("float32"!==s.dtype)throw new Error("Tensor filter must have dtype float32, got ".concat(s.dtype));let l=Hf.computeConv3DInfo(r.shape,s.shape,i,c,o),u=n.makeOutput(l.outShape,r.dtype);return NH(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,l.batchSize,l.inDepth,l.inHeight,l.inWidth,l.inChannels,l.outDepth,l.outHeight,l.outWidth,l.outChannels,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.filterDepth,l.filterHeight,l.filterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),u}};var EH,_H={kernelName:Ot,backendName:"wasm",setupFunc:function(e){OH=e.wasm.cwrap(Ot,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:c}=a;if("float32"!==r.dtype)throw new Error("Tensor dy must have dtype float32, got ".concat(r.dtype));if("float32"!==s.dtype)throw new Error("Tensor filter must have dtype float32, got ".concat(s.dtype));let l=Hf.computeConv3DInfo(r.shape,c,i,1,o),u=n.makeOutput(l.filterShape,s.dtype);return OH(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,l.batchSize,l.inDepth,l.inHeight,l.inWidth,l.inChannels,l.outDepth,l.outHeight,l.outWidth,l.outChannels,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.filterDepth,l.filterHeight,l.filterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),u}};var AH,RH,DH={kernelName:Ct,backendName:"wasm",setupFunc:function(e){EH=e.wasm.cwrap(Ct,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:c}=a;if("float32"!==r.dtype)throw new Error("Tensor dy must have dtype float32, got ".concat(r.dtype));if("float32"!==s.dtype)throw new Error("Tensor filter must have dtype float32, got ".concat(s.dtype));let l=Hf.computeConv3DInfo(c,s.shape,o,1,i),u=n.makeOutput(l.inShape,r.dtype);return EH(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(u.dataId).id,l.batchSize,l.inDepth,l.inHeight,l.inWidth,l.inChannels,l.outDepth,l.outHeight,l.outWidth,l.outChannels,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.filterDepth,l.filterHeight,l.filterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),u}},FH=SG(Et),MH=SG(_t);!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}(AH||(AH={}));var jH,zH={kernelName:Dt,backendName:"wasm",setupFunc:function(e){RH=e.wasm.cwrap(Dt,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:a,attrs:r}=e,{method:s,extrapolationValue:i,cropSize:o}=r,{image:c,boxes:l,boxInd:u}=a,d=l.shape[0],[h,p]=o,f=[d,h,p,c.shape[3]],m=n.dataIdMap.get(c.dataId);"float32"!==c.dtype&&(t=mH({backend:n,inputs:{x:c},attrs:{dtype:"float32"}}),m=n.dataIdMap.get(t.dataId));let g=m.id,b=n.dataIdMap.get(l.dataId).id,y=n.dataIdMap.get(u.dataId).id,v=n.makeOutput(f,"float32"),x=n.dataIdMap.get(v.dataId).id,w=new Uint8Array(new Int32Array(c.shape).buffer);return RH(g,b,y,d,w,h,p,AH[s],i,x),null!=t&&n.disposeData(t.dataId),v}};var LH,PH={kernelName:At,backendName:"wasm",setupFunc:function(e){jH=e.wasm.cwrap(At,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a,c=r.shape.length;Nr.assert("float32"===r.dtype||"int32"===r.dtype,()=>"cumprod does not support ".concat(r.dtype," tensors in the WASM backend"));let l=Hf.getAxesPermutation([s],c),u=r;null!==l&&(u=MG({inputs:{x:r},attrs:{perm:l},backend:n}));let d=Hf.getInnerMostAxes(1,c)[0];Hf.assertAxesAreInnerMostDims("cumprod",[d],c);let h=n.makeOutput(u.shape,u.dtype),p=u.shape[d],f=n.dataIdMap.get(u.dataId).id,m=n.dataIdMap.get(h.dataId).id;jH(f,i?1:0,o?1:0,p,m,vG[r.dtype]);let g=h;if(null!==l){g=MG({inputs:{x:h},attrs:{perm:Hf.getUndoAxesPermutation(l)},backend:n}),n.disposeData(u.dataId),n.disposeData(h.dataId)}return g}};var BH,WH={kernelName:Rt,backendName:"wasm",setupFunc:function(e){LH=e.wasm.cwrap(Rt,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a,c=r.shape.length;Nr.assert("float32"===r.dtype||"int32"===r.dtype,()=>"cumsum does not support ".concat(r.dtype," tensors in the WASM backend"));let l=Hf.getAxesPermutation([s],c),u=r;null!==l&&(u=MG({inputs:{x:r},attrs:{perm:l},backend:n}));let d=Hf.getInnerMostAxes(1,c)[0];Hf.assertAxesAreInnerMostDims("cumsum",[d],c);let h=n.makeOutput(u.shape,u.dtype),p=u.shape[d],f=n.dataIdMap.get(u.dataId).id,m=n.dataIdMap.get(h.dataId).id;LH(f,i?1:0,o?1:0,p,m,vG[r.dtype]);let g=h;if(null!==l){g=MG({inputs:{x:h},attrs:{perm:Hf.getUndoAxesPermutation(l)},backend:n}),n.disposeData(u.dataId),n.disposeData(h.dataId)}return g}};var UH,VH={kernelName:Ft,backendName:"wasm",setupFunc:function(e){BH=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i,binaryOutput:o}=a,c=0!==s.shape.reduce((e,t)=>e*t,1),l=1===r.shape.length?[i]:[r.shape[0],i],u=t.makeOutput(l,s.dtype);function d(e){return t.dataIdMap.get(e.dataId).id}return BH(d(r),new Uint8Array(new Int32Array(r.shape).buffer),r.shape.length,i,c,d(s),vG[s.dtype],o,d(u)),u}};var GH,HH={kernelName:Mt,backendName:"wasm",setupFunc:function(e){UH=e.wasm.cwrap(Mt,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{blockSize:s,dataFormat:i}=a,o=r.shape[0],c=("NHWC"===i?r.shape[1]:r.shape[2])*s,l=("NHWC"===i?r.shape[2]:r.shape[3])*s,u=("NHWC"===i?r.shape[3]:r.shape[1])/(s*s),d="NHWC"===i?[o,c,l,u]:[o,u,c,l],h=t.makeOutput(d,"float32"),p=t.dataIdMap.get(r.dataId).id,f=new Uint8Array(new Int32Array(Nr.computeStrides(r.shape)).buffer),m=new Uint8Array(new Int32Array(d).buffer),g=new Uint8Array(new Int32Array(Nr.computeStrides(d)).buffer),b=t.dataIdMap.get(h.dataId).id;return UH(p,s,"NHWC"===i?1:0,f,r.shape.length-1,m,g,d.length,b),h}};var qH,KH={kernelName:jt,backendName:"wasm",setupFunc:function(e){GH=e.wasm.cwrap(jt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(s.dataId).id,{strides:c,dilations:l,pad:u,dimRoundingMode:d}=n,h=null==l?[1,1]:l,p=Hf.computeConv2DInfo(r.shape,s.shape,c,h,u,d,!0),f=p.filterHeight,m=p.filterWidth,g=p.padInfo.top,b=p.padInfo.right,y=p.padInfo.bottom,v=p.padInfo.left,x=p.dilationHeight,w=p.dilationWidth,k=p.strideHeight,I=p.strideWidth,S=p.inChannels,N=p.outChannels,T="SAME"===p.padInfo.type?1:0;if("channelsLast"!==p.dataFormat)throw new Error("wasm backend DepthwiseConv2dNative does not support dataFormat:'".concat(p.dataFormat,"'. Please use 'channelsLast'."));let O=a.makeOutput(p.outShape,"float32"),C=a.dataIdMap.get(O.dataId).id;return GH(i,r.shape[0],r.shape[1],r.shape[2],o,f,m,g,b,y,v,T,x,w,k,I,S,N,C),O}};var XH,ZH={kernelName:Pt,backendName:"wasm",setupFunc:function(e){qH=e.wasm.cwrap("Diag",null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:a}=t,r=Nr.sizeFromShape(a.shape),s=n.makeOutput([...a.shape,...a.shape],a.dtype);return qH(n.dataIdMap.get(a.dataId).id,vG[a.dtype],r,n.dataIdMap.get(s.dataId).id),s}};var YH,JH={kernelName:Bt,backendName:"wasm",setupFunc:function(e){XH=e.wasm.cwrap(Bt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:c}=a;if(r.dtype!==s.dtype)throw new Error("Dilation2D error: x must have the same dtype as filter. Got ".concat(r.dtype," and ").concat(s.dtype));let l=Hf.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",c),u=n.makeOutput(l.outShape,r.dtype);return XH(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,vG[r.dtype],l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.filterHeight,l.filterWidth,l.padInfo.top,l.padInfo.left),u}};var QH,$H={kernelName:Ut,backendName:"wasm",setupFunc:function(e){YH=e.wasm.cwrap(Ut,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:c,dilations:l}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error("Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ".concat(r.dtype,", ").concat(s.dtype,", and ").concat(i.dtype));let u=Hf.computeDilation2DInfo(r.shape,s.shape,o,c,"NHWC",l),d=n.makeOutput(s.shape,s.dtype);return YH(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,vG[r.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),d}};var eq,tq={kernelName:Wt,backendName:"wasm",setupFunc:function(e){QH=e.wasm.cwrap(Wt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:c,dilations:l}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error("Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ".concat(r.dtype,", ").concat(s.dtype,", and ").concat(i.dtype));let u=Hf.computeDilation2DInfo(r.shape,s.shape,o,c,"NHWC",l),d=n.makeOutput(r.shape,r.dtype);return QH(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,vG[r.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),d}},nq=SG(qt);var aq={kernelName:Kt,backendName:"wasm",setupFunc:function(e){eq=e.wasm.cwrap(Kt,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=n.makeOutput(r.shape,"float32"),i=e=>n.dataIdMap.get(e.dataId).id;return eq(i(r),i(a),i(s)),s}},rq=CG(Zt,0,"bool"),sq=SG(Xt),iq=SG(Yt,"float32");function oq(e){let{inputs:t,attrs:n,backend:a}=e,{input:r}=t,{dim:s}=n,i=r.shape.length,o=r.shape.slice(),c=s;return s<0&&(Nr.assert(-(i+1)<=s,()=>"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]")),c=i+s+1),o.splice(c,0,1),rH({inputs:{x:r},backend:a,attrs:{shape:o}})}var cq={kernelName:Jt,backendName:"wasm",kernelFunc:oq},lq=SG(Qt,"float32");function uq(e){let{attrs:{shape:t,value:n,dtype:a},backend:r}=e,s=r.makeOutput(t,a);return r.typedArrayFromHeap(s).fill(n),s}var dq,hq={kernelName:en,backendName:"wasm",kernelFunc:uq};var pq,fq={kernelName:tn,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{image:a}=t,r=n.makeOutput(a.shape,a.dtype),s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,[o,c,l,u]=a.shape;return dq(s,o,c,l,u,i),r},setupFunc:function(e){dq=e.wasm.cwrap(tn,null,["number","number","number","number","number","number"])}},mq=SG(nn),gq=CG(an);var bq,yq={kernelName:rn,backendName:"wasm",setupFunc:function(e){pq=e.wasm.cwrap(rn,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{varianceEpsilon:r}=a,{x:s,mean:i,variance:o,offset:c,scale:l}=n,u=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(i.dataId).id,h=t.dataIdMap.get(o.dataId).id,p=null!=c?t.dataIdMap.get(c.dataId).id:0,f=null!=l?t.dataIdMap.get(l.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(0===Nr.sizeFromShape(s.shape))return m;let g=t.dataIdMap.get(m.dataId).id;return pq(u,d,h,p,f,r,g),m}};var vq,xq={kernelName:ur,backendName:"wasm",setupFunc:function(e){bq=e.wasm.cwrap(ur,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dilations:u,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=Hf.computeConv2DInfo(r.shape,s.shape,c,u,l,h),g=xG[p];if(null==g)throw new Error("".concat(p," activation not yet supported for FusedConv2D in the wasm backend."));let b=a.dataIdMap.get(r.dataId).id,y=a.dataIdMap.get(s.dataId).id,v=m.outChannels,x=0;if(null!=i){let e=a.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error("FusedConv2D only supports rank-1 bias but got rank ".concat(e.shape.length,"."));if(e.shape[0]!==v)throw new Error("FusedConv2D bias shape (".concat(e.shape,") does not match the number of output channels (").concat(v,")"));x=e.id}let w=m.filterHeight,k=m.filterWidth,I=m.padInfo.top,S=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,O=m.dilationHeight,C=m.dilationWidth,E=m.strideHeight,_=m.strideWidth,A=m.inChannels,R="SAME"===m.padInfo.type?1:0,D=m.batchSize,F=m.inHeight,M=m.inWidth;if("NHWC"!==d)throw new Error("wasm backend FusedConv2D does not support dataFormat:'".concat(d,"'. Please use 'NHWC'."));let j=a.makeOutput(m.outShape,"float32"),z=a.dataIdMap.get(j.dataId).id,L=null==o?0:a.dataIdMap.get(o.dataId).id;return bq(b,D,F,M,y,w,k,x,I,S,N,T,R,O,C,E,_,A,v,g,L,f||0,z),j}};var wq,kq={kernelName:dr,backendName:"wasm",setupFunc:function(e){vq=e.wasm.cwrap(dr,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:c,pad:l,dilations:u,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=Hf.computeConv2DInfo(r.shape,s.shape,c,u,l,h,!0),g=xG[p];if(null==g)throw new Error("".concat(p," activation not yet supported for FusedDepthwiseConv2D in the wasm backend."));let b=a.dataIdMap.get(r.dataId).id,y=a.dataIdMap.get(s.dataId).id,v=m.outChannels,x=0;if(null!=i){let e=a.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error("FusedDepthwiseConv2D only supports rank-1 bias but got rank ".concat(e.shape.length,"."));if(e.shape[0]!==v)throw new Error("FusedDepthwiseConv2D bias shape (".concat(e.shape,") does not match the number of output channels (").concat(v,")"));x=e.id}let w=m.filterHeight,k=m.filterWidth,I=m.padInfo.top,S=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,O=m.dilationHeight,C=m.dilationWidth,E=m.strideHeight,_=m.strideWidth,A=m.inChannels,R="SAME"===m.padInfo.type?1:0,D=m.batchSize,F=m.inHeight,M=m.inWidth;if("NHWC"!==d)throw new Error("wasm backend FusedDepthwiseConv2D does not support dataFormat:'".concat(d,"'. Please use 'NHWC'."));let j=a.makeOutput(m.outShape,"float32"),z=a.dataIdMap.get(j.dataId).id,L=null==o?0:a.dataIdMap.get(o.dataId).id;return vq(b,D,F,M,y,w,k,x,I,S,N,T,R,O,C,E,_,A,v,g,L,f||0,z),j}};var Iq,Sq={kernelName:on,backendName:"wasm",setupFunc:function(e){wq=e.wasm.cwrap(on,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{params:a,indices:r}=n,[s,i,o,c]=vf.prepareAndValidate(a,r),l=t.makeOutput(s,a.dtype);if(0===i)return l;let u=r.shape,d=u[u.length-1],h=t.dataIdMap.get(a.dataId).id,p=t.dataIdMap.get(r.dataId).id,f=new Uint8Array(new Int32Array(c).buffer),m=t.dataIdMap.get(l.dataId).id;return wq(h,vG[a.dtype],p,i,d,o,f,m),l}};var Nq,Tq={kernelName:sn,backendName:"wasm",setupFunc:function(e){Iq=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,indices:s}=n,{axis:i,batchDims:o}=a,c=Nr.parseAxisParam(i,r.shape)[0],l=t.readSync(s.dataId),u=r.shape[c];for(let I=0;I<l.length;++I){let e=l[I];Nr.assert(e<=u-1&&e>=0,()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(u-1,"]"))}let d=Hf.segment_util.collectGatherOpShapeInfo(r,s,c,o),h=rH({inputs:{x:r},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),p=Nr.sizeFromShape(s.shape),f=rH({inputs:{x:s},attrs:{shape:[d.batchSize,p/d.batchSize]},backend:t}),m=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize],g=t.makeOutput(m,r.dtype);if(0===Nr.sizeFromShape(r.shape))return g;let b=h.shape.length-1,y=t.dataIdMap.get(h.dataId).id,v=t.dataIdMap.get(f.dataId).id,x=t.dataIdMap.get(g.dataId).id,w=new Uint8Array(new Int32Array(Nr.computeStrides(h.shape)).buffer),k=new Uint8Array(new Int32Array(Nr.computeStrides(m)).buffer);return Iq(y,vG[r.dtype],w,b,v,d.batchSize,k,x),t.disposeData(h.dataId),t.disposeData(f.dataId),g.shape=d.outputShape,g}},Oq=CG(cn,0,"bool"),Cq=CG(ln,0,"bool"),Eq=SG(pn,"bool"),_q=SG(fn,"bool"),Aq=SG(mn,"bool");var Rq,Dq={kernelName:gn,backendName:"wasm",setupFunc:function(e){Nq=e.wasm.cwrap(gn,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:{x:t},attrs:{alpha:n},backend:a}=e,r=a.dataIdMap.get(t.dataId).id,s=a.makeOutput(t.shape,"float32");if(0!==Nr.sizeFromShape(t.shape)){let e=a.dataIdMap.get(s.dataId).id;Nq(r,vG[t.dtype],n,e)}return s}},Fq=CG(bn,0,"bool"),Mq=CG(yn,0,"bool");var jq,zq={kernelName:vn,backendName:"wasm",setupFunc:function(e){Rq=e.wasm.cwrap(vn,null,["number","number","number","number"])},kernelFunc:function(e){let{attrs:t,backend:n}=e,{start:a,stop:r,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],"float32");return Rq(n.dataIdMap.get(o.dataId).id,a,r,i),o}},Lq=SG(xn),Pq=SG(wn),Bq=CG(kn,0,"bool"),Wq=SG(In),Uq=CG(Sn,0,"bool"),Vq=CG(Nn,0,"bool");var Gq,Hq={kernelName:Cn,backendName:"wasm",setupFunc:function(e){jq=e.wasm.cwrap(Cn,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:c}=a;if("float32"!==r.dtype)throw new Error("LRN error: x must have dtype float32");let l=n.makeOutput(r.shape,r.dtype);return jq(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(l.dataId).id,r.shape[3],s,i,o,c),l}};var qq,Kq={kernelName:En,backendName:"wasm",setupFunc:function(e){Gq=e.wasm.cwrap(En,null,["number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:c,alpha:l,beta:u}=a;if("float32"!==r.dtype||"float32"!==s.dtype||"float32"!==i.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let d=n.makeOutput(r.shape,r.dtype);return Gq(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,i.shape[3],o,c,l,u),d}};var Xq,Zq={kernelName:An,backendName:"wasm",setupFunc:function(e){qq=e.wasm.cwrap(An,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{reductionIndices:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,c=i,{transposed:l,axes:u,originalAxes:d,inputWasTransposed:h}=LG(i,r,t);if(h){c=l,o=t.dataIdMap.get(l.dataId).id}let p=c.shape.length;Hf.assertAxesAreInnerMostDims("max",u,p);let[f,m]=Hf.computeOutAndReduceShapes(c.shape,u),g=Nr.sizeFromShape(m),b=t.makeOutput(f,i.dtype);if(0!==Nr.sizeFromShape(c.shape)){let e=t.dataIdMap.get(b.dataId).id;qq(o,vG[i.dtype],g,e)}if(h&&t.disposeData(l.dataId),s){let e=Hf.expandShapeToKeepDim(b.shape,d);b.shape=e}return b}},Yq=CG(Rn);var Jq,Qq={kernelName:Dn,backendName:"wasm",setupFunc:function(e){Xq=e.wasm.cwrap(Dn,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id;Nr.assert("float32"===r.dtype,()=>"Error in MaxPool: only float32 input is supported. Got ".concat(r.dtype,"."));let{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=n,u=Hf.computePool2DInfo(r.shape,i,o,1,c,l),d=u.filterHeight,h=u.filterWidth,p=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,g=u.padInfo.left,b=u.dilationHeight,y=u.dilationWidth,v=u.strideHeight,x=u.strideWidth,w=u.inChannels,k=u.outChannels;if("channelsLast"!==u.dataFormat)throw new Error("wasm backend does not support dataFormat:'".concat(u.dataFormat,"'. Please use 'channelsLast'."));let I=a.makeOutput(u.outShape,"float32"),S=a.dataIdMap.get(I.dataId).id;return Xq(s,r.shape[0],r.shape[1],r.shape[2],d,h,p,f,m,g,b,y,v,x,w,k,S),I}};var $q,eK={kernelName:Mn,backendName:"wasm",setupFunc:function(e){Jq=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:c,dataFormat:l}=a,u=Hf.computePool3DInfo(r.shape,s,i,1,o,c,l),d=n.makeOutput(u.outShape,r.dtype);return Jq(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),d}};var tK,nK={kernelName:jn,backendName:"wasm",setupFunc:function(e){$q=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=a,u=Hf.computePool3DInfo(s.shape,i,o,1,c,l),d=n.makeOutput(s.shape,s.dtype);return $q(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),d}};var aK,rK={kernelName:Fn,backendName:"wasm",setupFunc:function(e){tK=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:c,dimRoundingMode:l}=a,u=Hf.computePool2DInfo(s.shape,i,o,1,c,l),d=n.makeOutput(s.shape,s.dtype);return tK(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left),d}};var sK,iK={kernelName:zn,backendName:"wasm",setupFunc:function(e){aK=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:c}=a;Nr.assert(4===r.shape.length,()=>"Error in maxPool: input must be rank 4 but got rank ".concat(r.shape.length,"."));let l=[1,1];Nr.assert(Hf.eitherStridesOrDilationsAreOne(i,l),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(i," and dilations '").concat(l,"'"));let u=Hf.computePool2DInfo(r.shape,s,i,[1,1],o),d=n.makeOutput(u.outShape,r.dtype),h=n.makeOutput(u.outShape,"int32");return aK(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(h.dataId).id,vG[r.dtype],c,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left),[d,h]}};var oK,cK={kernelName:Ln,backendName:"wasm",setupFunc:function(e){sK=e.wasm.cwrap(Ln,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,c=o,l=i,{transposed:u,axes:d,originalAxes:h,inputWasTransposed:p}=LG(i,r,t),f=d;if(p){let e=t.dataIdMap.get(u.dataId).id;e!==o&&(l=u,c=e,f=Hf.getInnerMostAxes(f.length,l.shape.length))}Hf.assertAxesAreInnerMostDims("mean",f,l.shape.length);let[m,g]=Hf.computeOutAndReduceShapes(l.shape,f),b=Nr.sizeFromShape(g),y=l;"float32"!==l.dtype&&(y=mH({backend:t,inputs:{x:l},attrs:{dtype:"float32"}}),c=t.dataIdMap.get(y.dataId).id);let v=t.makeOutput(m,"float32");if(0!==Nr.sizeFromShape(l.shape)){let e=t.dataIdMap.get(v.dataId).id;sK(c,b,e)}if(p&&t.disposeData(u.dataId),s){let e=Hf.expandShapeToKeepDim(v.shape,h);v.shape=e}return"float32"!==l.dtype&&t.disposeData(y.dataId),v}};var lK,uK,dK={kernelName:Pn,backendName:"wasm",setupFunc:function(e){oK=e.wasm.cwrap(Pn,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,c=o,l=i,{transposed:u,axes:d,originalAxes:h,inputWasTransposed:p}=LG(i,r,t);if(p){let e=t.dataIdMap.get(u.dataId).id;e!==o&&(l=u,c=e)}let f=l.shape.length;Hf.assertAxesAreInnerMostDims("min",d,f);let[m,g]=Hf.computeOutAndReduceShapes(l.shape,d),b=Nr.sizeFromShape(g),y=t.makeOutput(m,l.dtype);if(0!==Nr.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;oK(c,vG[i.dtype],b,e)}if(p&&t.disposeData(u.dataId),s){let e=Hf.expandShapeToKeepDim(y.shape,h);y.shape=e}return y}},hK=CG(Bn);!function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"}(lK||(lK={}));var pK,fK={kernelName:Wn,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,mode:r}}=e,s=a.map((e,n)=>e[0]+t.shape[n]+e[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),c=n.dataIdMap.get(o.dataId).id,l=new Uint8Array(new Int32Array(t.shape).buffer),u=a.map(e=>e[0]),d=a.map(e=>e[1]),h=new Uint8Array(new Int32Array(u).buffer),p=new Uint8Array(new Int32Array(d).buffer);return uK(i,l,t.shape.length,vG[t.dtype],h,p,lK[r],c),o},setupFunc:function(e){uK=e.wasm.cwrap(Wn,null,["number","array","number","number","array","array","number","number"])}};function mK(e){let{backend:t,inputs:{logits:n},attrs:{dim:a}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[a],c=Nr.sizeFromShape(n.shape)/o;return 0===Nr.sizeFromShape(s.shape)||pK(r,i,o,c),s}var gK,bK={kernelName:Ma,backendName:"wasm",setupFunc:function(e){pK=e.wasm.cwrap(Ma,null,["number","number","number","number"])},kernelFunc:mK};var yK,vK={kernelName:Vn,backendName:"wasm",setupFunc:function(e){gK=e.wasm.cwrap(Vn,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a;if("float32"!==r.dtype)throw new Error("Tensor logits must have dtype float32, got ".concat(r.dtype));let c=o?r:mK({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),[l,u]=c.shape,d=n.makeOutput([l,s],"int32");return gK(n.dataIdMap.get(c.dataId).id,l,u,s,i,n.dataIdMap.get(d.dataId).id),o||n.disposeData(c.dataId),d}},xK=CG(Un),wK=CG(Gn),kK=SG(Hn);function IK(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),a=n[0],r=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:a,selectedSize:r,pSelectedScores:s,pValidOutputs:i}}var SK,NK={kernelName:Kn,backendName:"wasm",setupFunc:function(e){yK=e.wasm.cwrap(Kn,"number",["number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i}=a,{boxes:o,scores:c}=n,l=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(c.dataId).id,d=yK(l,u,s,r,i),{pSelectedIndices:h,selectedSize:p,pSelectedScores:f,pValidOutputs:m}=IK(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([p],"int32",h)}};var TK,OK={kernelName:Xn,backendName:"wasm",setupFunc:function(e){SK=e.wasm.cwrap(Xn,"number",["number","number","number","number","number","bool"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=a,{boxes:c,scores:l}=n,u=t.dataIdMap.get(c.dataId).id,d=t.dataIdMap.get(l.dataId).id,h=SK(u,d,s,r,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=IK(t,h);return t.wasm._free(m),[t.makeOutput([f],"int32",p),t.makeOutput([],"int32",g)]}};var CK,EK={kernelName:Zn,backendName:"wasm",setupFunc:function(e){TK=e.wasm.cwrap(Zn,"number",["number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=a,{boxes:c,scores:l}=n,u=t.dataIdMap.get(c.dataId).id,d=t.dataIdMap.get(l.dataId).id,h=TK(u,d,s,r,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=IK(t,h);return t.wasm._free(g),[t.makeOutput([f],"int32",p),t.makeOutput([f],"float32",m)]}},_K=CG(qn,0,"bool");var AK={kernelName:Jn,backendName:"wasm",setupFunc:function(e){CK=e.wasm.cwrap(Jn,null,["number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:c}=a,l=n.makeOutput([...r.shape,i],s),u=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(r.dataId).id;return CK(d,i,o,c,u),l}};var RK={kernelName:Yn,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(1),a}};var DK,FK={kernelName:Qn,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return oq({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(e=>{Nr.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),Nr.assert(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],c=xH({inputs:t.map(e=>{let t=oq({inputs:{input:e},backend:n,attrs:{dim:r}});return o.push(t),t}),backend:n,attrs:{axis:r}});return o.forEach(e=>n.disposeData(e.dataId)),c}};var MK,jK={kernelName:$n,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,constantValue:r}}=e,s=a.map((e,n)=>e[0]+t.shape[n]+e[1]);if(0===Nr.sizeFromShape(t.shape))return uq({backend:n,attrs:{shape:s,value:r,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),c=n.dataIdMap.get(o.dataId).id,l=new Uint8Array(new Int32Array(t.shape).buffer),u=a.map(e=>e[0]),d=a.map(e=>e[1]),h=new Uint8Array(new Int32Array(u).buffer),p=new Uint8Array(new Int32Array(d).buffer);return DK(i,l,t.shape.length,vG[t.dtype],h,p,r,c),o},setupFunc:function(e){DK=e.wasm.cwrap($n,null,["number","array","number","number","array","array","number","number"])}},zK=CG(ta);var LK,PK={kernelName:na,backendName:"wasm",setupFunc:function(e){MK=e.wasm.cwrap(na,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,o=s,c=a,l=c;"float32"!==c.dtype&&(l=mH({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(l.dataId).id);let u=n.makeOutput(a.shape,"float32"),d=n.dataIdMap.get(u.dataId).id;return MK(o,i,d),"float32"!==c.dtype&&n.disposeData(l.dataId),u}};var BK,WK={kernelName:aa,backendName:"wasm",setupFunc:function(e){LK=e.wasm.cwrap(aa,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,c=o,l=i,{transposed:u,axes:d,originalAxes:h,inputWasTransposed:p}=LG(i,r,t),f=d;if(p){let e=t.dataIdMap.get(u.dataId).id;e!==o&&(l=u,c=e,f=Hf.getInnerMostAxes(f.length,l.shape.length))}Hf.assertAxesAreInnerMostDims("prod",f,l.shape.length);let[m,g]=Hf.computeOutAndReduceShapes(l.shape,f),b=Nr.sizeFromShape(g),y=t.makeOutput(m,l.dtype);if(0!==Nr.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;LK(c,b,vG[y.dtype],e)}if(p&&t.disposeData(u.dataId),s){let e=Hf.expandShapeToKeepDim(y.shape,h);y.shape=e}return y}},UK={kernelName:oa,backendName:"wasm",kernelFunc:e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=S_(a,r,s,i),c=t.makeOutput([o.length],i);return t.typedArrayFromHeap(c).set(o),c}},VK=CG(Gt),GK=SG(la),HK=SG(ua),qK=SG(ga);var KK,XK={kernelName:fa,backendName:"wasm",setupFunc:function(e){BK=e.wasm.cwrap(fa,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:a,attrs:r}=e,{images:s}=a,{alignCorners:i,halfPixelCenters:o,size:c}=r,[l,u]=c,[d,h,p,f]=s.shape,m=[d,l,u,f],g=n.dataIdMap.get(s.dataId);"float32"!==g.dtype&&(t=mH({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),g=n.dataIdMap.get(t.dataId));let b=g.id,y=n.makeOutput(m,"float32");if(0===Nr.sizeFromShape(s.shape))return y;let v=n.dataIdMap.get(y.dataId).id;return BK(b,d,h,p,f,l,u,i?1:0,o?1:0,v),null!=t&&n.disposeData(t.dataId),y}};var ZK,YK={kernelName:ma,backendName:"wasm",setupFunc:function(e){KK=e.wasm.cwrap(ma,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:a,attrs:r}=e,{images:s,dy:i}=n,{alignCorners:o}=r,c=a.makeOutput(s.shape,"float32"),l=a.dataIdMap.get(s.dataId);return"float32"!==l.dtype&&(t=mH({backend:a,inputs:{x:s},attrs:{dtype:"float32"}}),l=a.dataIdMap.get(t.dataId)),KK(a.dataIdMap.get(s.dataId).id,a.dataIdMap.get(i.dataId).id,a.dataIdMap.get(c.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),o),null!=t&&a.disposeData(t.dataId),c}};var JK,QK={kernelName:ha,backendName:"wasm",setupFunc:function(e){ZK=e.wasm.cwrap(ha,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:i,size:o}=a,[c,l]=o,[u,d,h,p]=r.shape,f=[u,c,l,p],m=t.makeOutput(f,"float32");if(0===Nr.sizeFromShape(r.shape))return m;let g,b=t.dataIdMap.get(r.dataId);"float32"!==b.dtype&&(g=mH({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),b=t.dataIdMap.get(g.dataId));let y=b.id,v=t.dataIdMap.get(m.dataId).id;return ZK(y,u,d,h,p,c,l,s?1:0,i?1:0,v),null!=g&&t.disposeData(g.dataId),m}};var $K,eX={kernelName:pa,backendName:"wasm",setupFunc:function(e){JK=e.wasm.cwrap(pa,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:a,attrs:r}=e,{images:s,dy:i}=n,{alignCorners:o}=r,c=a.makeOutput(s.shape,"float32"),l=a.dataIdMap.get(s.dataId);return"float32"!==l.dtype&&(t=mH({backend:a,inputs:{x:s},attrs:{dtype:"float32"}}),l=a.dataIdMap.get(t.dataId)),JK(a.dataIdMap.get(s.dataId).id,a.dataIdMap.get(i.dataId).id,a.dataIdMap.get(c.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),o),null!=t&&a.disposeData(t.dataId),c}};var tX,nX={kernelName:ba,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=Nr.parseAxisParam(s,r.shape);if(0===r.shape.length)return RG({inputs:{x:r},backend:n});let o=n.makeOutput(r.shape,r.dtype),c=n.dataIdMap.get(r.dataId).id,l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(r.shape).buffer);$K(c,u,i.length,d,r.shape.length,l);let h=rH({inputs:{x:o},attrs:{shape:r.shape},backend:n});return n.disposeData(o.dataId),h},setupFunc:function(e){$K=e.wasm.cwrap(ba,null,["number","array","number","array","number","number"])}};var aX,rX={kernelName:cr,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{radians:s,fillValue:i,center:o}=a,c=n.makeOutput(r.shape,r.dtype),l=n.dataIdMap.get(r.dataId).id,u=n.dataIdMap.get(c.dataId).id,[d,h,p,f]=r.shape,[m,g]=Hf.getImageCenter(o,h,p),b="number"==typeof i?[i,i,i,0===i?0:255]:[...i,255],y=new Uint8Array(new Int32Array(b).buffer);return tX(l,d,h,p,f,s,m,g,y,b.length,u),c},setupFunc:function(e){tX=e.wasm.cwrap(cr,null,["number","number","number","number","number","number","number","number","array","number","number"])}},sX=SG(ya),iX=SG(va);var oX,cX={kernelName:xa,backendName:"wasm",setupFunc:function(e){aX=e.wasm.cwrap(xa,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{indices:r,updates:s}=n,{shape:i}=a,o=t.makeOutput(i,s.dtype);if(0===Nr.sizeFromShape(i))return o;let{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=Pd.calculateShapes(s,r,i),p=t.dataIdMap.get(r.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(d).buffer),g=t.dataIdMap.get(o.dataId).id;return aX(p,f,vG[s.dtype],c,l,u,m,h,g),o}};var lX,uX={kernelName:ka,backendName:"wasm",setupFunc:function(e){oX=e.wasm.cwrap(ka,null,["number","number","number","number","number","number","bool","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a;if(r.dtype!==s.dtype)throw new Error("SearchSorted error: sorted_sequence must have the same dtype as values. Got ".concat(r.dtype," and ").concat(s.dtype));let o=n.makeOutput(s.shape,"int32");function c(e){return n.dataIdMap.get(e.dataId).id}return oX(c(r),c(s),r.shape[0],r.shape[1],s.shape[1],vG[r.dtype],"left"===i,c(o)),o}};var dX,hX={kernelName:Ia,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=n.dataIdMap.get(a.dataId).id,o=n.dataIdMap.get(r.dataId).id,c=n.dataIdMap.get(s.dataId).id,l=n.makeOutput(r.shape,r.dtype),u=n.dataIdMap.get(l.dataId).id,d=a.shape.length,h=r.shape.length,p=0===d||d>1||1===h?1:Nr.sizeFromShape(r.shape.slice(1));return lX(i,o,c,p,u),l},setupFunc:function(e){lX=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}},pX=SG(Sa);var fX={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(e){dX=e.wasm.cwrap(Ea,null,["number","number"])},kernelFunc:function(e){let{backend:t,inputs:{x:n}}=e,a=t.dataIdMap.get(n.dataId).id,r=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(r.dataId).id;return 0===Nr.sizeFromShape(r.shape)||dX(a,s),r}},mX=SG(Ca),gX=SG(Ta),bX=SG(Oa),yX=SG(_a);var vX,xX={kernelName:Da,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a,o=Nr.sizeFromShape(s),c=[[0,0]];c.push(...i);for(let g=1+s.length;g<r.shape.length;++g)c.push([0,0]);let l=jK.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),u=Hf.getReshaped(l.shape,s,o,!1),d=Hf.getPermuted(u.length,s.length,!1),h=Hf.getReshapedPermuted(l.shape,s,o,!1),p=rH({inputs:{x:l},backend:n,attrs:{shape:u}}),f=MG({inputs:{x:p},backend:n,attrs:{perm:d}}),m=rH({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeData(l.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}};var wX,kX={kernelName:ja,backendName:"wasm",setupFunc:function(e){vX=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:a}=e,{indices:r,values:s,denseShape:i,defaultValue:o}=a,c=r.shape[0],l=r.shape[1],u=n.readSync(i.dataId)[0],d=[c+u,l],h=n.dataIdMap.get(r.dataId).id,p=n.dataIdMap.get(s.dataId).id,f=n.dataIdMap.get(o.dataId).id,m=n.makeOutput(d,r.dtype),g=n.dataIdMap.get(m.dataId).id,b=n.makeOutput(d.slice(0,1),s.dtype),y=n.dataIdMap.get(b.dataId).id,v=n.makeOutput([u],"bool"),x=n.dataIdMap.get(v.dataId).id,w=n.makeOutput([c],r.dtype),k=n.dataIdMap.get(w.dataId).id,I=n.makeOutput([4],"int32"),S=n.dataIdMap.get(I.dataId).id,N=vX(h,p,vG[s.dtype],c,u,l,f,g,y,x,k,S),T=n.readSync(I.dataId);switch(T[0]){case 1:t=Hf.getSparseFillEmptyRowsIndicesDenseShapeMismatch(T[1]);break;case 2:t=Hf.getSparseFillEmptyRowsNegativeIndexErrorMessage(T[1],T[2]);break;case 3:t=Hf.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(T[1],T[2],T[3]);break;default:t=""}if(n.disposeData(I.dataId),t)throw n.disposeData(m.dataId),n.disposeData(b.dataId),n.disposeData(v.dataId),n.disposeData(w.dataId),new Error(t);let O=m,C=b;return N!==d[0]&&(O=cH({inputs:{x:m},attrs:{begin:0,size:[N,l]},backend:n}),C=cH({inputs:{x:b},attrs:{begin:0,size:N},backend:n}),n.disposeData(m.dataId),n.disposeData(b.dataId)),[O,C,v,w]}};var IX,SX={kernelName:za,backendName:"wasm",setupFunc:function(e){wX=e.wasm.cwrap(za,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{inputIndices:a,inputShape:r,newShape:s}=n;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(r.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));let i=t.dataIdMap.get(a.dataId).id,o=t.dataIdMap.get(r.dataId).id,c=t.dataIdMap.get(s.dataId).id,l=a.shape[0],u=Nr.sizeFromShape(s.shape),d=t.makeOutput([l,u],a.dtype),h=t.dataIdMap.get(d.dataId).id,p=t.makeOutput([u],s.dtype),f=t.dataIdMap.get(p.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;wX(i,o,c,l,h,f,g);let b,y=t.readSync(m.dataId);switch(y[0]){case 0:b=Hf.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break;case 1:b=Hf.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break;case 2:b=Hf.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let e=Array.from(t.readSync(r.dataId)),n=Array.from(t.readSync(p.dataId));b=Hf.getSparseReshapeInputOutputMultipleErrorMessage(e,n);break}case 4:{let e=Array.from(t.readSync(r.dataId)),n=Array.from(t.readSync(p.dataId));b=Hf.getSparseReshapeInputOutputMismatchErrorMessage(e,n);break}default:b=""}if(t.disposeData(m.dataId),b)throw t.disposeData(d.dataId),t.disposeData(p.dataId),new Error(b);return[d,p]}};function NX(e){IX=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function TX(e,t){let{backend:n,inputs:a}=e,{data:r,indices:s,segmentIds:i}=a,o=s.shape[0],c=n.readSync(i.dataId,o-1,o)[0],l=o>0?c+1:0;if(l<0)throw new Error(Hf.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let u=r.shape.slice();u[0]=l;let d=n.dataIdMap.get(r.dataId).id,h=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(u,r.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),b=n.dataIdMap.get(g.dataId).id;IX(d,vG[r.dtype],r.shape[0],h,p,m,b,t,0);let y,v=n.readSync(g.dataId);switch(v[0]){case 0:y=Hf.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:y=Hf.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:y=Hf.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v[1],v[2]);break;case 3:y=Hf.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v[1],v[2],v[3]);break;default:y=""}if(n.disposeData(g.dataId),y)throw n.disposeData(f.dataId),new Error(y);return f}var OX={kernelName:La,backendName:"wasm",setupFunc:NX,kernelFunc:function(e){return TX(e,!0)}};var CX,EX={kernelName:Pa,backendName:"wasm",setupFunc:NX,kernelFunc:function(e){return TX(e,!1)}};var _X={kernelName:Ba,backendName:"wasm",setupFunc:function(e){CX=e.wasm.cwrap(Ba,null,["number","number","number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=n,{outputShape:o}=a,c=t.makeOutput(o,i.dtype);if(0===Nr.sizeFromShape(o))return c;let{sliceRank:l,numUpdates:u,sliceSize:d,strides:h,outputSize:p}=Hf.calculateShapes(s,r,o),f=t.dataIdMap.get(r.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,b=new Uint8Array(new Int32Array(h).buffer),y=t.dataIdMap.get(c.dataId).id;return CX(f,m,s.shape.length,g,vG[i.dtype],l,u,d,b,p,y),c}};var AX,RX={kernelName:Fa,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=n,o=Nr.parseAxisParam(i,r.shape)[0],c=Hf.prepareSplitSize(r,s,o),l=new Array(r.shape.length).fill(0),u=r.shape.slice();return c.map(e=>{let t=[...u];t[o]=e;let n=cH({inputs:{x:r},attrs:{begin:l,size:t},backend:a});return l[o]+=e,n})}},DX=SG(Aa),FX=SG(Ua),MX=CG(Wa);var jX,zX={kernelName:ir,backendName:"wasm",setupFunc:function(e){AX=e.wasm.cwrap(ir,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{alpha:r}=a,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),c=t.dataIdMap.get(o.dataId).id;return AX(i,r,vG[s.dtype],c),o}};var LX={kernelName:Ga,backendName:"wasm",setupFunc:function(e){jX=e.wasm.cwrap(Ga,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:a,attrs:r}=e,{x:s}=a,{begin:i,end:o,strides:c,beginMask:l,endMask:u,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=r,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:y,begin:v,end:x,strides:w}=wf.sliceInfo(s.shape,i,o,c,l,u,d,h,p);if(g)t=rH({inputs:{x:s},backend:n,attrs:{shape:m}});else if(b||y){Nr.assert(s.shape.length>=1,()=>"Input must have rank at least 1, got: ".concat(s.shape.length));let e=wf.computeOutShape(v,x,w),a=cH({inputs:{x:s},backend:n,attrs:{begin:v,size:e}});t=rH({inputs:{x:a},backend:n,attrs:{shape:m}}),n.disposeData(a.dataId)}else{let e=n.makeOutput(f,"float32"),a=n.dataIdMap.get(s.dataId).id,r=new Uint8Array(new Int32Array(Nr.computeStrides(s.shape)).buffer),i=new Uint8Array(new Int32Array(v).buffer),o=new Uint8Array(new Int32Array(x).buffer),c=new Uint8Array(new Int32Array(w).buffer),l=new Uint8Array(new Int32Array(f).buffer),u=new Uint8Array(new Int32Array(Nr.computeStrides(f)).buffer),d=n.dataIdMap.get(e.dataId).id;jX(a,r,s.shape.length,i,o,c,l,u,f.length,d),t=rH({inputs:{x:e},backend:n,attrs:{shape:m}}),n.disposeData(e.dataId)}return t}};var PX={kernelName:Ha,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{data:r,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:c,rightPad:l,padWidth:u,preserveShortSequences:d}=a,h=t.readSync(r.dataId),p=t.readSync(s.dataId),[f,m]=X_(h,p,i,o,c,l,u,d),g=t.makeOutput([f.length],"string");t.dataIdMap.get(g.dataId).stringBytes=f;let b=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(b).set(m),[g,b]}};var BX={kernelName:qa,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{input:r,delimiter:s}=n,{skipEmpty:i}=a,o=t.readSync(r.dataId),c=t.readSync(s.dataId),[l,u,d]=Y_(o,c[0],i),h=u.length,p=t.makeOutput([h,2],"int32");t.typedArrayFromHeap(p).set(l);let f=t.makeOutput([h],"string");t.dataIdMap.get(f.dataId).stringBytes=u;let m=t.makeOutput([2],"int32");return t.typedArrayFromHeap(m).set(d),[p,f,m]}};var WX,UX={kernelName:Ka,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{input:r}=n,{numBuckets:s}=a,i=J_(t.readSync(r.dataId),s),o=t.makeOutput(r.shape,"int32");return t.typedArrayFromHeap(o).set(i),o}},VX=CG(Xa);var GX,HX,qX,KX={kernelName:Ra,backendName:"wasm",setupFunc:function(e){WX=e.wasm.cwrap(Ra,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,c=o,l=i,{transposed:u,axes:d,originalAxes:h,inputWasTransposed:p}=LG(i,r,t),f=d;if(p){let e=t.dataIdMap.get(u.dataId).id;e!==o&&(l=u,c=e,f=Hf.getInnerMostAxes(f.length,l.shape.length))}Hf.assertAxesAreInnerMostDims("sum",f,l.shape.length);let[m,g]=Hf.computeOutAndReduceShapes(l.shape,f),b=Nr.sizeFromShape(g),y=t.makeOutput(m,l.dtype);if(0!==Nr.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;WX(c,b,vG[y.dtype],e)}if(p&&t.disposeData(u.dataId),s){let e=Hf.expandShapeToKeepDim(y.shape,h);y.shape=e}return y}},XX=SG(Za),ZX=SG(Ya);var YX;var JX=[IG,NG,TG,OG,_G,AG,BG,WG,GG,HG,qG,KG,XG,ZG,YG,QG,aH,eH,nH,oH,dH,hH,pH,fH,bH,yH,vH,kH,SH,TH,CH,_H,DH,FH,MH,zH,PH,WH,VH,HH,KH,ZH,JH,$H,tq,nq,aq,rq,sq,iq,cq,lq,hq,fq,mq,gq,yq,xq,kq,Sq,Tq,Oq,Cq,FG,Eq,_q,Aq,Dq,Fq,Mq,zq,Pq,Lq,Bq,Wq,Uq,Vq,Hq,Kq,Zq,Yq,Qq,eK,nK,rK,iK,cK,dK,hK,fK,vK,xK,wK,kK,NK,OK,EK,_K,AK,RK,FK,jK,zK,PK,WK,UK,VK,GK,HK,qK,iH,XK,YK,QK,eX,nX,rX,sX,iX,cX,uX,hX,pX,fX,mX,gX,bX,lH,bK,yX,xX,kX,SX,OX,EX,_X,RX,DX,FX,MX,zX,LX,PX,BX,UX,VX,KX,XX,ZX,{kernelName:wa,backendName:"wasm",setupFunc:function(e){GX=e.wasm.cwrap(wa,null,["number","number","number","number","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=n,{}=a,o=t.makeOutput(r.shape,r.dtype);if(0===Nr.sizeFromShape(r.shape))return o;let{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=Pd.calculateShapes(i,s,r.shape),p=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(r.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),b=t.dataIdMap.get(o.dataId).id;return GX(p,f,vG[i.dtype],c,l,u,g,h,b,m),o}},{kernelName:Ja,backendName:"wasm",setupFunc:function(e){HX=e.wasm.cwrap(Ja,null,["number","array","number","array","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,s=n.dataIdMap.get(r.dataId).id,{reps:i}=a,o=new Array(r.shape.length);for(let h=0;h<o.length;h++)o[h]=r.shape[h]*i[h];let c=new Uint8Array(new Int32Array(r.shape).buffer),l=new Uint8Array(new Int32Array(o).buffer),u=n.makeOutput(o,r.dtype),d=n.dataIdMap.get(u.dataId).id;return HX(s,c,r.shape.length,l,o.length,vG[u.dtype],d),u}},{kernelName:Qa,backendName:"wasm",setupFunc:function(e){qX=e.wasm.cwrap(Qa,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a,o=n.dataIdMap.get(r.dataId).id,c=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=s;let u=n.makeOutput(l,r.dtype),d=n.dataIdMap.get(u.dataId).id,h=n.makeOutput(l,"int32"),p=n.dataIdMap.get(h.dataId).id;return qX(o,c,r.shape.length,vG[r.dtype],s,i,d,p),[u,h]}},{kernelName:$a,backendName:"wasm",setupFunc:function(e){YX=e.wasm.cwrap($a,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:a,attrs:r}=e,{image:s,transforms:i}=a,{interpolation:o,fillMode:c,fillValue:l,outputShape:u}=r,[d,h,p,f]=s.shape,[m,g]=null!=u?u:[h,p],b=[d,m,g,f],y=new Uint8Array(new Int32Array(Nr.computeStrides(s.shape)).buffer),v=new Uint8Array(new Int32Array(Nr.computeStrides(b)).buffer),x=n.makeOutput(b,s.dtype),w=n.dataIdMap.get(x.dataId).id,k=n.dataIdMap.get(s.dataId).id,I=n.dataIdMap.get(i.dataId).id,S="nearest"===o?1:2;switch(c){case"constant":t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4;break;default:t=1}return YX(k,I,i.shape[0]>1,d,m,g,f,p,h,y,s.shape.length-1,v,b.length-1,S,t,l,w),x}},zG,{kernelName:tr,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:c}=iA(a.readSync(s.dataId),r,s.shape,s.dtype);return[a.makeOutput(o,s.dtype,void 0,i),a.makeOutput([c.length],"int32",void 0,c)]}},{kernelName:nr,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r.shape[s],o=r.shape.length,c=new Array(o-1),l=0;for(let p=0;p<o;p++)p!==s&&(c[l++]=r.shape[p]);let u=new Array(i),d=new Array(o).fill(0),h=r.shape.slice();h[s]=1;for(let p=0;p<u.length;p++)d[s]=p,u[p]=cH({inputs:{x:r},attrs:{begin:d,size:h},backend:n});return u.map(e=>{let{dataId:t,dtype:n}=e;return{dataId:t,dtype:n,shape:c}})}},{kernelName:sr,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(0),a}}];for(let t of JX)vr(t);var QX=Ue();QX.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(ds){return!1}}),QX.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(QX.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(ds){return!1}});var $X=v(L()),eZ=v(P()),tZ=v(B()),nZ=$X.default||$X,aZ=tZ.default||tZ,rZ=class extends U{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(mZ),gZ=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new W(this,Ji())}write(e,t,n){let a={id:this.dataIdNextNumber++};return this.move(a,e,t,n,1),a}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=Nr.now();return e(),{kernelMs:Nr.now()-t}}move(e,t,n,a,r){let s=this.dataIdNextNumber++;if("string"===a){let i=t;return void this.dataIdMap.set(e,{id:s,stringBytes:i,shape:n,dtype:a,memoryOffset:null,refCount:r})}let i=Nr.sizeFromShape(n),o=i*Nr.bytesPerElement(a),c=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:c,shape:n,dtype:a,refCount:r}),this.wasm.tfjs.registerTensor(s,i,c),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),c)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:a,dtype:r,shape:s,stringBytes:i}=this.dataIdMap.get(e);if("string"===r)return null!=t&&0!==t||!(null==n||n>=i.length)?i.slice(t,n):i;t=t||0,n=n||Nr.sizeFromShape(s);let o=Nr.bytesPerElement(r);return function(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error("Unknown dtype ".concat(t))}}(this.wasm.HEAPU8.slice(a+t*o,a+n*o).buffer,r)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,a){let r;if(null==n)r=this.write(null!=a?a:null,e,t);else{let a=this.dataIdNextNumber++;r={id:a},this.dataIdMap.set(r,{id:a,memoryOffset:n,shape:e,dtype:t,refCount:1});let s=Nr.sizeFromShape(e);this.wasm.tfjs.registerTensor(a,s,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap(e){let{shape:t,dtype:n,dataId:a}=e,r=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(a),i=Nr.sizeFromShape(t);switch(n){case"float32":return new Float32Array(r,s,i);case"int32":return new Int32Array(r,s,i);case"bool":return new Uint8Array(r,s,i);default:throw new Error("Unknown dtype ".concat(n))}}};function sZ(e,t,n){if(null!=cZ)return cZ;let a="tfjs-backend-wasm.wasm";return e&&t?a="tfjs-backend-wasm-threaded-simd.wasm":e&&(a="tfjs-backend-wasm-simd.wasm"),null!=uZ&&null!=uZ[a]?uZ[a]:n+a}async function iZ(){let[e,t]=await Promise.all([Ue().getAsync("WASM_HAS_SIMD_SUPPORT"),Ue().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,a)=>{let r={locateFile:(n,a)=>{if(n.endsWith(".worker.js")){let e=eZ.wasmWorkerContents.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return n.endsWith(".wasm")?sZ(e,t,null!=lZ?lZ:a):a+n}};hZ&&(r.instantiateWasm=function(e){return(t,n)=>(Nr.fetch(e,{credentials:"same-origin"}).then(a=>{a.ok||t.env.a("failed to load wasm binary file at '".concat(e,"'")),a.arrayBuffer().then(e=>{WebAssembly.instantiate(e,t).then(e=>{n(e.instance,e.module)})})}),{})}(sZ(e,t,null!=lZ?lZ:"")));let s,i=!1;r.onAbort=()=>{i||dZ||(dZ=!0,a({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&null==cZ?(r.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+nZ.toString()],{type:"text/javascript"}),s=nZ(r)):s=aZ(r),s.then(e=>{i=!0,dZ=!1;e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",null,["number"]),dispose:e.cwrap("dispose",null,[])},n({wasm:e})}).catch(a)})}var oZ=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],cZ=null,lZ=null,uZ={},dZ=!1,hZ=!1;function pZ(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Zi("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),dZ)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");cZ=e,hZ=t}function fZ(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(dZ)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)lZ=e;else{uZ=e;let t=oZ.filter(e=>null==uZ[e]);if(t.length>0)throw new Error("There were no entries found for the following binaries: ".concat(t.join(","),". Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found."))}hZ=t}var mZ=-1,gZ=-1;function bZ(e){mZ=e}function yZ(){if(-1===gZ)throw new Error("WASM backend not initialized.");return gZ}var vZ="4.7.0";uo("wasm",async()=>{let{wasm:e}=await iZ();return new rZ(e)},2);var xZ={tfjs:"4.7.0","tfjs-core":"4.7.0","tfjs-converter":"4.7.0","tfjs-backend-cpu":"4.7.0","tfjs-backend-webgl":"4.7.0","tfjs-backend-wasm":"4.7.0"},wZ={};function kZ(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(e.beginPath(),t.slice(1).forEach((n,a)=>{let{x:r,y:s}=n,i=t[a];e.moveTo(i.x,i.y),e.lineTo(r,s)}),n){let n=t[t.length-1],a=t[0];if(!n||!a)return;e.moveTo(n.x,n.y),e.lineTo(a.x,a.y)}e.stroke()}u(wZ,{AnchorPosition:()=>dY,DrawBox:()=>mY,DrawBoxOptions:()=>fY,DrawFaceLandmarks:()=>sJ,DrawFaceLandmarksOptions:()=>rJ,DrawTextField:()=>pY,DrawTextFieldOptions:()=>hY,drawContour:()=>kZ,drawDetections:()=>gY,drawFaceExpressions:()=>tJ,drawFaceLandmarks:()=>iJ});u({},{computeReshapedDimensions:()=>DZ,getCenterPoint:()=>FZ,isDimensions:()=>RZ,isEven:()=>_Z,isFloat:()=>EZ,isTensor:()=>SZ,isTensor1D:()=>NZ,isTensor2D:()=>TZ,isTensor3D:()=>OZ,isTensor4D:()=>CZ,isValidNumber:()=>jZ,isValidProbablitiy:()=>zZ,range:()=>MZ,round:()=>AZ});var IZ=class{constructor(e,t){if(!jZ(e)||!jZ(t))throw new Error("Dimensions.constructor - expected width and height to be valid numbers, instead have ".concat(JSON.stringify({width:e,height:t})));this._width=e,this._height=t}get width(){return this._width}get height(){return this._height}reverse(){return new IZ(1/this.width,1/this.height)}};function SZ(e,t){return e instanceof os&&e.shape.length===t}function NZ(e){return SZ(e,1)}function TZ(e){return SZ(e,2)}function OZ(e){return SZ(e,3)}function CZ(e){return SZ(e,4)}function EZ(e){return e%1!==0}function _Z(e){return e%2===0}function AZ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=10**t;return Math.floor(e*n)/n}function RZ(e){return e&&e.width&&e.height}function DZ(e,t){let{width:n,height:a}=e,r=t/Math.max(a,n);return new IZ(Math.round(n*r),Math.round(a*r))}function FZ(e){return e.reduce((e,t)=>e.add(t),new LZ(0,0)).div(new LZ(e.length,e.length))}function MZ(e,t,n){return Array(e).fill(0).map((e,a)=>t+a*n)}function jZ(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||0===e}function zZ(e){return jZ(e)&&e>=0&&e<=1}var LZ=class{constructor(e,t){this._x=e,this._y=t}get x(){return this._x}get y(){return this._y}add(e){return new LZ(this.x+e.x,this.y+e.y)}sub(e){return new LZ(this.x-e.x,this.y-e.y)}mul(e){return new LZ(this.x*e.x,this.y*e.y)}div(e){return new LZ(this.x/e.x,this.y/e.y)}abs(){return new LZ(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new LZ(Math.floor(this.x),Math.floor(this.y))}},PZ=class{static isRect(e){return!!e&&[e.x,e.y,e.width,e.height].every(jZ)}static assertIsValidBox(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!PZ.isRect(e))throw new Error("".concat(t," - invalid box: ").concat(JSON.stringify(e),", expected object with properties x, y, width, height"));if(!n&&(e.width<0||e.height<0))throw new Error("".concat(t," - width (").concat(e.width,") and height (").concat(e.height,") must be positive numbers"))}constructor(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=e||{},a=[n.left,n.top,n.right,n.bottom].every(jZ),r=[n.x,n.y,n.width,n.height].every(jZ);if(!r&&!a)throw new Error("Box.constructor - expected box to be IBoundingBox | IRect, instead have ".concat(JSON.stringify(n)));let[s,i,o,c]=r?[n.x,n.y,n.width,n.height]:[n.left,n.top,n.right-n.left,n.bottom-n.top];PZ.assertIsValidBox({x:s,y:i,width:o,height:c},"Box.constructor",t),this._x=s,this._y=i,this._width=o,this._height=c}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new LZ(this.left,this.top)}get topRight(){return new LZ(this.right,this.top)}get bottomLeft(){return new LZ(this.left,this.bottom)}get bottomRight(){return new LZ(this.right,this.bottom)}round(){let[e,t,n,a]=[this.x,this.y,this.width,this.height].map(e=>Math.round(e));return new PZ({x:e,y:t,width:n,height:a})}floor(){let[e,t,n,a]=[this.x,this.y,this.width,this.height].map(e=>Math.floor(e));return new PZ({x:e,y:t,width:n,height:a})}toSquare(){let{x:e,y:t,width:n,height:a}=this,r=Math.abs(n-a);return n<a&&(e-=r/2,n+=r),a<n&&(t-=r/2,a+=r),new PZ({x:e,y:t,width:n,height:a})}rescale(e){let t=RZ(e)?e.width:e,n=RZ(e)?e.height:e;return new PZ({x:this.x*t,y:this.y*n,width:this.width*t,height:this.height*n})}pad(e,t){let[n,a,r,s]=[this.x-e/2,this.y-t/2,this.width+e,this.height+t];return new PZ({x:n,y:a,width:r,height:s})}clipAtImageBorders(e,t){let{x:n,y:a,right:r,bottom:s}=this,i=Math.max(n,0),o=Math.max(a,0),c=r-i,l=s-o,u=Math.min(c,e-i),d=Math.min(l,t-o);return new PZ({x:i,y:o,width:u,height:d}).floor()}shift(e,t){let{width:n,height:a}=this,r=this.x+e,s=this.y+t;return new PZ({x:r,y:s,width:n,height:a})}padAtBorders(e,t){let n=this.width+1,a=this.height+1,r=n,s=a,i=this.left,o=this.top,c=this.right,l=this.bottom;return c>t&&(r=-c+t+n,c=t),l>e&&(s=-l+e+a,l=e),i<1&&(s=2-i,i=1),o<1&&(s=2-o,o=1),{dy:1,edy:s,dx:1,edx:r,y:o,ey:l,x:i,ex:c,w:n,h:a}}calibrate(e){return new PZ({left:this.left+e.left*this.width,top:this.top+e.top*this.height,right:this.right+e.right*this.width,bottom:this.bottom+e.bottom*this.height}).toSquare().round()}},BZ=class extends PZ{constructor(e,t,n,a){super({left:e,top:t,right:n,bottom:a},arguments.length>4&&void 0!==arguments[4]&&arguments[4])}},WZ=class{constructor(e,t,n,a,r){this._imageDims=new IZ(r.width,r.height),this._score=e,this._classScore=t,this._className=n,this._box=new PZ(a).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new PZ(this._box).rescale(this.imageDims.reverse())}forSize(e,t){return new WZ(this.score,this.classScore,this.className,this.relativeBox,{width:e,height:t})}},UZ=class extends WZ{constructor(e,t,n){super(e,e,"",t,n)}forSize(e,t){let{score:n,relativeBox:a,imageDims:r}=super.forSize(e,t);return new UZ(n,a,r)}};function VZ(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],a=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),r=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=a*r;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function GZ(e,t){return eo(()=>{let[n,a,r]=t,s=fc([...e.shape.slice(0,3),1],n,"float32"),i=fc([...e.shape.slice(0,3),1],a,"float32"),o=fc([...e.shape.slice(0,3),1],r,"float32"),c=Jo([s,i,o],3);return Vl(e,c)})}function HZ(e){return 1/(1+Math.exp(-e))}var qZ,KZ=class extends PZ{constructor(e,t,n,a){super({x:e,y:t,width:n,height:a},arguments.length>4&&void 0!==arguments[4]&&arguments[4])}},XZ=class{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new LZ(0,0),{width:a,height:r}=t;this._imgDims=new IZ(a,r),this._shift=n,this._positions=e.map(e=>e.mul(new LZ(a,r)).add(n))}get shift(){return new LZ(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new LZ(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new LZ(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(e){let n=e instanceof UZ?e.box.floor():new PZ(e);return this.shiftBy(n.x,n.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:a}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(a)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,a]=e,r=e=>a.sub(e).magnitude(),s=(r(t)+r(n))/2,i=Math.floor(s/.45),o=FZ(e),c=Math.floor(Math.max(0,o.x-.5*i)),l=Math.floor(Math.max(0,o.y-.43*i));return new KZ(c,l,Math.min(i,this.imageWidth+c),Math.min(i,this.imageHeight+l))}alignMinBbox(e){let t=function(e){let t=e.map(e=>e.x),n=e.map(e=>e.y),a=t.reduce((e,t)=>t<e?t:e,1/0),r=n.reduce((e,t)=>t<e?t:e,1/0),s=t.reduce((e,t)=>e<t?t:e,0),i=n.reduce((e,t)=>e<t?t:e,0);return new BZ(a,r,s,i)}(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},ZZ=class extends XZ{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(FZ)}},YZ=class{constructor(e,t){this._label=e,this._distance=t}get label(){return this._label}get distance(){return this._distance}toString(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return"".concat(this.label).concat(e?" (".concat(AZ(this.distance),")"):"")}},JZ=class{constructor(e,t){if("string"!=typeof e)throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(t)||t.some(e=>!(e instanceof Float32Array)))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=e,this._descriptors=t}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map(e=>Array.from(e))}}static fromJSON(e){let t=e.descriptors.map(e=>new Float32Array(e));return new JZ(e.label,t)}};function QZ(e){return e.detection instanceof UZ}function $Z(e,t){return{...e,detection:t}}function eY(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D:CanvasRenderingContext2D,Image:HTMLImageElement,ImageData:ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function tY(){return"object"==typeof s&&"undefined"!=typeof a&&null!=a.versions&&null!=a.versions.node}function nY(e){let t="";if(!e&&tY())try{e=l("fs")}catch(n){t=n.toString()}return{readFile:e?t=>new Promise((n,a)=>{e.readFile(t,(e,t)=>e?a(e):n(t))}):()=>{throw new Error("readFile - failed to require fs in nodejs environment with error: ".concat(t))}}}function aY(){let e=s.Canvas||s.HTMLCanvasElement,t=s.Image||s.HTMLImageElement,n=s.Video||s.HTMLVideoElement,a=s.fetch,r=nY();return{Canvas:e||class{},CanvasRenderingContext2D:s.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:s.ImageData||class{},Video:s.HTMLVideoElement||class{},createCanvasElement:()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},createImageElement:()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},createVideoElement:()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},fetch:a,...r}}function rY(){return"object"==typeof window&&"undefined"!=typeof document&&"undefined"!=typeof HTMLImageElement&&"undefined"!=typeof HTMLCanvasElement&&"undefined"!=typeof HTMLVideoElement&&"undefined"!=typeof ImageData&&"undefined"!=typeof CanvasRenderingContext2D}function sY(e){qZ=e}function iY(){return rY()?sY(eY()):tY()?sY(aY()):null}var oY={getEnv:function(){if(!qZ)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return qZ},setEnv:sY,initialize:iY,createBrowserEnv:eY,createFileSystem:nY,createNodejsEnv:aY,monkeyPatch:function(e){if(qZ||iY(),!qZ)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=qZ.Canvas,Image:n=qZ.Image}=e;qZ.Canvas=t,qZ.Image=n,qZ.createCanvasElement=e.createCanvasElement||(()=>new t),qZ.createImageElement=e.createImageElement||(()=>new n),qZ.ImageData=e.ImageData||qZ.ImageData,qZ.Video=e.Video||qZ.Video,qZ.fetch=e.fetch||qZ.fetch,qZ.readFile=e.readFile||qZ.readFile},isBrowser:rY,isNodejs:tY};function cY(e){return oY.isNodejs()||"string"!=typeof e?e:document.getElementById(e)}function lY(e){let{Canvas:t,CanvasRenderingContext2D:n}=oY.getEnv();if(e instanceof n)return e;let a=cY(e);if(!(a instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let r=a.getContext("2d",{willReadFrequently:!0});if(!r)throw new Error("resolveContext2d - canvas 2d context is null");return r}iY();var uY,dY=((uY=dY||{}).TOP_LEFT="TOP_LEFT",uY.TOP_RIGHT="TOP_RIGHT",uY.BOTTOM_LEFT="BOTTOM_LEFT",uY.BOTTOM_RIGHT="BOTTOM_RIGHT",uY),hY=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{anchorPosition:t,backgroundColor:n,fontColor:a,fontSize:r,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=a||"rgba(255, 255, 255, 1)",this.fontSize=r||14,this.fontStyle=s||"Georgia",this.padding=i||4}},pY=class{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.text="string"==typeof e?[e]:e instanceof pY?e.text:e,this.anchor=t,this.options=new hY(n)}measureWidth(e){let{padding:t}=this.options;return this.text.map(t=>e.measureText(t).width).reduce((e,t)=>e<t?t:e,0)+2*t}measureHeight(){let{fontSize:e,padding:t}=this.options;return this.text.length*e+2*t}getUpperLeft(e,t){let{anchorPosition:n}=this.options,a="BOTTOM_RIGHT"===n||"TOP_RIGHT"===n,r="BOTTOM_LEFT"===n||"BOTTOM_RIGHT"===n,s=this.measureWidth(e),i=this.measureHeight(),o=a?this.anchor.x-s:this.anchor.x,c=r?this.anchor.y-i:this.anchor.y;if(t){let{width:e,height:n}=t;return{x:Math.max(Math.min(o,e-s),0),y:Math.max(Math.min(c,n-i),0)}}return{x:o,y:c}}draw(e){let t=cY(e),n=lY(t),{backgroundColor:a,fontColor:r,fontSize:s,fontStyle:i,padding:o}=this.options;n.font="".concat(s,"px ").concat(i);let c=this.measureWidth(n),l=this.measureHeight();n.fillStyle=a;let u=this.getUpperLeft(n,t);n.fillRect(u.x,u.y,c,l),n.fillStyle=r,this.text.forEach((e,t)=>{let a=o+u.x,r=o+u.y+(t+1)*s;n.fillText(e,a,r)})}},fY=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{boxColor:t,lineWidth:n,label:a,drawLabelOptions:r}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=a;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new hY({...s,...r})}},mY=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.box=new PZ(e),this.options=new fY(t)}draw(e){let t=lY(e),{boxColor:n,lineWidth:a}=this.options,{x:r,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=a,t.strokeRect(r,s,i,o);let{label:c}=this.options;c&&new pY([c],{x:r-a/2,y:s},this.options.drawLabelOptions).draw(e)}};function gY(e,t){(Array.isArray(t)?t:[t]).forEach(t=>{let n=t instanceof UZ?t.score:QZ(t)?t.detection.score:void 0,a=t instanceof UZ?t.box:QZ(t)?t.detection.box:new PZ(t),r=n?"".concat(AZ(n)):void 0;new mY(a,{label:r}).draw(e)})}function bY(e){let{Image:t,Video:n}=oY.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function yY(e){let{Image:t,Video:n}=oY.getEnv();return e instanceof t?new IZ(e.naturalWidth,e.naturalHeight):e instanceof n?new IZ(e.videoWidth,e.videoHeight):new IZ(e.width,e.height)}function vY(e){let{width:t,height:n}=e,{createCanvasElement:a}=oY.getEnv(),r=a();return r.width=t,r.height=n,r}function xY(e,t){let{ImageData:n}=oY.getEnv();if(!(e instanceof n)&&!bY(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:a,height:r}=t||yY(e),s=vY({width:a,height:r});return e instanceof n?lY(s).putImageData(e,0,0):lY(s).drawImage(e,0,0,a,r),s}function wY(e){let{Image:t,Canvas:n,Video:a}=oY.getEnv();return e instanceof t||e instanceof n||e instanceof a}var kY=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error("NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ".concat(e));this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((e,t)=>{if(OZ(e))return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape);if(CZ(e)){let n=e.shape[0];if(1!==n)throw new Error("NetInput - tf.Tensor4D with batchSize ".concat(n," passed, but not supported in input array"));return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape.slice(1))}let n=e instanceof oY.getEnv().Canvas?e:xY(e);this._canvases[t]=n,this._inputDimensions[t]=[n.height,n.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return MZ(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if("number"!=typeof this.inputSize)throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");return DZ({width:this.getInputWidth(e),height:this.getInputHeight(e)},this.inputSize)}toBatchTensor(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return this._inputSize=e,eo(()=>{let n=MZ(this.batchSize,0,1).map(n=>{let a=this.getInput(n);if(a instanceof os){let n=CZ(a)?a:fl(a);return n=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return eo(()=>{let[n,a]=e.shape.slice(1);if(n===a)return e;let r=Math.abs(n-a),s=Math.round(r*(t?.5:1)),i=n>a?2:1,o=t=>{let n=e.shape.slice();return n[i]=t,fc(n,0,"float32")},c=o(s),l=r-c.shape[i],u=[t&&l?o(l):null,e,c].filter(e=>!!e).map(e=>Vi(e,"float32"));return Jo(u,i)})}(n,t),(n.shape[1]!==e||n.shape[2]!==e)&&(n=kp.resizeBilinear(n,[e,e],!1,!1)),n.as3D(e,e,3)}if(a instanceof oY.getEnv().Canvas)return lf.fromPixels(function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],{Image:a,Canvas:r}=oY.getEnv();if(!(e instanceof a||e instanceof r))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return vY({width:1,height:1});let s=yY(e),i=t/Math.max(s.height,s.width),o=i*s.width,c=i*s.height,l=vY({width:t,height:t}),u=e instanceof r?e:xY(e),d=Math.abs(o-c)/2,h=n&&o<c?d:0,p=n&&c<o?d:0;return u.width>0&&u.height>0&&lY(l).drawImage(u,h,p,o,c),l}(a,e,t));throw new Error("toBatchTensor - at batchIdx ".concat(n,", expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ").concat(a))});return Ed(n.map(e=>Vi(e,"float32"))).as4D(this.batchSize,e,e,3)})}};async function IY(e){if(e instanceof kY)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=t=>Array.isArray(e)?" at input index ".concat(t,":"):"",a=t.map(cY);return a.forEach((e,a)=>{if(!wY(e)&&!OZ(e)&&!CZ(e))throw"string"==typeof t[a]?new Error("toNetInput -".concat(n(a)," string passed, but could not resolve HTMLElement for element id ").concat(t[a])):new Error("toNetInput -".concat(n(a)," expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id"));if(CZ(e)){let t=e.shape[0];if(1!==t)throw new Error("toNetInput -".concat(n(a)," tf.Tensor4D with batchSize ").concat(t," passed, but not supported in input array"))}}),await Promise.all(a.map(e=>wY(e)&&function(e){return new Promise((t,n)=>{function a(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",r),e.currentTarget.removeEventListener("error",a),n(e))}function r(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",r),e.currentTarget.removeEventListener("error",a),t(e))}(e instanceof oY.getEnv().Canvas||bY(e))&&t(null),e.addEventListener("load",r),e.addEventListener("error",a)})}(e))),new kY(a,Array.isArray(e))}async function SY(e,t){let{Canvas:n}=oY.getEnv(),a=e;if(!(e instanceof n)){let t=await IY(e);if(t.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let r=t.getInput(0);a=r instanceof n?r:await async function(e,t){let n=t||oY.getEnv().createCanvasElement(),[a,r,s]=e.shape.slice(CZ(e)?1:0),i=eo(()=>e.as3D(a,r,s).toInt());return await lf.toPixels(i,n),i.dispose(),n}(r)}let r=lY(a);return t.map(e=>e instanceof UZ?e.forSize(a.width,a.height).box.floor():e).map(e=>e.clipAtImageBorders(a.width,a.height)).map(e=>{let{x:t,y:n,width:a,height:s}=e,i=vY({width:a,height:s});return a>0&&s>0&&lY(i).putImageData(r.getImageData(t,n,a,s),0,0),i})}async function NY(e,t){if(!OZ(e)&&!CZ(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(CZ(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return eo(()=>{let[n,a,r]=e.shape.slice(CZ(e)?1:0);return t.map(e=>e instanceof UZ?e.forSize(a,n).box:e).map(e=>e.clipAtImageBorders(a,n)).filter(e=>e.width>0&&e.height>0).map(t=>{let{x:s,y:i,width:o,height:c}=t;return vd(e.as3D(n,a,r),[i,s,0],[c,o,r])})})}async function TY(e,t){let{fetch:n}=oY.getEnv(),a=await n(e,t);if(!(a.status<400))throw new Error("failed to fetch: (".concat(a.status,") ").concat(a.statusText,", from url: ").concat(a.url));return a}async function OY(e){let t=await TY(e),n=await t.blob();if(!n.type.startsWith("image/"))throw new Error("fetchImage - expected blob type to be of type image/*, instead have: ".concat(n.type,", for url: ").concat(t.url));return function(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error("bufferToImage - expected buf to be of type: Blob"));let a=new FileReader;a.onload=()=>{"string"!=typeof a.result&&n(new Error("bufferToImage - expected reader.result to be a string, in onload"));let e=oY.getEnv().createImageElement();e.onload=()=>t(e),e.onerror=n,e.src=a.result},a.onerror=n,a.readAsDataURL(e)})}(n)}function CY(e,t){let n="".concat(t,"-weights_manifest.json");if(!e)return{modelBaseUri:"",manifestUri:n};if("/"===e)return{modelBaseUri:"/",manifestUri:"/".concat(n)};let a=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"",r=(e=e.replace(a,"")).split("/").filter(e=>e),s=e.endsWith(".json")?r[r.length-1]:n,i=a+(e.endsWith(".json")?r.slice(0,r.length-1):r).join("/");return i=e.startsWith("/")?"/".concat(i):i,{modelBaseUri:i,manifestUri:"/"===i?"/".concat(s):"".concat(i,"/").concat(s)}}async function EY(e,t){let{manifestUri:n,modelBaseUri:a}=CY(e,t),r=await async function(e){return(await TY(e)).json()}(n);return Bp.loadWeights(r,a)}function _Y(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],{width:a,height:r}=n?yY(t):t;return e.width=a,e.height=r,{width:a,height:r}}var AY=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:a}=this.traversePropertyPath(e);n[a].dispose(),n[a]=t}getParamList(){return this._paramMappings.map(e=>{let{paramPath:t}=e;return{path:t,tensor:this.getParamFromPath(t)}})}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof ls)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof ls))}variable(){this.getFrozenParams().forEach(e=>{let{path:t,tensor:n}=e;this.reassignParamFromPath(t,n.variable())})}freeze(){this.getTrainableParams().forEach(e=>{let{path:t,tensor:n}=e,a=qs(n.dataSync());n.dispose(),this.reassignParamFromPath(t,a)})}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error("param tensor has already been disposed for path ".concat(t.path));t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(e=>{let{tensor:t}=e;return Array.from(t.dataSync())}).reduce((e,t)=>e.concat(t)))}async load(e){e instanceof Float32Array?this.extractWeights(e):await this.loadFromUri(e)}async loadFromUri(e){if(e&&"string"!=typeof e)throw new Error("".concat(this._name,".loadFromUri - expected model uri"));let t=await EY(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&"string"!=typeof e)throw new Error("".concat(this._name,".loadFromDisk - expected model file path"));let{readFile:t}=oY.getEnv(),{manifestUri:n,modelBaseUri:a}=CY(e,this.getDefaultModelName()),r=Bp.weightsLoaderFactory(e=>Promise.all(e.map(e=>t(e).then(e=>e.buffer)))),s=JSON.parse((await t(n)).toString()),i=await r(s,a);this.loadFromWeightMap(i)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((t,n)=>{if(!t.nextObj.hasOwnProperty(n))throw new Error("traversePropertyPath - object does not have property ".concat(n,", for path ").concat(e));return{obj:t.nextObj,objProp:n,nextObj:t.nextObj[n]}},{nextObj:this.params}),{obj:n,objProp:a}=t;if(!n||!a||!(n[a]instanceof os))throw new Error("traversePropertyPath - parameter is not a tensor, for path ".concat(e));return{obj:n,objProp:a}}};function RY(e,t,n){return eo(()=>{let a=hd(e,t.depthwise_filter,t.pointwise_filter,n,"same");return a=fo(a,t.bias),a})}function DY(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return eo(()=>{let a=nd(n?fo(xc(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):RY(e,t.conv0,[2,2])),r=RY(a,t.conv1,[1,1]),s=RY(nd(fo(a,r)),t.conv2,[1,1]);return nd(fo(a,fo(r,s)))})}function FY(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];return eo(()=>{let r=nd(n?fo(xc(e,t.conv0.filters,a?[2,2]:[1,1],"same"),t.conv0.bias):RY(e,t.conv0,a?[2,2]:[1,1])),s=RY(r,t.conv1,[1,1]),i=RY(nd(fo(r,s)),t.conv2,[1,1]),o=RY(nd(fo(r,fo(s,i))),t.conv3,[1,1]);return nd(fo(r,fo(s,fo(i,o))))})}function MY(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"same",a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return eo(()=>{let r=fo(xc(e,t.filters,[1,1],n),t.bias);return a?nd(r):r})}function jY(e,t){Object.keys(e).forEach(n=>{t.some(e=>e.originalPath===n)||e[n].dispose()})}function zY(e,t){return(n,a,r,s)=>{let i=jd(e(n*a*r*r),[r,r,n,a]),o=Dd(e(a));return t.push({paramPath:"".concat(s,"/filters")},{paramPath:"".concat(s,"/bias")}),{filters:i,bias:o}}}function LY(e,t){return(n,a,r)=>{let s=Fd(e(n*a),[n,a]),i=Dd(e(a));return t.push({paramPath:"".concat(r,"/weights")},{paramPath:"".concat(r,"/bias")}),{weights:s,bias:i}}}var PY=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function BY(e,t){return(n,a,r)=>{let s=jd(e(9*n),[3,3,n,1]),i=jd(e(n*a),[1,1,n,a]),o=Dd(e(a));return t.push({paramPath:"".concat(r,"/depthwise_filter")},{paramPath:"".concat(r,"/pointwise_filter")},{paramPath:"".concat(r,"/bias")}),new PY(s,i,o)}}function WY(e){return t=>{let n=e("".concat(t,"/depthwise_filter"),4),a=e("".concat(t,"/pointwise_filter"),4),r=e("".concat(t,"/bias"),1);return new PY(n,a,r)}}function UY(e,t){return(n,a,r)=>{let s=e[n];if(!SZ(s,a))throw new Error("expected weightMap[".concat(n,"] to be a Tensor").concat(a,"D, instead have ").concat(s));return t.push({originalPath:n,paramPath:r||n}),s}}function VY(e){let t=e;return{extractWeights:function(e){let n=t.slice(0,e);return t=t.slice(e),n},getRemainingWeights:function(){return t}}}function GY(e,t){let n=zY(e,t),a=BY(e,t);function r(e,t,r){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],i=s?n(e,t,3,"".concat(r,"/conv0")):a(e,t,"".concat(r,"/conv0")),o=a(t,t,"".concat(r,"/conv1")),c=a(t,t,"".concat(r,"/conv2"));return{conv0:i,conv1:o,conv2:c}}return{extractDenseBlock3Params:r,extractDenseBlock4Params:function(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],{conv0:i,conv1:o,conv2:c}=r(e,t,n,s),l=a(t,t,"".concat(n,"/conv3"));return{conv0:i,conv1:o,conv2:c,conv3:l}}}}function HY(e){return t=>({filters:e("".concat(t,"/filters"),4),bias:e("".concat(t,"/bias"),1)})}function qY(e,t){let n=UY(e,t),a=HY(n),r=WY(n);return{extractDenseBlock3Params:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=t?a("".concat(e,"/conv0")):r("".concat(e,"/conv0")),s=r("".concat(e,"/conv1")),i=r("".concat(e,"/conv2"));return{conv0:n,conv1:s,conv2:i}},extractDenseBlock4Params:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=t?a("".concat(e,"/conv0")):r("".concat(e,"/conv0")),s=r("".concat(e,"/conv1")),i=r("".concat(e,"/conv2")),o=r("".concat(e,"/conv3"));return{conv0:n,conv1:s,conv2:i,conv3:o}}}}var KY=class extends AY{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return eo(()=>{let n=FY(GZ(Vi(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=FY(n,t.dense1),n=FY(n,t.dense2),n=FY(n,t.dense3),n=Zo(n,[7,7],[2,2],"valid"),n})}async forward(e){return this.forwardInput(await IY(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock4Params:n}=qY(e,t),a={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return jY(e,t),{params:a,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:a}=VY(e),{extractDenseBlock4Params:r}=GY(n,t),s=r(3,32,"dense0",!0),i=r(32,64,"dense1"),o=r(64,128,"dense2"),c=r(128,256,"dense3");if(0!==a().length)throw new Error("weights remaing after extract: ".concat(a().length));return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:c}}}(e)}};function XY(e,t){return eo(()=>fo(Qo(e,t.weights),t.bias))}function ZY(e){let t={},n={};return Object.keys(e).forEach(a=>{(a.startsWith("fc")?n:t)[a]=e[a]}),{featureExtractorMap:t,classifierMap:n}}var YY=class extends AY{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error("".concat(this._name," - load model before inference"));return eo(()=>{let n=e instanceof kY?this.faceFeatureExtractor.forwardInput(e):e;return XY(n.as2D(n.shape[0],-1),t.fc)})}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e,t,n){let a=[],{extractWeights:r,getRemainingWeights:s}=VY(e),i=LY(r,a)(t,n,"fc");if(0!==s().length)throw new Error("weights remaing after extract: ".concat(s().length));return{paramMappings:a,params:{fc:i}}}(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=ZY(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=UY(e,t),a={fc:(r="fc",{weights:n("".concat(r,"/weights"),2),bias:n("".concat(r,"/bias"),1)})};var r;return jY(e,t),{params:a,paramMappings:t}}(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),a=n*t+n,r=e.slice(0,e.length-a),s=e.slice(e.length-a);return this.faceFeatureExtractor.extractWeights(r),this.extractClassifierParams(s)}},JY=["neutral","happy","sad","angry","fearful","disgusted","surprised"],QY=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,7!==e.length)throw new Error("FaceExpressions.constructor - expected probabilities.length to be 7, have: ".concat(e.length));JY.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return JY.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}};function $Y(e){return e.expressions instanceof QY}function eJ(e,t){return{...e,expressions:t}}function tJ(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1,a=arguments.length>3?arguments[3]:void 0;(Array.isArray(t)?t:[t]).forEach(t=>{let r=t instanceof QY?t:$Y(t)?t.expressions:void 0;if(!r)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let s=r.asSortedArray().filter(e=>e.probability>n),i=QZ(t)?t.detection.box.bottomLeft:a||new LZ(0,0);new pY(s.map(e=>"".concat(e.expression," (").concat(AZ(e.probability),")")),i).draw(e)})}function nJ(e){return QZ(e)&&e.landmarks instanceof XZ&&e.unshiftedLandmarks instanceof XZ&&e.alignedRect instanceof UZ}function aJ(e,t){let{box:n}=e.detection,a=t.shiftBy(n.x,n.y),r=a.align(),{imageDims:s}=e.detection,i=new UZ(e.detection.score,r.rescale(s.reverse()),s),o=function(e){let t=e=>180*e/Math.PI,n=(e,t)=>Math.sqrt((e._x-t._x)**2+(e._y-t._y)**2),a={roll:void 0,pitch:void 0,yaw:void 0};if(!e||!e._positions||68!==e._positions.length)return a;let r=e._positions;return a.roll=((e,n)=>{let a=Math.hypot(n._x-e._x,n._y-e._y),r=n._y-e._y,s=Math.asin(r/a),i=t(s);return Math.floor(90-i)*(n._x-e._x<0?-1:1)})(r[27],r[66]),a.pitch=((e,a,r)=>{let s=n(e,r),i={_x:(e._x+r._x)/2,_y:(e._y+r._y)/2},o=n(a,i),c=Math.atan(o/s);return Math.floor(t(c))*(i._y-a._y<0?-1:1)})(r[14],r[30],r[2]),a.yaw=(s=r[14],i=r[33],o=r[2],Math.floor(s._x-i._x)-Math.floor(i._x-o._x)),a;var s,i,o}(t);return{...e,landmarks:a,unshiftedLandmarks:t,alignedRect:i,angle:o}}var rJ=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{drawLines:t=!0,drawPoints:n=!0,lineWidth:a,lineColor:r,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=a||1,this.pointSize=s||2,this.lineColor=r||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},sJ=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.faceLandmarks=e,this.options=new rJ(t)}draw(e){let t=lY(e),{drawLines:n,drawPoints:a,lineWidth:r,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof ZZ&&(t.strokeStyle=s,t.lineWidth=r,kZ(t,this.faceLandmarks.getJawOutline()),kZ(t,this.faceLandmarks.getLeftEyeBrow()),kZ(t,this.faceLandmarks.getRightEyeBrow()),kZ(t,this.faceLandmarks.getNose()),kZ(t,this.faceLandmarks.getLeftEye(),!0),kZ(t,this.faceLandmarks.getRightEye(),!0),kZ(t,this.faceLandmarks.getMouth(),!0)),a){t.strokeStyle=o,t.fillStyle=o;let e=e=>{t.beginPath(),t.arc(e.x,e.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(e)}}};function iJ(e,t){(Array.isArray(t)?t:[t]).forEach(t=>{let n=t instanceof XZ?t:nJ(t)?t.landmarks:void 0;if(!n)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new sJ(n).draw(e)})}function oJ(e,t){let n=[],{extractWeights:a,getRemainingWeights:r}=VY(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:c}=function(e,t){let n=zY(e,t),a=BY(e,t);return{extractConvParams:n,extractSeparableConvParams:a,extractReductionBlockParams:function(e,t,r){return{separable_conv0:a(e,t,"".concat(r,"/separable_conv0")),separable_conv1:a(t,t,"".concat(r,"/separable_conv1")),expansion_conv:n(e,t,1,"".concat(r,"/expansion_conv"))}},extractMainBlockParams:function(e,t){return{separable_conv0:a(e,e,"".concat(t,"/separable_conv0")),separable_conv1:a(e,e,"".concat(t,"/separable_conv1")),separable_conv2:a(e,e,"".concat(t,"/separable_conv2"))}}}}(a,n),l={conv_in:s(3,32,3,"entry_flow/conv_in"),reduction_block_0:o(32,64,"entry_flow/reduction_block_0"),reduction_block_1:o(64,128,"entry_flow/reduction_block_1")},u={};MZ(t,0,1).forEach(e=>{u["main_block_".concat(e)]=c(128,"middle_flow/main_block_".concat(e))});let d={reduction_block:o(128,256,"exit_flow/reduction_block"),separable_conv:i(256,512,"exit_flow/separable_conv")};if(0!==r().length)throw new Error("weights remaing after extract: ".concat(r().length));return{paramMappings:n,params:{entry_flow:l,middle_flow:u,exit_flow:d}}}function cJ(e,t){let n=[],{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:i}=function(e,t){let n=UY(e,t),a=HY(n),r=WY(n);return{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:function(e){return{separable_conv0:r("".concat(e,"/separable_conv0")),separable_conv1:r("".concat(e,"/separable_conv1")),expansion_conv:a("".concat(e,"/expansion_conv"))}},extractMainBlockParams:function(e){return{separable_conv0:r("".concat(e,"/separable_conv0")),separable_conv1:r("".concat(e,"/separable_conv1")),separable_conv2:r("".concat(e,"/separable_conv2"))}}}}(e,n),o={conv_in:a("entry_flow/conv_in"),reduction_block_0:s("entry_flow/reduction_block_0"),reduction_block_1:s("entry_flow/reduction_block_1")},c={};MZ(t,0,1).forEach(e=>{c["main_block_".concat(e)]=i("middle_flow/main_block_".concat(e))});let l={reduction_block:s("exit_flow/reduction_block"),separable_conv:r("exit_flow/separable_conv")};return jY(e,n),{params:{entry_flow:o,middle_flow:c,exit_flow:l},paramMappings:n}}function lJ(e,t,n){return fo(xc(e,t.filters,n,"same"),t.bias)}function uJ(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],a=n?nd(e):e;return a=RY(a,t.separable_conv0,[1,1]),a=RY(nd(a),t.separable_conv1,[1,1]),a=$l(a,[3,3],[2,2],"same"),a=fo(a,lJ(e,t.expansion_conv,[2,2])),a}var dJ=class extends AY{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return eo(()=>{let n=GZ(Vi(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),a=nd(lJ(n,t.entry_flow.conv_in,[2,2]));return a=uJ(a,t.entry_flow.reduction_block_0,!1),a=uJ(a,t.entry_flow.reduction_block_1),MZ(this._numMainBlocks,0,1).forEach(e=>{a=function(e,t){let n=RY(nd(e),t.separable_conv0,[1,1]);return n=RY(nd(n),t.separable_conv1,[1,1]),n=RY(nd(n),t.separable_conv2,[1,1]),n=fo(n,e),n}(a,t.middle_flow["main_block_".concat(e)])}),a=uJ(a,t.exit_flow.reduction_block),a=nd(RY(a,t.exit_flow.separable_conv,[1,1])),a})}async forward(e){return this.forwardInput(await IY(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return cJ(e,this._numMainBlocks)}extractParams(e){return oJ(e,this._numMainBlocks)}};var hJ,pJ=((hJ=pJ||{}).FEMALE="female",hJ.MALE="male",hJ),fJ=class extends YY{postProcess(e,t,n){let a=n.map(e=>{let{width:n,height:a}=e,r=t/Math.max(a,n);return{width:n*r,height:a*r}}),r=a.length;return eo(()=>{let n=(e,t)=>Ed([fc([68],e,"float32"),fc([68],t,"float32")],1).as2D(1,136).as1D(),s=(e,t)=>{let{width:n,height:r}=a[e];return t(n,r)?Math.abs(n-r)/2:0};return e.mul(fc([r,136],t,"float32")).sub(Ed(Array.from(Array(r),(e,t)=>n((e=>s(e,(e,t)=>e<t))(t),(e=>s(e,(e,t)=>t<e))(t))))).div(Ed(Array.from(Array(r),(e,t)=>n(a[t].width,a[t].height))))})}forwardInput(e){return eo(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(e=>{let[t,n]=e;return{height:t,width:n}}))})}async forward(e){return this.forwardInput(await IY(e))}async detectLandmarks(e){let t=await IY(e),n=eo(()=>Xd(this.forwardInput(t))),a=await Promise.all(n.map(async(e,n)=>{let a=Array.from(e.dataSync()),r=a.filter((e,t)=>_Z(t)),s=a.filter((e,t)=>!_Z(t));return new ZZ(Array(68).fill(0).map((e,t)=>new LZ(r[t],s[t])),{height:t.getInputHeight(n),width:t.getInputWidth(n)})}));return n.forEach(e=>e.dispose()),t.isBatchInput?a:a[0]}getClassifierChannelsOut(){return 136}},mJ=class extends fJ{constructor(){super("FaceLandmark68Net",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new KY)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};var gJ=class extends AY{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return eo(()=>{let n=DY(GZ(Vi(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=DY(n,t.dense1),n=DY(n,t.dense2),n=Zo(n,[14,14],[2,2],"valid"),n})}async forward(e){return this.forwardInput(await IY(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock3Params:n}=qY(e,t),a={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return jY(e,t),{params:a,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:a}=VY(e),{extractDenseBlock3Params:r}=GY(n,t),s=r(3,32,"dense0",!0),i=r(32,64,"dense1"),o=r(64,128,"dense2");if(0!==a().length)throw new Error("weights remaing after extract: ".concat(a().length));return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}(e)}};function bJ(e,t){return fo(bo(e,t.weights),t.biases)}function yJ(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"same",{filters:s,bias:i}=t.conv,o=xc(e,s,n,r);return o=fo(o,i),o=bJ(o,t.scale),a?nd(o):o}function vJ(e,t){return yJ(e,t,[1,1],!1)}function xJ(e,t){return yJ(e,t,[2,2],!0,"valid")}function wJ(e,t){function n(n,a,r,s){let i=function(t,n,a){let r=e(t),s=r.length/(n*a*a);if(EZ(s))throw new Error("depth has to be an integer: ".concat(s,", weights.length: ").concat(r.length,", numFilters: ").concat(n,", filterSize: ").concat(a));return eo(()=>eh(jd(r,[n,s,a,a]),[2,3,1,0]))}(n,a,r),o=Dd(e(a));return t.push({paramPath:"".concat(s,"/filters")},{paramPath:"".concat(s,"/bias")}),{filters:i,bias:o}}function a(a,r,s,i){return{conv:n(a,r,s,"".concat(i,"/conv")),scale:function(n,a){let r=Dd(e(n)),s=Dd(e(n));return t.push({paramPath:"".concat(a,"/weights")},{paramPath:"".concat(a,"/biases")}),{weights:r,biases:s}}(r,"".concat(i,"/scale"))}}return{extractConvLayerParams:a,extractResidualLayerParams:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=a((s?.5:1)*e,t,n,"".concat(r,"/conv1")),o=a(e,t,n,"".concat(r,"/conv2"));return{conv1:i,conv2:o}}}}function kJ(e,t){let n=UY(e,t);function a(e){return{conv:{filters:n("".concat(e,"/conv/filters"),4),bias:n("".concat(e,"/conv/bias"),1)},scale:function(e){return{weights:n("".concat(e,"/scale/weights"),1),biases:n("".concat(e,"/scale/biases"),1)}}(e)}}return{extractConvLayerParams:a,extractResidualLayerParams:function(e){return{conv1:a("".concat(e,"/conv1")),conv2:a("".concat(e,"/conv2"))}}}}function IJ(e,t){let n=function(e,t){return yJ(e,t,[1,1],!0)}(e,t.conv1);return n=vJ(n,t.conv2),n=fo(n,e),n=nd(n),n}function SJ(e,t){let n=xJ(e,t.conv1);n=vJ(n,t.conv2);let a=Zo(e,2,2,"valid"),r=ru(a.shape),s=a.shape[3]!==n.shape[3];if(a.shape[1]!==n.shape[1]||a.shape[2]!==n.shape[2]){let e=[...n.shape];e[1]=1;let t=ru(e);n=Jo([n,t],1);let a=[...n.shape];a[2]=1;let r=ru(a);n=Jo([n,r],2)}return a=s?Jo([a,r],3):a,n=fo(a,n),n=nd(n),n}var NJ=class extends AY{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return eo(()=>{let n=xJ(GZ(Vi(e.toBatchTensor(150,!0),"float32"),[122.782,117.001,104.298]).div(255),t.conv32_down);n=$l(n,3,2,"valid"),n=IJ(n,t.conv32_1),n=IJ(n,t.conv32_2),n=IJ(n,t.conv32_3),n=SJ(n,t.conv64_down),n=IJ(n,t.conv64_1),n=IJ(n,t.conv64_2),n=IJ(n,t.conv64_3),n=SJ(n,t.conv128_down),n=IJ(n,t.conv128_1),n=IJ(n,t.conv128_2),n=SJ(n,t.conv256_down),n=IJ(n,t.conv256_1),n=IJ(n,t.conv256_2),n=SJ(n,t.conv256_down_out);let a=n.mean([1,2]);return Qo(a,t.fc)})}async forward(e){return this.forwardInput(await IY(e))}async computeFaceDescriptor(e){var t;if(null!=(t=null==e?void 0:e.shape)&&t.some(e=>e<=0))return new Float32Array(128);let n=await IY(e),a=eo(()=>Xd(this.forwardInput(n))),r=await Promise.all(a.map(e=>e.data()));return a.forEach(e=>e.dispose()),n.isBatchInput?r:r[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:a}=kJ(e,t),r=n("conv32_down"),s=a("conv32_1"),i=a("conv32_2"),o=a("conv32_3"),c=a("conv64_down"),l=a("conv64_1"),u=a("conv64_2"),d=a("conv64_3"),h=a("conv128_down"),p=a("conv128_1"),f=a("conv128_2"),m=a("conv256_down"),g=a("conv256_1"),b=a("conv256_2"),y=a("conv256_down_out"),{fc:v}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!TZ(v))throw new Error("expected weightMap[fc] to be a Tensor2D, instead have ".concat(v));let x={conv32_down:r,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:c,conv64_1:l,conv64_2:u,conv64_3:d,conv128_down:h,conv128_1:p,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:b,conv256_down_out:y,fc:v};return jY(e,t),{params:x,paramMappings:t}}(e)}extractParams(e){return function(e){let{extractWeights:t,getRemainingWeights:n}=VY(e),a=[],{extractConvLayerParams:r,extractResidualLayerParams:s}=wJ(t,a),i=r(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),c=s(9216,32,3,"conv32_2"),l=s(9216,32,3,"conv32_3"),u=s(36864,64,3,"conv64_down",!0),d=s(36864,64,3,"conv64_1"),h=s(36864,64,3,"conv64_2"),p=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),m=s(147456,128,3,"conv128_1"),g=s(147456,128,3,"conv128_2"),b=s(589824,256,3,"conv256_down",!0),y=s(589824,256,3,"conv256_1"),v=s(589824,256,3,"conv256_2"),x=s(589824,256,3,"conv256_down_out"),w=eo(()=>eh(Fd(t(32768),[128,256]),[1,0]));if(a.push({paramPath:"fc"}),0!==n().length)throw new Error("weights remaing after extract: ".concat(n().length));return{params:{conv32_down:i,conv32_1:o,conv32_2:c,conv32_3:l,conv64_down:u,conv64_1:d,conv64_2:h,conv64_3:p,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:b,conv256_1:y,conv256_2:v,conv256_down_out:x,fc:w},paramMappings:a}}(e)}};function TJ(e,t){return{...e,descriptor:t}}function OJ(e,t){return{...e,age:t}}function CJ(e,t,n){return{...e,gender:t,genderProbability:n}}function EJ(e,t){function n(n,a,r,s,i){let o=jd(e(n*a*r*r),[r,r,n,a]),c=Dd(e(a));return t.push({paramPath:"".concat(s,"/filters")},{paramPath:"".concat(s,"/").concat(i?"batch_norm_offset":"bias")}),{filters:o,bias:c}}function a(e,t,a,r){let{filters:s,bias:i}=n(e,t,a,r,!0);return{filters:s,batch_norm_offset:i}}function r(n,r,s){return{depthwise_conv:function(n,a){let r=jd(e(9*n),[3,3,n,1]),s=Dd(e(n)),i=Dd(e(n)),o=Dd(e(n)),c=Dd(e(n));return t.push({paramPath:"".concat(a,"/filters")},{paramPath:"".concat(a,"/batch_norm_scale")},{paramPath:"".concat(a,"/batch_norm_offset")},{paramPath:"".concat(a,"/batch_norm_mean")},{paramPath:"".concat(a,"/batch_norm_variance")}),{filters:r,batch_norm_scale:s,batch_norm_offset:i,batch_norm_mean:o,batch_norm_variance:c}}(n,"".concat(s,"/depthwise_conv")),pointwise_conv:a(n,r,1,"".concat(s,"/pointwise_conv"))}}return{extractMobilenetV1Params:function(){return{conv_0:a(3,32,3,"mobilenetv1/conv_0"),conv_1:r(32,64,"mobilenetv1/conv_1"),conv_2:r(64,128,"mobilenetv1/conv_2"),conv_3:r(128,128,"mobilenetv1/conv_3"),conv_4:r(128,256,"mobilenetv1/conv_4"),conv_5:r(256,256,"mobilenetv1/conv_5"),conv_6:r(256,512,"mobilenetv1/conv_6"),conv_7:r(512,512,"mobilenetv1/conv_7"),conv_8:r(512,512,"mobilenetv1/conv_8"),conv_9:r(512,512,"mobilenetv1/conv_9"),conv_10:r(512,512,"mobilenetv1/conv_10"),conv_11:r(512,512,"mobilenetv1/conv_11"),conv_12:r(512,1024,"mobilenetv1/conv_12"),conv_13:r(1024,1024,"mobilenetv1/conv_13")}},extractPredictionLayerParams:function(){return{conv_0:a(1024,256,1,"prediction_layer/conv_0"),conv_1:a(256,512,3,"prediction_layer/conv_1"),conv_2:a(512,128,1,"prediction_layer/conv_2"),conv_3:a(128,256,3,"prediction_layer/conv_3"),conv_4:a(256,128,1,"prediction_layer/conv_4"),conv_5:a(128,256,3,"prediction_layer/conv_5"),conv_6:a(256,64,1,"prediction_layer/conv_6"),conv_7:a(64,128,3,"prediction_layer/conv_7"),box_predictor_0:{box_encoding_predictor:n(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),class_predictor:n(512,9,1,"prediction_layer/box_predictor_0/class_predictor")},box_predictor_1:{box_encoding_predictor:n(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),class_predictor:n(1024,18,1,"prediction_layer/box_predictor_1/class_predictor")},box_predictor_2:{box_encoding_predictor:n(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),class_predictor:n(512,18,1,"prediction_layer/box_predictor_2/class_predictor")},box_predictor_3:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_3/class_predictor")},box_predictor_4:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_4/class_predictor")},box_predictor_5:{box_encoding_predictor:n(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),class_predictor:n(128,18,1,"prediction_layer/box_predictor_5/class_predictor")}}}}}function _J(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:a}=function(e,t){let n=UY(e,t);function a(e,t,a){return{filters:n("".concat(e,"/Conv2d_").concat(t,"_pointwise/weights"),4,"".concat(a,"/filters")),batch_norm_offset:n("".concat(e,"/Conv2d_").concat(t,"_pointwise/convolution_bn_offset"),1,"".concat(a,"/batch_norm_offset"))}}function r(e){let t="mobilenetv1/conv_".concat(e),r="MobilenetV1/Conv2d_".concat(e,"_depthwise"),s="".concat(t,"/depthwise_conv"),i="".concat(t,"/pointwise_conv");return{depthwise_conv:{filters:n("".concat(r,"/depthwise_weights"),4,"".concat(s,"/filters")),batch_norm_scale:n("".concat(r,"/BatchNorm/gamma"),1,"".concat(s,"/batch_norm_scale")),batch_norm_offset:n("".concat(r,"/BatchNorm/beta"),1,"".concat(s,"/batch_norm_offset")),batch_norm_mean:n("".concat(r,"/BatchNorm/moving_mean"),1,"".concat(s,"/batch_norm_mean")),batch_norm_variance:n("".concat(r,"/BatchNorm/moving_variance"),1,"".concat(s,"/batch_norm_variance"))},pointwise_conv:a("MobilenetV1",e,i)}}function s(e,t){return{filters:n("".concat(e,"/weights"),4,"".concat(t,"/filters")),bias:n("".concat(e,"/biases"),1,"".concat(t,"/bias"))}}function i(e){return{box_encoding_predictor:s("Prediction/BoxPredictor_".concat(e,"/BoxEncodingPredictor"),"prediction_layer/box_predictor_".concat(e,"/box_encoding_predictor")),class_predictor:s("Prediction/BoxPredictor_".concat(e,"/ClassPredictor"),"prediction_layer/box_predictor_".concat(e,"/class_predictor"))}}return{extractMobilenetV1Params:function(){return{conv_0:a("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:r(1),conv_2:r(2),conv_3:r(3),conv_4:r(4),conv_5:r(5),conv_6:r(6),conv_7:r(7),conv_8:r(8),conv_9:r(9),conv_10:r(10),conv_11:r(11),conv_12:r(12),conv_13:r(13)}},extractPredictionLayerParams:function(){return{conv_0:a("Prediction",0,"prediction_layer/conv_0"),conv_1:a("Prediction",1,"prediction_layer/conv_1"),conv_2:a("Prediction",2,"prediction_layer/conv_2"),conv_3:a("Prediction",3,"prediction_layer/conv_3"),conv_4:a("Prediction",4,"prediction_layer/conv_4"),conv_5:a("Prediction",5,"prediction_layer/conv_5"),conv_6:a("Prediction",6,"prediction_layer/conv_6"),conv_7:a("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:i(0),box_predictor_1:i(1),box_predictor_2:i(2),box_predictor_3:i(3),box_predictor_4:i(4),box_predictor_5:i(5)}}}}(e,t),r=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!OZ(r))throw new Error("expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ".concat(r));let s={mobilenetv1:n(),prediction_layer:a(),output_layer:{extra_dim:r}};return jY(e,t),{params:s,paramMappings:t}}function AJ(e,t,n){return eo(()=>{let a=xc(e,t.filters,n,"same");return a=fo(a,t.batch_norm_offset),mc(a,0,6)})}function RJ(e,t){return eo(()=>{let n,a=AJ(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((e,t)=>{let r=t+1,s=function(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}(r);a=function(e,t,n){return eo(()=>{let a=Dc(e,t.filters,n,"same");return a=sc(a,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,.0010000000474974513),mc(a,0,6)})}(a,e.depthwise_conv,s),a=AJ(a,e.pointwise_conv,[1,1]),11===r&&(n=a)}),null===n)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:a,conv11:n}})}function DJ(e,t,n){let a=e.arraySync(),r=Math.min(a[t][0],a[t][2]),s=Math.min(a[t][1],a[t][3]),i=Math.max(a[t][0],a[t][2]),o=Math.max(a[t][1],a[t][3]),c=Math.min(a[n][0],a[n][2]),l=Math.min(a[n][1],a[n][3]),u=Math.max(a[n][0],a[n][2]),d=Math.max(a[n][1],a[n][3]),h=(i-r)*(o-s),p=(u-c)*(d-l);if(h<=0||p<=0)return 0;let f=Math.max(r,c),m=Math.max(s,l),g=Math.min(i,u),b=Math.min(o,d),y=Math.max(g-f,0)*Math.max(b-m,0);return y/(h+p-y)}function FJ(e,t){let{sizes:n,centers:a}=function(e){let t=Xd(eh(e,[1,0])),n=[Vl(t[2],t[0]),Vl(t[3],t[1])];return{sizes:n,centers:[fo(t[0],go(n[0],2)),fo(t[1],go(n[1],2))]}}(e),r=Xd(eh(t,[1,0])),s=go(bo(pl(go(r[2],5)),n[0]),2),i=fo(bo(go(r[0],10),n[0]),a[0]),o=go(bo(pl(go(r[3],5)),n[1]),2),c=fo(bo(go(r[1],10),n[1]),a[1]);return eh(Ed([Vl(i,s),Vl(c,o),fo(i,s),fo(c,o)]),[1,0])}function MJ(e,t){return eo(()=>{let n=e.shape[0];return{boxPredictionEncoding:Xo(MY(e,t.box_encoding_predictor),[n,-1,1,4]),classPrediction:Xo(MY(e,t.class_predictor),[n,-1,3])}})}var jJ=class{constructor(){let{minConfidence:e,maxResults:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,"number"!=typeof this._minConfidence||this._minConfidence<=0||this._minConfidence>=1)throw new Error("".concat(this._name," - expected minConfidence to be a number between 0 and 1"));if("number"!=typeof this._maxResults)throw new Error("".concat(this._name," - expected maxResults to be a number"))}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},zJ=class extends AY{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return eo(()=>{let n=Vi(e.toBatchTensor(512,!1),"float32"),a=RJ(Vl(go(n,127.5),1),t.mobilenetv1),{boxPredictions:r,classPredictions:s}=function(e,t,n){return eo(()=>{let a=AJ(e,n.conv_0,[1,1]),r=AJ(a,n.conv_1,[2,2]),s=AJ(r,n.conv_2,[1,1]),i=AJ(s,n.conv_3,[2,2]),o=AJ(i,n.conv_4,[1,1]),c=AJ(o,n.conv_5,[2,2]),l=AJ(c,n.conv_6,[1,1]),u=AJ(l,n.conv_7,[2,2]),d=MJ(t,n.box_predictor_0),h=MJ(e,n.box_predictor_1),p=MJ(r,n.box_predictor_2),f=MJ(i,n.box_predictor_3),m=MJ(c,n.box_predictor_4),g=MJ(u,n.box_predictor_5);return{boxPredictions:Jo([d.boxPredictionEncoding,h.boxPredictionEncoding,p.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),classPredictions:Jo([d.classPrediction,h.classPrediction,p.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1)}})}(a.out,a.conv11,t.prediction_layer);return function(e,t,n){return eo(()=>{let a=e.shape[0],r=FJ(Xo(gl(n.extra_dim,[a,1,1]),[-1,4]),Xo(e,[-1,4]));r=Xo(r,[a,r.shape[0]/a,4]);let s=$o(ec(t,[0,0,1],[-1,-1,-1])),i=ec(s,[0,0,0],[-1,-1,1]);return i=Xo(i,[a,i.shape[1]]),{boxes:Xd(r),scores:Xd(i)}})}(r,s,t.output_layer)})}async forward(e){return this.forwardInput(await IY(e))}async locateFaces(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{maxResults:n,minConfidence:a}=new jJ(t),r=await IY(e),{boxes:s,scores:i}=this.forwardInput(r),o=s[0],c=i[0];for(let b=1;b<s.length;b++)s[b].dispose(),i[b].dispose();let l=Array.from(c.dataSync()),u=function(e,t,n,a,r){let s=e.shape[0],i=Math.min(n,s),o=t.map((e,t)=>({score:e,boxIndex:t})).filter(e=>e.score>r).sort((e,t)=>t.score-e.score),c=e=>e<=a?1:0,l=[];return o.forEach(t=>{if(l.length>=i)return;let n=t.score;for(let a=l.length-1;a>=0;--a){let n=DJ(e,t.boxIndex,l[a]);if(0!==n&&(t.score*=c(n),t.score<=r))break}n===t.score&&l.push(t.boxIndex)}),l}(o,l,n,.5,a),d=r.getReshapedInputDimensions(0),h=r.inputSize,p=h/d.width,f=h/d.height,m=o.arraySync(),g=u.map(e=>{let[t,n]=[Math.max(0,m[e][0]),Math.min(1,m[e][2])].map(e=>e*f),[a,s]=[Math.max(0,m[e][1]),Math.min(1,m[e][3])].map(e=>e*p);return new UZ(l[e],new KZ(a,t,s-a,n-t),{height:r.getInputHeight(0),width:r.getInputWidth(0)})});return o.dispose(),c.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return _J(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:a}=VY(e),{extractMobilenetV1Params:r,extractPredictionLayerParams:s}=EJ(n,t),i=r(),o=s(),c={extra_dim:Md(n(20472),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),0!==a().length)throw new Error("weights remaing after extract: ".concat(a().length));return{params:{mobilenetv1:i,prediction_layer:o,output_layer:c},paramMappings:t}}(e)}};var LJ=[new LZ(.738768,.874946),new LZ(2.42204,2.65704),new LZ(4.30971,7.04493),new LZ(10.246,4.59428),new LZ(12.6868,11.8741)],PJ=[new LZ(1.603231,2.094468),new LZ(6.041143,7.080126),new LZ(2.882459,3.518061),new LZ(4.266906,5.178857),new LZ(9.041765,10.66308)],BJ=[117.001,114.697,97.404],WJ=e=>"number"==typeof e;function UJ(e){return eo(()=>{let t=bo(e,il(.10000000149011612));return fo(nd(Vl(e,t)),t)})}function VJ(e,t){return eo(()=>{let n=bu(e,[[0,0],[1,1],[1,1],[0,0]]);return n=xc(n,t.conv.filters,[1,1],"valid"),n=Vl(n,t.bn.sub),n=bo(n,t.bn.truediv),n=fo(n,t.conv.bias),UJ(n)})}function GJ(e,t){return eo(()=>{let n=bu(e,[[0,0],[1,1],[1,1],[0,0]]);return n=hd(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=fo(n,t.bias),UJ(n)})}function HJ(e,t){let n=zY(e,t);let a=BY(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:function(a,r,s){return{conv:n(a,r,3,"".concat(s,"/conv")),bn:function(n,a){let r=Dd(e(n)),s=Dd(e(n));return t.push({paramPath:"".concat(a,"/sub")},{paramPath:"".concat(a,"/truediv")}),{sub:r,truediv:s}}(r,"".concat(s,"/bn"))}},extractSeparableConvParams:a}}function qJ(e,t){let n=UY(e,t);function a(e){return{filters:n("".concat(e,"/filters"),4),bias:n("".concat(e,"/bias"),1)}}return{extractConvParams:a,extractConvWithBatchNormParams:function(e){return{conv:a("".concat(e,"/conv")),bn:function(e){return{sub:n("".concat(e,"/sub"),1),truediv:n("".concat(e,"/truediv"),1)}}("".concat(e,"/bn"))}},extractSeparableConvParams:WY(n)}}var KJ=class{constructor(){let{inputSize:e,scoreThreshold:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,"number"!=typeof this._inputSize||this._inputSize%32!==0)throw new Error("".concat(this._name," - expected inputSize to be a number divisible by 32"));if("number"!=typeof this._scoreThreshold||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error("".concat(this._name," - expected scoreThreshold to be a number between 0 and 1"))}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},XJ=class extends AY{constructor(e){super("TinyYolov2"),function(e){if(!e)throw new Error("invalid config: ".concat(e));if("boolean"!=typeof e.withSeparableConvs)throw new Error("config.withSeparableConvs has to be a boolean, have: ".concat(e.withSeparableConvs));if(!WJ(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error("config.iouThreshold has to be a number between [0, 1], have: ".concat(e.iouThreshold));if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(e=>"string"==typeof e))throw new Error("config.classes has to be an array class names: string[], have: ".concat(JSON.stringify(e.classes)));if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(e=>e||{}).every(e=>WJ(e.x)&&WJ(e.y)))throw new Error("config.anchors has to be an array of { x: number, y: number }, have: ".concat(JSON.stringify(e.anchors)));if(e.meanRgb&&(!Array.isArray(e.meanRgb)||3!==e.meanRgb.length||!e.meanRgb.every(WJ)))throw new Error("config.meanRgb has to be an array of shape [number, number, number], have: ".concat(JSON.stringify(e.meanRgb)))}(e),this._config=e}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(e,t){let n=VJ(e,t.conv0);return n=$l(n,[2,2],[2,2],"same"),n=VJ(n,t.conv1),n=$l(n,[2,2],[2,2],"same"),n=VJ(n,t.conv2),n=$l(n,[2,2],[2,2],"same"),n=VJ(n,t.conv3),n=$l(n,[2,2],[2,2],"same"),n=VJ(n,t.conv4),n=$l(n,[2,2],[2,2],"same"),n=VJ(n,t.conv5),n=$l(n,[2,2],[1,1],"same"),n=VJ(n,t.conv6),n=VJ(n,t.conv7),MY(n,t.conv8,"valid",!1)}runMobilenet(e,t){let n=this.config.isFirstLayerConv2d?UJ(MY(e,t.conv0,"valid",!1)):GJ(e,t.conv0);return n=$l(n,[2,2],[2,2],"same"),n=GJ(n,t.conv1),n=$l(n,[2,2],[2,2],"same"),n=GJ(n,t.conv2),n=$l(n,[2,2],[2,2],"same"),n=GJ(n,t.conv3),n=$l(n,[2,2],[2,2],"same"),n=GJ(n,t.conv4),n=$l(n,[2,2],[2,2],"same"),n=GJ(n,t.conv5),n=$l(n,[2,2],[1,1],"same"),n=t.conv6?GJ(n,t.conv6):n,n=t.conv7?GJ(n,t.conv7):n,MY(n,t.conv8,"valid",!1)}forwardInput(e,t){let{params:n}=this;if(!n)throw new Error("TinyYolov2 - load model before inference");return eo(()=>{let a=Vi(e.toBatchTensor(t,!1),"float32");return a=this.config.meanRgb?GZ(a,this.config.meanRgb):a,a=a.div(255),this.config.withSeparableConvs?this.runMobilenet(a,n):this.runTinyYolov2(a,n)})}async forward(e,t){return this.forwardInput(await IY(e),t)}async detect(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{inputSize:n,scoreThreshold:a}=new KJ(t),r=await IY(e),s=await this.forwardInput(r,n),i=eo(()=>Xd(s)[0].expandDims()),o={width:r.getInputWidth(0),height:r.getInputHeight(0)},c=await this.extractBoxes(i,r.getReshapedInputDimensions(0),a);s.dispose(),i.dispose();let l=c.map(e=>e.box),u=c.map(e=>e.score),d=c.map(e=>e.classScore),h=c.map(e=>this.config.classes[e.label]);return function(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=t.map((e,t)=>({score:e,boxIndex:t})).sort((e,t)=>e.score-t.score).map(e=>e.boxIndex),s=[];for(;r.length>0;){let t=r.pop();s.push(t);let i=r,o=[];for(let n=0;n<i.length;n++){let r=i[n],s=e[t],c=e[r];o.push(VZ(s,c,a))}r=r.filter((e,t)=>o[t]<=n)}return s}(l.map(e=>e.rescale(n)),u,this.config.iouThreshold,!0).map(e=>new WZ(u[e],d[e],h[e],l[e],o))}getDefaultModelName(){return""}extractParamsFromWeightMap(e){return function(e,t){let n,a=[],{extractConvParams:r,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}=qJ(e,a);if(t.withSeparableConvs){let e=t.filterSizes&&t.filterSizes.length||9;n={conv0:t.isFirstLayerConv2d?r("conv0"):i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:e>7?i("conv6"):void 0,conv7:e>8?i("conv7"):void 0,conv8:r("conv8")}}else n={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:r("conv8")};return jY(e,a),{params:n,paramMappings:a}}(e,this.config)}extractParams(e){let t=this.config.filterSizes||XJ.DEFAULT_FILTER_SIZES,n=t?t.length:void 0;if(7!==n&&8!==n&&9!==n)throw new Error("TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ".concat(n," filterSizes in config"));return function(e,t,n,a){let r,{extractWeights:s,getRemainingWeights:i}=VY(e),o=[],{extractConvParams:c,extractConvWithBatchNormParams:l,extractSeparableConvParams:u}=HJ(s,o);if(t.withSeparableConvs){let[e,s,i,o,l,d,h,p,f]=a;r={conv0:t.isFirstLayerConv2d?c(e,s,3,"conv0"):u(e,s,"conv0"),conv1:u(s,i,"conv1"),conv2:u(i,o,"conv2"),conv3:u(o,l,"conv3"),conv4:u(l,d,"conv4"),conv5:u(d,h,"conv5"),conv6:p?u(h,p,"conv6"):void 0,conv7:f?u(p,f,"conv7"):void 0,conv8:c(f||p||h,5*n,1,"conv8")}}else{let[e,t,s,i,o,u,d,h,p]=a;r={conv0:l(e,t,"conv0"),conv1:l(t,s,"conv1"),conv2:l(s,i,"conv2"),conv3:l(i,o,"conv3"),conv4:l(o,u,"conv4"),conv5:l(u,d,"conv5"),conv6:l(d,h,"conv6"),conv7:l(h,p,"conv7"),conv8:c(p,5*n,1,"conv8")}}if(0!==i().length)throw new Error("weights remaing after extract: ".concat(i().length));return{params:r,paramMappings:o}}(e,this.config,this.boxEncodingSize,t)}async extractBoxes(e,t,n){let{width:a,height:r}=t,s=Math.max(a,r),i=s/a,o=s/r,c=e.shape[1],l=this.config.anchors.length,[u,d,h]=eo(()=>{let t=e.reshape([c,c,l,this.boxEncodingSize]);return[t.slice([0,0,0,0],[c,c,l,4]),t.slice([0,0,0,4],[c,c,l,1]),this.withClassScores?wd(t.slice([0,0,0,5],[c,c,l,this.config.classes.length]),3):il(0)]}),p=[],f=await d.array(),m=await u.array();for(let g=0;g<c;g++)for(let e=0;e<c;e++)for(let t=0;t<l;t++){let a=HZ(f[g][e][t][0]);if(!n||a>n){let n=(e+HZ(m[g][e][t][0]))/c*i,r=(g+HZ(m[g][e][t][1]))/c*o,s=Math.exp(m[g][e][t][2])*this.config.anchors[t].x/c*i,l=Math.exp(m[g][e][t][3])*this.config.anchors[t].y/c*o,u=n-s/2,d=r-l/2,f={row:g,col:e,anchor:t},{classScore:b,label:y}=this.withClassScores?await this.extractPredictedClass(h,f):{classScore:1,label:0};p.push({box:new BZ(u,d,u+s,d+l),score:a,classScore:a*b,label:y,...f})}}return u.dispose(),d.dispose(),h.dispose(),p}async extractPredictedClass(e,t){let{row:n,col:a,anchor:r}=t,s=await e.array();return Array(this.config.classes.length).fill(0).map((e,t)=>s[n][a][r][t]).map((e,t)=>({classScore:e,label:t})).reduce((e,t)=>e.classScore>t.classScore?e:t)}},ZJ=XJ;ZJ.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var YJ=class extends ZJ{constructor(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];super({withSeparableConvs:e,iouThreshold:.4,classes:["face"],...e?{anchors:PJ,meanRgb:BJ}:{anchors:LJ,withClassScores:!0}})}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(e=>new UZ(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?"tiny_yolov2_separable_conv_model":"tiny_yolov2_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}};var JJ=class extends KJ{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},QJ=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function $J(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:e=>{let{alignedRect:t}=e;return t},s=e.map(e=>nJ(e)?r(e):e.detection),i=a||(t instanceof os?await NY(t,s):await SY(t,s)),o=await n(i);return i.forEach(e=>e instanceof os&&e.dispose()),o}async function eQ(e,t,n,a,r){return $J([e],t,async e=>n(e[0]),a,r)}var tQ=[new LZ(1.603231,2.094468),new LZ(6.041143,7.080126),new LZ(2.882459,3.518061),new LZ(4.266906,5.178857),new LZ(9.041765,10.66308)],nQ=[117.001,114.697,97.404],aQ=class extends ZJ{constructor(){super({withSeparableConvs:!0,iouThreshold:.4,classes:["face"],anchors:tQ,meanRgb:nQ,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]})}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(e=>new UZ(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},rQ={ssdMobilenetv1:new zJ,tinyFaceDetector:new aQ,tinyYolov2:new YJ,faceLandmark68Net:new mJ,faceLandmark68TinyNet:new class extends fJ{constructor(){super("FaceLandmark68TinyNet",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new gJ)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}},faceRecognitionNet:new NJ,faceExpressionNet:new class extends YY{constructor(){super("FaceExpressionNet",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new KY)}forwardInput(e){return eo(()=>wd(this.runNet(e)))}async forward(e){return this.forwardInput(await IY(e))}async predictExpressions(e){let t=await IY(e),n=await this.forwardInput(t),a=await Promise.all(Xd(n).map(async e=>{let t=e.dataSync();return e.dispose(),t}));n.dispose();let r=a.map(e=>new QY(e));return t.isBatchInput?r:r[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}},ageGenderNet:new class extends AY{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new dJ(2);super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error("".concat(this._name," - load model before inference"));return eo(()=>{let n=e instanceof kY?this.faceFeatureExtractor.forwardInput(e):e,a=Zo(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1);return{age:XY(a,t.fc.age).as1D(),gender:XY(a,t.fc.gender)}})}forwardInput(e){return eo(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:wd(n)}})}async forward(e){return this.forwardInput(await IY(e))}async predictAgeAndGender(e){let t=await IY(e),n=await this.forwardInput(t),a=Xd(n.age),r=Xd(n.gender),s=a.map((e,t)=>({ageTensor:e,genderTensor:r[t]})),i=await Promise.all(s.map(async e=>{let{ageTensor:t,genderTensor:n}=e,a=t.dataSync()[0],r=n.dataSync()[0],s=r>.5,i=s?"male":"female",o=s?r:1-r;return t.dispose(),n.dispose(),{age:a,gender:i,genderProbability:o}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:a}=VY(e),r=LY(n,t),s=r(512,1,"fc/age"),i=r(512,2,"fc/gender");if(0!==a().length)throw new Error("weights remaing after extract: ".concat(a().length));return{paramMappings:t,params:{fc:{age:s,gender:i}}}}(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=ZY(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=UY(e,t);function a(e){return{weights:n("".concat(e,"/weights"),2),bias:n("".concat(e,"/bias"),1)}}let r={fc:{age:a("fc/age"),gender:a("fc/gender")}};return jY(e,t),{params:r,paramMappings:t}}(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}}},sQ=class extends QJ{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},iQ=class extends sQ{async run(){let e=await this.parentTask,t=await $J(e,this.input,async e=>Promise.all(e.map(e=>rQ.faceExpressionNet.predictExpressions(e))),this.extractedFaces);return e.map((e,n)=>eJ(e,t[n]))}withAgeAndGender(){return new dQ(this,this.input)}},oQ=class extends sQ{async run(){let e=await this.parentTask;if(e)return eJ(e,await eQ(e,this.input,e=>rQ.faceExpressionNet.predictExpressions(e),this.extractedFaces))}withAgeAndGender(){return new hQ(this,this.input)}},cQ=class extends iQ{withAgeAndGender(){return new pQ(this,this.input)}withFaceDescriptors(){return new gQ(this,this.input)}},lQ=class extends oQ{withAgeAndGender(){return new fQ(this,this.input)}withFaceDescriptor(){return new bQ(this,this.input)}},uQ=class extends QJ{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},dQ=class extends uQ{async run(){let e=await this.parentTask,t=await $J(e,this.input,async e=>Promise.all(e.map(e=>rQ.ageGenderNet.predictAgeAndGender(e))),this.extractedFaces);return e.map((e,n)=>{let{age:a,gender:r,genderProbability:s}=t[n];return OJ(CJ(e,r,s),a)})}withFaceExpressions(){return new iQ(this,this.input)}},hQ=class extends uQ{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:a}=await eQ(e,this.input,e=>rQ.ageGenderNet.predictAgeAndGender(e),this.extractedFaces);return OJ(CJ(e,n,a),t)}withFaceExpressions(){return new oQ(this,this.input)}},pQ=class extends dQ{withFaceExpressions(){return new cQ(this,this.input)}withFaceDescriptors(){return new gQ(this,this.input)}},fQ=class extends hQ{withFaceExpressions(){return new lQ(this,this.input)}withFaceDescriptor(){return new bQ(this,this.input)}},mQ=class extends QJ{constructor(e,t){super(),this.parentTask=e,this.input=t}},gQ=class extends mQ{async run(){let e=await this.parentTask;return(await $J(e,this.input,e=>Promise.all(e.map(e=>rQ.faceRecognitionNet.computeFaceDescriptor(e))),null,e=>e.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>TJ(e[n],t))}withFaceExpressions(){return new cQ(this,this.input)}withAgeAndGender(){return new pQ(this,this.input)}},bQ=class extends mQ{async run(){let e=await this.parentTask;if(e)return TJ(e,await eQ(e,this.input,e=>rQ.faceRecognitionNet.computeFaceDescriptor(e),null,e=>e.landmarks.align(null,{useDlibAlignment:!0})))}withFaceExpressions(){return new lQ(this,this.input)}withAgeAndGender(){return new fQ(this,this.input)}},yQ=class extends QJ{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?rQ.faceLandmark68TinyNet:rQ.faceLandmark68Net}},vQ=class extends yQ{async run(){let e=await this.parentTask,t=e.map(e=>e.detection),n=this.input instanceof os?await NY(this.input,t):await SY(this.input,t),a=await Promise.all(n.map(e=>this.landmarkNet.detectLandmarks(e)));return n.forEach(e=>e instanceof os&&e.dispose()),e.filter((e,t)=>a[t]).map((e,t)=>aJ(e,a[t]))}withFaceExpressions(){return new cQ(this,this.input)}withAgeAndGender(){return new pQ(this,this.input)}withFaceDescriptors(){return new gQ(this,this.input)}},xQ=class extends yQ{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof os?await NY(this.input,[t]):await SY(this.input,[t]),a=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(e=>e instanceof os&&e.dispose()),aJ(e,a)}withFaceExpressions(){return new lQ(this,this.input)}withAgeAndGender(){return new fQ(this,this.input)}withFaceDescriptor(){return new bQ(this,this.input)}},wQ=class extends QJ{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new jJ;super(),this.input=e,this.options=t}},kQ=class extends wQ{async run(){let e,{input:t,options:n}=this;if(n instanceof JJ)e=rQ.tinyFaceDetector.locateFaces(t,n);else if(n instanceof jJ)e=rQ.ssdMobilenetv1.locateFaces(t,n);else{if(!(n instanceof KJ))throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");e=rQ.tinyYolov2.locateFaces(t,n)}return e}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(t=>e(t.map(e=>$Z({},e)))).catch(e=>t(e))})}withFaceLandmarks(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return new vQ(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new iQ(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new dQ(this.runAndExtendWithFaceDetections(),this.input)}},IQ=class extends wQ{async run(){let e=await new kQ(this.input,this.options),t=e[0];return e.forEach(e=>{e.score>t.score&&(t=e)}),t}runAndExtendWithFaceDetection(){return new Promise(async e=>{let t=await this.run();e(t?$Z({},t):void 0)})}withFaceLandmarks(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return new xQ(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new oQ(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new hQ(this.runAndExtendWithFaceDetection(),this.input)}};function SQ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new jJ;return new IQ(e,t)}function NQ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new jJ;return new kQ(e,t)}var TQ=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.6;this._distanceThreshold=t;let n=Array.isArray(e)?e:[e];if(!n.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let a=1,r=()=>"person ".concat(a++);this._labeledDescriptors=n.map(e=>{if(e instanceof JZ)return e;if(e instanceof Float32Array)return new JZ(r(),[e]);if(e.descriptor&&e.descriptor instanceof Float32Array)return new JZ(r(),[e.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")})}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(e,t){return t.map(t=>function(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),a=Array.from(t);return Math.sqrt(n.map((e,t)=>e-a[t]).reduce((e,t)=>e+t*t,0))}(t,e)).reduce((e,t)=>e+t,0)/(t.length||1)}matchDescriptor(e){return this.labeledDescriptors.map(t=>{let{descriptors:n,label:a}=t;return new YZ(a,this.computeMeanDistance(e,n))}).reduce((e,t)=>e.distance<t.distance?e:t)}findBestMatch(e){let t=this.matchDescriptor(e);return t.distance<this._distanceThreshold?t:new YZ("unknown",t.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map(e=>e.toJSON())}}static fromJSON(e){let t=e.labeledDescriptors.map(e=>JZ.fromJSON(e));return new TQ(t,e.distanceThreshold)}};function OQ(e,t){let{width:n,height:a}=new IZ(t.width,t.height);if(n<=0||a<=0)throw new Error("resizeResults - invalid dimensions: ".concat(JSON.stringify({width:n,height:a})));if(Array.isArray(e))return e.map(e=>OQ(e,{width:n,height:a}));if(nJ(e)){let t=e.detection.forSize(n,a),r=e.unshiftedLandmarks.forSize(t.box.width,t.box.height);return aJ($Z(e,t),r)}return QZ(e)?$Z(e,e.detection.forSize(n,a)):e instanceof XZ||e instanceof UZ?e.forSize(n,a):e}}).call(this,"/index.js",n(101),"/",n(100),n(128).Buffer,n(176).setImmediate)},function(e,t){e.exports=function(){throw new Error("define cannot be used indirect")}},function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(22),c=n(4),l=n(7);const u=Object(c.b)({conv2d_:function(e,t,n,c){let u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],h=arguments.length>6?arguments[6]:void 0;const p=Object(s.a)(e,"x","conv2d","float32"),f=Object(s.a)(t,"filter","conv2d","float32");let m=p,g=!1;3===p.rank&&(g=!0,m=Object(l.a)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),i.b(4===m.rank,()=>"Error in conv2d: input must be rank 4, but got rank ".concat(m.rank,".")),i.b(4===f.rank,()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(f.rank,".")),o.a("conv2d",c,h);const b="NHWC"===u?m.shape[3]:m.shape[1];i.b(b===f.shape[2],()=>"Error in conv2d: depth of input (".concat(b,") must match ")+"input depth for filter ".concat(f.shape[2],".")),i.b(o.i(n,d),()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(d,"'"));const y={x:m,filter:f},v={strides:n,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h},x=a.a.runKernel(r.D,y,v);return g?Object(l.a)(x,[x.shape[1],x.shape[2],x.shape[3]]):x}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(15),c=n(4);const l=Object(c.b)({greaterEqual_:function(e,t){let n=Object(i.a)(e,"a","greaterEqual","string_or_numeric"),c=Object(i.a)(t,"b","greaterEqual","string_or_numeric");[n,c]=Object(s.makeTypesMatch)(n,c),Object(o.assertAndGetBroadcastShape)(n.shape,c.shape);const l={a:n,b:c};return a.a.runKernel(r.rb,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({clone_:function(e){const t={x:Object(s.a)(e,"x","clone","string_or_numeric")};return a.a.runKernel(r.tb,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({sigmoid_:function(e){const t={x:Object(s.a)(e,"x","sigmoid","float32")};return a.a.runKernel(r.Fc,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=Object(s.a)(e,"x","max"),o={x:i},c={reductionIndices:t,keepDims:n};return a.a.runKernel(r.Kb,o,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4);const c=Object(o.b)({tile_:function(e,t){const n=Object(s.a)(e,"x","tile","string_or_numeric");i.b(n.rank===t.length,()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(t,"."));const o={x:n},c={reps:t};return a.a.runKernel(r.fd,o,c)}})},function(e,t,n){"use strict";n.d(t,"b",(function(){return r})),n.d(t,"d",(function(){return i})),n.d(t,"f",(function(){return c})),n.d(t,"c",(function(){return l})),n.d(t,"e",(function(){return u})),n.d(t,"a",(function(){return d}));var a=n(0);function r(e,t){return s(e,t)}function s(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(u(e)){const r=Array.isArray(e)?[]:{};a.add(e);for(const i in e){const o=s(e[i],t,n,a);r[i]=o}return a.delete(e),e.__proto__&&(r.__proto__=e.__proto__),r}throw new Error("Can't recurse into non-iterable type: ".concat(e))}return n.set(e,r.value),r.value}function i(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c;return o(e,t)}function o(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(u(a)){const r=Array.isArray(a)?[]:{};n.add(a);for(const s in a){const a=o(e.map(e=>e[s]),t,n);r[s]=a}return n.delete(a),r}throw new Error("Can't recurse into non-iterable type: ".concat(a))}return r.value}function c(e){return null===e?null:u(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function l(e,t){const n=new Map;s(e,t,n);for(const r of Array.from(n.keys())){const e=n.get(r);if(a.Df.isPromise(e)){const t=await e;n.set(r,t)}}return s(e,t,n)}function u(e){let t=!1;if(a.be().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:a}=n(248);t=e instanceof a}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof a.gd)&&!(e instanceof Promise)&&!t)}function d(e){return null==e||(null===(t=e)||"object"!==typeof t&&"function"!==typeof t)||Array.isArray(e)||"object"===typeof e&&e instanceof a.gd||a.Df.isTypedArray(e);var t}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({log_:function(e){const t={x:Object(s.a)(e,"x","log","float32")};return a.a.runKernel(r.Eb,t)}})},function(e,t,n){"use strict";n.d(t,"b",(function(){return r})),n.d(t,"a",(function(){return s}));var a=n(19);function r(){Object(a.b)().getBool("IS_TEST")||Object(a.b)().getBool("PROD")||console.warn(...arguments)}function s(){Object(a.b)().getBool("IS_TEST")||Object(a.b)().getBool("PROD")||console.log(...arguments)}},function(e,t,n){"use strict";var a,r;n.d(t,"a",(function(){return a})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(a||(a={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(r||(r={}))},function(e,t,n){"use strict";function a(e,t,n){const a=function(e,t,n){return function(e,t,n){let a=0,r=e.length,s=0,i=!1;for(;a<r;){s=a+(r-a>>>1);const o=n(t,e[s]);o>0?a=s+1:(r=s,i=!o)}return i?a:-a-1}(e,t,n||r)}(e,t,n),s=a<0?-(a+1):a;e.splice(s,0,t)}function r(e,t){return e>t?1:e<t?-1:0}function s(e,t,n,a,r){return c(e,t,n,a,r,0)}function i(e,t,n,a,r,s){return c(e,t,n,a,r,0,!1,s,!0)}function o(e,t,n,a,r,s){return c(e,t,n,a,r,s,!0)}function c(e,t,n,r,s,i){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],c=arguments.length>7&&void 0!==arguments[7]&&arguments[7],h=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const p=[];for(let a=0;a<t.length;a++)t[a]>s&&p.push({score:t[a],boxIndex:a,suppressBeginIndex:0});p.sort(d);const f=i>0?-.5/i:0,m=[],g=[];for(;m.length<n&&p.length>0;){const t=p.pop(),{score:n,boxIndex:i,suppressBeginIndex:o}=t;if(n<s)break;let c=!1;for(let a=m.length-1;a>=o;--a){const n=l(e,i,m[a]);if(n>=r){c=!0;break}if(t.score=t.score*u(r,f,n),t.score<=s)break}t.suppressBeginIndex=m.length,c||(t.score===n?(m.push(i),g.push(t.score)):t.score>s&&a(p,t,d))}const b=m.length,y=n-b;c&&y>0&&(m.push(...new Array(y).fill(0)),g.push(...new Array(y).fill(0)));const v={selectedIndices:m};return o&&(v.selectedScores=g),h&&(v.validOutputs=b),v}function l(e,t,n){const a=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),s=Math.min(a[0],a[2]),i=Math.min(a[1],a[3]),o=Math.max(a[0],a[2]),c=Math.max(a[1],a[3]),l=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),p=(o-s)*(c-i),f=(d-l)*(h-u);if(p<=0||f<=0)return 0;const m=Math.max(s,l),g=Math.max(i,u),b=Math.min(o,d),y=Math.min(c,h),v=Math.max(b-m,0)*Math.max(y-g,0);return v/(p+f-v)}function u(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function d(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return i})),n.d(t,"c",(function(){return o}))},function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var a=n(5),r=n(3);function s(e,t,n){const s={shape:e,value:t,dtype:n};return a.a.runKernel(r.gb,{},s)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var a=n(5),r=n(9),s=n(47);function i(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if("complex64"===t){const t=i(e,"float32"),n=i(e,"float32");return Object(s.a)(t,n)}const n=Object(r.F)(Object(r.O)(e),t);return a.a.makeTensor(n,e,t)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({relu_:function(e){const t={x:Object(s.a)(e,"x","relu")};return a.a.runKernel(r.qc,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Object(s.a)(e,"x","step"),i={x:n},o={alpha:t};return a.a.runKernel(r.Wc,i,o)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4);const c=Object(o.b)({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Object(s.a)(e,"x","unstack","string_or_numeric");i.b(t>=-n.shape.length&&t<n.shape.length,()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")"));const o={value:n},c={axis:t};return a.a.runKernel(r.kd,o,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(7);var c=n(4);const l=Object(c.b)({batchNorm_:function(e,t,n,c,l,u){null==u&&(u=.001);const d=Object(s.a)(e,"x","batchNorm"),h=Object(s.a)(t,"mean","batchNorm"),p=Object(s.a)(n,"variance","batchNorm");let f,m;null!=l&&(f=Object(s.a)(l,"scale","batchNorm")),null!=c&&(m=Object(s.a)(c,"offset","batchNorm")),i.b(h.rank===p.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),i.b(null==m||h.rank===m.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),i.b(null==f||h.rank===f.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const g={x:function(e){let t;return t=0===e.rank||1===e.rank?Object(o.a)(e,[1,1,1,e.size]):2===e.rank?Object(o.a)(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Object(o.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(d),scale:f,offset:m,mean:h,variance:p},b={varianceEpsilon:u},y=a.a.runKernel(r.lb,g,b);return Object(o.a)(y,d.shape)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var a=n(2),r=n(46);function s(e,t,n){const s=Object(a.c)(e,n);return Object(r.a)(e,t,s,n)}},function(e,t,n){var a=n(239),r=n(240),s=n(241),i=n(242),o=n(243),c=n(244),l=n(245);l.alea=a,l.xor128=r,l.xorwow=s,l.xorshift7=i,l.xor4096=o,l.tychei=c,e.exports=l},function(e,t){(function(t){e.exports=t}).call(this,{})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=Object(s.a)(e,"x","mean"),o={x:i},c={axis:t,keepDims:n};return a.a.runKernel(r.Rb,o,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({real_:function(e){const t={input:Object(s.a)(e,"input","real")};return a.a.runKernel(r.nc,t)}})},function(e,t,n){"use strict";var a,r,s,i,o;n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return u})),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(a||(a={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(r||(r={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(s||(s={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(i||(i={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(o||(o={}));const c={float32:i,int32:r,bool:s,complex64:o};function l(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return c[e][t]}function u(e){return l(e,"int32")}},function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"d",(function(){return d})),n.d(t,"b",(function(){return u})),n.d(t,"e",(function(){return l})),n.d(t,"c",(function(){return c}));var a=n(9),r=n(36);class s{constructor(){this.managers={}}static getInstance(){return null==s.instance&&(s.instance=new s),s.instance}static registerManager(e,t){Object(a.b)(null!=e,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),Object(a.b)(e.length>0,()=>"scheme must not be an empty string.");const n=s.getInstance();Object(a.b)(null==n.managers[e],()=>"A model store manager is already registered for scheme '".concat(e,"'.")),n.managers[e]=t}static getManager(e){const t=s.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(s.getInstance().managers)}}function i(e){if(-1===e.indexOf("://"))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+"".concat(s.getSchemes().join(",")));return{scheme:e.split("://")[0],path:e.split("://")[1]}}async function o(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];Object(a.b)(e!==t,()=>"Old path and new path are the same: '".concat(e,"'"));const o=r.a.getLoadHandlers(e);Object(a.b)(o.length>0,()=>"Copying failed because no load handler is found for source URL ".concat(e,".")),Object(a.b)(o.length<2,()=>"Copying failed because more than one (".concat(o.length,") ")+"load handlers for source URL ".concat(e,"."));const c=o[0],l=r.a.getSaveHandlers(t);Object(a.b)(l.length>0,()=>"Copying failed because no save handler is found for destination "+"URL ".concat(t,".")),Object(a.b)(l.length<2,()=>"Copying failed because more than one (".concat(o.length,") ")+"save handlers for destination URL ".concat(t,"."));const u=l[0],d=i(e).scheme,h=i(e).path,p=d===i(e).scheme,f=await c.load();n&&p&&await s.getManager(d).removeModel(h);const m=await u.save(f);return n&&!p&&await s.getManager(d).removeModel(h),m.modelArtifactsInfo}async function c(){const e=s.getSchemes(),t={};for(const n of e){const e=await s.getManager(n).listModels();for(const a in e){t[n+"://"+a]=e[a]}}return t}async function l(e){const t=i(e);return s.getManager(t.scheme).removeModel(t.path)}async function u(e,t){return o(e,t,!1)}async function d(e,t){return o(e,t,!0)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4);const c=Object(o.b)({batchToSpaceND_:function(e,t,n){const o=Object(s.a)(e,"x","batchToSpaceND"),c=t.reduce((e,t)=>e*t);i.b(o.rank>=1+t.length,()=>"input rank is ".concat(o.rank," but should be > than blockShape.length ").concat(t.length)),i.b(n.length===t.length,()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length)),i.b(o.shape[0]%c===0,()=>"input tensor batch is ".concat(o.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(t.join(" * ")," === ").concat(c));const l={x:o},u={blockShape:t,crops:n};return a.a.runKernel(r.t,l,u)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(22),c=n(4),l=n(7);const u=Object(c.b)({depthwiseConv2d_:function(e,t,n,c){let u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],h=arguments.length>6?arguments[6]:void 0;const p=Object(s.a)(e,"x","depthwiseConv2d","float32"),f=Object(s.a)(t,"filter","depthwiseConv2d","float32");let m=p,g=!1;3===p.rank&&(g=!0,m=Object(l.a)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),i.b(4===m.rank,()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(m.rank,".")),i.b(4===f.rank,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(f.rank,"."));const b="NHWC"===u?m.shape[3]:m.shape[1];i.b(b===f.shape[2],()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(b,") must match the inChannels dimension in ")+"filter ".concat(f.shape[2],".")),o.a("depthwiseConv2d",c,h);const y={x:m,filter:f},v={strides:n,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h},x=a.a.runKernel(r.Q,y,v);return g?Object(l.a)(x,[x.shape[1],x.shape[2],x.shape[3]]):x}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(15),c=n(4);const l=Object(c.b)({equal_:function(e,t){let n=Object(i.a)(e,"a","equal","string_or_numeric"),c=Object(i.a)(t,"b","equal","string_or_numeric");[n,c]=Object(s.makeTypesMatch)(n,c),Object(o.assertAndGetBroadcastShape)(n.shape,c.shape);const l={a:n,b:c};return a.a.runKernel(r.ab,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return b}));var a=n(2),r=n(9),s=n(38),i=n(34),o=n(64),c=n(97),l=n(4),u=n(48),d=n(7),h=n(17),p=n(33),f=n(23),m=n(16);function g(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return Object(s.a)(e);if(1!==e.rank&&null===n)return g(Object(d.a)(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Object(m.a)(Object(s.a)(e),n);if(t===1/0)return Object(o.a)(Object(s.a)(e),n);if(t===-1/0)return Object(c.a)(Object(s.a)(e),n);if("euclidean"===t||2===t)return Object(p.a)(Object(m.a)(Object(u.a)(Object(s.a)(e),Object(h.a)(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return Object(o.a)(Object(m.a)(Object(s.a)(e),n[0]),n[1]-1);if(t===1/0)return Object(o.a)(Object(m.a)(Object(s.a)(e),n[1]),n[0]);if(t===-1/0)return Object(c.a)(Object(m.a)(Object(s.a)(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Object(p.a)(Object(m.a)(Object(f.a)(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}const b=Object(l.b)({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const o=g(e=Object(a.a)(e,"x","norm"),t,n);let c=o.shape;if(s){const t=Object(r.I)(n,e.shape);c=i.e(o.shape,t)}return Object(d.a)(o,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const o=Object(s.a)(e,"x","gather"),c=Object(s.a)(t,"indices","gather","int32"),l={x:o,indices:c},u={axis:n,batchDims:i};return a.a.runKernel(r.pb,l,u)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({imag_:function(e){const t={input:Object(s.a)(e,"input","imag")};return a.a.runKernel(r.ub,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({logicalNot_:function(e){const t={x:Object(s.a)(e,"x","logicalNot","bool")};return a.a.runKernel(r.Ib,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(15),c=n(11),l=n(4);const u=Object(l.b)({maximum_:function(e,t){let n=Object(i.a)(e,"a","maximum"),l=Object(i.a)(t,"b","maximum");[n,l]=Object(s.makeTypesMatch)(n,l),"bool"===n.dtype&&(n=Object(c.a)(n,"int32"),l=Object(c.a)(l,"int32")),Object(o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return a.a.runKernel(r.Qb,u)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4);const c=Object(o.b)({spaceToBatchND_:function(e,t,n){const o=Object(s.a)(e,"x","spaceToBatchND");i.b(o.rank>=1+t.length,()=>"input rank ".concat(o.rank," should be > than [blockShape] ").concat(t.length)),i.b(n.length===t.length,()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length)),i.b(o.shape.reduce((e,a,r)=>r>0&&r<=t.length?e&&(a+n[r-1][0]+n[r-1][1])%t[r-1]===0:e,!0),()=>"input spatial dimensions ".concat(o.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString()));const c={x:o},l={blockShape:t,paddings:n};return a.a.runKernel(r.Mc,c,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(2),r=n(9),s=n(4),i=n(7);const o=Object(s.b)({squeeze_:function(e,t){const n=Object(a.a)(e,"x","squeeze","string_or_numeric");return Object(i.a)(n,Object(r.Q)(n.shape,t).newShape)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(2),i=n(62),o=n(4),c=n(7);const l=Object(o.b)({broadcastTo_:function(e,t){let n=Object(s.a)(e,"broadcastTo","x");const o=n.shape;if(t.some(e=>!(e>0)||e%1!==0))throw new Error("broadcastTo(): Invalid broadcast shape [".concat(t,"]."));if(t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Object(c.a)(n,e)}const l=n.shape,u=Array.from(t);for(let a=t.length-1;a>=0;a--)if(l[a]===t[a])u[a]=1;else if(1!==n.shape[a])throw new Error("broadcastTo(): [".concat(o,"] cannot be broadcast to [").concat(t,"]."));if(0===u.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length)return Object(i.a)(n);const d={x:n},h={reps:u};return a.a.runKernel(r.fd,d,h)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));const a={};function r(e){return a[e]}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const o=Object(s.a)(e,"x","cumprod"),c={x:o},l={axis:t,exclusive:n,reverse:i};return a.a.runKernel(r.M,c,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=Object(s.a)(e,"x","min"),o={x:i},c={axis:t,keepDims:n};return a.a.runKernel(r.Sb,o,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(9),i=n(4);const o=Object(i.b)({ifft_:function(e){Object(s.b)("complex64"===e.dtype,()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(e.dtype,"."));const t={input:e};return a.a.runKernel(r.sb,t)}})},function(e,t,n){"use strict";(function(e,a){let r;function s(){if(null==r){let t;if("undefined"!==typeof window)t=window;else if("undefined"!==typeof e)t=e;else if("undefined"!==typeof a)t=a;else{if("undefined"===typeof self)throw new Error("Could not find a global object");t=self}r=t}return r}function i(e,t){const n=function(){const e=s();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}n.d(t,"b",(function(){return s})),n.d(t,"a",(function(){return i}))}).call(this,n(100),n(101))},function(e,t){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(a){"object"===typeof window&&(n=window)}e.exports=n},function(e,t){var n,a,r=e.exports={};function s(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function o(e){if(n===setTimeout)return setTimeout(e,0);if((n===s||!n)&&setTimeout)return n=setTimeout,setTimeout(e,0);try{return n(e,0)}catch(t){try{return n.call(null,e,0)}catch(t){return n.call(this,e,0)}}}!function(){try{n="function"===typeof setTimeout?setTimeout:s}catch(e){n=s}try{a="function"===typeof clearTimeout?clearTimeout:i}catch(e){a=i}}();var c,l=[],u=!1,d=-1;function h(){u&&c&&(u=!1,c.length?l=c.concat(l):d=-1,l.length&&p())}function p(){if(!u){var e=o(h);u=!0;for(var t=l.length;t;){for(c=l,l=[];++d<t;)c&&c[d].run();d=-1,t=l.length}c=null,u=!1,function(e){if(a===clearTimeout)return clearTimeout(e);if((a===i||!a)&&clearTimeout)return a=clearTimeout,clearTimeout(e);try{a(e)}catch(t){try{return a.call(null,e)}catch(t){return a.call(this,e)}}}(e)}}function f(e,t){this.fun=e,this.array=t}function m(){}r.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];l.push(new f(e,t)),1!==l.length||u||o(p)},f.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={},r.on=m,r.addListener=m,r.once=m,r.off=m,r.removeListener=m,r.removeAllListeners=m,r.emit=m,r.prependListener=m,r.prependOnceListener=m,r.listeners=function(e){return[]},r.binding=function(e){throw new Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(e){throw new Error("process.chdir is not supported")},r.umask=function(){return 0}},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,t,n){"use strict";n.d(t,"c",(function(){return r})),n.d(t,"b",(function(){return s})),n.d(t,"a",(function(){return i}));var a=n(9);function r(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(t.shape,", shape: ").concat(e)+", sliceDim: ".concat(a,", and batchDim: ").concat(r,".");if(n.rank<r)throw new Error(s+" update.rank < ".concat(r,". "));if(e.length<a+(n.rank-r))throw new Error(s+" Output shape length < ".concat(a+(n.rank-r)));if(n.rank!==r+e.length-a)throw new Error(s+" update.rank != ".concat(r+e.length-a));for(let i=0;i<r;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+" updates.shape[".concat(i,"] (").concat(n.shape[i],") != indices.shape[").concat(i,"] (").concat(t.shape[i],")."));for(let i=0;i<n.rank-r;++i)if(n.shape[i+r]!==e[i+a])throw new Error(s+" updates.shape[".concat(i+r,"] (").concat(n.shape[i+r],") != shape[").concat(i+r,"] (").concat(e[i+r],")"))}function s(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}r(n,t,e)}function i(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,i=n.length;let o=1;for(let a=s;a<i;++a)o*=n[a];const c=s<1?1:s;return{sliceRank:s,numUpdates:Object(a.O)(t.shape)/c,sliceSize:o,strides:[...Object(a.j)(n.slice(0,s)),1],outputSize:Object(a.O)(n)}}},function(e,t,n){"use strict";n.r(t),n.d(t,"assertParamsValid",(function(){return r})),n.d(t,"maskToAxes",(function(){return s})),n.d(t,"computeOutShape",(function(){return i})),n.d(t,"stridesWithElidedDims",(function(){return o})),n.d(t,"getNormalizedAxes",(function(){return u})),n.d(t,"startIndicesWithElidedDims",(function(){return d})),n.d(t,"stopIndicesWithElidedDims",(function(){return h})),n.d(t,"stridesForAxis",(function(){return p})),n.d(t,"startForAxis",(function(){return f})),n.d(t,"stopForAxis",(function(){return m})),n.d(t,"isSliceContinous",(function(){return g})),n.d(t,"computeFlatOffset",(function(){return b})),n.d(t,"parseSliceParams",(function(){return y})),n.d(t,"sliceInfo",(function(){return v}));var a=n(9);function r(e,t,n){const r=e.shape.length;a.b(r===t.length,()=>"Error in slice".concat(r,"D: Length of begin ").concat(t," must ")+"match the rank of the array (".concat(r,").")),a.b(r===n.length,()=>"Error in slice".concat(r,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(r,")."));for(let s=0;s<r;++s)a.b(t[s]+n[s]<=e.shape[s],()=>"Error in slice".concat(r,"D: begin[").concat(s,"] + size[").concat(s,"] ")+"(".concat(t[s]+n[s],") would overflow input.shape[").concat(s,"] (").concat(e.shape[s],")"))}function s(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function i(e,t,n){const a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function o(e,t,n,a){const r=[...e];for(let s=r.length;s<a.length;s++)r.push(1);for(let s=0;s<n;s++)0===s?r[t]=1:(r.splice(t,0,1),r.pop());return r}function c(e,t,n){return n<=e?n:n-(t-1)}function l(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function u(e,t,n,a,r,s,i,c,l){const u=e.length;let g=new Array(u),b=new Array(u),y=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;g=d(i,l,u,a,e),b=h(c,l,u,r,e),y=o(s,l,u,e)}else for(let o=0;o<u;o++)g[o]=f(i,a,s,e,o,l),b[o]=m(c,r,s,e,o,l),y[o]=p(s,o,l);return{begin:g,end:b,strides:y}}function d(e,t,n,a,r){const s=[...r],i=l(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{const r=c(t,n,o);let i=a[r];e&1<<r&&(i=0),s[o]=i}return s}function h(e,t,n,r,s){const i=[...s],o=l(n,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const s=c(t,n,a);let o=r[s];e&1<<s&&(o=Number.MAX_SAFE_INTEGER),i[a]=o}for(let c=0;c<i.length;c++){const e=s[c];i[c]<0&&(i[c]+=e),i[c]=a.i(0,i[c],s[c])}return i}function p(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function f(e,t,n,r,s,i){let o=t[s];const c=n[s]||1;(e&1<<s||i&1<<s||null==o)&&(o=c>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=a.i(0,o,l-1),o}function m(e,t,n,r,s,i){let o=t[s];const c=n[s]||1;(e&1<<s||i&1<<s||null==o)&&(o=c>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=c>0?a.i(0,o,l):a.i(-1,o,l-1),o}function g(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function b(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function y(e,t,n){let r;const s=e.shape.length;let i;return r="number"===typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(e=>{a.b(-1!==e,()=>"slice() does not support negative begin indexing.")}),i=null==n?new Array(s).fill(-1):"number"===typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,i=i.map((t,n)=>t>=0?t:(a.b(-1===t,()=>"Negative size values should be exactly -1 but got "+"".concat(t," for the slice() size at index ").concat(n,".")),e.shape[n]-r[n])),[r,i]}function v(e,t,n,a,r,s,i,o,c){let l;if(null==a?(l=new Array(t.length),l.fill(1)):l=a,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:c};for(let y=0;y<d.dims;y++)u&&0!==(1<<y&o)&&d.numAddAxisAfterEllipsis++,1<<y&i&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[a]),null!=e.end&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}(d,h);let p=!0,f=!0,m=!0;const g=[],b=[];for(let y=0;y<e.length;++y){if(0===h.strides[y])throw Error("strides[".concat(y,"] must be non-zero"));const t=!!(h.shrinkAxisMask&1<<y),n=e[y];if(-1===n){g.push(t?1:-1);continue}const a=[h.beginMask&1<<y,h.endMask&1<<y],r=[h.strides[y]>0?0:-1,h.strides[y]>0?n:n-1];if(t&&h.strides[y]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[y];const s=!!(h.beginMask&1<<y&&h.endMask&1<<y);if(h.beginValid&&h.endValid){if(t){const e=h.begin[y]<0?n+h.begin[y]:h.begin[y];if(h.begin[y]=e,h.end[y]=h.begin[y]+1,e<0||e>=n)throw Error("slice index ".concat(h.begin[y]," of dimension ").concat(y," out of bounds."))}else h.begin[y]=x(h.begin[y],0,h.strides[y],n,a,r),h.end[y]=x(h.end[y],1,h.strides[y],n,a,r);const e=1===h.strides[y]&&0===h.begin[y]&&h.end[y]===n;p=p&&e,f=f&&(0===y&&1===h.strides[y]||e)}else p=p&&1===h.strides[y]&&s,f=f&&(0===y&&1===h.strides[y]||s);let i,o=!1;if(h.beginValid&&h.endValid?(i=h.end[y]-h.begin[y],o=!0):t?(i=1,o=!0):s&&n>=0&&(i=h.strides[y]<0?-n:n,o=!0),o){let e;e=0===i||i<0!==h.strides[y]<0?0:Math.trunc(i/h.strides[y])+(i%h.strides[y]!==0?1:0),g.push(e)}else g.push(-1)}for(let y=0;y<h.finalShapeGatherIndices.length;++y){const e=h.finalShapeGatherIndices[y];e>=0?b.push(g[e]):-2===e&&b.push(1)}return{finalShapeSparse:b.filter((e,t)=>-2!==h.finalShapeGatherIndices[t]),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function x(e,t,n,a,r,s){if(r[t])return n>0?s[t]:s[t+1&1];{const t=e<0?a+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(11),c=n(22),l=n(4),u=n(7);const d=Object(l.b)({avgPool_:function(e,t,n,l,d){const h=Object(s.a)(e,"x","avgPool","float32");i.b(c.i(n,1),()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"));let p=h,f=!1;3===h.rank&&(f=!0,p=Object(u.a)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),i.b(4===p.rank,()=>"Error in avgPool: x must be rank 4 but got rank ".concat(p.rank,".")),c.a("avgPool",l,d);const m={x:p},g={filterSize:t,strides:n,pad:l,dimRoundingMode:d};let b=a.a.runKernel(r.o,m,g);return b=Object(o.a)(b,h.dtype),f?Object(u.a)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({cos_:function(e){const t={x:Object(s.a)(e,"x","cos","float32")};return a.a.runKernel(r.J,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const o=Object(s.a)(e,"x","cumsum"),c={x:o},l={axis:t,exclusive:n,reverse:i};return a.a.runKernel(r.N,c,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(4);const c=Object(o.b)({floorDiv_:function(e,t){let n=Object(i.a)(e,"a","floorDiv"),o=Object(i.a)(t,"b","floorDiv");[n,o]=Object(s.makeTypesMatch)(n,o);const c={a:n,b:o};return a.a.runKernel(r.jb,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({elu_:function(e){const t={x:Object(s.a)(e,"x","elu","float32")};return a.a.runKernel(r.Y,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({floor_:function(e){const t={x:Object(s.a)(e,"x","floor","float32")};return a.a.runKernel(r.ib,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n=Object(s.a)(e,"x","leakyRelu"),i={x:n},o={alpha:t};return a.a.runKernel(r.Ab,i,o)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(15),c=n(4);const l=Object(c.b)({less_:function(e,t){let n=Object(i.a)(e,"a","less","string_or_numeric"),c=Object(i.a)(t,"b","less","string_or_numeric");[n,c]=Object(s.makeTypesMatch)(n,c),Object(o.assertAndGetBroadcastShape)(n.shape,c.shape);const l={a:n,b:c};return a.a.runKernel(r.Bb,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return f}));var a=n(2),r=n(9),s=n(12),i=n(34),o=n(35),c=n(67),l=n(64),u=n(4),d=n(7),h=n(13),p=n(16);const f=Object(u.b)({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const u=Object(a.a)(e,"x","logSumExp"),f=Object(r.I)(t,u.shape),m=Object(l.a)(u,f,!0),g=Object(h.a)(u,m),b=Object(o.a)(g),y=Object(p.a)(b,f),v=Object(c.a)(y),x=Object(s.a)(Object(d.a)(m,v.shape),v);if(n){const e=Object(i.e)(x.shape,f);return Object(d.a)(x,e)}return x}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(15),o=n(4);const c=Object(o.b)({logicalOr_:function(e,t){const n=Object(s.a)(e,"a","logicalOr","bool"),o=Object(s.a)(t,"b","logicalOr","bool");Object(i.assertAndGetBroadcastShape)(n.shape,o.shape);const c={a:n,b:o};return a.a.runKernel(r.Jb,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(22),c=n(4),l=n(7);const u=Object(c.b)({maxPool_:function(e,t,n,c,u){const d=Object(s.a)(e,"x","maxPool");let h=d,p=!1;3===d.rank&&(p=!0,h=Object(l.a)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),i.b(4===h.rank,()=>"Error in maxPool: input must be rank 4 but got rank ".concat(h.rank,".")),i.b(o.i(n,1),()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")),o.a("maxPool",c,u);const f={x:h},m={filterSize:t,strides:n,pad:c,dimRoundingMode:u},g=a.a.runKernel(r.Lb,f,m);return p?Object(l.a)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(15),c=n(11),l=n(4);const u=Object(l.b)({minimum_:function(e,t){let n=Object(i.a)(e,"a","minimum"),l=Object(i.a)(t,"b","minimum");[n,l]=Object(s.makeTypesMatch)(n,l),"bool"===n.dtype&&(n=Object(c.a)(n,"int32"),l=Object(c.a)(l,"int32")),Object(o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return a.a.runKernel(r.Tb,u)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(15),c=n(4);const l=Object(c.b)({notEqual_:function(e,t){let n=Object(i.a)(e,"a","notEqual","string_or_numeric"),c=Object(i.a)(t,"b","notEqual","string_or_numeric");[n,c]=Object(s.makeTypesMatch)(n,c),Object(o.assertAndGetBroadcastShape)(n.shape,c.shape);const l={a:n,b:c};return a.a.runKernel(r.cc,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({prelu_:function(e,t){const n={x:Object(s.a)(e,"x","prelu"),alpha:Object(s.a)(t,"alpha","prelu")};return a.a.runKernel(r.ic,n)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({relu6_:function(e){const t={x:Object(s.a)(e,"x","relu6")};return a.a.runKernel(r.rc,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(9),i=n(4);const o=Object(i.b)({fft_:function(e){Object(s.b)("complex64"===e.dtype,()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(e.dtype,"."));const t={input:e};return a.a.runKernel(r.fb,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return m}));var a=n(9),r=n(47),s=n(29),i=n(89),o=n(4),c=n(81),l=n(7),u=n(26),d=n(54),h=n(72),p=n(18),f=n(120);const m=Object(o.b)({rfft_:function(e,t){Object(a.b)("float32"===e.dtype,()=>"The dtype for rfft() must be real value but got ".concat(e.dtype));let n=e.shape[e.shape.length-1];const o=e.size/n;let m;if(null!=t&&t<n){const a=e.shape.map(e=>0),r=e.shape.map(e=>e);r[e.shape.length-1]=t,m=Object(u.a)(e,a,r),n=t}else if(null!=t&&t>n){const a=e.shape.map(e=>e);a[e.shape.length-1]=t-n,m=Object(s.a)([e,Object(h.a)(a)],e.shape.length-1),n=t}else m=e;const g=Object(p.a)(m),b=Object(l.a)(Object(r.a)(m,g),[o,n]),y=Object(f.a)(b),v=Math.floor(n/2)+1,x=Object(c.a)(y),w=Object(i.a)(y),k=Object(d.a)(x,[v,n-v],x.shape.length-1),I=Object(d.a)(w,[v,n-v],w.shape.length-1),S=m.shape.slice();return S[m.shape.length-1]=v,Object(l.a)(Object(r.a)(k[0],I[0]),S)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(15),c=n(4);const l=Object(c.b)({squaredDifference_:function(e,t){let n=Object(i.a)(e,"a","squaredDifference"),c=Object(i.a)(t,"b","squaredDifference");[n,c]=Object(s.makeTypesMatch)(n,c),Object(o.assertAndGetBroadcastShape)(n.shape,c.shape);const l={a:n,b:c};return a.a.runKernel(r.Vc,l,{})}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4);const c=Object(o.b)({unsortedSegmentSum_:function(e,t,n){const o=Object(s.a)(e,"x","unsortedSegmentSum"),c=Object(s.a)(t,"segmentIds","unsortedSegmentSum","int32");Object(i.b)(Object(i.v)(n),()=>"numSegments must be of dtype int");const l={x:o,segmentIds:c},u={numSegments:n};return a.a.runKernel(r.ld,l,u)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(9),i=n(22),o=n(4),c=n(7);const l=Object(o.b)({conv2DBackpropInput_:function(e,t,n,o,l){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",d=arguments.length>6?arguments[6]:void 0;s.b(e.length===t.rank,()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match"));let h=e,p=t,f=!1;3===t.rank&&(f=!0,p=Object(c.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]),h=[1,e[0],e[1],e[2]]),s.b(4===h.length,()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(h.length,".")),s.b(4===p.rank,()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(p.rank)),s.b(4===n.rank,()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank));const m="NHWC"===u?h[3]:h[1],g="NHWC"===u?p.shape[3]:p.shape[1];s.b(m===n.shape[2],()=>"Error in conv2dDerInput: depth of input (".concat(m,") must ")+"match input depth for filter ".concat(n.shape[2],".")),s.b(g===n.shape[3],()=>"Error in conv2dDerInput: depth of output (".concat(g,") must ")+"match output depth for filter ".concat(n.shape[3],".")),i.a("conv2dDerInput",l,d);const b={dy:p,filter:n},y={strides:o,pad:l,dataFormat:u,dimRoundingMode:d,inputShape:h},v=a.a.runKernel(r.F,b,y);return f?Object(c.a)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}})},function(e,t,n){"use strict";n.d(t,"b",(function(){return r})),n.d(t,"a",(function(){return s}));var a=n(5);n(2),n(9),n(10);function r(){return 32===a.a.backend.floatPrecision()?.001:.1}function s(e,t,n){if(null==n&&(n=r()),!i(e,t,n))throw new Error("Numbers differ: actual === ".concat(e,", expected === ").concat(t));"undefined"!==typeof expect&&expect().nothing()}function i(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(9),i=n(22),o=n(4),c=n(7);const l=Object(o.b)({conv2DBackpropFilter_:function(e,t,n,o,l){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",d=arguments.length>6?arguments[6]:void 0,h=e;3===e.rank&&(h=Object(c.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let p=t;3===p.rank&&(p=Object(c.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]])),s.b(4===h.rank,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(h.shape,".")),s.b(4===p.rank,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(p.shape,".")),s.b(4===n.length,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,"."));const f="NHWC"===u?h.shape[3]:h.shape[1],m="NHWC"===u?p.shape[3]:p.shape[1];s.b(f===n[2],()=>"Error in conv2dDerFilter: depth of input ".concat(f,") must ")+"match input depth in filter (".concat(n[2],".")),s.b(m===n[3],()=>"Error in conv2dDerFilter: depth of dy (".concat(m,") must ")+"match output depth for filter (".concat(n[3],").")),i.a("conv2dDerFilter",l,d);const g={x:h,dy:p},b={strides:o,pad:l,dataFormat:u,dimRoundingMode:d,filterShape:n};return a.a.runKernel(r.E,g,b)}})},function(e,t,n){"use strict";(function(e){n(5);var t=n(134),a=n(19);const r=Object(a.b)();r.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),r.registerFlag("IS_BROWSER",()=>t.isBrowser()),r.registerFlag("IS_NODE",()=>"undefined"!==typeof e&&"undefined"!==typeof e.versions&&"undefined"!==typeof e.versions.node),r.registerFlag("IS_CHROME",()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),r.registerFlag("PROD",()=>!1),r.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>r.getBool("DEBUG")),r.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),r.registerFlag("IS_TEST",()=>!1),r.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),r.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),r.registerFlag("ENGINE_COMPILE_ONLY",()=>!1),r.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),r.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1)}).call(this,n(101))},function(e,t,n){"use strict";(function(e){var a=n(233),r=n(234),s=n(235);function i(){return c.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function o(e,t){if(i()<t)throw new RangeError("Invalid typed array length");return c.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=c.prototype:(null===e&&(e=new c(t)),e.length=t),e}function c(e,t,n){if(!c.TYPED_ARRAY_SUPPORT&&!(this instanceof c))return new c(e,t,n);if("number"===typeof e){if("string"===typeof t)throw new Error("If encoding is specified then the first argument must be a string");return d(this,e)}return l(this,e,t,n)}function l(e,t,n,a){if("number"===typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!==typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,n,a){if(t.byteLength,n<0||t.byteLength<n)throw new RangeError("'offset' is out of bounds");if(t.byteLength<n+(a||0))throw new RangeError("'length' is out of bounds");t=void 0===n&&void 0===a?new Uint8Array(t):void 0===a?new Uint8Array(t,n):new Uint8Array(t,n,a);c.TYPED_ARRAY_SUPPORT?(e=t).__proto__=c.prototype:e=h(e,t);return e}(e,t,n,a):"string"===typeof t?function(e,t,n){"string"===typeof n&&""!==n||(n="utf8");if(!c.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var a=0|f(t,n),r=(e=o(e,a)).write(t,n);r!==a&&(e=e.slice(0,r));return e}(e,t,n):function(e,t){if(c.isBuffer(t)){var n=0|p(t.length);return 0===(e=o(e,n)).length||t.copy(e,0,0,n),e}if(t){if("undefined"!==typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!==typeof t.length||(a=t.length)!==a?o(e,0):h(e,t);if("Buffer"===t.type&&s(t.data))return h(e,t.data)}var a;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function u(e){if("number"!==typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function d(e,t){if(u(t),e=o(e,t<0?0:0|p(t)),!c.TYPED_ARRAY_SUPPORT)for(var n=0;n<t;++n)e[n]=0;return e}function h(e,t){var n=t.length<0?0:0|p(t.length);e=o(e,n);for(var a=0;a<n;a+=1)e[a]=255&t[a];return e}function p(e){if(e>=i())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i().toString(16)+" bytes");return 0|e}function f(e,t){if(c.isBuffer(e))return e.length;if("undefined"!==typeof ArrayBuffer&&"function"===typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!==typeof e&&(e=""+e);var n=e.length;if(0===n)return 0;for(var a=!1;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return B(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return W(e).length;default:if(a)return B(e).length;t=(""+t).toLowerCase(),a=!0}}function m(e,t,n){var a=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return E(this,t,n);case"utf8":case"utf-8":return T(this,t,n);case"ascii":return O(this,t,n);case"latin1":case"binary":return C(this,t,n);case"base64":return N(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return _(this,t,n);default:if(a)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),a=!0}}function g(e,t,n){var a=e[t];e[t]=e[n],e[n]=a}function b(e,t,n,a,r){if(0===e.length)return-1;if("string"===typeof n?(a=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=r?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(r)return-1;n=e.length-1}else if(n<0){if(!r)return-1;n=0}if("string"===typeof t&&(t=c.from(t,a)),c.isBuffer(t))return 0===t.length?-1:y(e,t,n,a,r);if("number"===typeof t)return t&=255,c.TYPED_ARRAY_SUPPORT&&"function"===typeof Uint8Array.prototype.indexOf?r?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):y(e,[t],n,a,r);throw new TypeError("val must be string, number or Buffer")}function y(e,t,n,a,r){var s,i=1,o=e.length,c=t.length;if(void 0!==a&&("ucs2"===(a=String(a).toLowerCase())||"ucs-2"===a||"utf16le"===a||"utf-16le"===a)){if(e.length<2||t.length<2)return-1;i=2,o/=2,c/=2,n/=2}function l(e,t){return 1===i?e[t]:e.readUInt16BE(t*i)}if(r){var u=-1;for(s=n;s<o;s++)if(l(e,s)===l(t,-1===u?0:s-u)){if(-1===u&&(u=s),s-u+1===c)return u*i}else-1!==u&&(s-=s-u),u=-1}else for(n+c>o&&(n=o-c),s=n;s>=0;s--){for(var d=!0,h=0;h<c;h++)if(l(e,s+h)!==l(t,h)){d=!1;break}if(d)return s}return-1}function v(e,t,n,a){n=Number(n)||0;var r=e.length-n;a?(a=Number(a))>r&&(a=r):a=r;var s=t.length;if(s%2!==0)throw new TypeError("Invalid hex string");a>s/2&&(a=s/2);for(var i=0;i<a;++i){var o=parseInt(t.substr(2*i,2),16);if(isNaN(o))return i;e[n+i]=o}return i}function x(e,t,n,a){return U(B(t,e.length-n),e,n,a)}function w(e,t,n,a){return U(function(e){for(var t=[],n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,a)}function k(e,t,n,a){return w(e,t,n,a)}function I(e,t,n,a){return U(W(t),e,n,a)}function S(e,t,n,a){return U(function(e,t){for(var n,a,r,s=[],i=0;i<e.length&&!((t-=2)<0);++i)n=e.charCodeAt(i),a=n>>8,r=n%256,s.push(r),s.push(a);return s}(t,e.length-n),e,n,a)}function N(e,t,n){return 0===t&&n===e.length?a.fromByteArray(e):a.fromByteArray(e.slice(t,n))}function T(e,t,n){n=Math.min(e.length,n);for(var a=[],r=t;r<n;){var s,i,o,c,l=e[r],u=null,d=l>239?4:l>223?3:l>191?2:1;if(r+d<=n)switch(d){case 1:l<128&&(u=l);break;case 2:128===(192&(s=e[r+1]))&&(c=(31&l)<<6|63&s)>127&&(u=c);break;case 3:s=e[r+1],i=e[r+2],128===(192&s)&&128===(192&i)&&(c=(15&l)<<12|(63&s)<<6|63&i)>2047&&(c<55296||c>57343)&&(u=c);break;case 4:s=e[r+1],i=e[r+2],o=e[r+3],128===(192&s)&&128===(192&i)&&128===(192&o)&&(c=(15&l)<<18|(63&s)<<12|(63&i)<<6|63&o)>65535&&c<1114112&&(u=c)}null===u?(u=65533,d=1):u>65535&&(u-=65536,a.push(u>>>10&1023|55296),u=56320|1023&u),a.push(u),r+=d}return function(e){var t=e.length;if(t<=4096)return String.fromCharCode.apply(String,e);var n="",a=0;for(;a<t;)n+=String.fromCharCode.apply(String,e.slice(a,a+=4096));return n}(a)}t.Buffer=c,t.SlowBuffer=function(e){+e!=e&&(e=0);return c.alloc(+e)},t.INSPECT_MAX_BYTES=50,c.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"===typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(t){return!1}}(),t.kMaxLength=i(),c.poolSize=8192,c._augment=function(e){return e.__proto__=c.prototype,e},c.from=function(e,t,n){return l(null,e,t,n)},c.TYPED_ARRAY_SUPPORT&&(c.prototype.__proto__=Uint8Array.prototype,c.__proto__=Uint8Array,"undefined"!==typeof Symbol&&Symbol.species&&c[Symbol.species]===c&&Object.defineProperty(c,Symbol.species,{value:null,configurable:!0})),c.alloc=function(e,t,n){return function(e,t,n,a){return u(t),t<=0?o(e,t):void 0!==n?"string"===typeof a?o(e,t).fill(n,a):o(e,t).fill(n):o(e,t)}(null,e,t,n)},c.allocUnsafe=function(e){return d(null,e)},c.allocUnsafeSlow=function(e){return d(null,e)},c.isBuffer=function(e){return!(null==e||!e._isBuffer)},c.compare=function(e,t){if(!c.isBuffer(e)||!c.isBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var n=e.length,a=t.length,r=0,s=Math.min(n,a);r<s;++r)if(e[r]!==t[r]){n=e[r],a=t[r];break}return n<a?-1:a<n?1:0},c.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},c.concat=function(e,t){if(!s(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return c.alloc(0);var n;if(void 0===t)for(t=0,n=0;n<e.length;++n)t+=e[n].length;var a=c.allocUnsafe(t),r=0;for(n=0;n<e.length;++n){var i=e[n];if(!c.isBuffer(i))throw new TypeError('"list" argument must be an Array of Buffers');i.copy(a,r),r+=i.length}return a},c.byteLength=f,c.prototype._isBuffer=!0,c.prototype.swap16=function(){var e=this.length;if(e%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)g(this,t,t+1);return this},c.prototype.swap32=function(){var e=this.length;if(e%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)g(this,t,t+3),g(this,t+1,t+2);return this},c.prototype.swap64=function(){var e=this.length;if(e%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)g(this,t,t+7),g(this,t+1,t+6),g(this,t+2,t+5),g(this,t+3,t+4);return this},c.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?T(this,0,e):m.apply(this,arguments)},c.prototype.equals=function(e){if(!c.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===c.compare(this,e)},c.prototype.inspect=function(){var e="",n=t.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,n).match(/.{2}/g).join(" "),this.length>n&&(e+=" ... ")),"<Buffer "+e+">"},c.prototype.compare=function(e,t,n,a,r){if(!c.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===a&&(a=0),void 0===r&&(r=this.length),t<0||n>e.length||a<0||r>this.length)throw new RangeError("out of range index");if(a>=r&&t>=n)return 0;if(a>=r)return-1;if(t>=n)return 1;if(this===e)return 0;for(var s=(r>>>=0)-(a>>>=0),i=(n>>>=0)-(t>>>=0),o=Math.min(s,i),l=this.slice(a,r),u=e.slice(t,n),d=0;d<o;++d)if(l[d]!==u[d]){s=l[d],i=u[d];break}return s<i?-1:i<s?1:0},c.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},c.prototype.indexOf=function(e,t,n){return b(this,e,t,n,!0)},c.prototype.lastIndexOf=function(e,t,n){return b(this,e,t,n,!1)},c.prototype.write=function(e,t,n,a){if(void 0===t)a="utf8",n=this.length,t=0;else if(void 0===n&&"string"===typeof t)a=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(n)?(n|=0,void 0===a&&(a="utf8")):(a=n,n=void 0)}var r=this.length-t;if((void 0===n||n>r)&&(n=r),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");a||(a="utf8");for(var s=!1;;)switch(a){case"hex":return v(this,e,t,n);case"utf8":case"utf-8":return x(this,e,t,n);case"ascii":return w(this,e,t,n);case"latin1":case"binary":return k(this,e,t,n);case"base64":return I(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return S(this,e,t,n);default:if(s)throw new TypeError("Unknown encoding: "+a);a=(""+a).toLowerCase(),s=!0}},c.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function O(e,t,n){var a="";n=Math.min(e.length,n);for(var r=t;r<n;++r)a+=String.fromCharCode(127&e[r]);return a}function C(e,t,n){var a="";n=Math.min(e.length,n);for(var r=t;r<n;++r)a+=String.fromCharCode(e[r]);return a}function E(e,t,n){var a=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>a)&&(n=a);for(var r="",s=t;s<n;++s)r+=P(e[s]);return r}function _(e,t,n){for(var a=e.slice(t,n),r="",s=0;s<a.length;s+=2)r+=String.fromCharCode(a[s]+256*a[s+1]);return r}function A(e,t,n){if(e%1!==0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function R(e,t,n,a,r,s){if(!c.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>r||t<s)throw new RangeError('"value" argument is out of bounds');if(n+a>e.length)throw new RangeError("Index out of range")}function D(e,t,n,a){t<0&&(t=65535+t+1);for(var r=0,s=Math.min(e.length-n,2);r<s;++r)e[n+r]=(t&255<<8*(a?r:1-r))>>>8*(a?r:1-r)}function F(e,t,n,a){t<0&&(t=4294967295+t+1);for(var r=0,s=Math.min(e.length-n,4);r<s;++r)e[n+r]=t>>>8*(a?r:3-r)&255}function M(e,t,n,a,r,s){if(n+a>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function j(e,t,n,a,s){return s||M(e,0,n,4),r.write(e,t,n,a,23,4),n+4}function z(e,t,n,a,s){return s||M(e,0,n,8),r.write(e,t,n,a,52,8),n+8}c.prototype.slice=function(e,t){var n,a=this.length;if((e=~~e)<0?(e+=a)<0&&(e=0):e>a&&(e=a),(t=void 0===t?a:~~t)<0?(t+=a)<0&&(t=0):t>a&&(t=a),t<e&&(t=e),c.TYPED_ARRAY_SUPPORT)(n=this.subarray(e,t)).__proto__=c.prototype;else{var r=t-e;n=new c(r,void 0);for(var s=0;s<r;++s)n[s]=this[s+e]}return n},c.prototype.readUIntLE=function(e,t,n){e|=0,t|=0,n||A(e,t,this.length);for(var a=this[e],r=1,s=0;++s<t&&(r*=256);)a+=this[e+s]*r;return a},c.prototype.readUIntBE=function(e,t,n){e|=0,t|=0,n||A(e,t,this.length);for(var a=this[e+--t],r=1;t>0&&(r*=256);)a+=this[e+--t]*r;return a},c.prototype.readUInt8=function(e,t){return t||A(e,1,this.length),this[e]},c.prototype.readUInt16LE=function(e,t){return t||A(e,2,this.length),this[e]|this[e+1]<<8},c.prototype.readUInt16BE=function(e,t){return t||A(e,2,this.length),this[e]<<8|this[e+1]},c.prototype.readUInt32LE=function(e,t){return t||A(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},c.prototype.readUInt32BE=function(e,t){return t||A(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},c.prototype.readIntLE=function(e,t,n){e|=0,t|=0,n||A(e,t,this.length);for(var a=this[e],r=1,s=0;++s<t&&(r*=256);)a+=this[e+s]*r;return a>=(r*=128)&&(a-=Math.pow(2,8*t)),a},c.prototype.readIntBE=function(e,t,n){e|=0,t|=0,n||A(e,t,this.length);for(var a=t,r=1,s=this[e+--a];a>0&&(r*=256);)s+=this[e+--a]*r;return s>=(r*=128)&&(s-=Math.pow(2,8*t)),s},c.prototype.readInt8=function(e,t){return t||A(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},c.prototype.readInt16LE=function(e,t){t||A(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},c.prototype.readInt16BE=function(e,t){t||A(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},c.prototype.readInt32LE=function(e,t){return t||A(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},c.prototype.readInt32BE=function(e,t){return t||A(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},c.prototype.readFloatLE=function(e,t){return t||A(e,4,this.length),r.read(this,e,!0,23,4)},c.prototype.readFloatBE=function(e,t){return t||A(e,4,this.length),r.read(this,e,!1,23,4)},c.prototype.readDoubleLE=function(e,t){return t||A(e,8,this.length),r.read(this,e,!0,52,8)},c.prototype.readDoubleBE=function(e,t){return t||A(e,8,this.length),r.read(this,e,!1,52,8)},c.prototype.writeUIntLE=function(e,t,n,a){(e=+e,t|=0,n|=0,a)||R(this,e,t,n,Math.pow(2,8*n)-1,0);var r=1,s=0;for(this[t]=255&e;++s<n&&(r*=256);)this[t+s]=e/r&255;return t+n},c.prototype.writeUIntBE=function(e,t,n,a){(e=+e,t|=0,n|=0,a)||R(this,e,t,n,Math.pow(2,8*n)-1,0);var r=n-1,s=1;for(this[t+r]=255&e;--r>=0&&(s*=256);)this[t+r]=e/s&255;return t+n},c.prototype.writeUInt8=function(e,t,n){return e=+e,t|=0,n||R(this,e,t,1,255,0),c.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},c.prototype.writeUInt16LE=function(e,t,n){return e=+e,t|=0,n||R(this,e,t,2,65535,0),c.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):D(this,e,t,!0),t+2},c.prototype.writeUInt16BE=function(e,t,n){return e=+e,t|=0,n||R(this,e,t,2,65535,0),c.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):D(this,e,t,!1),t+2},c.prototype.writeUInt32LE=function(e,t,n){return e=+e,t|=0,n||R(this,e,t,4,4294967295,0),c.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):F(this,e,t,!0),t+4},c.prototype.writeUInt32BE=function(e,t,n){return e=+e,t|=0,n||R(this,e,t,4,4294967295,0),c.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):F(this,e,t,!1),t+4},c.prototype.writeIntLE=function(e,t,n,a){if(e=+e,t|=0,!a){var r=Math.pow(2,8*n-1);R(this,e,t,n,r-1,-r)}var s=0,i=1,o=0;for(this[t]=255&e;++s<n&&(i*=256);)e<0&&0===o&&0!==this[t+s-1]&&(o=1),this[t+s]=(e/i>>0)-o&255;return t+n},c.prototype.writeIntBE=function(e,t,n,a){if(e=+e,t|=0,!a){var r=Math.pow(2,8*n-1);R(this,e,t,n,r-1,-r)}var s=n-1,i=1,o=0;for(this[t+s]=255&e;--s>=0&&(i*=256);)e<0&&0===o&&0!==this[t+s+1]&&(o=1),this[t+s]=(e/i>>0)-o&255;return t+n},c.prototype.writeInt8=function(e,t,n){return e=+e,t|=0,n||R(this,e,t,1,127,-128),c.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},c.prototype.writeInt16LE=function(e,t,n){return e=+e,t|=0,n||R(this,e,t,2,32767,-32768),c.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):D(this,e,t,!0),t+2},c.prototype.writeInt16BE=function(e,t,n){return e=+e,t|=0,n||R(this,e,t,2,32767,-32768),c.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):D(this,e,t,!1),t+2},c.prototype.writeInt32LE=function(e,t,n){return e=+e,t|=0,n||R(this,e,t,4,2147483647,-2147483648),c.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):F(this,e,t,!0),t+4},c.prototype.writeInt32BE=function(e,t,n){return e=+e,t|=0,n||R(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),c.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):F(this,e,t,!1),t+4},c.prototype.writeFloatLE=function(e,t,n){return j(this,e,t,!0,n)},c.prototype.writeFloatBE=function(e,t,n){return j(this,e,t,!1,n)},c.prototype.writeDoubleLE=function(e,t,n){return z(this,e,t,!0,n)},c.prototype.writeDoubleBE=function(e,t,n){return z(this,e,t,!1,n)},c.prototype.copy=function(e,t,n,a){if(n||(n=0),a||0===a||(a=this.length),t>=e.length&&(t=e.length),t||(t=0),a>0&&a<n&&(a=n),a===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(a<0)throw new RangeError("sourceEnd out of bounds");a>this.length&&(a=this.length),e.length-t<a-n&&(a=e.length-t+n);var r,s=a-n;if(this===e&&n<t&&t<a)for(r=s-1;r>=0;--r)e[r+t]=this[r+n];else if(s<1e3||!c.TYPED_ARRAY_SUPPORT)for(r=0;r<s;++r)e[r+t]=this[r+n];else Uint8Array.prototype.set.call(e,this.subarray(n,n+s),t);return s},c.prototype.fill=function(e,t,n,a){if("string"===typeof e){if("string"===typeof t?(a=t,t=0,n=this.length):"string"===typeof n&&(a=n,n=this.length),1===e.length){var r=e.charCodeAt(0);r<256&&(e=r)}if(void 0!==a&&"string"!==typeof a)throw new TypeError("encoding must be a string");if("string"===typeof a&&!c.isEncoding(a))throw new TypeError("Unknown encoding: "+a)}else"number"===typeof e&&(e&=255);if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;var s;if(t>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"===typeof e)for(s=t;s<n;++s)this[s]=e;else{var i=c.isBuffer(e)?e:B(new c(e,a).toString()),o=i.length;for(s=0;s<n-t;++s)this[s+t]=i[s%o]}return this};var L=/[^+\/0-9A-Za-z-_]/g;function P(e){return e<16?"0"+e.toString(16):e.toString(16)}function B(e,t){var n;t=t||1/0;for(var a=e.length,r=null,s=[],i=0;i<a;++i){if((n=e.charCodeAt(i))>55295&&n<57344){if(!r){if(n>56319){(t-=3)>-1&&s.push(239,191,189);continue}if(i+1===a){(t-=3)>-1&&s.push(239,191,189);continue}r=n;continue}if(n<56320){(t-=3)>-1&&s.push(239,191,189),r=n;continue}n=65536+(r-55296<<10|n-56320)}else r&&(t-=3)>-1&&s.push(239,191,189);if(r=null,n<128){if((t-=1)<0)break;s.push(n)}else if(n<2048){if((t-=2)<0)break;s.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;s.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;s.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return s}function W(e){return a.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(L,"")).length<2)return"";for(;e.length%4!==0;)e+="=";return e}(e))}function U(e,t,n,a){for(var r=0;r<a&&!(r+n>=t.length||r>=e.length);++r)t[r+n]=e[r];return r}}).call(this,n(100))},function(e,t,n){"use strict";n.d(t,"a",(function(){return a})),n.d(t,"b",(function(){return r}));class a{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class r{refCount(e){return s("refCount")}incRef(e){return s("incRef")}timerAvailable(){return!0}time(e){return s("time")}read(e){return s("read")}readSync(e){return s("readSync")}readToGPU(e,t){return s("readToGPU")}numDataIds(){return s("numDataIds")}disposeData(e,t){return s("disposeData")}write(e,t,n){return s("write")}move(e,t,n,a,r){return s("move")}memory(){return s("memory")}floatPrecision(){return s("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return s("dispose")}}function s(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({tanh_:function(e){const t={x:Object(s.a)(e,"x","tanh","float32")};return a.a.runKernel(r.ed,t)}})},function(e,t,n){"use strict";n.d(t,"b",(function(){return a})),n.d(t,"a",(function(){return r}));const a=1.7580993408473768,r=1.0507009873554805},function(e,t,n){"use strict";n.d(t,"fc",(function(){return ie})),n.d(t,"gd",(function(){return P.a})),n.d(t,"hd",(function(){return P.b})),n.d(t,"qf",(function(){return oe.a})),n.d(t,"Cf",(function(){return oe.b})),n.d(t,"rd",(function(){return ce.b})),n.d(t,"sd",(function(){return ce.e})),n.d(t,"td",(function(){return ce.g})),n.d(t,"ud",(function(){return ce.h})),n.d(t,"vd",(function(){return ce.i})),n.d(t,"wd",(function(){return ce.p})),n.d(t,"xd",(function(){return ce.q})),n.d(t,"Ad",(function(){return ce.t})),n.d(t,"Bd",(function(){return ce.u})),n.d(t,"Cd",(function(){return ce.v})),n.d(t,"Dd",(function(){return ce.A})),n.d(t,"Gd",(function(){return ce.B})),n.d(t,"Hd",(function(){return ce.C})),n.d(t,"Id",(function(){return ce.E})),n.d(t,"Jd",(function(){return ce.F})),n.d(t,"Kd",(function(){return ce.H})),n.d(t,"Ld",(function(){return ce.I})),n.d(t,"Md",(function(){return ce.J})),n.d(t,"Nd",(function(){return ce.K})),n.d(t,"Od",(function(){return ce.L})),n.d(t,"Pd",(function(){return ce.M})),n.d(t,"Qd",(function(){return ce.N})),n.d(t,"Rd",(function(){return ce.O})),n.d(t,"Sd",(function(){return ce.P})),n.d(t,"Td",(function(){return ce.Q})),n.d(t,"Ud",(function(){return ce.Y})),n.d(t,"Xd",(function(){return ce.bb})),n.d(t,"Zd",(function(){return ce.gb})),n.d(t,"ce",(function(){return ce.ib})),n.d(t,"de",(function(){return ce.lb})),n.d(t,"ee",(function(){return ce.mb})),n.d(t,"fe",(function(){return ce.ob})),n.d(t,"ge",(function(){return ce.qb})),n.d(t,"he",(function(){return ce.rb})),n.d(t,"je",(function(){return ce.ub})),n.d(t,"ke",(function(){return ce.wb})),n.d(t,"le",(function(){return ce.xb})),n.d(t,"qe",(function(){return ce.Gb})),n.d(t,"se",(function(){return ce.Mb})),n.d(t,"te",(function(){return ce.Nb})),n.d(t,"ue",(function(){return ce.Pb})),n.d(t,"ve",(function(){return ce.Rb})),n.d(t,"we",(function(){return ce.Xb})),n.d(t,"xe",(function(){return ce.Yb})),n.d(t,"ye",(function(){return ce.Zb})),n.d(t,"ze",(function(){return ce.ac})),n.d(t,"Ae",(function(){return ce.cc})),n.d(t,"Be",(function(){return ce.dc})),n.d(t,"De",(function(){return ce.gc})),n.d(t,"Ee",(function(){return ce.jc})),n.d(t,"Fe",(function(){return ce.lc})),n.d(t,"Ge",(function(){return ce.oc})),n.d(t,"Ie",(function(){return ce.qc})),n.d(t,"Je",(function(){return ce.rc})),n.d(t,"Ke",(function(){return ce.sc})),n.d(t,"Le",(function(){return ce.tc})),n.d(t,"Me",(function(){return ce.wc})),n.d(t,"Ne",(function(){return ce.Cc})),n.d(t,"Oe",(function(){return ce.Dc})),n.d(t,"Pe",(function(){return ce.Kc})),n.d(t,"Qe",(function(){return ce.Mc})),n.d(t,"Te",(function(){return ce.Qc})),n.d(t,"Ue",(function(){return ce.Sc})),n.d(t,"Ve",(function(){return ce.Tc})),n.d(t,"We",(function(){return ce.bd})),n.d(t,"Xe",(function(){return ce.ed})),n.d(t,"Ye",(function(){return ce.fd})),n.d(t,"bf",(function(){return ce.hd})),n.d(t,"cf",(function(){return ce.md})),n.d(t,"df",(function(){return ce.nd})),n.d(t,"ef",(function(){return ce.od})),n.d(t,"ff",(function(){return ce.pd})),n.d(t,"gf",(function(){return ce.qd})),n.d(t,"if",(function(){return ce.rd})),n.d(t,"jf",(function(){return ce.sd})),n.d(t,"kf",(function(){return ce.xd})),n.d(t,"lf",(function(){return ce.yd})),n.d(t,"mf",(function(){return ce.Bd})),n.d(t,"nf",(function(){return ce.Cd})),n.d(t,"of",(function(){return ce.Gd})),n.d(t,"pf",(function(){return ce.Hd})),n.d(t,"rf",(function(){return ce.Jd})),n.d(t,"sf",(function(){return ce.Kd})),n.d(t,"tf",(function(){return ce.Ld})),n.d(t,"uf",(function(){return ce.Md})),n.d(t,"xf",(function(){return ce.Rd})),n.d(t,"Af",(function(){return ce.Ud})),n.d(t,"Bf",(function(){return ce.Xd})),n.d(t,"Ef",(function(){return ce.Zd})),n.d(t,"Hf",(function(){return ce.ae})),n.d(t,"If",(function(){return ce.ce})),n.d(t,"Jf",(function(){return ce.de})),n.d(t,"zf",(function(){return ce.Td})),n.d(t,"Yd",(function(){return ce.eb})),n.d(t,"me",(function(){return ce.Ab})),n.d(t,"re",(function(){return ce.Jb})),n.d(t,"ie",(function(){return ce.tb})),n.d(t,"yf",(function(){return Ce})),n.d(t,"ae",(function(){return ae.c})),n.d(t,"Ce",(function(){return ae.e})),n.d(t,"wf",(function(){return ae.h})),n.d(t,"Wd",(function(){return ae.b})),n.d(t,"oe",(function(){return ae.d})),n.d(t,"af",(function(){return ae.g})),n.d(t,"Re",(function(){return ae.f})),n.d(t,"yd",(function(){return ae.a})),n.d(t,"Se",(function(){return L.e})),n.d(t,"Ff",(function(){return re.b})),n.d(t,"be",(function(){return l.b})),n.d(t,"Gf",(function(){return ne})),n.d(t,"He",(function(){return Ee.a})),n.d(t,"Fd",(function(){return r})),n.d(t,"ne",(function(){return a})),n.d(t,"Ze",(function(){return s})),n.d(t,"Df",(function(){return te})),n.d(t,"zd",(function(){return o})),n.d(t,"Ed",(function(){return M})),n.d(t,"vf",(function(){return ee})),n.d(t,"hf",(function(){return Y})),n.d(t,"Vd",(function(){return zt})),n.d(t,"pe",(function(){return c})),n.d(t,"yb",(function(){return Bt.b})),n.d(t,"N",(function(){return Bt.a})),n.d(t,"a",(function(){return z.a})),n.d(t,"b",(function(){return z.b})),n.d(t,"c",(function(){return z.c})),n.d(t,"d",(function(){return z.d})),n.d(t,"e",(function(){return z.e})),n.d(t,"f",(function(){return z.f})),n.d(t,"g",(function(){return z.g})),n.d(t,"h",(function(){return z.h})),n.d(t,"i",(function(){return z.i})),n.d(t,"j",(function(){return z.j})),n.d(t,"k",(function(){return z.k})),n.d(t,"l",(function(){return z.l})),n.d(t,"n",(function(){return z.n})),n.d(t,"m",(function(){return z.m})),n.d(t,"o",(function(){return z.o})),n.d(t,"r",(function(){return z.r})),n.d(t,"p",(function(){return z.p})),n.d(t,"q",(function(){return z.q})),n.d(t,"s",(function(){return z.s})),n.d(t,"t",(function(){return z.t})),n.d(t,"u",(function(){return z.u})),n.d(t,"v",(function(){return z.v})),n.d(t,"w",(function(){return z.x})),n.d(t,"x",(function(){return z.y})),n.d(t,"y",(function(){return z.z})),n.d(t,"z",(function(){return z.A})),n.d(t,"A",(function(){return z.B})),n.d(t,"B",(function(){return z.C})),n.d(t,"C",(function(){return z.D})),n.d(t,"D",(function(){return z.E})),n.d(t,"E",(function(){return z.F})),n.d(t,"F",(function(){return z.G})),n.d(t,"G",(function(){return z.H})),n.d(t,"H",(function(){return z.I})),n.d(t,"I",(function(){return z.J})),n.d(t,"J",(function(){return z.K})),n.d(t,"L",(function(){return z.M})),n.d(t,"M",(function(){return z.N})),n.d(t,"K",(function(){return z.L})),n.d(t,"O",(function(){return z.O})),n.d(t,"P",(function(){return z.P})),n.d(t,"Q",(function(){return z.Q})),n.d(t,"R",(function(){return z.R})),n.d(t,"S",(function(){return z.S})),n.d(t,"T",(function(){return z.T})),n.d(t,"U",(function(){return z.U})),n.d(t,"W",(function(){return z.W})),n.d(t,"V",(function(){return z.V})),n.d(t,"pc",(function(){return z.oc})),n.d(t,"X",(function(){return z.X})),n.d(t,"Y",(function(){return z.Y})),n.d(t,"Z",(function(){return z.Z})),n.d(t,"bb",(function(){return z.bb})),n.d(t,"ab",(function(){return z.ab})),n.d(t,"cb",(function(){return z.cb})),n.d(t,"db",(function(){return z.db})),n.d(t,"eb",(function(){return z.eb})),n.d(t,"fb",(function(){return z.fb})),n.d(t,"gb",(function(){return z.gb})),n.d(t,"hb",(function(){return z.hb})),n.d(t,"ib",(function(){return z.ib})),n.d(t,"jb",(function(){return z.jb})),n.d(t,"lb",(function(){return z.lb})),n.d(t,"pb",(function(){return z.pb})),n.d(t,"ob",(function(){return z.ob})),n.d(t,"qb",(function(){return z.qb})),n.d(t,"rb",(function(){return z.rb})),n.d(t,"tb",(function(){return z.tb})),n.d(t,"sb",(function(){return z.sb})),n.d(t,"ub",(function(){return z.ub})),n.d(t,"vb",(function(){return z.vb})),n.d(t,"wb",(function(){return z.wb})),n.d(t,"xb",(function(){return z.xb})),n.d(t,"Bb",(function(){return z.Ab})),n.d(t,"Cb",(function(){return z.Bb})),n.d(t,"Db",(function(){return z.Cb})),n.d(t,"Eb",(function(){return z.Db})),n.d(t,"Fb",(function(){return z.Eb})),n.d(t,"Gb",(function(){return z.Fb})),n.d(t,"Hb",(function(){return z.Hb})),n.d(t,"Ib",(function(){return z.Ib})),n.d(t,"Jb",(function(){return z.Jb})),n.d(t,"zb",(function(){return z.yb})),n.d(t,"Ab",(function(){return z.zb})),n.d(t,"Kb",(function(){return z.Kb})),n.d(t,"Qb",(function(){return z.Qb})),n.d(t,"Lb",(function(){return z.Lb})),n.d(t,"Ob",(function(){return z.Ob})),n.d(t,"Mb",(function(){return z.Mb})),n.d(t,"Nb",(function(){return z.Nb})),n.d(t,"Pb",(function(){return z.Pb})),n.d(t,"Rb",(function(){return z.Rb})),n.d(t,"Sb",(function(){return z.Sb})),n.d(t,"Tb",(function(){return z.Tb})),n.d(t,"Ub",(function(){return z.Ub})),n.d(t,"Vb",(function(){return z.Vb})),n.d(t,"Wb",(function(){return z.Wb})),n.d(t,"Xb",(function(){return z.Xb})),n.d(t,"Yb",(function(){return z.Yb})),n.d(t,"cc",(function(){return z.cc})),n.d(t,"Zb",(function(){return z.Zb})),n.d(t,"ac",(function(){return z.ac})),n.d(t,"bc",(function(){return z.bc})),n.d(t,"ec",(function(){return z.ec})),n.d(t,"dc",(function(){return z.dc})),n.d(t,"gc",(function(){return z.fc})),n.d(t,"hc",(function(){return z.gc})),n.d(t,"ic",(function(){return z.hc})),n.d(t,"jc",(function(){return z.ic})),n.d(t,"kc",(function(){return z.jc})),n.d(t,"lc",(function(){return z.kc})),n.d(t,"mc",(function(){return z.lc})),n.d(t,"nc",(function(){return z.mc})),n.d(t,"oc",(function(){return z.nc})),n.d(t,"qc",(function(){return z.pc})),n.d(t,"rc",(function(){return z.qc})),n.d(t,"tc",(function(){return z.sc})),n.d(t,"wc",(function(){return z.vc})),n.d(t,"xc",(function(){return z.wc})),n.d(t,"uc",(function(){return z.tc})),n.d(t,"vc",(function(){return z.uc})),n.d(t,"sc",(function(){return z.rc})),n.d(t,"yc",(function(){return z.xc})),n.d(t,"Ac",(function(){return z.zc})),n.d(t,"Bc",(function(){return z.Ac})),n.d(t,"Cc",(function(){return z.Bc})),n.d(t,"Dc",(function(){return z.Cc})),n.d(t,"Ec",(function(){return z.Dc})),n.d(t,"Fc",(function(){return z.Ec})),n.d(t,"Kc",(function(){return z.Jc})),n.d(t,"Ic",(function(){return z.Hc})),n.d(t,"Jc",(function(){return z.Ic})),n.d(t,"Hc",(function(){return z.Gc})),n.d(t,"Gc",(function(){return z.Fc})),n.d(t,"Mc",(function(){return z.Lc})),n.d(t,"Uc",(function(){return z.Tc})),n.d(t,"dd",(function(){return z.cd})),n.d(t,"Nc",(function(){return z.Mc})),n.d(t,"Tc",(function(){return z.Sc})),n.d(t,"Lc",(function(){return z.Kc})),n.d(t,"Oc",(function(){return z.Nc})),n.d(t,"Pc",(function(){return z.Oc})),n.d(t,"Qc",(function(){return z.Pc})),n.d(t,"Rc",(function(){return z.Qc})),n.d(t,"Sc",(function(){return z.Rc})),n.d(t,"Wc",(function(){return z.Vc})),n.d(t,"Vc",(function(){return z.Uc})),n.d(t,"Yc",(function(){return z.Xc})),n.d(t,"Zc",(function(){return z.Yc})),n.d(t,"ad",(function(){return z.Zc})),n.d(t,"bd",(function(){return z.ad})),n.d(t,"cd",(function(){return z.bd})),n.d(t,"ed",(function(){return z.dd})),n.d(t,"fd",(function(){return z.ed})),n.d(t,"id",(function(){return z.fd})),n.d(t,"jd",(function(){return z.gd})),n.d(t,"kd",(function(){return z.hd})),n.d(t,"ld",(function(){return z.id})),n.d(t,"md",(function(){return z.jd})),n.d(t,"nd",(function(){return z.kd})),n.d(t,"od",(function(){return z.ld})),n.d(t,"pd",(function(){return z.md})),n.d(t,"Xc",(function(){return z.Wc})),n.d(t,"kb",(function(){return z.kb})),n.d(t,"zc",(function(){return z.yc})),n.d(t,"qd",(function(){return z.nd})),n.d(t,"mb",(function(){return z.mb})),n.d(t,"nb",(function(){return z.nb}));var a={};n.r(a),n.d(a,"copyModel",(function(){return F.b})),n.d(a,"listModels",(function(){return F.c})),n.d(a,"moveModel",(function(){return F.d})),n.d(a,"removeModel",(function(){return F.e})),n.d(a,"browserFiles",(function(){return m})),n.d(a,"browserHTTPRequest",(function(){return T})),n.d(a,"concatenateArrayBuffers",(function(){return u.d})),n.d(a,"decodeWeights",(function(){return u.e})),n.d(a,"encodeWeights",(function(){return u.f})),n.d(a,"fromMemory",(function(){return _})),n.d(a,"fromMemorySync",(function(){return A})),n.d(a,"getLoadHandlers",(function(){return d.b})),n.d(a,"getModelArtifactsForJSON",(function(){return u.g})),n.d(a,"getModelArtifactsForJSONSync",(function(){return u.h})),n.d(a,"getModelArtifactsInfoForJSON",(function(){return u.i})),n.d(a,"getSaveHandlers",(function(){return d.c})),n.d(a,"getWeightSpecs",(function(){return u.k})),n.d(a,"http",(function(){return N})),n.d(a,"isHTTPScheme",(function(){return I})),n.d(a,"loadWeights",(function(){return x})),n.d(a,"registerLoadRouter",(function(){return d.d})),n.d(a,"registerSaveRouter",(function(){return d.e})),n.d(a,"weightsLoaderFactory",(function(){return w})),n.d(a,"withSaveHandler",(function(){return R})),n.d(a,"withSaveHandlerSync",(function(){return D}));var r={};n.r(r),n.d(r,"fromPixelsAsync",(function(){return K})),n.d(r,"toPixels",(function(){return X})),n.d(r,"fromPixels",(function(){return Z}));var s={};n.r(s),n.d(s,"Serializable",(function(){return J})),n.d(s,"SerializationMap",(function(){return Q})),n.d(s,"registerClass",(function(){return $}));var i={};n.r(i),n.d(i,"segOpComputeOptimalWindowSize",(function(){return Rt})),n.d(i,"computeOutShape",(function(){return Dt})),n.d(i,"collectGatherOpShapeInfo",(function(){return Ft}));var o={};n.r(o),n.d(o,"axesAreInnerMostDims",(function(){return _e.b})),n.d(o,"combineLocations",(function(){return _e.c})),n.d(o,"computeOutAndReduceShapes",(function(){return _e.d})),n.d(o,"expandShapeToKeepDim",(function(){return _e.e})),n.d(o,"assertAxesAreInnerMostDims",(function(){return _e.a})),n.d(o,"getAxesPermutation",(function(){return _e.f})),n.d(o,"getUndoAxesPermutation",(function(){return _e.h})),n.d(o,"getInnerMostAxes",(function(){return _e.g})),n.d(o,"getBroadcastDims",(function(){return M.getBroadcastDims})),n.d(o,"getReductionAxes",(function(){return M.getReductionAxes})),n.d(o,"assertAndGetBroadcastShape",(function(){return M.assertAndGetBroadcastShape})),n.d(o,"assertParamsConsistent",(function(){return Ae})),n.d(o,"computeOutShape",(function(){return Re})),n.d(o,"computeDilation2DInfo",(function(){return Fe.e})),n.d(o,"computePool2DInfo",(function(){return Fe.f})),n.d(o,"computePool3DInfo",(function(){return Fe.g})),n.d(o,"computeConv2DInfo",(function(){return Fe.b})),n.d(o,"computeConv3DInfo",(function(){return Fe.c})),n.d(o,"computeDefaultPad",(function(){return Fe.d})),n.d(o,"tupleValuesAreOne",(function(){return Fe.j})),n.d(o,"eitherStridesOrDilationsAreOne",(function(){return Fe.i})),n.d(o,"convertConv2DDataFormat",(function(){return Fe.h})),n.d(o,"checkPadOnDimRoundingMode",(function(){return Fe.a})),n.d(o,"getFusedDyActivation",(function(){return Me.c})),n.d(o,"getFusedBiasGradient",(function(){return Me.b})),n.d(o,"applyActivation",(function(){return Me.a})),n.d(o,"shouldFuse",(function(){return Me.d})),n.d(o,"RowPartitionType",(function(){return De})),n.d(o,"combineRaggedTensorToTensorShapes",(function(){return je})),n.d(o,"getRowPartitionTypesHelper",(function(){return ze})),n.d(o,"getRaggedRank",(function(){return Le})),n.d(o,"validateDefaultValueShape",(function(){return Pe})),n.d(o,"PARALLELIZE_THRESHOLD",(function(){return Be})),n.d(o,"computeOptimalWindowSize",(function(){return We})),n.d(o,"slice_util",(function(){return Y})),n.d(o,"upcastType",(function(){return oe.b})),n.d(o,"getImageCenter",(function(){return Ue})),n.d(o,"getReshaped",(function(){return Ve})),n.d(o,"getPermuted",(function(){return Ge})),n.d(o,"getReshapedPermuted",(function(){return He})),n.d(o,"getSliceBeginCoords",(function(){return qe})),n.d(o,"getSliceSize",(function(){return Ke})),n.d(o,"prepareAndValidate",(function(){return Xe})),n.d(o,"validateUpdateShape",(function(){return Ze.c})),n.d(o,"validateInput",(function(){return Ze.b})),n.d(o,"calculateShapes",(function(){return Ze.a})),n.d(o,"SELU_SCALEALPHA",(function(){return Ye.b})),n.d(o,"SELU_SCALE",(function(){return Ye.a})),n.d(o,"ERF_P",(function(){return Je})),n.d(o,"ERF_A1",(function(){return Qe})),n.d(o,"ERF_A2",(function(){return $e})),n.d(o,"ERF_A3",(function(){return et})),n.d(o,"ERF_A4",(function(){return tt})),n.d(o,"ERF_A5",(function(){return nt})),n.d(o,"warn",(function(){return at.b})),n.d(o,"log",(function(){return at.a})),n.d(o,"mergeRealAndImagArrays",(function(){return rt})),n.d(o,"splitRealAndImagArrays",(function(){return st})),n.d(o,"complexWithEvenIndex",(function(){return it})),n.d(o,"complexWithOddIndex",(function(){return ot})),n.d(o,"getComplexWithIndex",(function(){return ct})),n.d(o,"assignToTypedArray",(function(){return lt})),n.d(o,"exponents",(function(){return ut})),n.d(o,"exponent",(function(){return dt})),n.d(o,"decodeEinsumEquation",(function(){return pt})),n.d(o,"getEinsumPermutation",(function(){return ft})),n.d(o,"checkEinsumDimSizes",(function(){return mt})),n.d(o,"getEinsumComputePath",(function(){return gt})),n.d(o,"isIdentityPermutation",(function(){return bt})),n.d(o,"prepareSplitSize",(function(){return vt})),n.d(o,"getSparseFillEmptyRowsIndicesDenseShapeMismatch",(function(){return xt})),n.d(o,"getSparseFillEmptyRowsNegativeIndexErrorMessage",(function(){return wt})),n.d(o,"getSparseFillEmptyRowsOutOfRangeIndexErrorMessage",(function(){return kt})),n.d(o,"getSparseReshapeMultipleNegativeOneOutputDimErrorMessage",(function(){return It})),n.d(o,"getSparseReshapeNegativeOutputDimErrorMessage",(function(){return St})),n.d(o,"getSparseReshapeEmptyTensorZeroOutputDimErrorMessage",(function(){return Nt})),n.d(o,"getSparseReshapeInputOutputMultipleErrorMessage",(function(){return Tt})),n.d(o,"getSparseReshapeInputOutputMismatchErrorMessage",(function(){return Ot})),n.d(o,"getSparseSegmentReductionNegativeSegmentIdsErrorMessage",(function(){return Ct})),n.d(o,"getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage",(function(){return Et})),n.d(o,"getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage",(function(){return _t})),n.d(o,"getSparseSegmentReductionIndicesOutOfRangeErrorMessage",(function(){return At})),n.d(o,"segment_util",(function(){return i})),n.d(o,"fromUint8ToStringArray",(function(){return Mt})),n.d(o,"fromStringArrayToUint8",(function(){return jt}));var c={};n.r(c),n.d(c,"nonMaxSuppressionV3Impl",(function(){return Lt.a})),n.d(c,"nonMaxSuppressionV4Impl",(function(){return Lt.b})),n.d(c,"nonMaxSuppressionV5Impl",(function(){return Lt.c})),n.d(c,"whereImpl",(function(){return Pt.a}));n(169),n(170),n(127);var l=n(19),u=n(28),d=n(36);function h(e){return new Promise(e=>setTimeout(e)).then(e)}class p{constructor(e){if(!Object(l.b)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(p.URL_SCHEME)&&(e=e.slice(p.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],a=Object(u.j)(e,n),r=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=r,await h(()=>s.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await h(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Object(u.i)(e)}}}}p.URL_SCHEME="downloads://";class f{constructor(e){if(null==e||e.length<1)throw new Error("When calling browserFiles, at least 1 file is required, "+"but received ".concat(e));this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const n=new FileReader;n.onload=n=>{const a=JSON.parse(n.target.result),r=a.modelTopology;if(null==r)return void t(new Error("modelTopology field is missing from file ".concat(this.jsonFile.name)));if(null==a.weightsManifest)return void t(new Error("weightManifest field is missing from file ".concat(this.jsonFile.name)));if(0===this.weightsFiles.length)return void e({modelTopology:r});const s=Object(u.g)(a,e=>this.loadWeights(e));e(s)},n.onerror=e=>t("Failed to read model topology and weights manifest JSON "+"from file '".concat(this.jsonFile.name,"'. BrowserFiles supports loading ")+"Keras-style tf.Model artifacts only."),n.readAsText(this.jsonFile)})}loadWeights(e){const t=[],n=[];for(const s of e)t.push(...s.weights),n.push(...s.paths);const a=this.checkManifestAndWeightFiles(e),r=n.map(e=>this.loadWeightsFile(e,a[e]));return Promise.all(r).then(e=>[t,Object(u.d)(e)])}loadWeightsFile(e,t){return new Promise((n,a)=>{const r=new FileReader;r.onload=e=>{const t=e.target.result;n(t)},r.onerror=t=>a("Failed to weights data from file of path '".concat(e,"'.")),r.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map(e=>Object(u.c)(e.name)),a={};for(const r of e)r.paths.forEach(e=>{const r=Object(u.c)(e);if(-1!==t.indexOf(r))throw new Error("Duplicate file basename found in weights manifest: "+"'".concat(r,"'"));if(t.push(r),-1===n.indexOf(r))throw new Error("Weight file with basename '".concat(r,"' is not provided."));a[e]=this.weightsFiles[n.indexOf(r)]});if(t.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest "+"(".concat(t.length,") and the number of weight files provided ")+"(".concat(this.weightsFiles.length,")."));return a}}function m(e){return new f(e)}d.a.registerSaveRouter(e=>Object(l.b)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(p.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new p(e)}(e.slice(p.URL_SCHEME.length)):null);var g=n(9);function b(e,t,n,a){!function(e){Object(g.b)(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array")}(e),function(e,t){Object(g.b)(e>=0&&e<=1,()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(e)),Object(g.b)(t>=0&&t<=1,()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(t)),Object(g.b)(t>=e,()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(e," and endFraction ")+"".concat(t))}(n=null==n?0:n,a=null==a?1:a);let r=0;return Promise.all(e.map(s=>(s.then(s=>{const i=n+ ++r/e.length*(a-n);return t(i),s}),s)))}var y=n(133);async function v(e,t){null==t&&(t={});const n=null==t.fetchFunc?Object(l.b)().platform.fetch:t.fetchFunc,a=e.map(e=>n(e,t.requestInit,{isBinary:!0})),r=(null==t.onProgress?await Promise.all(a):await b(a,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?await Promise.all(r):await b(r,t.onProgress,.5,1)}async function x(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;const r=e=>v(e,{requestInit:a}),s=w(r);return s(e,t,n)}function w(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",a=arguments.length>2?arguments[2]:void 0;const r=t.map(()=>!1),s={},i=null!=a?a.map(()=>!1):[],o=[];if(t.forEach((e,t)=>{let n=0;e.weights.forEach(e=>{const c="quantization"in e?e.quantization.dtype:e.dtype,l=y.a[c]*g.O(e.shape),u=()=>{r[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=a?a.forEach((t,n)=>{t===e.name&&(u(),i[n]=!0)}):u(),o.push(e.name),n+=l})}),!i.every(e=>e)){const e=a.filter((e,t)=>!i[t]);throw new Error("Could not find weights in manifest with names: "+"".concat(e.join(", "),". \n")+"Manifest JSON has weights with names: "+"".concat(o.join(", "),"."))}const c=r.reduce((e,t,n)=>(t&&e.push(n),e),[]),l=[];c.forEach(e=>{t[e].paths.forEach(e=>{const t=n+(n.endsWith("/")?"":"/")+e;l.push(t)})});const d=await e(l),h={};let p=0;return c.forEach(e=>{const n=t[e].paths.length;let a=0;for(let t=0;t<n;t++)a+=d[p+t].byteLength;const r=new ArrayBuffer(a),i=new Uint8Array(r);let o=0;for(let t=0;t<n;t++){const e=new Uint8Array(d[p+t]);i.set(e,o),o+=e.byteLength}s[e].forEach(e=>{const t=r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),n=Object(u.e)(t,[e.manifestEntry]);for(const a in n)h[a]=n[a]}),p+=n}),h}}class k{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Object(g.b)("function"===typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Object(l.b)().platform.fetch,Object(g.b)(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Object(g.b)(2===e.length,()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(e.length,").")),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],a=Object(u.j)(e,n);t.body.append("model.json",new Blob([JSON.stringify(a)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:Object(u.i)(e),responses:[r]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(r.status,"."))}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(e.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let t;try{t=await e.json()}catch(r){let e="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=t.modelTopology,a=t.weightsManifest;if(null==n&&null==a)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return Object(u.g)(t,e=>this.loadWeights(e))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}(t),r=this.weightPathPrefix||n,s=Object(u.k)(e),i=[],o=[];for(const l of e)for(const e of l.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(e)):i.push(r+e+a);this.weightUrlConverter&&i.push(...await Promise.all(o));const c=await v(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[s,Object(u.d)(c)]}}function I(e){return null!=e.match(k.URL_SCHEME_REGEX)}k.URL_SCHEME_REGEX=/^https?:\/\//;const S=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>I(e)):I(e),n)return N(e,t)}return null};function N(e,t){return new k(e,t)}function T(e,t){return N(e,t)}d.a.registerSaveRouter(S),d.a.registerLoadRouter(S);class O{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class C{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class E{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function _(e,t,n,a){const r=arguments;return new E(A(...r))}function A(e,t,n,a){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new O(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new O({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new O({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a})}function R(e){return new C(e)}function D(e){return new C(e)}var F=n(83),M=n(15),j=n(5),z=n(3),L=n(56),P=n(6),B=n(2),W=n(11),U=n(4),V=n(165);let G;function H(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)a=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)r=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, "+"but was ".concat(e.constructor.name));o=!0}const c=Object(L.b)(z.kb,j.a.backendName);if(null!=c){const n={pixels:e},a={numChannels:t};return j.a.runKernel(z.kb,n,a)}const[l,u]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height];let d,h;if(i)d=e.getContext("2d").getImageData(0,0,l,u).data;else if(a||n)d=e.data;else if(s||r||o){if(null==G)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");G=new OffscreenCanvas(1,1).getContext("2d")}else G=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});G.canvas.width=l,G.canvas.height=u,G.drawImage(e,0,0,l,u),d=G.getImageData(0,0,l,u).data}if(4===t)h=new Int32Array(d);else{const e=l*u;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=d[4*n+e]}const p=[u,l,t];return Object(V.a)(h,p,"int32")}function q(e){return"undefined"!==typeof window&&"undefined"!==typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function K(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3,n=null;if(Object(l.b)().getBool("WRAP_TO_IMAGEBITMAP")&&q(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(a){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return H(n,t)}async function X(e,t){let n=Object(B.a)(e,"img","toPixels");if(!(e instanceof P.a)){const e=n;n=Object(W.a)(e,"int32"),e.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank ".concat(n.rank,"."));const[a,r]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2];if(s>4||2===s)throw new Error("toPixels only supports depth of size "+"1, 3 or 4 but got ".concat(s));if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error("Unsupported type for toPixels: ".concat(n.dtype,".")+" Please use float32 or int32 tensors.");const i=await n.data(),o="float32"===n.dtype?255:1,c=new Uint8ClampedArray(r*a*4);for(let l=0;l<a*r;++l){const e=[0,0,0,255];for(let a=0;a<s;a++){const t=i[l*s+a];if("float32"===n.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===n.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===s?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[a]=t*o}const t=4*l;c[t+0]=Math.round(e[0]),c[t+1]=Math.round(e[1]),c[t+2]=Math.round(e[2]),c[t+3]=Math.round(e[3])}if(null!=t){t.width=r,t.height=a;const e=t.getContext("2d"),n=new ImageData(c,r,a);e.putImageData(n,0,0)}return n!==e&&n.dispose(),c}const Z=Object(U.b)({fromPixels_:H});var Y=n(104);class J{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Q{constructor(){this.classNameMap={}}static getMap(){return null==Q.instance&&(Q.instance=new Q),Q.instance}static register(e){Q.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function $(e){Object(g.b)(null!=e.className,()=>"Class being registered does not have the static className property defined."),Object(g.b)("string"===typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),Object(g.b)(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Q.register(e)}var ee=n(21),te=n(10);const ne="3.21.0";var ae=n(24),re=n(31),se=n(17);class ie extends J{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:a,grads:r}=this.computeGradients(e,n);if(null!=n){const e=n.map(e=>({name:e.name,tensor:r[e.name]}));this.applyGradients(e)}else this.applyGradients(r);return Object(ae.b)(r),t?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Object(re.b)(e,t)}dispose(){null!=this.iterations_&&Object(ae.b)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Object(se.a)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(ie,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var oe=n(82),ce=n(20),le=n(12),ue=n(14),de=n(8),he=n(33),pe=n(23),fe=n(18);class me extends ie{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=j.a.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=j.a.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:Object(ae.h)(()=>Object(fe.a)(a).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:Object(ae.h)(()=>Object(fe.a)(a).variable(!1))});const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;Object(ae.h)(()=>{const e=Object(le.a)(Object(de.a)(s,this.rho),Object(de.a)(Object(pe.a)(r),1-this.rho)),t=Object(de.a)(Object(ue.a)(Object(he.a)(Object(le.a)(i,this.epsilon)),Object(he.a)(Object(le.a)(s,this.epsilon))),r),n=Object(le.a)(Object(de.a)(i,this.rho),Object(de.a)(Object(pe.a)(t),1-this.rho));s.assign(e),i.assign(n);const o=Object(le.a)(Object(de.a)(t,-this.learningRate),a);a.assign(o)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Object(ae.b)(this.accumulatedGrads.map(e=>e.variable)),Object(ae.b)(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedUpdates=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}me.className="Adadelta",$(me);var ge=n(71);class be extends ie{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=j.a.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:Object(ae.h)(()=>Object(ge.a)(a.shape,this.initialAccumulatorValue).variable(e))}}const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=this.accumulatedGrads[n].variable;Object(ae.h)(()=>{const e=Object(le.a)(s,Object(pe.a)(r));s.assign(e);const t=Object(le.a)(Object(de.a)(Object(ue.a)(r,Object(he.a)(Object(le.a)(e,j.a.backend.epsilon()))),-this.learningRate),a);a.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Object(ae.b)(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}be.className="Adagrad",$(be);var ye=n(48),ve=n(13);class xe extends ie{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Object(ae.h)(()=>{this.accBeta1=Object(se.a)(t).variable(),this.accBeta2=Object(se.a)(n).variable()}),null==a&&(this.epsilon=j.a.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Object(ae.h)(()=>{const n=Object(ve.a)(1,this.accBeta1),a=Object(ve.a)(1,this.accBeta2);t.forEach((t,r)=>{const s=j.a.registeredVariables[t];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:Object(ae.h)(()=>Object(fe.a)(s).variable(!1))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:"".concat(t,"/v"),variable:Object(ae.h)(()=>Object(fe.a)(s).variable(!1))});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const o=this.accumulatedFirstMoment[r].variable,c=this.accumulatedSecondMoment[r].variable,l=Object(le.a)(Object(de.a)(o,this.beta1),Object(de.a)(i,1-this.beta1)),u=Object(le.a)(Object(de.a)(c,this.beta2),Object(de.a)(Object(pe.a)(i),1-this.beta2)),d=Object(ue.a)(l,n),h=Object(ue.a)(u,a);o.assign(l),c.assign(u);const p=Object(le.a)(Object(de.a)(Object(ue.a)(d,Object(le.a)(Object(he.a)(h),this.epsilon)),-this.learningRate),s);s.assign(p)}),this.accBeta1.assign(Object(de.a)(this.accBeta1,this.beta1)),this.accBeta2.assign(Object(de.a)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Object(ae.b)(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&Object(ae.b)(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),Object(ae.h)(()=>{this.accBeta1.assign(Object(ye.a)(this.beta1,this.iterations_+1)),this.accBeta2.assign(Object(ye.a)(this.beta2,this.iterations_+1))});const t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedSecondMoment=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}xe.className="Adam",$(xe);var we=n(38),ke=n(91);class Ie extends ie{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Object(ae.h)(()=>{this.iteration=Object(se.a)(0).variable(),this.accBeta1=Object(se.a)(t).variable()}),null==a&&(this.epsilon=j.a.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Object(ae.h)(()=>{const n=Object(ve.a)(1,this.accBeta1),a=Object(ue.a)(-this.learningRate,Object(le.a)(Object(de.a)(this.iteration,this.decay),1));t.forEach((t,r)=>{const s=j.a.registeredVariables[t];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:Object(fe.a)(s).variable(!1)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:"".concat(t,"/v"),variable:Object(fe.a)(s).variable(!1)});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const o=this.accumulatedFirstMoment[r].variable,c=this.accumulatedWeightedInfNorm[r].variable,l=Object(le.a)(Object(de.a)(o,this.beta1),Object(de.a)(i,1-this.beta1)),u=Object(de.a)(c,this.beta2),d=Object(we.a)(i),h=Object(ke.a)(u,d);o.assign(l),c.assign(h);const p=Object(le.a)(Object(de.a)(Object(ue.a)(a,n),Object(ue.a)(l,Object(le.a)(h,this.epsilon))),s);s.assign(p)}),this.iteration.assign(Object(le.a)(this.iteration,1)),this.accBeta1.assign(Object(de.a)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Object(ae.b)(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&Object(ae.b)(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}Ie.className="Adamax",$(Ie);class Se extends ie{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const r=j.a.registeredVariables[t];Object(ae.h)(()=>{const e=Object(le.a)(Object(de.a)(this.c,a),r);r.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Object(ae.d)(Object(se.a)(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}Se.className="SGD",$(Se);class Ne extends Se{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Object(se.a)(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=j.a.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:Object(ae.h)(()=>Object(fe.a)(a).variable(e))}}const r=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&Object(ae.h)(()=>{let e;const t=Object(le.a)(Object(de.a)(this.m,r),s);e=this.useNesterov?Object(le.a)(Object(de.a)(this.c,Object(le.a)(s,Object(de.a)(t,this.m))),a):Object(le.a)(Object(de.a)(this.c,t),a),r.assign(t),a.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Object(ae.b)(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}Ne.className="Momentum",$(Ne);class Te extends ie{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==a&&(this.epsilon=j.a.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const a=j.a.registeredVariables[t];null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:Object(ae.h)(()=>Object(fe.a)(a).variable(!1))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:Object(ae.h)(()=>Object(fe.a)(a).variable(!1))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:Object(ae.h)(()=>Object(fe.a)(a).variable(!1))});const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;Object(ae.h)(()=>{const e=Object(le.a)(Object(de.a)(s,this.decay),Object(de.a)(Object(pe.a)(r),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,o=Object(le.a)(Object(de.a)(t,this.decay),Object(de.a)(r,1-this.decay)),c=Object(ue.a)(Object(de.a)(r,this.learningRate),Object(he.a)(Object(ve.a)(e,Object(le.a)(Object(pe.a)(o),this.epsilon)))),l=Object(le.a)(Object(de.a)(i,this.momentum),c);s.assign(e),t.assign(o),i.assign(l);const u=Object(ve.a)(a,l);a.assign(u)}else{const e=Object(le.a)(Object(de.a)(s,this.decay),Object(de.a)(Object(pe.a)(r),1-this.decay)),t=Object(le.a)(Object(de.a)(i,this.momentum),Object(ue.a)(Object(de.a)(r,this.learningRate),Object(he.a)(Object(le.a)(e,this.epsilon))));s.assign(e),i.assign(t);const n=Object(ve.a)(a,t);a.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Object(ae.b)(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&Object(ae.b)(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&Object(ae.b)(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2;this.accumulatedMeanSquares=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedMoments=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}Te.className="RMSProp",$(Te);class Oe{static sgd(e){return new Se(e)}static momentum(e,t){return new Ne(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new Te(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new xe(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new me(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new Ie(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new be(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}}const Ce={sgd:Oe.sgd,momentum:Oe.momentum,adadelta:Oe.adadelta,adagrad:Oe.adagrad,rmsprop:Oe.rmsprop,adamax:Oe.adamax,adam:Oe.adam};var Ee=n(200),_e=n(34);function Ae(e,t){const n=e[0].length;e.forEach((e,t)=>{g.b(e.length===n,()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same ")+"as the rank of the rest (".concat(n,")"))}),g.b(t>=0&&t<n,()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,"."));const a=e[0];e.forEach((e,r)=>{for(let s=0;s<n;s++)g.b(s===t||e[s]===a[s],()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(r,"] (").concat(e,") ")+"does not match the shape of the rest (".concat(a,") ")+"along the non-concatenated axis ".concat(r,"."))})}function Re(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var De,Fe=n(22),Me=n(39);function je(e,t,n){let a=new Array;if(null==n&&null==t)return a;if(null==t)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(null==n)return a;if(e+n.length!==a.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(a.length));for(let r=1;r<n.length;++r){const s=n[r],i=a[a.length-n.length+r],o=a[i];if(s>=0)if(o>=0){if(o!==s)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(r+e,"] = ").concat(s," but shape[").concat(r+e,"] = ").concat(o))}else a[i]=s}return a}function ze(e){const t={FIRST_DIM_SIZE:De.FIRST_DIM_SIZE,VALUE_ROWIDS:De.VALUE_ROWIDS,ROW_LENGTHS:De.ROW_LENGTHS,ROW_SPLITS:De.ROW_SPLITS,ROW_LIMITS:De.ROW_LIMITS,ROW_STARTS:De.ROW_STARTS},n=[];for(const a of e){if(!(a in t))break;n.push(t[a])}return n}function Le(e){return 0===e.length?0:e[0]===De.FIRST_DIM_SIZE?e.length-1:e.length}function Pe(e,t){if(null==e||null==t)return;const n=e.length,a=t.length;if(n>=a)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(a,")"));for(let r=0;r<Math.min(n,a-1);++r){const n=e[r],a=t[r+1];if(n>=0&&a>=0&&1!==n&&n!==a)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(r-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(r-e.length,"] = ").concat(a))}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(De||(De={}));const Be=30;function We(e){return e<=Be?e:Object(g.G)(e,Math.floor(Math.sqrt(e)))}function Ue(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function Ve(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=[];if(a)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function Ge(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=[];if(n){a.push(t);for(let n=t+1;n<e;++n)n<=2*t?(a.push(n),a.push(n-(t+1))):a.push(n)}else{const n=[],r=[];for(let a=1;a<e;++a)a>=2*t+1||a%2===1?r.push(a):n.push(a);a.push(...n),a.push(0),a.push(...r)}return a}function He(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?a?r.push(t[s-1]*e[s]):r.push(e[s]/t[s-1]):r.push(e[s]);return r}function qe(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function Ke(e,t,n){const a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}function Xe(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(a<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(a,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(t.dtype,"."));if(t.shape[a-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(t.shape[a-1]," vs. ").concat(n));if(0===Object(g.O)(e.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(e.shape,"."));const r=t.shape,s=r[r.length-1];let i=1;for(let d=0;d<r.length-1;++d)i*=r[d];const o=e.shape,c=r.slice();c.pop();let l=1;for(let d=s;d<n;++d)l*=o[d],c.push(o[d]);const u=[...Object(g.j)(e.shape).map(e=>e/l),1].slice(0,s);return[c,i,l,u]}var Ze=n(103),Ye=n(131);const Je=.3275911,Qe=.254829592,$e=-.284496736,et=1.421413741,tt=-1.453152027,nt=1.061405429;var at=n(68);function rt(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(e.length,", imag: ").concat(t.length,"."));const n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function st(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function it(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function ot(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function ct(e,t){return{real:e[2*t],imag:e[2*t+1]}}function lt(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function ut(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const s=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(s),a[r]=Math.sin(s)}return{real:n,imag:a}}function dt(e,t,n){const a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}const ht=/->/g;function pt(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(ht,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat("->",'").'));const[a,r]=e.split("->");Object(g.b)(-1===a.indexOf("..."),()=>'The ellipsis notation ("'.concat("...",'") is not supported yet.'));const s=a.split(","),i=s.length;if(t!==i)throw new Error("Expected ".concat(i," input tensors, received ").concat(t));if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let d=0;d<r.length;++d){const e=r[d];if(!s.some(t=>-1!==t.indexOf(e)))throw new Error("Output subscripts contain the label ".concat(e," ")+"not present in the input subscripts.");-1===o.indexOf(e)&&o.push(e)}for(let d=0;d<a.length;++d){const e=a[d];-1===o.indexOf(e)&&","!==e&&o.push(e)}const c=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error("Found duplicate axes in input component ".concat(s[d],". ")+"Support for duplicate axes in input is not implemented yet.");c[d]=[];for(let e=0;e<s[d].length;++e)c[d].push(o.indexOf(s[d][e]))}const l=o.length,u=[];for(let d=r.length;d<l;++d)u.push(d);return{allDims:o,summedDims:u,idDims:c}}function ft(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const a=[];for(let r=0;r<e;++r)-1===n[r]&&a.push(r);return n=n.filter(e=>-1!==e),{permutationIndices:n,expandDims:a}}function mt(e,t,n){const a=new Array(e);for(let r=0;r<n.length;++r){const e=n[r].shape;for(let n=0;n<t[r].length;++n)void 0===a[t[r][n]]?a[t[r][n]]=e[n]:Object(g.b)(a[t[r][n]]===e[n],()=>"Expected dimension ".concat(a[t[r][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(e),", ")+"but got dimension ".concat(e[n]))}}function gt(e,t){const n=e,a=[];let r=0;0===e.length&&n.push(-1),r=e.length+1;for(let i=0;i<r;++i)a.push([]);const s=[];for(let i=0;i<n.length;++i){const e=yt(t,n[i]);for(const t of e)-1===s.indexOf(t)&&(a[i].push(t),s.push(t))}return{path:n,steps:a}}function bt(e){return e.every((e,t)=>e===t)}function yt(e,t){const n=[];for(let a=0;a<e.length;++a)0!==e[a].length&&-1===e[a].indexOf(t)&&-1!==t||n.push(a);return n}function vt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=[];if("number"===typeof t)Object(g.b)(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),a=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce((e,t)=>(-1===t&&(e+=1),e),0);Object(g.b)(r<=1,()=>"There should be only one negative value in split array.");const s=t.indexOf(-1);if(-1!==s){const a=t.reduce((e,t)=>t>0?e+t:e);t[s]=e.shape[n]-a}Object(g.b)(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),a=t}return a}function xt(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function wt(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function kt(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function It(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function St(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function Nt(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Tt(e,t){const n=Object(g.O)(e),a=Object(g.O)(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(a,". inputShape=").concat(e," outputShape= ").concat(t)}function Ot(e,t){const n=Object(g.O)(e),a=Object(g.O)(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(a,". inputShape=").concat(e," outputShape=").concat(t)}function Ct(){return"segment ids must be >= 0"}function Et(){return"segment ids are not increasing"}function _t(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function At(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}function Rt(e,t){let n,a=!1;for(e<=Be?(n=e,a=!0):n=Object(g.G)(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=Object(g.G)(e,n+1);return n}function Dt(e,t,n){const a=[],r=e.length;for(let s=0;s<r;s++)s!==t?a.push(e[s]):a.push(n);return a}function Ft(e,t,n,a){const r=t.shape.length,s=e.shape.length;if(0!==a&&(a<-r||a>r))throw new Error("Expect batchDims in the range of [-".concat(r,", ").concat(r,"], but got ").concat(a));if(a<0&&(a+=r),a>s)throw new Error("batchDims (".concat(a,") must be less than rank(x) (\n    ").concat(s,")."));if(n<a)throw new Error("batchDims (".concat(a,") must be less than or equal to axis (").concat(n,")."));for(let d=0;d<a;++d)if(e.shape[d]!==t.shape[d])throw new Error("x.shape[".concat(d,"]: ").concat(e.shape[d]," should be equal to indices.shape[").concat(d,"]: ").concat(t.shape[d],"."));const i=e.shape[n],o=[];let c=1,l=1,u=1;for(let d=0;d<a;++d)o.push(e.shape[d]),c*=e.shape[d];for(let d=a;d<n;d++)o.push(e.shape[d]),l*=e.shape[d];for(let d=a;d<r;d++)o.push(t.shape[d]);for(let d=n+1;d<s;d++)o.push(e.shape[d]),u*=e.shape[d];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:i,outputShape:o}}function Mt(e){try{return e.map(e=>Object(te.decodeString)(e))}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(t))}}function jt(e){return e.map(e=>Object(te.encodeString)(e))}var zt=n(134),Lt=n(70),Pt=n(168),Bt=n(129)},function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));const a={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},function(e,t,n){"use strict";let a;function r(e){a=e}function s(e){if(void 0!==a)return a;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function i(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}n.r(t),n.d(t,"mockIsMobile",(function(){return r})),n.d(t,"isMobile",(function(){return s})),n.d(t,"isBrowser",(function(){return i}))},function(e,t,n){"use strict";function a(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}n.d(t,"a",(function(){return a}))},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=Object(s.a)(e,"x","all","bool"),o={x:i},c={axis:t,keepDims:n};return a.a.runKernel(r.f,o,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=Object(s.a)(e,"x","any","bool"),o={x:i},c={axis:t,keepDims:n};return a.a.runKernel(r.g,o,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Object(s.a)(e,"x","argMax"),i={x:n},o={axis:t};return a.a.runKernel(r.h,i,o)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Object(s.a)(e,"x","argMin"),i={x:n},o={axis:t};return a.a.runKernel(r.i,i,o)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(4);const c=Object(o.b)({atan2_:function(e,t){let n=Object(i.a)(e,"a","atan2"),o=Object(i.a)(t,"b","atan2");[n,o]=Object(s.makeTypesMatch)(n,o);const c={a:n,b:o};return a.a.runKernel(r.m,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(2),r=n(9),s=n(60),i=n(22),o=n(4),c=n(7);const l=Object(o.b)({conv1d_:function(e,t,n,o){let l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,d=arguments.length>6?arguments[6]:void 0;const h=Object(a.a)(e,"x","conv1d"),p=Object(a.a)(t,"filter","conv1d");let f=h,m=!1;2===h.rank&&(m=!0,f=Object(c.a)(h,[1,h.shape[0],h.shape[1]])),r.b(3===f.rank,()=>"Error in conv1d: input must be rank 3, but got rank ".concat(f.rank,".")),r.b(3===p.rank,()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(p.rank,".")),i.a("conv1d",o,d),r.b(f.shape[2]===p.shape[1],()=>"Error in conv1d: depth of input (".concat(f.shape[2],") must match ")+"input depth for filter ".concat(p.shape[1],".")),r.b(i.i(n,u),()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(u,"'")),r.b("NWC"===l,()=>"Error in conv1d: got dataFormat of ".concat(l," but only NWC is currently supported."));const g=Object(c.a)(p,[1,p.shape[0],p.shape[1],p.shape[2]]),b=Object(c.a)(f,[f.shape[0],1,f.shape[1],f.shape[2]]),y=[1,n],v=[1,u],x="NHWC",w=Object(s.a)(b,g,y,o,x,v,d);return m?Object(c.a)(w,[w.shape[2],w.shape[3]]):Object(c.a)(w,[w.shape[0],w.shape[2],w.shape[3]])}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var a=n(2),r=n(124),s=n(4);const i=Object(s.b)({conv2dTranspose_:function(e,t,n,s,i,o){const c=Object(a.a)(e,"x","conv2dTranspose"),l=Object(a.a)(t,"filter","conv2dTranspose");return Object(r.a)(n,c,l,s,i,"NHWC",o)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({cosh_:function(e){const t={x:Object(s.a)(e,"x","cosh","float32")};return a.a.runKernel(r.K,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4);const c=Object(o.b)({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const o=Object(s.a)(e,"x","depthToSpace","float32"),c="NHWC"===n?o.shape[1]:o.shape[2],l="NHWC"===n?o.shape[2]:o.shape[3],u="NHWC"===n?o.shape[3]:o.shape[1];i.b(t>1,()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t)),i.b(c*t>=0,()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(c," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(o.shape)),i.b(l*t>=0,()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(l," and ").concat(t," for depthToSpace with input shape\n        ").concat(o.shape)),i.b(u%(t*t)===0,()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(u," for depthToSpace with input shape ").concat(o.shape));const d={x:o},h={blockSize:t,dataFormat:n};return a.a.runKernel(r.P,d,h)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4),c=n(7);const l=Object(o.b)({dilation2d_:function(e,t,n,o){let l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const d=Object(s.a)(e,"x","dilation2d"),h=Object(s.a)(t,"filter","dilation2d");i.b(3===d.rank||4===d.rank,()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(d.rank,".")),i.b(3===h.rank,()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(h.rank,".")),i.b("NHWC"===u,()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(u));let p=d,f=!1;3===d.rank&&(p=Object(c.a)(d,[1,d.shape[0],d.shape[1],d.shape[2]]),f=!0);const m={x:p,filter:h},g={strides:n,pad:o,dilations:l},b=a.a.runKernel(r.U,m,g);return f?Object(c.a)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var a=n(21),r=n(2),s=n(14),i=n(86),o=n(4),c=n(30),l=n(18);const u=Object(o.b)({divNoNan_:function(e,t){let n=Object(r.a)(e,"a","div"),o=Object(r.a)(t,"b","div");[n,o]=Object(a.makeTypesMatch)(n,o);const u=Object(s.a)(n,o),d=Object(l.a)(u),h=Object(i.a)(o,d);return Object(c.a)(h,d,u)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(2),r=n(9),s=n(25),i=n(4),o=n(7);const c=Object(i.b)({dot_:function(e,t){const n=Object(a.a)(e,"t1","dot"),i=Object(a.a)(t,"t2","dot");r.b((1===n.rank||2===n.rank)&&(1===i.rank||2===i.rank),()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(i.rank,"."));const c=1===n.rank?n.size:n.shape[1],l=1===i.rank?i.size:i.shape[0];if(r.b(c===l,()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(c," and ").concat(l,".")),1===n.rank&&1===i.rank){const e=Object(o.a)(n,[1,-1]),t=Object(o.a)(i,[-1,1]),a=Object(s.a)(e,t);return Object(o.a)(a,[])}if(1===n.rank&&2===i.rank){const e=Object(o.a)(n,[1,-1]),t=Object(o.a)(i,[i.shape[0],i.shape[1]]),a=Object(s.a)(e,t);return Object(o.a)(a,[a.size])}if(2===n.rank&&1===i.rank){const e=Object(o.a)(i,[-1,1]),t=Object(s.a)(n,e);return Object(o.a)(t,[t.size])}{const e=Object(o.a)(i,[i.shape[0],i.shape[1]]);return Object(s.a)(n,e)}}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var a=n(87),r=n(4);const s=Object(r.b)({euclideanNorm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Object(a.a)(e,"euclidean",t,n)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4),c=n(7);const l=Object(o.b)({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const u=Object(s.a)(e,"x","localResponseNormalization");i.b(4===u.rank||3===u.rank,()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(u.rank,".")),i.b(i.v(t),()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(t,"."));let d=u,h=!1;3===u.rank&&(h=!0,d=Object(c.a)(u,[1,u.shape[0],u.shape[1],u.shape[2]]));const p={x:d},f={depthRadius:t,bias:n,alpha:o,beta:l},m=a.a.runKernel(r.yb,p,f);return h?Object(c.a)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({log1p_:function(e){const t={x:Object(s.a)(e,"x","log1p")};return a.a.runKernel(r.Fb,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({softplus_:function(e){const t={x:Object(s.a)(e,"x","softplus")};return a.a.runKernel(r.Lc,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(2),r=n(15),s=n(53),i=n(90),o=n(114),c=n(4);const l=Object(c.b)({logicalXor_:function(e,t){const n=Object(a.a)(e,"a","logicalXor","bool"),c=Object(a.a)(t,"b","logicalXor","bool");return Object(r.assertAndGetBroadcastShape)(n.shape,c.shape),Object(s.a)(Object(o.a)(e,t),Object(i.a)(Object(s.a)(e,t)))}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4);const c=Object(o.b)({mirrorPad_:function(e,t,n){i.b("reflect"===n||"symmetric"===n,()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,"."));const o=Object(s.a)(e,"x","mirrorPad");if(0===o.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");i.b(t.length===o.rank,()=>"Padding doesn't match input. Must be ".concat(o.rank,". ")+"Got ".concat(t.length,"."));const c="reflect"===n?1:0;for(let a=0;a<o.rank;a++)i.b(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),i.b(t[a][0]>=0&&t[a][0]<=o.shape[a]-c&&t[a][1]>=0&&t[a][1]<=o.shape[a]-c,()=>"Padding in dimension ".concat(a," cannot be greater than or equal ")+"to ".concat(o.shape[a]-c," or less than 0 for input of ")+"shape ".concat(o.shape));const l={paddings:t,mode:n},u={x:o};return a.a.runKernel(r.Ub,u,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(21),i=n(2),o=n(4);const c=Object(o.b)({mod_:function(e,t){let n=Object(i.a)(e,"a","mod"),o=Object(i.a)(t,"b","mod");[n,o]=Object(s.makeTypesMatch)(n,o);const c={a:n,b:o};return a.a.runKernel(r.Vb,c)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));const c=Object(s.a)(e,"indices","oneHot","int32"),l={indices:c},u={dtype:o,depth:t,onValue:n,offValue:i};return a.a.runKernel(r.dc,l,u)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return h}));var a=n(2),r=n(9),s=n(105),i=n(84),o=n(22),c=n(115),l=n(4),u=n(7),d=n(92);const h=Object(l.b)({pool_:function(e,t,n,l,h,p,f){null==h&&(h=[1,1]),null==p&&(p=1),0===l&&(l="valid");const m=Object(a.a)(e,"x","maxPool");let g=m,b=!1;3===m.rank&&(b=!0,g=Object(u.a)(m,[1,m.shape[0],m.shape[1],m.shape[2]])),r.b(o.i(p,h),()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(p," and dilations '").concat(h,"'"));const y=o.f(g.shape,t,p,h,l),v=[y.dilationHeight,y.dilationWidth];let x;x="same"===l?function(e,t){const n=e.map((e,n)=>e+(e-1)*(t[n]-1)).map(e=>e-1),a=n.map(e=>Math.floor(e/2)),r=n.map((e,t)=>e-a[t]);return n.map((e,t)=>[a[t],r[t]])}([y.filterHeight,y.filterWidth],v):[[0,0],[0,0]];const w=1===v[0]&&1===v[1],[k,I]=function(e,t,n){const a=n.map(e=>e[0]),r=n.map(e=>e[1]),s=e.concat(a,r),i=t.map((e,t)=>(e-s[t]%e)%e),o=r.map((e,t)=>e+i[t]),c=t.map((e,t)=>[a[t],o[t]]),l=t.map((e,t)=>[0,i[t]]);return[c,l]}([y.inHeight,y.inWidth],v,x),S=w?l:"valid",N=w?g:Object(d.a)(g,v,k),T=("avg"===n?()=>Object(s.a)(N,t,p,S,f):()=>Object(c.a)(N,t,p,S,f))(),O=w?T:Object(i.a)(T,v,I);return b?Object(u.a)(O,[O.shape[1],O.shape[2],O.shape[3]]):O}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(11),o=n(4);const c=Object(o.b)({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=Object(s.a)(e,"x","prod");"bool"===o.dtype&&(o=Object(i.a)(o,"int32"));const c={x:o},l={axis:t,keepDims:n};return a.a.runKernel(r.jc,c,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({round_:function(e){const t={x:Object(s.a)(e,"x","round")};return a.a.runKernel(r.zc,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({rsqrt_:function(e){const t={x:Object(s.a)(e,"x","rsqrt","float32")};return a.a.runKernel(r.Ac,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({selu_:function(e){const t={x:Object(s.a)(e,"x","selu")};return a.a.runKernel(r.Ec,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(2),r=n(9),s=n(60),i=n(85),o=n(4),c=n(7);const l=Object(o.b)({separableConv2d_:function(e,t,n,o,l){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],d=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const h=Object(a.a)(e,"x","separableConv2d"),p=Object(a.a)(t,"depthwiseFilter","separableConv2d"),f=Object(a.a)(n,"pointwiseFilter","separableConv2d");let m=h,g=!1;if(3===h.rank&&(g=!0,m=Object(c.a)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),"NCHW"===d)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");r.b(4===m.rank,()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(m.rank,".")),r.b(4===p.rank,()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(p.rank,".")),r.b(4===f.rank,()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(p.rank,".")),r.b(1===f.shape[0],()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(f.shape[0],".")),r.b(1===f.shape[1],()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(f.shape[1],"."));const b=p.shape[2],y=p.shape[3];r.b(f.shape[2]===b*y,()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(b*y,", ")+"but got ".concat(f.shape[2],"."));const v=Object(i.a)(m,p,o,l,d,u),x=1,w=Object(s.a)(v,f,x,"valid",d);return g?Object(c.a)(w,[w.shape[1],w.shape[2],w.shape[3]]):w}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({sin_:function(e){const t={x:Object(s.a)(e,"x","sin","float32")};return a.a.runKernel(r.Hc,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({sinh_:function(e){const t={x:Object(s.a)(e,"x","sinh")};return a.a.runKernel(r.Ic,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return f}));var a=n(47),r=n(29),s=n(89),i=n(8),o=n(4),c=n(81),l=n(7),u=n(44),d=n(17),h=n(26),p=n(98);const f=Object(o.b)({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let o;if(t<=2){const a=Object(l.a)(e,[n,t]);o=Object(p.a)(a)}else{const f=[n,2*(t-1)],m=Object(l.a)(Object(c.a)(e),[n,t]),g=Object(l.a)(Object(s.a)(e),[n,t]),b=Object(u.a)(Object(h.a)(m,[0,1],[n,t-2]),1),y=Object(i.a)(Object(u.a)(Object(h.a)(g,[0,1],[n,t-2]),1),Object(d.a)(-1)),v=Object(r.a)([m,b],1),x=Object(r.a)([g,y],1),w=Object(l.a)(Object(a.a)(v,x),[f[0],f[1]]);o=Object(p.a)(w)}if(o=Object(c.a)(o),3===e.rank&&0!==e.shape[0]){const t=o,n=e.shape[0];o=Object(l.a)(o,[n,o.shape[0]/n,o.shape[1]]),t.dispose()}return o}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var a=n(2),r=n(9),s=n(46);function i(e,t,n){if(Object(r.d)(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const i=Object(a.c)(e,n);if(3!==i.length&&1!==i.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Object(s.a)(e,t,i,n)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const i=Object(s.a)(e,"x","topk");if(0===i.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const o=i.shape[i.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>o)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(o,") ")+"but got ".concat(t));const c={x:i},l={k:t,sorted:n},[u,d]=a.a.runKernel(r.gd,c,l);return{values:u,indices:d}}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4);const c=Object(o.b)({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Object(s.a)(e,"x","unique","string_or_numeric");Object(i.b)(n.rank>0,()=>"The input tensor must be at least 1D");const o={x:n},c={axis:t},[l,u]=a.a.runKernel(r.jd,o,c);return{values:l,indices:u}}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));var a=n(43);function r(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const r=Object(a.a)(e,"int32"),s=Object(a.a)([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const t=r.indexToLoc(n[a]),i=a*e.length;s.values.set(t,i)}return s.toTensor()}},function(e,t,n){"use strict";n.d(t,"a",(function(){return c})),n.d(t,"b",(function(){return u}));n(127);var a=n(19),r=n(28),s=n(36);function i(){if(!Object(a.b)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function o(e){const t=e.result;t.createObjectStore("models_store",{keyPath:"modelPath"}),t.createObjectStore("model_info_store",{keyPath:"modelPath"})}class c{constructor(e){if(this.indexedDB=i(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((e,n)=>{const a=this.indexedDB.open("tensorflowjs",1);a.onupgradeneeded=()=>o(a),a.onsuccess=()=>{const s=a.result;if(null==t){const t=s.transaction("models_store","readonly"),a=t.objectStore("models_store").get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return s.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));e(a.result.modelArtifacts)},a.onerror=e=>(s.close(),n(a.error)),t.oncomplete=()=>s.close()}else{const a=Object(r.i)(t),i=s.transaction("model_info_store","readwrite");let o=i.objectStore("model_info_store");const c=o.put({modelPath:this.modelPath,modelArtifactsInfo:a});let l;c.onsuccess=()=>{l=s.transaction("models_store","readwrite");const r=l.objectStore("models_store").put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});r.onsuccess=()=>e({modelArtifactsInfo:a}),r.onerror=e=>{o=i.objectStore("model_info_store");const t=o.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(r.error)),t.onerror=e=>(s.close(),n(r.error))}},c.onerror=e=>(s.close(),n(c.error)),i.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}}},a.onerror=e=>n(a.error)})}}c.URL_SCHEME="indexeddb://";const l=e=>{return Object(a.b)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(c.URL_SCHEME)?(t=e.slice(c.URL_SCHEME.length),new c(t)):null;var t};s.a.registerSaveRouter(l),s.a.registerLoadRouter(l);class u{constructor(){this.indexedDB=i()}async listModels(){return new Promise((e,t)=>{const n=this.indexedDB.open("tensorflowjs",1);n.onupgradeneeded=()=>o(n),n.onsuccess=()=>{const a=n.result,r=a.transaction("model_info_store","readonly"),s=r.objectStore("model_info_store").getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(a.close(),t(s.error)),r.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)})}async removeModel(e){var t;return e=(t=e).startsWith(c.URL_SCHEME)?t.slice(c.URL_SCHEME.length):t,new Promise((t,n)=>{const a=this.indexedDB.open("tensorflowjs",1);a.onupgradeneeded=()=>o(a),a.onsuccess=()=>{const r=a.result,s=r.transaction("model_info_store","readwrite"),i=s.objectStore("model_info_store"),o=i.get(e);let c;o.onsuccess=()=>{if(null==o.result)return r.close(),n(new Error("Cannot find model with path '".concat(e,"' ")+"in IndexedDB."));{const a=i.delete(e),s=()=>{c=r.transaction("models_store","readwrite");const a=c.objectStore("models_store").delete(e);a.onsuccess=()=>t(o.result.modelArtifactsInfo),a.onerror=e=>n(o.error)};a.onsuccess=s,a.onerror=e=>(s(),r.close(),n(o.error))}},o.onerror=e=>(r.close(),n(o.error)),s.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}},a.onerror=e=>n(a.error)})}}},function(e,t,n){"use strict";n.d(t,"a",(function(){return g})),n.d(t,"b",(function(){return y}));n(127);var a=n(19),r=n(9),s=n(28),i=n(36);const o="tensorflowjs_models",c="info",l="model_topology",u="weight_specs",d="weight_data",h="model_metadata";function p(e){return{info:[o,e,c].join("/"),topology:[o,e,l].join("/"),weightSpecs:[o,e,u].join("/"),weightData:[o,e,d].join("/"),modelMetadata:[o,e,h].join("/")}}function f(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function m(e){const t=e.split("/");if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join("/")}class g{constructor(e){if(!Object(a.b)().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=p(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),a=JSON.stringify(e.weightSpecs),r=Object(s.i)(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,a),this.LS.setItem(this.keys.weightData,Object(s.a)(e.weightData));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:r}}catch(t){throw f(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(r.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(r.weightSpecsBytes,", ")+"weightDataBytes=".concat(r.weightDataBytes,"."))}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");t.modelTopology=n;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");t.weightSpecs=a;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(null==i)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return t.weightData=Object(s.b)(i),t}}g.URL_SCHEME="localstorage://";const b=e=>{return Object(a.b)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(g.URL_SCHEME)?(t=e.slice(g.URL_SCHEME.length),new g(t)):null;var t};i.a.registerSaveRouter(b),i.a.registerLoadRouter(b);class y{constructor(){Object(r.b)(Object(a.b)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Object(r.b)("undefined"===typeof window||"undefined"!==typeof window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=o+"/",n="/"+c;for(let a=0;a<this.LS.length;++a){const r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){e[m(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){var t;const n=p(e=(t=e).startsWith(g.URL_SCHEME)?t.slice(g.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(e,"'"));const a=JSON.parse(this.LS.getItem(n.info));return f(n),a}}},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var a=n(5),r=n(3),s=n(9),i=n(4),o=n(7);const c=Object(i.b)({conv3DBackpropInput_:function(e,t,n,i,c){s.b(e.length===t.rank,()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match"));let l=e,u=t,d=!1;4===t.rank&&(d=!0,u=Object(o.a)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),l=[1,e[0],e[1],e[2],e[3]]);const h=l[4],p=u.shape[4];s.b(5===l.length,()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(l.length,".")),s.b(5===u.rank,()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(u.rank)),s.b(5===n.rank,()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank)),s.b(h===n.shape[3],()=>"Error in conv3dDerInput: depth of input (".concat(h,") must ")+"match input depth for filter ".concat(n.shape[3],".")),s.b(p===n.shape[4],()=>"Error in conv3dDerInput: depth of output (".concat(p,") must ")+"match output depth for filter ".concat(n.shape[4],"."));const f={dy:u,filter:n},m={pad:c,strides:i,inputShape:l},g=a.a.runKernel(r.I,f,m);return d?Object(o.a)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4),c=n(7);const l=Object(o.b)({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const l=Object(s.a)(e,"images","resizeNearestNeighbor");i.b(3===l.rank||4===l.rank,()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(l.rank,".")),i.b(2===t.length,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(t,".")),i.b("float32"===l.dtype||"int32"===l.dtype,()=>"`images` must have `int32` or `float32` as dtype"),i.b(!1===o||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let u=l,d=!1;3===l.rank&&(d=!0,u=Object(c.a)(l,[1,l.shape[0],l.shape[1],l.shape[2]]));const[]=t,h={images:u},p={alignCorners:n,halfPixelCenters:o,size:t},f=a.a.runKernel(r.vc,h,p);return d?Object(c.a)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(4),c=n(7);const l=Object(o.b)({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const l=Object(s.a)(e,"images","resizeBilinear");i.b(3===l.rank||4===l.rank,()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(l.rank,".")),i.b(2===t.length,()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(t,".")),i.b(!1===o||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let u=l,d=!1;3===l.rank&&(d=!0,u=Object(c.a)(l,[1,l.shape[0],l.shape[1],l.shape[2]]));const[]=t,h={images:u},p={alignCorners:n,halfPixelCenters:o,size:t},f=a.a.runKernel(r.tc,h,p);return d?Object(c.a)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(4),i=n(7);const o=Object(s.b)({depthwiseConv2dNativeBackpropInput_:function(e,t,n,s,o){let c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],l=arguments.length>6?arguments[6]:void 0,u=t,d=!1;3===t.rank&&(d=!0,u=Object(i.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={dy:u,filter:n},p={strides:s,pad:o,dimRoundingMode:l,dilations:c,inputShape:e},f=a.a.runKernel(r.S,h,p);return d?Object(i.a)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(4),i=n(7);const o=Object(s.b)({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,s,o){let c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],l=arguments.length>6?arguments[6]:void 0,u=e;3===e.rank&&(u=Object(i.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let d=t;3===d.rank&&(d=Object(i.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={x:u,dy:d},p={strides:s,pad:o,dimRoundingMode:l,dilations:c,filterShape:n};return a.a.runKernel(r.R,h,p)}})},function(e,t,n){(function(e){var a="undefined"!==typeof e&&e||"undefined"!==typeof self&&self||window,r=Function.prototype.apply;function s(e,t){this._id=e,this._clearFn=t}t.setTimeout=function(){return new s(r.call(setTimeout,a,arguments),clearTimeout)},t.setInterval=function(){return new s(r.call(setInterval,a,arguments),clearInterval)},t.clearTimeout=t.clearInterval=function(e){e&&e.close()},s.prototype.unref=s.prototype.ref=function(){},s.prototype.close=function(){this._clearFn.call(a,this._id)},t.enroll=function(e,t){clearTimeout(e._idleTimeoutId),e._idleTimeout=t},t.unenroll=function(e){clearTimeout(e._idleTimeoutId),e._idleTimeout=-1},t._unrefActive=t.active=function(e){clearTimeout(e._idleTimeoutId);var t=e._idleTimeout;t>=0&&(e._idleTimeoutId=setTimeout((function(){e._onTimeout&&e._onTimeout()}),t))},n(247),t.setImmediate="undefined"!==typeof self&&self.setImmediate||"undefined"!==typeof e&&e.setImmediate||this&&this.setImmediate,t.clearImmediate="undefined"!==typeof self&&self.clearImmediate||"undefined"!==typeof e&&e.clearImmediate||this&&this.clearImmediate}).call(this,n(100))},function(e,t){e.exports=a;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(T){}function a(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}a.prototype.__isLong__,Object.defineProperty(a.prototype,"__isLong__",{value:!0}),a.isLong=r;var s={},i={};function o(e,t){var n,a,r;return t?(r=0<=(e>>>=0)&&e<256)&&(a=i[e])?a:(n=l(e,(0|e)<0?-1:0,!0),r&&(i[e]=n),n):(r=-128<=(e|=0)&&e<128)&&(a=s[e])?a:(n=l(e,e<0?-1:0,!1),r&&(s[e]=n),n)}function c(e,t){if(isNaN(e))return t?y:b;if(t){if(e<0)return y;if(e>=f)return I}else{if(e<=-m)return S;if(e+1>=m)return k}return e<0?c(-e,t).neg():l(e%p|0,e/p|0,t)}function l(e,t,n){return new a(e,t,n)}a.fromInt=o,a.fromNumber=c,a.fromBits=l;var u=Math.pow;function d(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return b;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var a;if((a=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===a)return d(e.substring(1),t,n).neg();for(var r=c(u(n,8)),s=b,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),l=parseInt(e.substring(i,i+o),n);if(o<8){var h=c(u(n,o));s=s.mul(h).add(c(l))}else s=(s=s.mul(r)).add(c(l))}return s.unsigned=t,s}function h(e,t){return"number"===typeof e?c(e,t):"string"===typeof e?d(e,t):l(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}a.fromString=d,a.fromValue=h;var p=4294967296,f=p*p,m=f/2,g=o(1<<24),b=o(0);a.ZERO=b;var y=o(0,!0);a.UZERO=y;var v=o(1);a.ONE=v;var x=o(1,!0);a.UONE=x;var w=o(-1);a.NEG_ONE=w;var k=l(-1,2147483647,!1);a.MAX_VALUE=k;var I=l(-1,-1,!0);a.MAX_UNSIGNED_VALUE=I;var S=l(0,-2147483648,!1);a.MIN_VALUE=S;var N=a.prototype;N.toInt=function(){return this.unsigned?this.low>>>0:this.low},N.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},N.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=c(e),n=this.div(t),a=n.mul(t).sub(this);return n.toString(e)+a.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var r=c(u(e,6),this.unsigned),s=this,i="";;){var o=s.div(r),l=(s.sub(o.mul(r)).toInt()>>>0).toString(e);if((s=o).isZero())return l+i;for(;l.length<6;)l="0"+l;i=""+l+i}},N.getHighBits=function(){return this.high},N.getHighBitsUnsigned=function(){return this.high>>>0},N.getLowBits=function(){return this.low},N.getLowBitsUnsigned=function(){return this.low>>>0},N.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},N.isZero=function(){return 0===this.high&&0===this.low},N.eqz=N.isZero,N.isNegative=function(){return!this.unsigned&&this.high<0},N.isPositive=function(){return this.unsigned||this.high>=0},N.isOdd=function(){return 1===(1&this.low)},N.isEven=function(){return 0===(1&this.low)},N.equals=function(e){return r(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},N.eq=N.equals,N.notEquals=function(e){return!this.eq(e)},N.neq=N.notEquals,N.ne=N.notEquals,N.lessThan=function(e){return this.comp(e)<0},N.lt=N.lessThan,N.lessThanOrEqual=function(e){return this.comp(e)<=0},N.lte=N.lessThanOrEqual,N.le=N.lessThanOrEqual,N.greaterThan=function(e){return this.comp(e)>0},N.gt=N.greaterThan,N.greaterThanOrEqual=function(e){return this.comp(e)>=0},N.gte=N.greaterThanOrEqual,N.ge=N.greaterThanOrEqual,N.compare=function(e){if(r(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},N.comp=N.compare,N.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(v)},N.neg=N.negate,N.add=function(e){r(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,a=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,c=e.low>>>16,u=0,d=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,d+=(p+=a+c)>>>16,u+=(d+=n+o)>>>16,u+=t+i,l((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(d&=65535),this.unsigned)},N.subtract=function(e){return r(e)||(e=h(e)),this.add(e.neg())},N.sub=N.subtract,N.multiply=function(e){if(this.isZero())return b;if(r(e)||(e=h(e)),n)return l(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return b;if(this.eq(S))return e.isOdd()?S:b;if(e.eq(S))return this.isOdd()?S:b;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return c(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,a=65535&this.high,s=this.low>>>16,i=65535&this.low,o=e.high>>>16,u=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,m=0,y=0,v=0;return y+=(v+=i*p)>>>16,m+=(y+=s*p)>>>16,y&=65535,m+=(y+=i*d)>>>16,f+=(m+=a*p)>>>16,m&=65535,f+=(m+=s*d)>>>16,m&=65535,f+=(m+=i*u)>>>16,f+=t*p+a*d+s*u+i*o,l((y&=65535)<<16|(v&=65535),(f&=65535)<<16|(m&=65535),this.unsigned)},N.mul=N.multiply,N.divide=function(e){if(r(e)||(e=h(e)),e.isZero())throw Error("division by zero");var t,a,s;if(n)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:b;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return x;s=y}else{if(this.eq(S))return e.eq(v)||e.eq(w)?S:e.eq(S)?v:(t=this.shr(1).div(e).shl(1)).eq(b)?e.isNegative()?v:w:(a=this.sub(e.mul(t)),s=t.add(a.div(e)));if(e.eq(S))return this.unsigned?y:b;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=b}for(a=this;a.gte(e);){t=Math.max(1,Math.floor(a.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(t)/Math.LN2),o=i<=48?1:u(2,i-48),d=c(t),p=d.mul(e);p.isNegative()||p.gt(a);)p=(d=c(t-=o,this.unsigned)).mul(e);d.isZero()&&(d=v),s=s.add(d),a=a.sub(p)}return s},N.div=N.divide,N.modulo=function(e){return r(e)||(e=h(e)),n?l((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},N.mod=N.modulo,N.rem=N.modulo,N.not=function(){return l(~this.low,~this.high,this.unsigned)},N.and=function(e){return r(e)||(e=h(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},N.or=function(e){return r(e)||(e=h(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},N.xor=function(e){return r(e)||(e=h(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},N.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},N.shl=N.shiftLeft,N.shiftRight=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},N.shr=N.shiftRight,N.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},N.shru=N.shiftRightUnsigned,N.shr_u=N.shiftRightUnsigned,N.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},N.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},N.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},N.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},N.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},a.fromBytes=function(e,t,n){return n?a.fromBytesLE(e,t):a.fromBytesBE(e,t)},a.fromBytesLE=function(e,t){return new a(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},a.fromBytesBE=function(e,t){return new a(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},function(e,t,n){"use strict";var a=Object.getOwnPropertySymbols,r=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;function i(e){if(null===e||void 0===e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var t={},n=0;n<10;n++)t["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(t).map((function(e){return t[e]})).join(""))return!1;var a={};return"abcdefghijklmnopqrst".split("").forEach((function(e){a[e]=e})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},a)).join("")}catch(r){return!1}}()?Object.assign:function(e,t){for(var n,o,c=i(e),l=1;l<arguments.length;l++){for(var u in n=Object(arguments[l]))r.call(n,u)&&(c[u]=n[u]);if(a){o=a(n);for(var d=0;d<o.length;d++)s.call(n,o[d])&&(c[o[d]]=n[o[d]])}}return c}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({acos_:function(e){const t={x:Object(s.a)(e,"x","acos")};return a.a.runKernel(r.b,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({acosh_:function(e){const t={x:Object(s.a)(e,"x","acosh")};return a.a.runKernel(r.c,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({asin_:function(e){const t={x:Object(s.a)(e,"x","asin")};return a.a.runKernel(r.j,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({asinh_:function(e){const t={x:Object(s.a)(e,"x","asinh")};return a.a.runKernel(r.k,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({atan_:function(e){const t={x:Object(s.a)(e,"x","atan")};return a.a.runKernel(r.l,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({atanh_:function(e){const t={x:Object(s.a)(e,"x","atanh")};return a.a.runKernel(r.n,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({ceil_:function(e){const t={x:Object(s.a)(e,"x","ceil","float32")};return a.a.runKernel(r.y,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(71),c=n(4);const l=Object(c.b)({clipByValue_:function(e,t,n){const c=Object(s.a)(e,"x","clipByValue");if(i.b(t<=n,()=>"Error in clip: min (".concat(t,") must be ")+"less than or equal to max (".concat(n,").")),t===n)return Object(o.a)(c.shape,t,c.dtype);const l={x:c},u={clipValueMin:t,clipValueMax:n};return a.a.runKernel(r.z,l,u)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var a=n(5),r=n(3),s=n(2),i=n(9),o=n(11),c=n(4);const l=Object(c.b)({erf_:function(e){let t=Object(s.a)(e,"x","erf");i.b("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=Object(o.a)(t,"float32"));const n={x:t};return a.a.runKernel(r.bb,n)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({expm1_:function(e){const t={x:Object(s.a)(e,"x","expm1")};return a.a.runKernel(r.eb,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({isFinite_:function(e){const t={x:Object(s.a)(e,"x","isFinite")};return a.a.runKernel(r.vb,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({isInf_:function(e){const t={x:Object(s.a)(e,"x","isInf")};return a.a.runKernel(r.wb,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({isNaN_:function(e){const t={x:Object(s.a)(e,"x","isNaN")};return a.a.runKernel(r.xb,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var a=n(31),r=n(2),s=n(8),i=n(27),o=n(4),c=n(63),l=n(151);const u=Object(o.b)({logSigmoid_:function(e){const t=Object(r.a)(e,"x","logSigmoid");return Object(a.a)(e=>({value:Object(i.a)(Object(l.a)(Object(i.a)(e))),gradFunc:t=>Object(s.a)(t,Object(c.a)(Object(i.a)(e)))}))(t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return p}));var a=n(31),r=n(2),s=n(11),i=n(35),o=n(67),c=n(64),l=n(8),u=n(4),d=n(13),h=n(16);const p=Object(u.b)({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Object(r.a)(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(t));const u=Object(a.a)((e,n)=>{const a=Object(c.a)(e,t,!0),r=Object(d.a)(e,a),u=Object(d.a)(Object(s.a)(r,"float32"),Object(o.a)(Object(h.a)(Object(i.a)(r),t,!0)));n([u]);return{value:u,gradFunc:(e,n)=>{const[a]=n,r=Object(i.a)(a);return Object(d.a)(e,Object(l.a)(Object(h.a)(e,t,!0),r))}}});return u(n)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({onesLike_:function(e){const t={x:Object(s.a)(e,"x","onesLike")};return a.a.runKernel(r.ec,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({reciprocal_:function(e){const t={x:Object(s.a)(e,"x","reciprocal")};return a.a.runKernel(r.pc,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({sign_:function(e){const t={x:Object(s.a)(e,"x","sign")};return a.a.runKernel(r.Gc,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Object(s.a)(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(t));const i={logits:n},o={dim:t};return a.a.runKernel(r.Kc,i,o)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({stridedSlice_:function(e,t,n,i){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,d=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const h=Object(s.a)(e,"x","stridedSlice","string_or_numeric"),p={x:h},f={begin:t,end:n,strides:i,beginMask:o,endMask:c,ellipsisMask:l,newAxisMask:u,shrinkAxisMask:d};return a.a.runKernel(r.Xc,p,f)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var a=n(5),r=n(3),s=n(2),i=n(4);const o=Object(i.b)({tan_:function(e){const t={x:Object(s.a)(e,"x","tan","float32")};return a.a.runKernel(r.dd,t)}})},function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return r}));const a="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof e?e:e=>e();function r(){return new Promise(e=>a(()=>e()))}}).call(this,n(176).setImmediate)},function(e,t,n){(function(t,n,a,r){e.exports=function e(t,n,a){function r(i,o){if(!n[i]){if(!t[i]){if(s)return s(i,!0);var c=new Error("Cannot find module '"+i+"'");throw c.code="MODULE_NOT_FOUND",c}var l=n[i]={exports:{}};t[i][0].call(l.exports,(function(e){return r(t[i][1][e]||e)}),l,l.exports,e,t,n,a)}return n[i].exports}for(var s=!1,i=0;i<a.length;i++)r(a[i]);return r}({1:[function(e,t,n){"use strict";var a=e("./utils"),r=e("./support"),s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";n.encode=function(e){for(var t,n,r,i,o,c,l,u=[],d=0,h=e.length,p=h,f="string"!==a.getTypeOf(e);d<e.length;)p=h-d,r=f?(t=e[d++],n=d<h?e[d++]:0,d<h?e[d++]:0):(t=e.charCodeAt(d++),n=d<h?e.charCodeAt(d++):0,d<h?e.charCodeAt(d++):0),i=t>>2,o=(3&t)<<4|n>>4,c=1<p?(15&n)<<2|r>>6:64,l=2<p?63&r:64,u.push(s.charAt(i)+s.charAt(o)+s.charAt(c)+s.charAt(l));return u.join("")},n.decode=function(e){var t,n,a,i,o,c,l=0,u=0,d="data:";if(e.substr(0,d.length)===d)throw new Error("Invalid base64 input, it looks like a data url.");var h,p=3*(e=e.replace(/[^A-Za-z0-9+/=]/g,"")).length/4;if(e.charAt(e.length-1)===s.charAt(64)&&p--,e.charAt(e.length-2)===s.charAt(64)&&p--,p%1!=0)throw new Error("Invalid base64 input, bad content length.");for(h=r.uint8array?new Uint8Array(0|p):new Array(0|p);l<e.length;)t=s.indexOf(e.charAt(l++))<<2|(i=s.indexOf(e.charAt(l++)))>>4,n=(15&i)<<4|(o=s.indexOf(e.charAt(l++)))>>2,a=(3&o)<<6|(c=s.indexOf(e.charAt(l++))),h[u++]=t,64!==o&&(h[u++]=n),64!==c&&(h[u++]=a);return h}},{"./support":30,"./utils":32}],2:[function(e,t,n){"use strict";var a=e("./external"),r=e("./stream/DataWorker"),s=e("./stream/Crc32Probe"),i=e("./stream/DataLengthProbe");function o(e,t,n,a,r){this.compressedSize=e,this.uncompressedSize=t,this.crc32=n,this.compression=a,this.compressedContent=r}o.prototype={getContentWorker:function(){var e=new r(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new i("data_length")),t=this;return e.on("end",(function(){if(this.streamInfo.data_length!==t.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")})),e},getCompressedWorker:function(){return new r(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(e,t,n){return e.pipe(new s).pipe(new i("uncompressedSize")).pipe(t.compressWorker(n)).pipe(new i("compressedSize")).withStreamInfo("compression",t)},t.exports=o},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(e,t,n){"use strict";var a=e("./stream/GenericWorker");n.STORE={magic:"\0\0",compressWorker:function(){return new a("STORE compression")},uncompressWorker:function(){return new a("STORE decompression")}},n.DEFLATE=e("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(e,t,n){"use strict";var a=e("./utils"),r=function(){for(var e,t=[],n=0;n<256;n++){e=n;for(var a=0;a<8;a++)e=1&e?3988292384^e>>>1:e>>>1;t[n]=e}return t}();t.exports=function(e,t){return void 0!==e&&e.length?"string"!==a.getTypeOf(e)?function(e,t,n,a){var s=r,i=0+n;e^=-1;for(var o=0;o<i;o++)e=e>>>8^s[255&(e^t[o])];return-1^e}(0|t,e,e.length):function(e,t,n,a){var s=r,i=0+n;e^=-1;for(var o=0;o<i;o++)e=e>>>8^s[255&(e^t.charCodeAt(o))];return-1^e}(0|t,e,e.length):0}},{"./utils":32}],5:[function(e,t,n){"use strict";n.base64=!1,n.binary=!1,n.dir=!1,n.createFolders=!0,n.date=null,n.compression=null,n.compressionOptions=null,n.comment=null,n.unixPermissions=null,n.dosPermissions=null},{}],6:[function(e,t,n){"use strict";var a;a="undefined"!=typeof Promise?Promise:e("lie"),t.exports={Promise:a}},{lie:37}],7:[function(e,t,n){"use strict";var a="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,r=e("pako"),s=e("./utils"),i=e("./stream/GenericWorker"),o=a?"uint8array":"array";function c(e,t){i.call(this,"FlateWorker/"+e),this._pako=null,this._pakoAction=e,this._pakoOptions=t,this.meta={}}n.magic="\b\0",s.inherits(c,i),c.prototype.processChunk=function(e){this.meta=e.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,e.data),!1)},c.prototype.flush=function(){i.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},c.prototype.cleanUp=function(){i.prototype.cleanUp.call(this),this._pako=null},c.prototype._createPako=function(){this._pako=new r[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var e=this;this._pako.onData=function(t){e.push({data:t,meta:e.meta})}},n.compressWorker=function(e){return new c("Deflate",e)},n.uncompressWorker=function(){return new c("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(e,t,n){"use strict";function a(e,t){var n,a="";for(n=0;n<t;n++)a+=String.fromCharCode(255&e),e>>>=8;return a}function r(e,t,n,r,i,u){var d,h,p=e.file,f=e.compression,m=u!==o.utf8encode,g=s.transformTo("string",u(p.name)),b=s.transformTo("string",o.utf8encode(p.name)),y=p.comment,v=s.transformTo("string",u(y)),x=s.transformTo("string",o.utf8encode(y)),w=b.length!==p.name.length,k=x.length!==y.length,I="",S="",N="",T=p.dir,O=p.date,C={crc32:0,compressedSize:0,uncompressedSize:0};t&&!n||(C.crc32=e.crc32,C.compressedSize=e.compressedSize,C.uncompressedSize=e.uncompressedSize);var E=0;t&&(E|=8),m||!w&&!k||(E|=2048);var _=0,A=0;T&&(_|=16),"UNIX"===i?(A=798,_|=function(e,t){var n=e;return e||(n=t?16893:33204),(65535&n)<<16}(p.unixPermissions,T)):(A=20,_|=function(e){return 63&(e||0)}(p.dosPermissions)),d=O.getUTCHours(),d<<=6,d|=O.getUTCMinutes(),d<<=5,d|=O.getUTCSeconds()/2,h=O.getUTCFullYear()-1980,h<<=4,h|=O.getUTCMonth()+1,h<<=5,h|=O.getUTCDate(),w&&(S=a(1,1)+a(c(g),4)+b,I+="up"+a(S.length,2)+S),k&&(N=a(1,1)+a(c(v),4)+x,I+="uc"+a(N.length,2)+N);var R="";return R+="\n\0",R+=a(E,2),R+=f.magic,R+=a(d,2),R+=a(h,2),R+=a(C.crc32,4),R+=a(C.compressedSize,4),R+=a(C.uncompressedSize,4),R+=a(g.length,2),R+=a(I.length,2),{fileRecord:l.LOCAL_FILE_HEADER+R+g+I,dirRecord:l.CENTRAL_FILE_HEADER+a(A,2)+R+a(v.length,2)+"\0\0\0\0"+a(_,4)+a(r,4)+g+I+v}}var s=e("../utils"),i=e("../stream/GenericWorker"),o=e("../utf8"),c=e("../crc32"),l=e("../signature");function u(e,t,n,a){i.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=t,this.zipPlatform=n,this.encodeFileName=a,this.streamFiles=e,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}s.inherits(u,i),u.prototype.push=function(e){var t=e.meta.percent||0,n=this.entriesCount,a=this._sources.length;this.accumulate?this.contentBuffer.push(e):(this.bytesWritten+=e.data.length,i.prototype.push.call(this,{data:e.data,meta:{currentFile:this.currentFile,percent:n?(t+100*(n-a-1))/n:100}}))},u.prototype.openedSource=function(e){this.currentSourceOffset=this.bytesWritten,this.currentFile=e.file.name;var t=this.streamFiles&&!e.file.dir;if(t){var n=r(e,t,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:n.fileRecord,meta:{percent:0}})}else this.accumulate=!0},u.prototype.closedSource=function(e){this.accumulate=!1;var t=this.streamFiles&&!e.file.dir,n=r(e,t,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(n.dirRecord),t)this.push({data:function(e){return l.DATA_DESCRIPTOR+a(e.crc32,4)+a(e.compressedSize,4)+a(e.uncompressedSize,4)}(e),meta:{percent:100}});else for(this.push({data:n.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},u.prototype.flush=function(){for(var e=this.bytesWritten,t=0;t<this.dirRecords.length;t++)this.push({data:this.dirRecords[t],meta:{percent:100}});var n=this.bytesWritten-e,r=function(e,t,n,r,i){var o=s.transformTo("string",i(r));return l.CENTRAL_DIRECTORY_END+"\0\0\0\0"+a(e,2)+a(e,2)+a(t,4)+a(n,4)+a(o.length,2)+o}(this.dirRecords.length,n,e,this.zipComment,this.encodeFileName);this.push({data:r,meta:{percent:100}})},u.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},u.prototype.registerPrevious=function(e){this._sources.push(e);var t=this;return e.on("data",(function(e){t.processChunk(e)})),e.on("end",(function(){t.closedSource(t.previous.streamInfo),t._sources.length?t.prepareNextSource():t.end()})),e.on("error",(function(e){t.error(e)})),this},u.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},u.prototype.error=function(e){var t=this._sources;if(!i.prototype.error.call(this,e))return!1;for(var n=0;n<t.length;n++)try{t[n].error(e)}catch(e){}return!0},u.prototype.lock=function(){i.prototype.lock.call(this);for(var e=this._sources,t=0;t<e.length;t++)e[t].lock()},t.exports=u},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(e,t,n){"use strict";var a=e("../compressions"),r=e("./ZipFileWorker");n.generateWorker=function(e,t,n){var s=new r(t.streamFiles,n,t.platform,t.encodeFileName),i=0;try{e.forEach((function(e,n){i++;var r=function(e,t){var n=e||t,r=a[n];if(!r)throw new Error(n+" is not a valid compression method !");return r}(n.options.compression,t.compression),o=n.options.compressionOptions||t.compressionOptions||{},c=n.dir,l=n.date;n._compressWorker(r,o).withStreamInfo("file",{name:e,dir:c,date:l,comment:n.comment||"",unixPermissions:n.unixPermissions,dosPermissions:n.dosPermissions}).pipe(s)})),s.entriesCount=i}catch(e){s.error(e)}return s}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(e,t,n){"use strict";function a(){if(!(this instanceof a))return new a;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files=Object.create(null),this.comment=null,this.root="",this.clone=function(){var e=new a;for(var t in this)"function"!=typeof this[t]&&(e[t]=this[t]);return e}}(a.prototype=e("./object")).loadAsync=e("./load"),a.support=e("./support"),a.defaults=e("./defaults"),a.version="3.10.1",a.loadAsync=function(e,t){return(new a).loadAsync(e,t)},a.external=e("./external"),t.exports=a},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(e,t,n){"use strict";var a=e("./utils"),r=e("./external"),s=e("./utf8"),i=e("./zipEntries"),o=e("./stream/Crc32Probe"),c=e("./nodejsUtils");function l(e){return new r.Promise((function(t,n){var a=e.decompressed.getContentWorker().pipe(new o);a.on("error",(function(e){n(e)})).on("end",(function(){a.streamInfo.crc32!==e.decompressed.crc32?n(new Error("Corrupted zip : CRC32 mismatch")):t()})).resume()}))}t.exports=function(e,t){var n=this;return t=a.extend(t||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:s.utf8decode}),c.isNode&&c.isStream(e)?r.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):a.prepareContent("the loaded zip file",e,!0,t.optimizedBinaryString,t.base64).then((function(e){var n=new i(t);return n.load(e),n})).then((function(e){var n=[r.Promise.resolve(e)],a=e.files;if(t.checkCRC32)for(var s=0;s<a.length;s++)n.push(l(a[s]));return r.Promise.all(n)})).then((function(e){for(var r=e.shift(),s=r.files,i=0;i<s.length;i++){var o=s[i],c=o.fileNameStr,l=a.resolve(o.fileNameStr);n.file(l,o.decompressed,{binary:!0,optimizedBinaryString:!0,date:o.date,dir:o.dir,comment:o.fileCommentStr.length?o.fileCommentStr:null,unixPermissions:o.unixPermissions,dosPermissions:o.dosPermissions,createFolders:t.createFolders}),o.dir||(n.file(l).unsafeOriginalName=c)}return r.zipComment.length&&(n.comment=r.zipComment),n}))}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(e,t,n){"use strict";var a=e("../utils"),r=e("../stream/GenericWorker");function s(e,t){r.call(this,"Nodejs stream input adapter for "+e),this._upstreamEnded=!1,this._bindStream(t)}a.inherits(s,r),s.prototype._bindStream=function(e){var t=this;(this._stream=e).pause(),e.on("data",(function(e){t.push({data:e,meta:{percent:0}})})).on("error",(function(e){t.isPaused?this.generatedError=e:t.error(e)})).on("end",(function(){t.isPaused?t._upstreamEnded=!0:t.end()}))},s.prototype.pause=function(){return!!r.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!r.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},t.exports=s},{"../stream/GenericWorker":28,"../utils":32}],13:[function(e,t,n){"use strict";var a=e("readable-stream").Readable;function r(e,t,n){a.call(this,t),this._helper=e;var r=this;e.on("data",(function(e,t){r.push(e)||r._helper.pause(),n&&n(t)})).on("error",(function(e){r.emit("error",e)})).on("end",(function(){r.push(null)}))}e("../utils").inherits(r,a),r.prototype._read=function(){this._helper.resume()},t.exports=r},{"../utils":32,"readable-stream":16}],14:[function(e,n,a){"use strict";n.exports={isNode:"undefined"!=typeof t,newBufferFrom:function(e,n){if(t.from&&t.from!==Uint8Array.from)return t.from(e,n);if("number"==typeof e)throw new Error('The "data" argument must not be a number');return new t(e,n)},allocBuffer:function(e){if(t.alloc)return t.alloc(e);var n=new t(e);return n.fill(0),n},isBuffer:function(e){return t.isBuffer(e)},isStream:function(e){return e&&"function"==typeof e.on&&"function"==typeof e.pause&&"function"==typeof e.resume}}},{}],15:[function(e,t,n){"use strict";function a(e,t,n){var a,r=s.getTypeOf(t),o=s.extend(n||{},c);o.date=o.date||new Date,null!==o.compression&&(o.compression=o.compression.toUpperCase()),"string"==typeof o.unixPermissions&&(o.unixPermissions=parseInt(o.unixPermissions,8)),o.unixPermissions&&16384&o.unixPermissions&&(o.dir=!0),o.dosPermissions&&16&o.dosPermissions&&(o.dir=!0),o.dir&&(e=m(e)),o.createFolders&&(a=f(e))&&g.call(this,a,!0);var d,b="string"===r&&!1===o.binary&&!1===o.base64;n&&void 0!==n.binary||(o.binary=!b),(t instanceof l&&0===t.uncompressedSize||o.dir||!t||0===t.length)&&(o.base64=!1,o.binary=!0,t="",o.compression="STORE",r="string"),d=t instanceof l||t instanceof i?t:h.isNode&&h.isStream(t)?new p(e,t):s.prepareContent(e,t,o.binary,o.optimizedBinaryString,o.base64);var y=new u(e,d,o);this.files[e]=y}var r=e("./utf8"),s=e("./utils"),i=e("./stream/GenericWorker"),o=e("./stream/StreamHelper"),c=e("./defaults"),l=e("./compressedObject"),u=e("./zipObject"),d=e("./generate"),h=e("./nodejsUtils"),p=e("./nodejs/NodejsStreamInputAdapter"),f=function(e){"/"===e.slice(-1)&&(e=e.substring(0,e.length-1));var t=e.lastIndexOf("/");return 0<t?e.substring(0,t):""},m=function(e){return"/"!==e.slice(-1)&&(e+="/"),e},g=function(e,t){return t=void 0!==t?t:c.createFolders,e=m(e),this.files[e]||a.call(this,e,null,{dir:!0,createFolders:t}),this.files[e]};function b(e){return"[object RegExp]"===Object.prototype.toString.call(e)}var y={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(e){var t,n,a;for(t in this.files)a=this.files[t],(n=t.slice(this.root.length,t.length))&&t.slice(0,this.root.length)===this.root&&e(n,a)},filter:function(e){var t=[];return this.forEach((function(n,a){e(n,a)&&t.push(a)})),t},file:function(e,t,n){if(1!==arguments.length)return e=this.root+e,a.call(this,e,t,n),this;if(b(e)){var r=e;return this.filter((function(e,t){return!t.dir&&r.test(e)}))}var s=this.files[this.root+e];return s&&!s.dir?s:null},folder:function(e){if(!e)return this;if(b(e))return this.filter((function(t,n){return n.dir&&e.test(t)}));var t=this.root+e,n=g.call(this,t),a=this.clone();return a.root=n.name,a},remove:function(e){e=this.root+e;var t=this.files[e];if(t||("/"!==e.slice(-1)&&(e+="/"),t=this.files[e]),t&&!t.dir)delete this.files[e];else for(var n=this.filter((function(t,n){return n.name.slice(0,e.length)===e})),a=0;a<n.length;a++)delete this.files[n[a].name];return this},generate:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(e){var t,n={};try{if((n=s.extend(e||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:r.utf8encode})).type=n.type.toLowerCase(),n.compression=n.compression.toUpperCase(),"binarystring"===n.type&&(n.type="string"),!n.type)throw new Error("No output type specified.");s.checkSupport(n.type),"darwin"!==n.platform&&"freebsd"!==n.platform&&"linux"!==n.platform&&"sunos"!==n.platform||(n.platform="UNIX"),"win32"===n.platform&&(n.platform="DOS");var a=n.comment||this.comment||"";t=d.generateWorker(this,n,a)}catch(e){(t=new i("error")).error(e)}return new o(t,n.type||"string",n.mimeType)},generateAsync:function(e,t){return this.generateInternalStream(e).accumulate(t)},generateNodeStream:function(e,t){return(e=e||{}).type||(e.type="nodebuffer"),this.generateInternalStream(e).toNodejsStream(t)}};t.exports=y},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(e,t,n){"use strict";t.exports=e("stream")},{stream:void 0}],17:[function(e,t,n){"use strict";var a=e("./DataReader");function r(e){a.call(this,e);for(var t=0;t<this.data.length;t++)e[t]=255&e[t]}e("../utils").inherits(r,a),r.prototype.byteAt=function(e){return this.data[this.zero+e]},r.prototype.lastIndexOfSignature=function(e){for(var t=e.charCodeAt(0),n=e.charCodeAt(1),a=e.charCodeAt(2),r=e.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===t&&this.data[s+1]===n&&this.data[s+2]===a&&this.data[s+3]===r)return s-this.zero;return-1},r.prototype.readAndCheckSignature=function(e){var t=e.charCodeAt(0),n=e.charCodeAt(1),a=e.charCodeAt(2),r=e.charCodeAt(3),s=this.readData(4);return t===s[0]&&n===s[1]&&a===s[2]&&r===s[3]},r.prototype.readData=function(e){if(this.checkOffset(e),0===e)return[];var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=r},{"../utils":32,"./DataReader":18}],18:[function(e,t,n){"use strict";var a=e("../utils");function r(e){this.data=e,this.length=e.length,this.index=0,this.zero=0}r.prototype={checkOffset:function(e){this.checkIndex(this.index+e)},checkIndex:function(e){if(this.length<this.zero+e||e<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+e+"). Corrupted zip ?")},setIndex:function(e){this.checkIndex(e),this.index=e},skip:function(e){this.setIndex(this.index+e)},byteAt:function(){},readInt:function(e){var t,n=0;for(this.checkOffset(e),t=this.index+e-1;t>=this.index;t--)n=(n<<8)+this.byteAt(t);return this.index+=e,n},readString:function(e){return a.transformTo("string",this.readData(e))},readData:function(){},lastIndexOfSignature:function(){},readAndCheckSignature:function(){},readDate:function(){var e=this.readInt(4);return new Date(Date.UTC(1980+(e>>25&127),(e>>21&15)-1,e>>16&31,e>>11&31,e>>5&63,(31&e)<<1))}},t.exports=r},{"../utils":32}],19:[function(e,t,n){"use strict";var a=e("./Uint8ArrayReader");function r(e){a.call(this,e)}e("../utils").inherits(r,a),r.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=r},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(e,t,n){"use strict";var a=e("./DataReader");function r(e){a.call(this,e)}e("../utils").inherits(r,a),r.prototype.byteAt=function(e){return this.data.charCodeAt(this.zero+e)},r.prototype.lastIndexOfSignature=function(e){return this.data.lastIndexOf(e)-this.zero},r.prototype.readAndCheckSignature=function(e){return e===this.readData(4)},r.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=r},{"../utils":32,"./DataReader":18}],21:[function(e,t,n){"use strict";var a=e("./ArrayReader");function r(e){a.call(this,e)}e("../utils").inherits(r,a),r.prototype.readData=function(e){if(this.checkOffset(e),0===e)return new Uint8Array(0);var t=this.data.subarray(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=r},{"../utils":32,"./ArrayReader":17}],22:[function(e,t,n){"use strict";var a=e("../utils"),r=e("../support"),s=e("./ArrayReader"),i=e("./StringReader"),o=e("./NodeBufferReader"),c=e("./Uint8ArrayReader");t.exports=function(e){var t=a.getTypeOf(e);return a.checkSupport(t),"string"!==t||r.uint8array?"nodebuffer"===t?new o(e):r.uint8array?new c(a.transformTo("uint8array",e)):new s(a.transformTo("array",e)):new i(e)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(e,t,n){"use strict";n.LOCAL_FILE_HEADER="PK\x03\x04",n.CENTRAL_FILE_HEADER="PK\x01\x02",n.CENTRAL_DIRECTORY_END="PK\x05\x06",n.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK\x06\x07",n.ZIP64_CENTRAL_DIRECTORY_END="PK\x06\x06",n.DATA_DESCRIPTOR="PK\x07\b"},{}],24:[function(e,t,n){"use strict";var a=e("./GenericWorker"),r=e("../utils");function s(e){a.call(this,"ConvertWorker to "+e),this.destType=e}r.inherits(s,a),s.prototype.processChunk=function(e){this.push({data:r.transformTo(this.destType,e.data),meta:e.meta})},t.exports=s},{"../utils":32,"./GenericWorker":28}],25:[function(e,t,n){"use strict";var a=e("./GenericWorker"),r=e("../crc32");function s(){a.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}e("../utils").inherits(s,a),s.prototype.processChunk=function(e){this.streamInfo.crc32=r(e.data,this.streamInfo.crc32||0),this.push(e)},t.exports=s},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(e,t,n){"use strict";var a=e("../utils"),r=e("./GenericWorker");function s(e){r.call(this,"DataLengthProbe for "+e),this.propName=e,this.withStreamInfo(e,0)}a.inherits(s,r),s.prototype.processChunk=function(e){if(e){var t=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=t+e.data.length}r.prototype.processChunk.call(this,e)},t.exports=s},{"../utils":32,"./GenericWorker":28}],27:[function(e,t,n){"use strict";var a=e("../utils"),r=e("./GenericWorker");function s(e){r.call(this,"DataWorker");var t=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,e.then((function(e){t.dataIsReady=!0,t.data=e,t.max=e&&e.length||0,t.type=a.getTypeOf(e),t.isPaused||t._tickAndRepeat()}),(function(e){t.error(e)}))}a.inherits(s,r),s.prototype.cleanUp=function(){r.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!r.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,a.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(a.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var e=null,t=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":e=this.data.substring(this.index,t);break;case"uint8array":e=this.data.subarray(this.index,t);break;case"array":case"nodebuffer":e=this.data.slice(this.index,t)}return this.index=t,this.push({data:e,meta:{percent:this.max?this.index/this.max*100:0}})},t.exports=s},{"../utils":32,"./GenericWorker":28}],28:[function(e,t,n){"use strict";function a(e){this.name=e||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}a.prototype={push:function(e){this.emit("data",e)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(e){this.emit("error",e)}return!0},error:function(e){return!this.isFinished&&(this.isPaused?this.generatedError=e:(this.isFinished=!0,this.emit("error",e),this.previous&&this.previous.error(e),this.cleanUp()),!0)},on:function(e,t){return this._listeners[e].push(t),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(e,t){if(this._listeners[e])for(var n=0;n<this._listeners[e].length;n++)this._listeners[e][n].call(this,t)},pipe:function(e){return e.registerPrevious(this)},registerPrevious:function(e){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=e.streamInfo,this.mergeStreamInfo(),this.previous=e;var t=this;return e.on("data",(function(e){t.processChunk(e)})),e.on("end",(function(){t.end()})),e.on("error",(function(e){t.error(e)})),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var e=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),e=!0),this.previous&&this.previous.resume(),!e},flush:function(){},processChunk:function(e){this.push(e)},withStreamInfo:function(e,t){return this.extraStreamInfo[e]=t,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var e in this.extraStreamInfo)Object.prototype.hasOwnProperty.call(this.extraStreamInfo,e)&&(this.streamInfo[e]=this.extraStreamInfo[e])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var e="Worker "+this.name;return this.previous?this.previous+" -> "+e:e}},t.exports=a},{}],29:[function(e,n,a){"use strict";var r=e("../utils"),s=e("./ConvertWorker"),i=e("./GenericWorker"),o=e("../base64"),c=e("../support"),l=e("../external"),u=null;if(c.nodestream)try{u=e("../nodejs/NodejsStreamOutputAdapter")}catch(e){}function d(e,t,n){var a=t;switch(t){case"blob":case"arraybuffer":a="uint8array";break;case"base64":a="string"}try{this._internalType=a,this._outputType=t,this._mimeType=n,r.checkSupport(a),this._worker=e.pipe(new s(a)),e.lock()}catch(e){this._worker=new i("error"),this._worker.error(e)}}d.prototype={accumulate:function(e){return function(e,n){return new l.Promise((function(a,s){var i=[],c=e._internalType,l=e._outputType,u=e._mimeType;e.on("data",(function(e,t){i.push(e),n&&n(t)})).on("error",(function(e){i=[],s(e)})).on("end",(function(){try{var e=function(e,t,n){switch(e){case"blob":return r.newBlob(r.transformTo("arraybuffer",t),n);case"base64":return o.encode(t);default:return r.transformTo(e,t)}}(l,function(e,n){var a,r=0,s=null,i=0;for(a=0;a<n.length;a++)i+=n[a].length;switch(e){case"string":return n.join("");case"array":return Array.prototype.concat.apply([],n);case"uint8array":for(s=new Uint8Array(i),a=0;a<n.length;a++)s.set(n[a],r),r+=n[a].length;return s;case"nodebuffer":return t.concat(n);default:throw new Error("concat : unsupported type '"+e+"'")}}(c,i),u);a(e)}catch(e){s(e)}i=[]})).resume()}))}(this,e)},on:function(e,t){var n=this;return"data"===e?this._worker.on(e,(function(e){t.call(n,e.data,e.meta)})):this._worker.on(e,(function(){r.delay(t,arguments,n)})),this},resume:function(){return r.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(e){if(r.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new u(this,{objectMode:"nodebuffer"!==this._outputType},e)}},n.exports=d},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(e,n,a){"use strict";if(a.base64=!0,a.array=!0,a.string=!0,a.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,a.nodebuffer="undefined"!=typeof t,a.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)a.blob=!1;else{var r=new ArrayBuffer(0);try{a.blob=0===new Blob([r],{type:"application/zip"}).size}catch(e){try{var s=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);s.append(r),a.blob=0===s.getBlob("application/zip").size}catch(e){a.blob=!1}}}try{a.nodestream=!!e("readable-stream").Readable}catch(e){a.nodestream=!1}},{"readable-stream":16}],31:[function(e,t,n){"use strict";for(var a=e("./utils"),r=e("./support"),s=e("./nodejsUtils"),i=e("./stream/GenericWorker"),o=new Array(256),c=0;c<256;c++)o[c]=252<=c?6:248<=c?5:240<=c?4:224<=c?3:192<=c?2:1;function l(){i.call(this,"utf-8 decode"),this.leftOver=null}function u(){i.call(this,"utf-8 encode")}o[254]=o[254]=1,n.utf8encode=function(e){return r.nodebuffer?s.newBufferFrom(e,"utf-8"):function(e){var t,n,a,s,i,o=e.length,c=0;for(s=0;s<o;s++)55296==(64512&(n=e.charCodeAt(s)))&&s+1<o&&56320==(64512&(a=e.charCodeAt(s+1)))&&(n=65536+(n-55296<<10)+(a-56320),s++),c+=n<128?1:n<2048?2:n<65536?3:4;for(t=r.uint8array?new Uint8Array(c):new Array(c),s=i=0;i<c;s++)55296==(64512&(n=e.charCodeAt(s)))&&s+1<o&&56320==(64512&(a=e.charCodeAt(s+1)))&&(n=65536+(n-55296<<10)+(a-56320),s++),n<128?t[i++]=n:(n<2048?t[i++]=192|n>>>6:(n<65536?t[i++]=224|n>>>12:(t[i++]=240|n>>>18,t[i++]=128|n>>>12&63),t[i++]=128|n>>>6&63),t[i++]=128|63&n);return t}(e)},n.utf8decode=function(e){return r.nodebuffer?a.transformTo("nodebuffer",e).toString("utf-8"):function(e){var t,n,r,s,i=e.length,c=new Array(2*i);for(t=n=0;t<i;)if((r=e[t++])<128)c[n++]=r;else if(4<(s=o[r]))c[n++]=65533,t+=s-1;else{for(r&=2===s?31:3===s?15:7;1<s&&t<i;)r=r<<6|63&e[t++],s--;1<s?c[n++]=65533:r<65536?c[n++]=r:(r-=65536,c[n++]=55296|r>>10&1023,c[n++]=56320|1023&r)}return c.length!==n&&(c.subarray?c=c.subarray(0,n):c.length=n),a.applyFromCharCode(c)}(e=a.transformTo(r.uint8array?"uint8array":"array",e))},a.inherits(l,i),l.prototype.processChunk=function(e){var t=a.transformTo(r.uint8array?"uint8array":"array",e.data);if(this.leftOver&&this.leftOver.length){if(r.uint8array){var s=t;(t=new Uint8Array(s.length+this.leftOver.length)).set(this.leftOver,0),t.set(s,this.leftOver.length)}else t=this.leftOver.concat(t);this.leftOver=null}var i=function(e,t){var n;for((t=t||e.length)>e.length&&(t=e.length),n=t-1;0<=n&&128==(192&e[n]);)n--;return n<0||0===n?t:n+o[e[n]]>t?n:t}(t),c=t;i!==t.length&&(r.uint8array?(c=t.subarray(0,i),this.leftOver=t.subarray(i,t.length)):(c=t.slice(0,i),this.leftOver=t.slice(i,t.length))),this.push({data:n.utf8decode(c),meta:e.meta})},l.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:n.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},n.Utf8DecodeWorker=l,a.inherits(u,i),u.prototype.processChunk=function(e){this.push({data:n.utf8encode(e.data),meta:e.meta})},n.Utf8EncodeWorker=u},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(e,t,a){"use strict";var r=e("./support"),s=e("./base64"),i=e("./nodejsUtils"),o=e("./external");function c(e){return e}function l(e,t){for(var n=0;n<e.length;++n)t[n]=255&e.charCodeAt(n);return t}e("setimmediate"),a.newBlob=function(t,n){a.checkSupport("blob");try{return new Blob([t],{type:n})}catch(e){try{var r=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return r.append(t),r.getBlob(n)}catch(e){throw new Error("Bug : can't construct the Blob.")}}};var u={stringifyByChunk:function(e,t,n){var a=[],r=0,s=e.length;if(s<=n)return String.fromCharCode.apply(null,e);for(;r<s;)"array"===t||"nodebuffer"===t?a.push(String.fromCharCode.apply(null,e.slice(r,Math.min(r+n,s)))):a.push(String.fromCharCode.apply(null,e.subarray(r,Math.min(r+n,s)))),r+=n;return a.join("")},stringifyByChar:function(e){for(var t="",n=0;n<e.length;n++)t+=String.fromCharCode(e[n]);return t},applyCanBeUsed:{uint8array:function(){try{return r.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(e){return!1}}(),nodebuffer:function(){try{return r.nodebuffer&&1===String.fromCharCode.apply(null,i.allocBuffer(1)).length}catch(e){return!1}}()}};function d(e){var t=65536,n=a.getTypeOf(e),r=!0;if("uint8array"===n?r=u.applyCanBeUsed.uint8array:"nodebuffer"===n&&(r=u.applyCanBeUsed.nodebuffer),r)for(;1<t;)try{return u.stringifyByChunk(e,n,t)}catch(e){t=Math.floor(t/2)}return u.stringifyByChar(e)}function h(e,t){for(var n=0;n<e.length;n++)t[n]=e[n];return t}a.applyFromCharCode=d;var p={};p.string={string:c,array:function(e){return l(e,new Array(e.length))},arraybuffer:function(e){return p.string.uint8array(e).buffer},uint8array:function(e){return l(e,new Uint8Array(e.length))},nodebuffer:function(e){return l(e,i.allocBuffer(e.length))}},p.array={string:d,array:c,arraybuffer:function(e){return new Uint8Array(e).buffer},uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return i.newBufferFrom(e)}},p.arraybuffer={string:function(e){return d(new Uint8Array(e))},array:function(e){return h(new Uint8Array(e),new Array(e.byteLength))},arraybuffer:c,uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return i.newBufferFrom(new Uint8Array(e))}},p.uint8array={string:d,array:function(e){return h(e,new Array(e.length))},arraybuffer:function(e){return e.buffer},uint8array:c,nodebuffer:function(e){return i.newBufferFrom(e)}},p.nodebuffer={string:d,array:function(e){return h(e,new Array(e.length))},arraybuffer:function(e){return p.nodebuffer.uint8array(e).buffer},uint8array:function(e){return h(e,new Uint8Array(e.length))},nodebuffer:c},a.transformTo=function(e,t){if(t=t||"",!e)return t;a.checkSupport(e);var n=a.getTypeOf(t);return p[n][e](t)},a.resolve=function(e){for(var t=e.split("/"),n=[],a=0;a<t.length;a++){var r=t[a];"."===r||""===r&&0!==a&&a!==t.length-1||(".."===r?n.pop():n.push(r))}return n.join("/")},a.getTypeOf=function(e){return"string"==typeof e?"string":"[object Array]"===Object.prototype.toString.call(e)?"array":r.nodebuffer&&i.isBuffer(e)?"nodebuffer":r.uint8array&&e instanceof Uint8Array?"uint8array":r.arraybuffer&&e instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function(e){if(!r[e.toLowerCase()])throw new Error(e+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(e){var t,n,a="";for(n=0;n<(e||"").length;n++)a+="\\x"+((t=e.charCodeAt(n))<16?"0":"")+t.toString(16).toUpperCase();return a},a.delay=function(e,t,a){n((function(){e.apply(a||null,t||[])}))},a.inherits=function(e,t){function n(){}n.prototype=t.prototype,e.prototype=new n},a.extend=function(){var e,t,n={};for(e=0;e<arguments.length;e++)for(t in arguments[e])Object.prototype.hasOwnProperty.call(arguments[e],t)&&void 0===n[t]&&(n[t]=arguments[e][t]);return n},a.prepareContent=function(e,t,n,i,c){return o.Promise.resolve(t).then((function(e){return r.blob&&(e instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(e)))&&"undefined"!=typeof FileReader?new o.Promise((function(t,n){var a=new FileReader;a.onload=function(e){t(e.target.result)},a.onerror=function(e){n(e.target.error)},a.readAsArrayBuffer(e)})):e})).then((function(t){var u=a.getTypeOf(t);return u?("arraybuffer"===u?t=a.transformTo("uint8array",t):"string"===u&&(c?t=s.decode(t):n&&!0!==i&&(t=function(e){return l(e,r.uint8array?new Uint8Array(e.length):new Array(e.length))}(t))),t):o.Promise.reject(new Error("Can't read the data of '"+e+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))}))}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,setimmediate:54}],33:[function(e,t,n){"use strict";var a=e("./reader/readerFor"),r=e("./utils"),s=e("./signature"),i=e("./zipEntry"),o=e("./support");function c(e){this.files=[],this.loadOptions=e}c.prototype={checkSignature:function(e){if(!this.reader.readAndCheckSignature(e)){this.reader.index-=4;var t=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+r.pretty(t)+", expected "+r.pretty(e)+")")}},isSignature:function(e,t){var n=this.reader.index;this.reader.setIndex(e);var a=this.reader.readString(4)===t;return this.reader.setIndex(n),a},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var e=this.reader.readData(this.zipCommentLength),t=o.uint8array?"uint8array":"array",n=r.transformTo(t,e);this.zipComment=this.loadOptions.decodeFileName(n)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var e,t,n,a=this.zip64EndOfCentralSize-44;0<a;)e=this.reader.readInt(2),t=this.reader.readInt(4),n=this.reader.readData(t),this.zip64ExtensibleData[e]={id:e,length:t,value:n}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var e,t;for(e=0;e<this.files.length;e++)t=this.files[e],this.reader.setIndex(t.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),t.readLocalPart(this.reader),t.handleUTF8(),t.processAttributes()},readCentralDir:function(){var e;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(e=new i({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(e);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var e=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(e<0)throw this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Corrupted zip: can't find end of central directory"):new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");this.reader.setIndex(e);var t=e;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===r.MAX_VALUE_16BITS||this.diskWithCentralDirStart===r.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===r.MAX_VALUE_16BITS||this.centralDirRecords===r.MAX_VALUE_16BITS||this.centralDirSize===r.MAX_VALUE_32BITS||this.centralDirOffset===r.MAX_VALUE_32BITS){if(this.zip64=!0,(e=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(e),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var n=this.centralDirOffset+this.centralDirSize;this.zip64&&(n+=20,n+=12+this.zip64EndOfCentralSize);var a=t-n;if(0<a)this.isSignature(t,s.CENTRAL_FILE_HEADER)||(this.reader.zero=a);else if(a<0)throw new Error("Corrupted zip: missing "+Math.abs(a)+" bytes.")},prepareReader:function(e){this.reader=a(e)},load:function(e){this.prepareReader(e),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},t.exports=c},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utils":32,"./zipEntry":34}],34:[function(e,t,n){"use strict";var a=e("./reader/readerFor"),r=e("./utils"),s=e("./compressedObject"),i=e("./crc32"),o=e("./utf8"),c=e("./compressions"),l=e("./support");function u(e,t){this.options=e,this.loadOptions=t}u.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(e){var t,n;if(e.skip(22),this.fileNameLength=e.readInt(2),n=e.readInt(2),this.fileName=e.readData(this.fileNameLength),e.skip(n),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(t=function(e){for(var t in c)if(Object.prototype.hasOwnProperty.call(c,t)&&c[t].magic===e)return c[t];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+r.pretty(this.compressionMethod)+" unknown (inner file : "+r.transformTo("string",this.fileName)+")");this.decompressed=new s(this.compressedSize,this.uncompressedSize,this.crc32,t,e.readData(this.compressedSize))},readCentralPart:function(e){this.versionMadeBy=e.readInt(2),e.skip(2),this.bitFlag=e.readInt(2),this.compressionMethod=e.readString(2),this.date=e.readDate(),this.crc32=e.readInt(4),this.compressedSize=e.readInt(4),this.uncompressedSize=e.readInt(4);var t=e.readInt(2);if(this.extraFieldsLength=e.readInt(2),this.fileCommentLength=e.readInt(2),this.diskNumberStart=e.readInt(2),this.internalFileAttributes=e.readInt(2),this.externalFileAttributes=e.readInt(4),this.localHeaderOffset=e.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");e.skip(t),this.readExtraFields(e),this.parseZIP64ExtraField(e),this.fileComment=e.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var e=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==e&&(this.dosPermissions=63&this.externalFileAttributes),3==e&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(){if(this.extraFields[1]){var e=a(this.extraFields[1].value);this.uncompressedSize===r.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===r.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===r.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===r.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4))}},readExtraFields:function(e){var t,n,a,r=e.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});e.index+4<r;)t=e.readInt(2),n=e.readInt(2),a=e.readData(n),this.extraFields[t]={id:t,length:n,value:a};e.setIndex(r)},handleUTF8:function(){var e=l.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var t=this.findExtraFieldUnicodePath();if(null!==t)this.fileNameStr=t;else{var n=r.transformTo(e,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(n)}var a=this.findExtraFieldUnicodeComment();if(null!==a)this.fileCommentStr=a;else{var s=r.transformTo(e,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(s)}}},findExtraFieldUnicodePath:function(){var e=this.extraFields[28789];if(e){var t=a(e.value);return 1!==t.readInt(1)||i(this.fileName)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null},findExtraFieldUnicodeComment:function(){var e=this.extraFields[25461];if(e){var t=a(e.value);return 1!==t.readInt(1)||i(this.fileComment)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null}},t.exports=u},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(e,t,n){"use strict";function a(e,t,n){this.name=e,this.dir=n.dir,this.date=n.date,this.comment=n.comment,this.unixPermissions=n.unixPermissions,this.dosPermissions=n.dosPermissions,this._data=t,this._dataBinary=n.binary,this.options={compression:n.compression,compressionOptions:n.compressionOptions}}var r=e("./stream/StreamHelper"),s=e("./stream/DataWorker"),i=e("./utf8"),o=e("./compressedObject"),c=e("./stream/GenericWorker");a.prototype={internalStream:function(e){var t=null,n="string";try{if(!e)throw new Error("No output type specified.");var a="string"===(n=e.toLowerCase())||"text"===n;"binarystring"!==n&&"text"!==n||(n="string"),t=this._decompressWorker();var s=!this._dataBinary;s&&!a&&(t=t.pipe(new i.Utf8EncodeWorker)),!s&&a&&(t=t.pipe(new i.Utf8DecodeWorker))}catch(e){(t=new c("error")).error(e)}return new r(t,n,"")},async:function(e,t){return this.internalStream(e).accumulate(t)},nodeStream:function(e,t){return this.internalStream(e||"nodebuffer").toNodejsStream(t)},_compressWorker:function(e,t){if(this._data instanceof o&&this._data.compression.magic===e.magic)return this._data.getCompressedWorker();var n=this._decompressWorker();return this._dataBinary||(n=n.pipe(new i.Utf8EncodeWorker)),o.createWorkerFrom(n,e,t)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof c?this._data:new s(this._data)}};for(var l=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],u=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},d=0;d<l.length;d++)a.prototype[l[d]]=u;t.exports=a},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(e,t,n){(function(e){"use strict";var n,a,r=e.MutationObserver||e.WebKitMutationObserver;if(r){var s=0,i=new r(u),o=e.document.createTextNode("");i.observe(o,{characterData:!0}),n=function(){o.data=s=++s%2}}else if(e.setImmediate||void 0===e.MessageChannel)n="document"in e&&"onreadystatechange"in e.document.createElement("script")?function(){var t=e.document.createElement("script");t.onreadystatechange=function(){u(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(u,0)};else{var c=new e.MessageChannel;c.port1.onmessage=u,n=function(){c.port2.postMessage(0)}}var l=[];function u(){var e,t;a=!0;for(var n=l.length;n;){for(t=l,l=[],e=-1;++e<n;)t[e]();n=l.length}a=!1}t.exports=function(e){1!==l.push(e)||a||n()}}).call(this,"undefined"!=typeof a?a:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],37:[function(e,t,n){"use strict";var a=e("immediate");function r(){}var s={},i=["REJECTED"],o=["FULFILLED"],c=["PENDING"];function l(e){if("function"!=typeof e)throw new TypeError("resolver must be a function");this.state=c,this.queue=[],this.outcome=void 0,e!==r&&p(this,e)}function u(e,t,n){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof n&&(this.onRejected=n,this.callRejected=this.otherCallRejected)}function d(e,t,n){a((function(){var a;try{a=t(n)}catch(a){return s.reject(e,a)}a===e?s.reject(e,new TypeError("Cannot resolve promise with itself")):s.resolve(e,a)}))}function h(e){var t=e&&e.then;if(e&&("object"==typeof e||"function"==typeof e)&&"function"==typeof t)return function(){t.apply(e,arguments)}}function p(e,t){var n=!1;function a(t){n||(n=!0,s.reject(e,t))}function r(t){n||(n=!0,s.resolve(e,t))}var i=f((function(){t(r,a)}));"error"===i.status&&a(i.value)}function f(e,t){var n={};try{n.value=e(t),n.status="success"}catch(e){n.status="error",n.value=e}return n}(t.exports=l).prototype.finally=function(e){if("function"!=typeof e)return this;var t=this.constructor;return this.then((function(n){return t.resolve(e()).then((function(){return n}))}),(function(n){return t.resolve(e()).then((function(){throw n}))}))},l.prototype.catch=function(e){return this.then(null,e)},l.prototype.then=function(e,t){if("function"!=typeof e&&this.state===o||"function"!=typeof t&&this.state===i)return this;var n=new this.constructor(r);return this.state!==c?d(n,this.state===o?e:t,this.outcome):this.queue.push(new u(n,e,t)),n},u.prototype.callFulfilled=function(e){s.resolve(this.promise,e)},u.prototype.otherCallFulfilled=function(e){d(this.promise,this.onFulfilled,e)},u.prototype.callRejected=function(e){s.reject(this.promise,e)},u.prototype.otherCallRejected=function(e){d(this.promise,this.onRejected,e)},s.resolve=function(e,t){var n=f(h,t);if("error"===n.status)return s.reject(e,n.value);var a=n.value;if(a)p(e,a);else{e.state=o,e.outcome=t;for(var r=-1,i=e.queue.length;++r<i;)e.queue[r].callFulfilled(t)}return e},s.reject=function(e,t){e.state=i,e.outcome=t;for(var n=-1,a=e.queue.length;++n<a;)e.queue[n].callRejected(t);return e},l.resolve=function(e){return e instanceof this?e:s.resolve(new this(r),e)},l.reject=function(e){var t=new this(r);return s.reject(t,e)},l.all=function(e){var t=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var n=e.length,a=!1;if(!n)return this.resolve([]);for(var i=new Array(n),o=0,c=-1,l=new this(r);++c<n;)u(e[c],c);return l;function u(e,r){t.resolve(e).then((function(e){i[r]=e,++o!==n||a||(a=!0,s.resolve(l,i))}),(function(e){a||(a=!0,s.reject(l,e))}))}},l.race=function(e){if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var t=e.length,n=!1;if(!t)return this.resolve([]);for(var a,i=-1,o=new this(r);++i<t;)a=e[i],this.resolve(a).then((function(e){n||(n=!0,s.resolve(o,e))}),(function(e){n||(n=!0,s.reject(o,e))}));return o}},{immediate:36}],38:[function(e,t,n){"use strict";var a={};(0,e("./lib/utils/common").assign)(a,e("./lib/deflate"),e("./lib/inflate"),e("./lib/zlib/constants")),t.exports=a},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(e,t,n){"use strict";var a=e("./zlib/deflate"),r=e("./utils/common"),s=e("./utils/strings"),i=e("./zlib/messages"),o=e("./zlib/zstream"),c=Object.prototype.toString;function l(e){if(!(this instanceof l))return new l(e);this.options=r.assign({level:-1,method:8,chunkSize:16384,windowBits:15,memLevel:8,strategy:0,to:""},e||{});var t=this.options;t.raw&&0<t.windowBits?t.windowBits=-t.windowBits:t.gzip&&0<t.windowBits&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new o,this.strm.avail_out=0;var n=a.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(0!==n)throw new Error(i[n]);if(t.header&&a.deflateSetHeader(this.strm,t.header),t.dictionary){var u;if(u="string"==typeof t.dictionary?s.string2buf(t.dictionary):"[object ArrayBuffer]"===c.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,0!==(n=a.deflateSetDictionary(this.strm,u)))throw new Error(i[n]);this._dict_set=!0}}function u(e,t){var n=new l(t);if(n.push(e,!0),n.err)throw n.msg||i[n.err];return n.result}l.prototype.push=function(e,t){var n,i,o=this.strm,l=this.options.chunkSize;if(this.ended)return!1;i=t===~~t?t:!0===t?4:0,"string"==typeof e?o.input=s.string2buf(e):"[object ArrayBuffer]"===c.call(e)?o.input=new Uint8Array(e):o.input=e,o.next_in=0,o.avail_in=o.input.length;do{if(0===o.avail_out&&(o.output=new r.Buf8(l),o.next_out=0,o.avail_out=l),1!==(n=a.deflate(o,i))&&0!==n)return this.onEnd(n),!(this.ended=!0);0!==o.avail_out&&(0!==o.avail_in||4!==i&&2!==i)||("string"===this.options.to?this.onData(s.buf2binstring(r.shrinkBuf(o.output,o.next_out))):this.onData(r.shrinkBuf(o.output,o.next_out)))}while((0<o.avail_in||0===o.avail_out)&&1!==n);return 4===i?(n=a.deflateEnd(this.strm),this.onEnd(n),this.ended=!0,0===n):2!==i||(this.onEnd(0),!(o.avail_out=0))},l.prototype.onData=function(e){this.chunks.push(e)},l.prototype.onEnd=function(e){0===e&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=r.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},n.Deflate=l,n.deflate=u,n.deflateRaw=function(e,t){return(t=t||{}).raw=!0,u(e,t)},n.gzip=function(e,t){return(t=t||{}).gzip=!0,u(e,t)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(e,t,n){"use strict";var a=e("./zlib/inflate"),r=e("./utils/common"),s=e("./utils/strings"),i=e("./zlib/constants"),o=e("./zlib/messages"),c=e("./zlib/zstream"),l=e("./zlib/gzheader"),u=Object.prototype.toString;function d(e){if(!(this instanceof d))return new d(e);this.options=r.assign({chunkSize:16384,windowBits:0,to:""},e||{});var t=this.options;t.raw&&0<=t.windowBits&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(0<=t.windowBits&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),15<t.windowBits&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new c,this.strm.avail_out=0;var n=a.inflateInit2(this.strm,t.windowBits);if(n!==i.Z_OK)throw new Error(o[n]);this.header=new l,a.inflateGetHeader(this.strm,this.header)}function h(e,t){var n=new d(t);if(n.push(e,!0),n.err)throw n.msg||o[n.err];return n.result}d.prototype.push=function(e,t){var n,o,c,l,d,h,p=this.strm,f=this.options.chunkSize,m=this.options.dictionary,g=!1;if(this.ended)return!1;o=t===~~t?t:!0===t?i.Z_FINISH:i.Z_NO_FLUSH,"string"==typeof e?p.input=s.binstring2buf(e):"[object ArrayBuffer]"===u.call(e)?p.input=new Uint8Array(e):p.input=e,p.next_in=0,p.avail_in=p.input.length;do{if(0===p.avail_out&&(p.output=new r.Buf8(f),p.next_out=0,p.avail_out=f),(n=a.inflate(p,i.Z_NO_FLUSH))===i.Z_NEED_DICT&&m&&(h="string"==typeof m?s.string2buf(m):"[object ArrayBuffer]"===u.call(m)?new Uint8Array(m):m,n=a.inflateSetDictionary(this.strm,h)),n===i.Z_BUF_ERROR&&!0===g&&(n=i.Z_OK,g=!1),n!==i.Z_STREAM_END&&n!==i.Z_OK)return this.onEnd(n),!(this.ended=!0);p.next_out&&(0!==p.avail_out&&n!==i.Z_STREAM_END&&(0!==p.avail_in||o!==i.Z_FINISH&&o!==i.Z_SYNC_FLUSH)||("string"===this.options.to?(c=s.utf8border(p.output,p.next_out),l=p.next_out-c,d=s.buf2string(p.output,c),p.next_out=l,p.avail_out=f-l,l&&r.arraySet(p.output,p.output,c,l,0),this.onData(d)):this.onData(r.shrinkBuf(p.output,p.next_out)))),0===p.avail_in&&0===p.avail_out&&(g=!0)}while((0<p.avail_in||0===p.avail_out)&&n!==i.Z_STREAM_END);return n===i.Z_STREAM_END&&(o=i.Z_FINISH),o===i.Z_FINISH?(n=a.inflateEnd(this.strm),this.onEnd(n),this.ended=!0,n===i.Z_OK):o!==i.Z_SYNC_FLUSH||(this.onEnd(i.Z_OK),!(p.avail_out=0))},d.prototype.onData=function(e){this.chunks.push(e)},d.prototype.onEnd=function(e){e===i.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=r.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},n.Inflate=d,n.inflate=h,n.inflateRaw=function(e,t){return(t=t||{}).raw=!0,h(e,t)},n.ungzip=h},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(e,t,n){"use strict";var a="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;n.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var n=t.shift();if(n){if("object"!=typeof n)throw new TypeError(n+"must be non-object");for(var a in n)n.hasOwnProperty(a)&&(e[a]=n[a])}}return e},n.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var r={arraySet:function(e,t,n,a,r){if(t.subarray&&e.subarray)e.set(t.subarray(n,n+a),r);else for(var s=0;s<a;s++)e[r+s]=t[n+s]},flattenChunks:function(e){var t,n,a,r,s,i;for(t=a=0,n=e.length;t<n;t++)a+=e[t].length;for(i=new Uint8Array(a),t=r=0,n=e.length;t<n;t++)s=e[t],i.set(s,r),r+=s.length;return i}},s={arraySet:function(e,t,n,a,r){for(var s=0;s<a;s++)e[r+s]=t[n+s]},flattenChunks:function(e){return[].concat.apply([],e)}};n.setTyped=function(e){e?(n.Buf8=Uint8Array,n.Buf16=Uint16Array,n.Buf32=Int32Array,n.assign(n,r)):(n.Buf8=Array,n.Buf16=Array,n.Buf32=Array,n.assign(n,s))},n.setTyped(a)},{}],42:[function(e,t,n){"use strict";var a=e("./common"),r=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(e){r=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){s=!1}for(var i=new a.Buf8(256),o=0;o<256;o++)i[o]=252<=o?6:248<=o?5:240<=o?4:224<=o?3:192<=o?2:1;function c(e,t){if(t<65537&&(e.subarray&&s||!e.subarray&&r))return String.fromCharCode.apply(null,a.shrinkBuf(e,t));for(var n="",i=0;i<t;i++)n+=String.fromCharCode(e[i]);return n}i[254]=i[254]=1,n.string2buf=function(e){var t,n,r,s,i,o=e.length,c=0;for(s=0;s<o;s++)55296==(64512&(n=e.charCodeAt(s)))&&s+1<o&&56320==(64512&(r=e.charCodeAt(s+1)))&&(n=65536+(n-55296<<10)+(r-56320),s++),c+=n<128?1:n<2048?2:n<65536?3:4;for(t=new a.Buf8(c),s=i=0;i<c;s++)55296==(64512&(n=e.charCodeAt(s)))&&s+1<o&&56320==(64512&(r=e.charCodeAt(s+1)))&&(n=65536+(n-55296<<10)+(r-56320),s++),n<128?t[i++]=n:(n<2048?t[i++]=192|n>>>6:(n<65536?t[i++]=224|n>>>12:(t[i++]=240|n>>>18,t[i++]=128|n>>>12&63),t[i++]=128|n>>>6&63),t[i++]=128|63&n);return t},n.buf2binstring=function(e){return c(e,e.length)},n.binstring2buf=function(e){for(var t=new a.Buf8(e.length),n=0,r=t.length;n<r;n++)t[n]=e.charCodeAt(n);return t},n.buf2string=function(e,t){var n,a,r,s,o=t||e.length,l=new Array(2*o);for(n=a=0;n<o;)if((r=e[n++])<128)l[a++]=r;else if(4<(s=i[r]))l[a++]=65533,n+=s-1;else{for(r&=2===s?31:3===s?15:7;1<s&&n<o;)r=r<<6|63&e[n++],s--;1<s?l[a++]=65533:r<65536?l[a++]=r:(r-=65536,l[a++]=55296|r>>10&1023,l[a++]=56320|1023&r)}return c(l,a)},n.utf8border=function(e,t){var n;for((t=t||e.length)>e.length&&(t=e.length),n=t-1;0<=n&&128==(192&e[n]);)n--;return n<0||0===n?t:n+i[e[n]]>t?n:t}},{"./common":41}],43:[function(e,t,n){"use strict";t.exports=function(e,t,n,a){for(var r=65535&e|0,s=e>>>16&65535|0,i=0;0!==n;){for(n-=i=2e3<n?2e3:n;s=s+(r=r+t[a++]|0)|0,--i;);r%=65521,s%=65521}return r|s<<16|0}},{}],44:[function(e,t,n){"use strict";t.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(e,t,n){"use strict";var a=function(){for(var e,t=[],n=0;n<256;n++){e=n;for(var a=0;a<8;a++)e=1&e?3988292384^e>>>1:e>>>1;t[n]=e}return t}();t.exports=function(e,t,n,r){var s=a,i=r+n;e^=-1;for(var o=r;o<i;o++)e=e>>>8^s[255&(e^t[o])];return-1^e}},{}],46:[function(e,t,n){"use strict";var a,r=e("../utils/common"),s=e("./trees"),i=e("./adler32"),o=e("./crc32"),c=e("./messages"),l=-2,u=258,d=262,h=113;function p(e,t){return e.msg=c[t],t}function f(e){return(e<<1)-(4<e?9:0)}function m(e){for(var t=e.length;0<=--t;)e[t]=0}function g(e){var t=e.state,n=t.pending;n>e.avail_out&&(n=e.avail_out),0!==n&&(r.arraySet(e.output,t.pending_buf,t.pending_out,n,e.next_out),e.next_out+=n,t.pending_out+=n,e.total_out+=n,e.avail_out-=n,t.pending-=n,0===t.pending&&(t.pending_out=0))}function b(e,t){s._tr_flush_block(e,0<=e.block_start?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,g(e.strm)}function y(e,t){e.pending_buf[e.pending++]=t}function v(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t}function x(e,t){var n,a,r=e.max_chain_length,s=e.strstart,i=e.prev_length,o=e.nice_match,c=e.strstart>e.w_size-d?e.strstart-(e.w_size-d):0,l=e.window,h=e.w_mask,p=e.prev,f=e.strstart+u,m=l[s+i-1],g=l[s+i];e.prev_length>=e.good_match&&(r>>=2),o>e.lookahead&&(o=e.lookahead);do{if(l[(n=t)+i]===g&&l[n+i-1]===m&&l[n]===l[s]&&l[++n]===l[s+1]){s+=2,n++;do{}while(l[++s]===l[++n]&&l[++s]===l[++n]&&l[++s]===l[++n]&&l[++s]===l[++n]&&l[++s]===l[++n]&&l[++s]===l[++n]&&l[++s]===l[++n]&&l[++s]===l[++n]&&s<f);if(a=u-(f-s),s=f-u,i<a){if(e.match_start=t,o<=(i=a))break;m=l[s+i-1],g=l[s+i]}}}while((t=p[t&h])>c&&0!=--r);return i<=e.lookahead?i:e.lookahead}function w(e){var t,n,a,s,c,l,u,h,p,f,m=e.w_size;do{if(s=e.window_size-e.lookahead-e.strstart,e.strstart>=m+(m-d)){for(r.arraySet(e.window,e.window,m,m,0),e.match_start-=m,e.strstart-=m,e.block_start-=m,t=n=e.hash_size;a=e.head[--t],e.head[t]=m<=a?a-m:0,--n;);for(t=n=m;a=e.prev[--t],e.prev[t]=m<=a?a-m:0,--n;);s+=m}if(0===e.strm.avail_in)break;if(l=e.strm,u=e.window,h=e.strstart+e.lookahead,f=void 0,(p=s)<(f=l.avail_in)&&(f=p),n=0===f?0:(l.avail_in-=f,r.arraySet(u,l.input,l.next_in,f,h),1===l.state.wrap?l.adler=i(l.adler,u,f,h):2===l.state.wrap&&(l.adler=o(l.adler,u,f,h)),l.next_in+=f,l.total_in+=f,f),e.lookahead+=n,e.lookahead+e.insert>=3)for(c=e.strstart-e.insert,e.ins_h=e.window[c],e.ins_h=(e.ins_h<<e.hash_shift^e.window[c+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[c+3-1])&e.hash_mask,e.prev[c&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=c,c++,e.insert--,!(e.lookahead+e.insert<3)););}while(e.lookahead<d&&0!==e.strm.avail_in)}function k(e,t){for(var n,a;;){if(e.lookahead<d){if(w(e),e.lookahead<d&&0===t)return 1;if(0===e.lookahead)break}if(n=0,e.lookahead>=3&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+3-1])&e.hash_mask,n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==n&&e.strstart-n<=e.w_size-d&&(e.match_length=x(e,n)),e.match_length>=3)if(a=s._tr_tally(e,e.strstart-e.match_start,e.match_length-3),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=3){for(e.match_length--;e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+3-1])&e.hash_mask,n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart,0!=--e.match_length;);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else a=s._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(a&&(b(e,!1),0===e.strm.avail_out))return 1}return e.insert=e.strstart<2?e.strstart:2,4===t?(b(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(b(e,!1),0===e.strm.avail_out)?1:2}function I(e,t){for(var n,a,r;;){if(e.lookahead<d){if(w(e),e.lookahead<d&&0===t)return 1;if(0===e.lookahead)break}if(n=0,e.lookahead>=3&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+3-1])&e.hash_mask,n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=2,0!==n&&e.prev_length<e.max_lazy_match&&e.strstart-n<=e.w_size-d&&(e.match_length=x(e,n),e.match_length<=5&&(1===e.strategy||3===e.match_length&&4096<e.strstart-e.match_start)&&(e.match_length=2)),e.prev_length>=3&&e.match_length<=e.prev_length){for(r=e.strstart+e.lookahead-3,a=s._tr_tally(e,e.strstart-1-e.prev_match,e.prev_length-3),e.lookahead-=e.prev_length-1,e.prev_length-=2;++e.strstart<=r&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+3-1])&e.hash_mask,n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!=--e.prev_length;);if(e.match_available=0,e.match_length=2,e.strstart++,a&&(b(e,!1),0===e.strm.avail_out))return 1}else if(e.match_available){if((a=s._tr_tally(e,0,e.window[e.strstart-1]))&&b(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return 1}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(a=s._tr_tally(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<2?e.strstart:2,4===t?(b(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(b(e,!1),0===e.strm.avail_out)?1:2}function S(e,t,n,a,r){this.good_length=e,this.max_lazy=t,this.nice_length=n,this.max_chain=a,this.func=r}function N(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=8,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new r.Buf16(1146),this.dyn_dtree=new r.Buf16(122),this.bl_tree=new r.Buf16(78),m(this.dyn_ltree),m(this.dyn_dtree),m(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new r.Buf16(16),this.heap=new r.Buf16(573),m(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new r.Buf16(573),m(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function T(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=2,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?42:h,e.adler=2===t.wrap?0:1,t.last_flush=0,s._tr_init(t),0):p(e,l)}function O(e){var t=T(e);return 0===t&&function(e){e.window_size=2*e.w_size,m(e.head),e.max_lazy_match=a[e.level].max_lazy,e.good_match=a[e.level].good_length,e.nice_match=a[e.level].nice_length,e.max_chain_length=a[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=2,e.match_available=0,e.ins_h=0}(e.state),t}function C(e,t,n,a,s,i){if(!e)return l;var o=1;if(-1===t&&(t=6),a<0?(o=0,a=-a):15<a&&(o=2,a-=16),s<1||9<s||8!==n||a<8||15<a||t<0||9<t||i<0||4<i)return p(e,l);8===a&&(a=9);var c=new N;return(e.state=c).strm=e,c.wrap=o,c.gzhead=null,c.w_bits=a,c.w_size=1<<c.w_bits,c.w_mask=c.w_size-1,c.hash_bits=s+7,c.hash_size=1<<c.hash_bits,c.hash_mask=c.hash_size-1,c.hash_shift=~~((c.hash_bits+3-1)/3),c.window=new r.Buf8(2*c.w_size),c.head=new r.Buf16(c.hash_size),c.prev=new r.Buf16(c.w_size),c.lit_bufsize=1<<s+6,c.pending_buf_size=4*c.lit_bufsize,c.pending_buf=new r.Buf8(c.pending_buf_size),c.d_buf=1*c.lit_bufsize,c.l_buf=3*c.lit_bufsize,c.level=t,c.strategy=i,c.method=n,O(e)}a=[new S(0,0,0,0,(function(e,t){var n=65535;for(n>e.pending_buf_size-5&&(n=e.pending_buf_size-5);;){if(e.lookahead<=1){if(w(e),0===e.lookahead&&0===t)return 1;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var a=e.block_start+n;if((0===e.strstart||e.strstart>=a)&&(e.lookahead=e.strstart-a,e.strstart=a,b(e,!1),0===e.strm.avail_out))return 1;if(e.strstart-e.block_start>=e.w_size-d&&(b(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,4===t?(b(e,!0),0===e.strm.avail_out?3:4):(e.strstart>e.block_start&&(b(e,!1),e.strm.avail_out),1)})),new S(4,4,8,4,k),new S(4,5,16,8,k),new S(4,6,32,32,k),new S(4,4,16,16,I),new S(8,16,32,32,I),new S(8,16,128,128,I),new S(8,32,128,256,I),new S(32,128,258,1024,I),new S(32,258,258,4096,I)],n.deflateInit=function(e,t){return C(e,t,8,15,8,0)},n.deflateInit2=C,n.deflateReset=O,n.deflateResetKeep=T,n.deflateSetHeader=function(e,t){return e&&e.state?2!==e.state.wrap?l:(e.state.gzhead=t,0):l},n.deflate=function(e,t){var n,r,i,c;if(!e||!e.state||5<t||t<0)return e?p(e,l):l;if(r=e.state,!e.output||!e.input&&0!==e.avail_in||666===r.status&&4!==t)return p(e,0===e.avail_out?-5:l);if(r.strm=e,n=r.last_flush,r.last_flush=t,42===r.status)if(2===r.wrap)e.adler=0,y(r,31),y(r,139),y(r,8),r.gzhead?(y(r,(r.gzhead.text?1:0)+(r.gzhead.hcrc?2:0)+(r.gzhead.extra?4:0)+(r.gzhead.name?8:0)+(r.gzhead.comment?16:0)),y(r,255&r.gzhead.time),y(r,r.gzhead.time>>8&255),y(r,r.gzhead.time>>16&255),y(r,r.gzhead.time>>24&255),y(r,9===r.level?2:2<=r.strategy||r.level<2?4:0),y(r,255&r.gzhead.os),r.gzhead.extra&&r.gzhead.extra.length&&(y(r,255&r.gzhead.extra.length),y(r,r.gzhead.extra.length>>8&255)),r.gzhead.hcrc&&(e.adler=o(e.adler,r.pending_buf,r.pending,0)),r.gzindex=0,r.status=69):(y(r,0),y(r,0),y(r,0),y(r,0),y(r,0),y(r,9===r.level?2:2<=r.strategy||r.level<2?4:0),y(r,3),r.status=h);else{var d=8+(r.w_bits-8<<4)<<8;d|=(2<=r.strategy||r.level<2?0:r.level<6?1:6===r.level?2:3)<<6,0!==r.strstart&&(d|=32),d+=31-d%31,r.status=h,v(r,d),0!==r.strstart&&(v(r,e.adler>>>16),v(r,65535&e.adler)),e.adler=1}if(69===r.status)if(r.gzhead.extra){for(i=r.pending;r.gzindex<(65535&r.gzhead.extra.length)&&(r.pending!==r.pending_buf_size||(r.gzhead.hcrc&&r.pending>i&&(e.adler=o(e.adler,r.pending_buf,r.pending-i,i)),g(e),i=r.pending,r.pending!==r.pending_buf_size));)y(r,255&r.gzhead.extra[r.gzindex]),r.gzindex++;r.gzhead.hcrc&&r.pending>i&&(e.adler=o(e.adler,r.pending_buf,r.pending-i,i)),r.gzindex===r.gzhead.extra.length&&(r.gzindex=0,r.status=73)}else r.status=73;if(73===r.status)if(r.gzhead.name){i=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>i&&(e.adler=o(e.adler,r.pending_buf,r.pending-i,i)),g(e),i=r.pending,r.pending===r.pending_buf_size)){c=1;break}c=r.gzindex<r.gzhead.name.length?255&r.gzhead.name.charCodeAt(r.gzindex++):0,y(r,c)}while(0!==c);r.gzhead.hcrc&&r.pending>i&&(e.adler=o(e.adler,r.pending_buf,r.pending-i,i)),0===c&&(r.gzindex=0,r.status=91)}else r.status=91;if(91===r.status)if(r.gzhead.comment){i=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>i&&(e.adler=o(e.adler,r.pending_buf,r.pending-i,i)),g(e),i=r.pending,r.pending===r.pending_buf_size)){c=1;break}c=r.gzindex<r.gzhead.comment.length?255&r.gzhead.comment.charCodeAt(r.gzindex++):0,y(r,c)}while(0!==c);r.gzhead.hcrc&&r.pending>i&&(e.adler=o(e.adler,r.pending_buf,r.pending-i,i)),0===c&&(r.status=103)}else r.status=103;if(103===r.status&&(r.gzhead.hcrc?(r.pending+2>r.pending_buf_size&&g(e),r.pending+2<=r.pending_buf_size&&(y(r,255&e.adler),y(r,e.adler>>8&255),e.adler=0,r.status=h)):r.status=h),0!==r.pending){if(g(e),0===e.avail_out)return r.last_flush=-1,0}else if(0===e.avail_in&&f(t)<=f(n)&&4!==t)return p(e,-5);if(666===r.status&&0!==e.avail_in)return p(e,-5);if(0!==e.avail_in||0!==r.lookahead||0!==t&&666!==r.status){var x=2===r.strategy?function(e,t){for(var n;;){if(0===e.lookahead&&(w(e),0===e.lookahead)){if(0===t)return 1;break}if(e.match_length=0,n=s._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,n&&(b(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,4===t?(b(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(b(e,!1),0===e.strm.avail_out)?1:2}(r,t):3===r.strategy?function(e,t){for(var n,a,r,i,o=e.window;;){if(e.lookahead<=u){if(w(e),e.lookahead<=u&&0===t)return 1;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=3&&0<e.strstart&&(a=o[r=e.strstart-1])===o[++r]&&a===o[++r]&&a===o[++r]){i=e.strstart+u;do{}while(a===o[++r]&&a===o[++r]&&a===o[++r]&&a===o[++r]&&a===o[++r]&&a===o[++r]&&a===o[++r]&&a===o[++r]&&r<i);e.match_length=u-(i-r),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=3?(n=s._tr_tally(e,1,e.match_length-3),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(n=s._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),n&&(b(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,4===t?(b(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(b(e,!1),0===e.strm.avail_out)?1:2}(r,t):a[r.level].func(r,t);if(3!==x&&4!==x||(r.status=666),1===x||3===x)return 0===e.avail_out&&(r.last_flush=-1),0;if(2===x&&(1===t?s._tr_align(r):5!==t&&(s._tr_stored_block(r,0,0,!1),3===t&&(m(r.head),0===r.lookahead&&(r.strstart=0,r.block_start=0,r.insert=0))),g(e),0===e.avail_out))return r.last_flush=-1,0}return 4!==t?0:r.wrap<=0?1:(2===r.wrap?(y(r,255&e.adler),y(r,e.adler>>8&255),y(r,e.adler>>16&255),y(r,e.adler>>24&255),y(r,255&e.total_in),y(r,e.total_in>>8&255),y(r,e.total_in>>16&255),y(r,e.total_in>>24&255)):(v(r,e.adler>>>16),v(r,65535&e.adler)),g(e),0<r.wrap&&(r.wrap=-r.wrap),0!==r.pending?0:1)},n.deflateEnd=function(e){var t;return e&&e.state?42!==(t=e.state.status)&&69!==t&&73!==t&&91!==t&&103!==t&&t!==h&&666!==t?p(e,l):(e.state=null,t===h?p(e,-3):0):l},n.deflateSetDictionary=function(e,t){var n,a,s,o,c,u,d,h,p=t.length;if(!e||!e.state)return l;if(2===(o=(n=e.state).wrap)||1===o&&42!==n.status||n.lookahead)return l;for(1===o&&(e.adler=i(e.adler,t,p,0)),n.wrap=0,p>=n.w_size&&(0===o&&(m(n.head),n.strstart=0,n.block_start=0,n.insert=0),h=new r.Buf8(n.w_size),r.arraySet(h,t,p-n.w_size,n.w_size,0),t=h,p=n.w_size),c=e.avail_in,u=e.next_in,d=e.input,e.avail_in=p,e.next_in=0,e.input=t,w(n);n.lookahead>=3;){for(a=n.strstart,s=n.lookahead-2;n.ins_h=(n.ins_h<<n.hash_shift^n.window[a+3-1])&n.hash_mask,n.prev[a&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=a,a++,--s;);n.strstart=a,n.lookahead=2,w(n)}return n.strstart+=n.lookahead,n.block_start=n.strstart,n.insert=n.lookahead,n.lookahead=0,n.match_length=n.prev_length=2,n.match_available=0,e.next_in=u,e.input=d,e.avail_in=c,n.wrap=o,0},n.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(e,t,n){"use strict";t.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(e,t,n){"use strict";t.exports=function(e,t){var n,a,r,s,i,o,c,l,u,d,h,p,f,m,g,b,y,v,x,w,k,I,S,N,T;n=e.state,a=e.next_in,N=e.input,r=a+(e.avail_in-5),s=e.next_out,T=e.output,i=s-(t-e.avail_out),o=s+(e.avail_out-257),c=n.dmax,l=n.wsize,u=n.whave,d=n.wnext,h=n.window,p=n.hold,f=n.bits,m=n.lencode,g=n.distcode,b=(1<<n.lenbits)-1,y=(1<<n.distbits)-1;e:do{f<15&&(p+=N[a++]<<f,f+=8,p+=N[a++]<<f,f+=8),v=m[p&b];t:for(;;){if(p>>>=x=v>>>24,f-=x,0===(x=v>>>16&255))T[s++]=65535&v;else{if(!(16&x)){if(0==(64&x)){v=m[(65535&v)+(p&(1<<x)-1)];continue t}if(32&x){n.mode=12;break e}e.msg="invalid literal/length code",n.mode=30;break e}w=65535&v,(x&=15)&&(f<x&&(p+=N[a++]<<f,f+=8),w+=p&(1<<x)-1,p>>>=x,f-=x),f<15&&(p+=N[a++]<<f,f+=8,p+=N[a++]<<f,f+=8),v=g[p&y];n:for(;;){if(p>>>=x=v>>>24,f-=x,!(16&(x=v>>>16&255))){if(0==(64&x)){v=g[(65535&v)+(p&(1<<x)-1)];continue n}e.msg="invalid distance code",n.mode=30;break e}if(k=65535&v,f<(x&=15)&&(p+=N[a++]<<f,(f+=8)<x&&(p+=N[a++]<<f,f+=8)),c<(k+=p&(1<<x)-1)){e.msg="invalid distance too far back",n.mode=30;break e}if(p>>>=x,f-=x,(x=s-i)<k){if(u<(x=k-x)&&n.sane){e.msg="invalid distance too far back",n.mode=30;break e}if(S=h,(I=0)===d){if(I+=l-x,x<w){for(w-=x;T[s++]=h[I++],--x;);I=s-k,S=T}}else if(d<x){if(I+=l+d-x,(x-=d)<w){for(w-=x;T[s++]=h[I++],--x;);if(I=0,d<w){for(w-=x=d;T[s++]=h[I++],--x;);I=s-k,S=T}}}else if(I+=d-x,x<w){for(w-=x;T[s++]=h[I++],--x;);I=s-k,S=T}for(;2<w;)T[s++]=S[I++],T[s++]=S[I++],T[s++]=S[I++],w-=3;w&&(T[s++]=S[I++],1<w&&(T[s++]=S[I++]))}else{for(I=s-k;T[s++]=T[I++],T[s++]=T[I++],T[s++]=T[I++],2<(w-=3););w&&(T[s++]=T[I++],1<w&&(T[s++]=T[I++]))}break}}break}}while(a<r&&s<o);a-=w=f>>3,p&=(1<<(f-=w<<3))-1,e.next_in=a,e.next_out=s,e.avail_in=a<r?r-a+5:5-(a-r),e.avail_out=s<o?o-s+257:257-(s-o),n.hold=p,n.bits=f}},{}],49:[function(e,t,n){"use strict";var a=e("../utils/common"),r=e("./adler32"),s=e("./crc32"),i=e("./inffast"),o=e("./inftrees"),c=-2;function l(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function u(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new a.Buf16(320),this.work=new a.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function d(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=1,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new a.Buf32(852),t.distcode=t.distdyn=new a.Buf32(592),t.sane=1,t.back=-1,0):c}function h(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,d(e)):c}function p(e,t){var n,a;return e&&e.state?(a=e.state,t<0?(n=0,t=-t):(n=1+(t>>4),t<48&&(t&=15)),t&&(t<8||15<t)?c:(null!==a.window&&a.wbits!==t&&(a.window=null),a.wrap=n,a.wbits=t,h(e))):c}function f(e,t){var n,a;return e?(a=new u,(e.state=a).window=null,0!==(n=p(e,t))&&(e.state=null),n):c}var m,g,b=!0;function y(e){if(b){var t;for(m=new a.Buf32(512),g=new a.Buf32(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(o(1,e.lens,0,288,m,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;o(2,e.lens,0,32,g,0,e.work,{bits:5}),b=!1}e.lencode=m,e.lenbits=9,e.distcode=g,e.distbits=5}function v(e,t,n,r){var s,i=e.state;return null===i.window&&(i.wsize=1<<i.wbits,i.wnext=0,i.whave=0,i.window=new a.Buf8(i.wsize)),r>=i.wsize?(a.arraySet(i.window,t,n-i.wsize,i.wsize,0),i.wnext=0,i.whave=i.wsize):(r<(s=i.wsize-i.wnext)&&(s=r),a.arraySet(i.window,t,n-r,s,i.wnext),(r-=s)?(a.arraySet(i.window,t,n-r,r,0),i.wnext=r,i.whave=i.wsize):(i.wnext+=s,i.wnext===i.wsize&&(i.wnext=0),i.whave<i.wsize&&(i.whave+=s))),0}n.inflateReset=h,n.inflateReset2=p,n.inflateResetKeep=d,n.inflateInit=function(e){return f(e,15)},n.inflateInit2=f,n.inflate=function(e,t){var n,u,d,h,p,f,m,g,b,x,w,k,I,S,N,T,O,C,E,_,A,R,D,F,M=0,j=new a.Buf8(4),z=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return c;12===(n=e.state).mode&&(n.mode=13),p=e.next_out,d=e.output,m=e.avail_out,h=e.next_in,u=e.input,f=e.avail_in,g=n.hold,b=n.bits,x=f,w=m,R=0;e:for(;;)switch(n.mode){case 1:if(0===n.wrap){n.mode=13;break}for(;b<16;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}if(2&n.wrap&&35615===g){j[n.check=0]=255&g,j[1]=g>>>8&255,n.check=s(n.check,j,2,0),b=g=0,n.mode=2;break}if(n.flags=0,n.head&&(n.head.done=!1),!(1&n.wrap)||(((255&g)<<8)+(g>>8))%31){e.msg="incorrect header check",n.mode=30;break}if(8!=(15&g)){e.msg="unknown compression method",n.mode=30;break}if(b-=4,A=8+(15&(g>>>=4)),0===n.wbits)n.wbits=A;else if(A>n.wbits){e.msg="invalid window size",n.mode=30;break}n.dmax=1<<A,e.adler=n.check=1,n.mode=512&g?10:12,b=g=0;break;case 2:for(;b<16;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}if(n.flags=g,8!=(255&n.flags)){e.msg="unknown compression method",n.mode=30;break}if(57344&n.flags){e.msg="unknown header flags set",n.mode=30;break}n.head&&(n.head.text=g>>8&1),512&n.flags&&(j[0]=255&g,j[1]=g>>>8&255,n.check=s(n.check,j,2,0)),b=g=0,n.mode=3;case 3:for(;b<32;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}n.head&&(n.head.time=g),512&n.flags&&(j[0]=255&g,j[1]=g>>>8&255,j[2]=g>>>16&255,j[3]=g>>>24&255,n.check=s(n.check,j,4,0)),b=g=0,n.mode=4;case 4:for(;b<16;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}n.head&&(n.head.xflags=255&g,n.head.os=g>>8),512&n.flags&&(j[0]=255&g,j[1]=g>>>8&255,n.check=s(n.check,j,2,0)),b=g=0,n.mode=5;case 5:if(1024&n.flags){for(;b<16;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}n.length=g,n.head&&(n.head.extra_len=g),512&n.flags&&(j[0]=255&g,j[1]=g>>>8&255,n.check=s(n.check,j,2,0)),b=g=0}else n.head&&(n.head.extra=null);n.mode=6;case 6:if(1024&n.flags&&(f<(k=n.length)&&(k=f),k&&(n.head&&(A=n.head.extra_len-n.length,n.head.extra||(n.head.extra=new Array(n.head.extra_len)),a.arraySet(n.head.extra,u,h,k,A)),512&n.flags&&(n.check=s(n.check,u,k,h)),f-=k,h+=k,n.length-=k),n.length))break e;n.length=0,n.mode=7;case 7:if(2048&n.flags){if(0===f)break e;for(k=0;A=u[h+k++],n.head&&A&&n.length<65536&&(n.head.name+=String.fromCharCode(A)),A&&k<f;);if(512&n.flags&&(n.check=s(n.check,u,k,h)),f-=k,h+=k,A)break e}else n.head&&(n.head.name=null);n.length=0,n.mode=8;case 8:if(4096&n.flags){if(0===f)break e;for(k=0;A=u[h+k++],n.head&&A&&n.length<65536&&(n.head.comment+=String.fromCharCode(A)),A&&k<f;);if(512&n.flags&&(n.check=s(n.check,u,k,h)),f-=k,h+=k,A)break e}else n.head&&(n.head.comment=null);n.mode=9;case 9:if(512&n.flags){for(;b<16;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}if(g!==(65535&n.check)){e.msg="header crc mismatch",n.mode=30;break}b=g=0}n.head&&(n.head.hcrc=n.flags>>9&1,n.head.done=!0),e.adler=n.check=0,n.mode=12;break;case 10:for(;b<32;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}e.adler=n.check=l(g),b=g=0,n.mode=11;case 11:if(0===n.havedict)return e.next_out=p,e.avail_out=m,e.next_in=h,e.avail_in=f,n.hold=g,n.bits=b,2;e.adler=n.check=1,n.mode=12;case 12:if(5===t||6===t)break e;case 13:if(n.last){g>>>=7&b,b-=7&b,n.mode=27;break}for(;b<3;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}switch(n.last=1&g,b-=1,3&(g>>>=1)){case 0:n.mode=14;break;case 1:if(y(n),n.mode=20,6!==t)break;g>>>=2,b-=2;break e;case 2:n.mode=17;break;case 3:e.msg="invalid block type",n.mode=30}g>>>=2,b-=2;break;case 14:for(g>>>=7&b,b-=7&b;b<32;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}if((65535&g)!=(g>>>16^65535)){e.msg="invalid stored block lengths",n.mode=30;break}if(n.length=65535&g,b=g=0,n.mode=15,6===t)break e;case 15:n.mode=16;case 16:if(k=n.length){if(f<k&&(k=f),m<k&&(k=m),0===k)break e;a.arraySet(d,u,h,k,p),f-=k,h+=k,m-=k,p+=k,n.length-=k;break}n.mode=12;break;case 17:for(;b<14;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}if(n.nlen=257+(31&g),g>>>=5,b-=5,n.ndist=1+(31&g),g>>>=5,b-=5,n.ncode=4+(15&g),g>>>=4,b-=4,286<n.nlen||30<n.ndist){e.msg="too many length or distance symbols",n.mode=30;break}n.have=0,n.mode=18;case 18:for(;n.have<n.ncode;){for(;b<3;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}n.lens[z[n.have++]]=7&g,g>>>=3,b-=3}for(;n.have<19;)n.lens[z[n.have++]]=0;if(n.lencode=n.lendyn,n.lenbits=7,D={bits:n.lenbits},R=o(0,n.lens,0,19,n.lencode,0,n.work,D),n.lenbits=D.bits,R){e.msg="invalid code lengths set",n.mode=30;break}n.have=0,n.mode=19;case 19:for(;n.have<n.nlen+n.ndist;){for(;T=(M=n.lencode[g&(1<<n.lenbits)-1])>>>16&255,O=65535&M,!((N=M>>>24)<=b);){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}if(O<16)g>>>=N,b-=N,n.lens[n.have++]=O;else{if(16===O){for(F=N+2;b<F;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}if(g>>>=N,b-=N,0===n.have){e.msg="invalid bit length repeat",n.mode=30;break}A=n.lens[n.have-1],k=3+(3&g),g>>>=2,b-=2}else if(17===O){for(F=N+3;b<F;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}b-=N,A=0,k=3+(7&(g>>>=N)),g>>>=3,b-=3}else{for(F=N+7;b<F;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}b-=N,A=0,k=11+(127&(g>>>=N)),g>>>=7,b-=7}if(n.have+k>n.nlen+n.ndist){e.msg="invalid bit length repeat",n.mode=30;break}for(;k--;)n.lens[n.have++]=A}}if(30===n.mode)break;if(0===n.lens[256]){e.msg="invalid code -- missing end-of-block",n.mode=30;break}if(n.lenbits=9,D={bits:n.lenbits},R=o(1,n.lens,0,n.nlen,n.lencode,0,n.work,D),n.lenbits=D.bits,R){e.msg="invalid literal/lengths set",n.mode=30;break}if(n.distbits=6,n.distcode=n.distdyn,D={bits:n.distbits},R=o(2,n.lens,n.nlen,n.ndist,n.distcode,0,n.work,D),n.distbits=D.bits,R){e.msg="invalid distances set",n.mode=30;break}if(n.mode=20,6===t)break e;case 20:n.mode=21;case 21:if(6<=f&&258<=m){e.next_out=p,e.avail_out=m,e.next_in=h,e.avail_in=f,n.hold=g,n.bits=b,i(e,w),p=e.next_out,d=e.output,m=e.avail_out,h=e.next_in,u=e.input,f=e.avail_in,g=n.hold,b=n.bits,12===n.mode&&(n.back=-1);break}for(n.back=0;T=(M=n.lencode[g&(1<<n.lenbits)-1])>>>16&255,O=65535&M,!((N=M>>>24)<=b);){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}if(T&&0==(240&T)){for(C=N,E=T,_=O;T=(M=n.lencode[_+((g&(1<<C+E)-1)>>C)])>>>16&255,O=65535&M,!(C+(N=M>>>24)<=b);){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}g>>>=C,b-=C,n.back+=C}if(g>>>=N,b-=N,n.back+=N,n.length=O,0===T){n.mode=26;break}if(32&T){n.back=-1,n.mode=12;break}if(64&T){e.msg="invalid literal/length code",n.mode=30;break}n.extra=15&T,n.mode=22;case 22:if(n.extra){for(F=n.extra;b<F;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}n.length+=g&(1<<n.extra)-1,g>>>=n.extra,b-=n.extra,n.back+=n.extra}n.was=n.length,n.mode=23;case 23:for(;T=(M=n.distcode[g&(1<<n.distbits)-1])>>>16&255,O=65535&M,!((N=M>>>24)<=b);){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}if(0==(240&T)){for(C=N,E=T,_=O;T=(M=n.distcode[_+((g&(1<<C+E)-1)>>C)])>>>16&255,O=65535&M,!(C+(N=M>>>24)<=b);){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}g>>>=C,b-=C,n.back+=C}if(g>>>=N,b-=N,n.back+=N,64&T){e.msg="invalid distance code",n.mode=30;break}n.offset=O,n.extra=15&T,n.mode=24;case 24:if(n.extra){for(F=n.extra;b<F;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}n.offset+=g&(1<<n.extra)-1,g>>>=n.extra,b-=n.extra,n.back+=n.extra}if(n.offset>n.dmax){e.msg="invalid distance too far back",n.mode=30;break}n.mode=25;case 25:if(0===m)break e;if(k=w-m,n.offset>k){if((k=n.offset-k)>n.whave&&n.sane){e.msg="invalid distance too far back",n.mode=30;break}I=k>n.wnext?(k-=n.wnext,n.wsize-k):n.wnext-k,k>n.length&&(k=n.length),S=n.window}else S=d,I=p-n.offset,k=n.length;for(m<k&&(k=m),m-=k,n.length-=k;d[p++]=S[I++],--k;);0===n.length&&(n.mode=21);break;case 26:if(0===m)break e;d[p++]=n.length,m--,n.mode=21;break;case 27:if(n.wrap){for(;b<32;){if(0===f)break e;f--,g|=u[h++]<<b,b+=8}if(w-=m,e.total_out+=w,n.total+=w,w&&(e.adler=n.check=n.flags?s(n.check,d,w,p-w):r(n.check,d,w,p-w)),w=m,(n.flags?g:l(g))!==n.check){e.msg="incorrect data check",n.mode=30;break}b=g=0}n.mode=28;case 28:if(n.wrap&&n.flags){for(;b<32;){if(0===f)break e;f--,g+=u[h++]<<b,b+=8}if(g!==(4294967295&n.total)){e.msg="incorrect length check",n.mode=30;break}b=g=0}n.mode=29;case 29:R=1;break e;case 30:R=-3;break e;case 31:return-4;case 32:default:return c}return e.next_out=p,e.avail_out=m,e.next_in=h,e.avail_in=f,n.hold=g,n.bits=b,(n.wsize||w!==e.avail_out&&n.mode<30&&(n.mode<27||4!==t))&&v(e,e.output,e.next_out,w-e.avail_out)?(n.mode=31,-4):(x-=e.avail_in,w-=e.avail_out,e.total_in+=x,e.total_out+=w,n.total+=w,n.wrap&&w&&(e.adler=n.check=n.flags?s(n.check,d,w,e.next_out-w):r(n.check,d,w,e.next_out-w)),e.data_type=n.bits+(n.last?64:0)+(12===n.mode?128:0)+(20===n.mode||15===n.mode?256:0),(0==x&&0===w||4===t)&&0===R&&(R=-5),R)},n.inflateEnd=function(e){if(!e||!e.state)return c;var t=e.state;return t.window&&(t.window=null),e.state=null,0},n.inflateGetHeader=function(e,t){var n;return e&&e.state?0==(2&(n=e.state).wrap)?c:((n.head=t).done=!1,0):c},n.inflateSetDictionary=function(e,t){var n,a=t.length;return e&&e.state?0!==(n=e.state).wrap&&11!==n.mode?c:11===n.mode&&r(1,t,a,0)!==n.check?-3:v(e,t,a,a)?(n.mode=31,-4):(n.havedict=1,0):c},n.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(e,t,n){"use strict";var a=e("../utils/common"),r=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],s=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],i=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],o=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];t.exports=function(e,t,n,c,l,u,d,h){var p,f,m,g,b,y,v,x,w,k=h.bits,I=0,S=0,N=0,T=0,O=0,C=0,E=0,_=0,A=0,R=0,D=null,F=0,M=new a.Buf16(16),j=new a.Buf16(16),z=null,L=0;for(I=0;I<=15;I++)M[I]=0;for(S=0;S<c;S++)M[t[n+S]]++;for(O=k,T=15;1<=T&&0===M[T];T--);if(T<O&&(O=T),0===T)return l[u++]=20971520,l[u++]=20971520,h.bits=1,0;for(N=1;N<T&&0===M[N];N++);for(O<N&&(O=N),I=_=1;I<=15;I++)if(_<<=1,(_-=M[I])<0)return-1;if(0<_&&(0===e||1!==T))return-1;for(j[1]=0,I=1;I<15;I++)j[I+1]=j[I]+M[I];for(S=0;S<c;S++)0!==t[n+S]&&(d[j[t[n+S]]++]=S);if(y=0===e?(D=z=d,19):1===e?(D=r,F-=257,z=s,L-=257,256):(D=i,z=o,-1),I=N,b=u,E=S=R=0,m=-1,g=(A=1<<(C=O))-1,1===e&&852<A||2===e&&592<A)return 1;for(;;){for(v=I-E,w=d[S]<y?(x=0,d[S]):d[S]>y?(x=z[L+d[S]],D[F+d[S]]):(x=96,0),p=1<<I-E,N=f=1<<C;l[b+(R>>E)+(f-=p)]=v<<24|x<<16|w|0,0!==f;);for(p=1<<I-1;R&p;)p>>=1;if(0!==p?(R&=p-1,R+=p):R=0,S++,0==--M[I]){if(I===T)break;I=t[n+d[S]]}if(O<I&&(R&g)!==m){for(0===E&&(E=O),b+=N,_=1<<(C=I-E);C+E<T&&!((_-=M[C+E])<=0);)C++,_<<=1;if(A+=1<<C,1===e&&852<A||2===e&&592<A)return 1;l[m=R&g]=O<<24|C<<16|b-u|0}}return 0!==R&&(l[b+R]=I-E<<24|64<<16|0),h.bits=O,0}},{"../utils/common":41}],51:[function(e,t,n){"use strict";t.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(e,t,n){"use strict";var a=e("../utils/common");function r(e){for(var t=e.length;0<=--t;)e[t]=0}var s=256,i=286,o=30,c=15,l=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],u=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],d=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],h=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],p=new Array(576);r(p);var f=new Array(60);r(f);var m=new Array(512);r(m);var g=new Array(256);r(g);var b=new Array(29);r(b);var y,v,x,w=new Array(o);function k(e,t,n,a,r){this.static_tree=e,this.extra_bits=t,this.extra_base=n,this.elems=a,this.max_length=r,this.has_stree=e&&e.length}function I(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}function S(e){return e<256?m[e]:m[256+(e>>>7)]}function N(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255}function T(e,t,n){e.bi_valid>16-n?(e.bi_buf|=t<<e.bi_valid&65535,N(e,e.bi_buf),e.bi_buf=t>>16-e.bi_valid,e.bi_valid+=n-16):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=n)}function O(e,t,n){T(e,n[2*t],n[2*t+1])}function C(e,t){for(var n=0;n|=1&e,e>>>=1,n<<=1,0<--t;);return n>>>1}function E(e,t,n){var a,r,s=new Array(16),i=0;for(a=1;a<=c;a++)s[a]=i=i+n[a-1]<<1;for(r=0;r<=t;r++){var o=e[2*r+1];0!==o&&(e[2*r]=C(s[o]++,o))}}function _(e){var t;for(t=0;t<i;t++)e.dyn_ltree[2*t]=0;for(t=0;t<o;t++)e.dyn_dtree[2*t]=0;for(t=0;t<19;t++)e.bl_tree[2*t]=0;e.dyn_ltree[512]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0}function A(e){8<e.bi_valid?N(e,e.bi_buf):0<e.bi_valid&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0}function R(e,t,n,a){var r=2*t,s=2*n;return e[r]<e[s]||e[r]===e[s]&&a[t]<=a[n]}function D(e,t,n){for(var a=e.heap[n],r=n<<1;r<=e.heap_len&&(r<e.heap_len&&R(t,e.heap[r+1],e.heap[r],e.depth)&&r++,!R(t,a,e.heap[r],e.depth));)e.heap[n]=e.heap[r],n=r,r<<=1;e.heap[n]=a}function F(e,t,n){var a,r,i,o,c=0;if(0!==e.last_lit)for(;a=e.pending_buf[e.d_buf+2*c]<<8|e.pending_buf[e.d_buf+2*c+1],r=e.pending_buf[e.l_buf+c],c++,0===a?O(e,r,t):(O(e,(i=g[r])+s+1,t),0!==(o=l[i])&&T(e,r-=b[i],o),O(e,i=S(--a),n),0!==(o=u[i])&&T(e,a-=w[i],o)),c<e.last_lit;);O(e,256,t)}function M(e,t){var n,a,r,s=t.dyn_tree,i=t.stat_desc.static_tree,o=t.stat_desc.has_stree,l=t.stat_desc.elems,u=-1;for(e.heap_len=0,e.heap_max=573,n=0;n<l;n++)0!==s[2*n]?(e.heap[++e.heap_len]=u=n,e.depth[n]=0):s[2*n+1]=0;for(;e.heap_len<2;)s[2*(r=e.heap[++e.heap_len]=u<2?++u:0)]=1,e.depth[r]=0,e.opt_len--,o&&(e.static_len-=i[2*r+1]);for(t.max_code=u,n=e.heap_len>>1;1<=n;n--)D(e,s,n);for(r=l;n=e.heap[1],e.heap[1]=e.heap[e.heap_len--],D(e,s,1),a=e.heap[1],e.heap[--e.heap_max]=n,e.heap[--e.heap_max]=a,s[2*r]=s[2*n]+s[2*a],e.depth[r]=(e.depth[n]>=e.depth[a]?e.depth[n]:e.depth[a])+1,s[2*n+1]=s[2*a+1]=r,e.heap[1]=r++,D(e,s,1),2<=e.heap_len;);e.heap[--e.heap_max]=e.heap[1],function(e,t){var n,a,r,s,i,o,l=t.dyn_tree,u=t.max_code,d=t.stat_desc.static_tree,h=t.stat_desc.has_stree,p=t.stat_desc.extra_bits,f=t.stat_desc.extra_base,m=t.stat_desc.max_length,g=0;for(s=0;s<=c;s++)e.bl_count[s]=0;for(l[2*e.heap[e.heap_max]+1]=0,n=e.heap_max+1;n<573;n++)m<(s=l[2*l[2*(a=e.heap[n])+1]+1]+1)&&(s=m,g++),l[2*a+1]=s,u<a||(e.bl_count[s]++,i=0,f<=a&&(i=p[a-f]),o=l[2*a],e.opt_len+=o*(s+i),h&&(e.static_len+=o*(d[2*a+1]+i)));if(0!==g){do{for(s=m-1;0===e.bl_count[s];)s--;e.bl_count[s]--,e.bl_count[s+1]+=2,e.bl_count[m]--,g-=2}while(0<g);for(s=m;0!==s;s--)for(a=e.bl_count[s];0!==a;)u<(r=e.heap[--n])||(l[2*r+1]!==s&&(e.opt_len+=(s-l[2*r+1])*l[2*r],l[2*r+1]=s),a--)}}(e,t),E(s,u,e.bl_count)}function j(e,t,n){var a,r,s=-1,i=t[1],o=0,c=7,l=4;for(0===i&&(c=138,l=3),t[2*(n+1)+1]=65535,a=0;a<=n;a++)r=i,i=t[2*(a+1)+1],++o<c&&r===i||(o<l?e.bl_tree[2*r]+=o:0!==r?(r!==s&&e.bl_tree[2*r]++,e.bl_tree[32]++):o<=10?e.bl_tree[34]++:e.bl_tree[36]++,s=r,l=(o=0)===i?(c=138,3):r===i?(c=6,3):(c=7,4))}function z(e,t,n){var a,r,s=-1,i=t[1],o=0,c=7,l=4;for(0===i&&(c=138,l=3),a=0;a<=n;a++)if(r=i,i=t[2*(a+1)+1],!(++o<c&&r===i)){if(o<l)for(;O(e,r,e.bl_tree),0!=--o;);else 0!==r?(r!==s&&(O(e,r,e.bl_tree),o--),O(e,16,e.bl_tree),T(e,o-3,2)):o<=10?(O(e,17,e.bl_tree),T(e,o-3,3)):(O(e,18,e.bl_tree),T(e,o-11,7));s=r,l=(o=0)===i?(c=138,3):r===i?(c=6,3):(c=7,4)}}r(w);var L=!1;function P(e,t,n,r){T(e,0+(r?1:0),3),function(e,t,n,r){A(e),N(e,n),N(e,~n),a.arraySet(e.pending_buf,e.window,t,n,e.pending),e.pending+=n}(e,t,n)}n._tr_init=function(e){L||(function(){var e,t,n,a,r,s=new Array(16);for(a=n=0;a<28;a++)for(b[a]=n,e=0;e<1<<l[a];e++)g[n++]=a;for(g[n-1]=a,a=r=0;a<16;a++)for(w[a]=r,e=0;e<1<<u[a];e++)m[r++]=a;for(r>>=7;a<o;a++)for(w[a]=r<<7,e=0;e<1<<u[a]-7;e++)m[256+r++]=a;for(t=0;t<=c;t++)s[t]=0;for(e=0;e<=143;)p[2*e+1]=8,e++,s[8]++;for(;e<=255;)p[2*e+1]=9,e++,s[9]++;for(;e<=279;)p[2*e+1]=7,e++,s[7]++;for(;e<=287;)p[2*e+1]=8,e++,s[8]++;for(E(p,287,s),e=0;e<o;e++)f[2*e+1]=5,f[2*e]=C(e,5);y=new k(p,l,257,i,c),v=new k(f,u,0,o,c),x=new k(new Array(0),d,0,19,7)}(),L=!0),e.l_desc=new I(e.dyn_ltree,y),e.d_desc=new I(e.dyn_dtree,v),e.bl_desc=new I(e.bl_tree,x),e.bi_buf=0,e.bi_valid=0,_(e)},n._tr_stored_block=P,n._tr_flush_block=function(e,t,n,a){var r,i,o=0;0<e.level?(2===e.strm.data_type&&(e.strm.data_type=function(e){var t,n=4093624447;for(t=0;t<=31;t++,n>>>=1)if(1&n&&0!==e.dyn_ltree[2*t])return 0;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return 1;for(t=32;t<s;t++)if(0!==e.dyn_ltree[2*t])return 1;return 0}(e)),M(e,e.l_desc),M(e,e.d_desc),o=function(e){var t;for(j(e,e.dyn_ltree,e.l_desc.max_code),j(e,e.dyn_dtree,e.d_desc.max_code),M(e,e.bl_desc),t=18;3<=t&&0===e.bl_tree[2*h[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),r=e.opt_len+3+7>>>3,(i=e.static_len+3+7>>>3)<=r&&(r=i)):r=i=n+5,n+4<=r&&-1!==t?P(e,t,n,a):4===e.strategy||i===r?(T(e,2+(a?1:0),3),F(e,p,f)):(T(e,4+(a?1:0),3),function(e,t,n,a){var r;for(T(e,t-257,5),T(e,n-1,5),T(e,a-4,4),r=0;r<a;r++)T(e,e.bl_tree[2*h[r]+1],3);z(e,e.dyn_ltree,t-1),z(e,e.dyn_dtree,n-1)}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,o+1),F(e,e.dyn_ltree,e.dyn_dtree)),_(e),a&&A(e)},n._tr_tally=function(e,t,n){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&n,e.last_lit++,0===t?e.dyn_ltree[2*n]++:(e.matches++,t--,e.dyn_ltree[2*(g[n]+s+1)]++,e.dyn_dtree[2*S(t)]++),e.last_lit===e.lit_bufsize-1},n._tr_align=function(e){T(e,2,3),O(e,256,p),function(e){16===e.bi_valid?(N(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):8<=e.bi_valid&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)}(e)}},{"../utils/common":41}],53:[function(e,t,n){"use strict";t.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(e,t,n){(function(e){!function(e,t){"use strict";if(!e.setImmediate){var n,a,s,i,o=1,c={},l=!1,u=e.document,d=Object.getPrototypeOf&&Object.getPrototypeOf(e);d=d&&d.setTimeout?d:e,n="[object process]"==={}.toString.call(e.process)?function(e){r.nextTick((function(){p(e)}))}:function(){if(e.postMessage&&!e.importScripts){var t=!0,n=e.onmessage;return e.onmessage=function(){t=!1},e.postMessage("","*"),e.onmessage=n,t}}()?(i="setImmediate$"+Math.random()+"$",e.addEventListener?e.addEventListener("message",f,!1):e.attachEvent("onmessage",f),function(t){e.postMessage(i+t,"*")}):e.MessageChannel?((s=new MessageChannel).port1.onmessage=function(e){p(e.data)},function(e){s.port2.postMessage(e)}):u&&"onreadystatechange"in u.createElement("script")?(a=u.documentElement,function(e){var t=u.createElement("script");t.onreadystatechange=function(){p(e),t.onreadystatechange=null,a.removeChild(t),t=null},a.appendChild(t)}):function(e){setTimeout(p,0,e)},d.setImmediate=function(e){"function"!=typeof e&&(e=new Function(""+e));for(var t=new Array(arguments.length-1),a=0;a<t.length;a++)t[a]=arguments[a+1];var r={callback:e,args:t};return c[o]=r,n(o),o++},d.clearImmediate=h}function h(e){delete c[e]}function p(e){if(l)setTimeout(p,0,e);else{var t=c[e];if(t){l=!0;try{!function(e){var t=e.callback,n=e.args;switch(n.length){case 0:t();break;case 1:t(n[0]);break;case 2:t(n[0],n[1]);break;case 3:t(n[0],n[1],n[2]);break;default:t.apply(void 0,n)}}(t)}finally{h(e),l=!1}}}}function f(t){t.source===e&&"string"==typeof t.data&&0===t.data.indexOf(i)&&p(+t.data.slice(i.length))}}("undefined"==typeof self?void 0===e?this:e:self)}).call(this,"undefined"!=typeof a?a:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}]},{},[10])(10)}).call(this,n(128).Buffer,n(176).setImmediate,n(100),n(101))},,function(e,t,n){"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE){0;try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}}(),e.exports=n(229)},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return a}));const a=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}]},function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return i}));var a=n(0),r=n(40),s=n(224);class i extends r.a{decodeUTF8(){return new o(this)}}class o extends s.a{constructor(e){super(),this.upstream=e,this.impl=new c(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class c extends r.b{constructor(e){if(super(),this.upstream=e,Object(a.be)().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:e}=n(249);this.decoder=new e("utf8")}}summary(){return"".concat(this.upstream.summary()," -> Utf8")}async pump(){const t=await this.upstream.next();let n,r;return!t.done&&(n=t.value,r=Object(a.be)().get("IS_BROWSER")?this.decoder.decode(n,{stream:!0}):this.decoder.write(e.from(n.buffer)),this.outputQueue.push(r),!0)}}}).call(this,n(128).Buffer)},function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));var a=n(40);class r extends a.a{split(e){return new s(this,e)}}class s extends r{constructor(e,t){super(),this.upstream=e,this.impl=new i(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class i extends a.b{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return"".concat(this.upstream.summary()," -> Split('").concat(this.separator,"')")}async pump(){const e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}}},function(e,t,n){var a;a=function(e){return function(e){var t={};function n(a){if(t[a])return t[a].exports;var r=t[a]={i:a,l:!1,exports:{}};return e[a].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=e,n.c=t,n.d=function(e,t,a){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},n.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(n.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)n.d(a,r,function(t){return e[t]}.bind(null,r));return a},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":function(e,t,n){"use strict";n.r(t);var a=n("react"),r=function(){var e=function(t,n){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(t,n)};return function(t,n){function a(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(a.prototype=n.prototype,new a)}}(),s=function(){return(s=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)},i=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var r=0;for(a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]])}return n};function o(){return!(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)}"undefined"!==typeof window&&(void 0===navigator.mediaDevices&&(navigator.mediaDevices={}),void 0===navigator.mediaDevices.getUserMedia&&(navigator.mediaDevices.getUserMedia=function(e){var t=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return t?new Promise((function(n,a){t.call(navigator,e,n,a)})):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}));var c=function(e){function t(t){var n=e.call(this,t)||this;return n.canvas=null,n.ctx=null,n.unmounted=!1,n.state={hasUserMedia:!1},n}return r(t,e),t.prototype.componentDidMount=function(){var e=this.state,t=this.props;o()?e.hasUserMedia||this.requestUserMedia():t.onUserMediaError("getUserMedia not supported")},t.prototype.componentDidUpdate=function(e){var t=this.props;if(o()){var n=JSON.stringify(e.audioConstraints)!==JSON.stringify(t.audioConstraints),a=JSON.stringify(e.videoConstraints)!==JSON.stringify(t.videoConstraints),r=e.minScreenshotWidth!==t.minScreenshotWidth,s=e.minScreenshotHeight!==t.minScreenshotHeight;(a||r||s)&&(this.canvas=null,this.ctx=null),(n||a)&&(this.stopAndCleanup(),this.requestUserMedia())}else t.onUserMediaError("getUserMedia not supported")},t.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},t.stopMediaStream=function(e){e&&(e.getVideoTracks&&e.getAudioTracks?(e.getVideoTracks().map((function(t){e.removeTrack(t),t.stop()})),e.getAudioTracks().map((function(t){e.removeTrack(t),t.stop()}))):e.stop())},t.prototype.stopAndCleanup=function(){var e=this.state;e.hasUserMedia&&(t.stopMediaStream(this.stream),e.src&&window.URL.revokeObjectURL(e.src))},t.prototype.getScreenshot=function(e){var t=this.state,n=this.props;if(!t.hasUserMedia)return null;var a=this.getCanvas(e);return a&&a.toDataURL(n.screenshotFormat,n.screenshotQuality)},t.prototype.getCanvas=function(e){var t=this.state,n=this.props;if(!this.video)return null;if(!t.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var a=this.video.videoWidth,r=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var s=a/r;r=(a=n.minScreenshotWidth||this.video.clientWidth)/s,n.minScreenshotHeight&&r<n.minScreenshotHeight&&(a=(r=n.minScreenshotHeight)*s)}this.canvas=document.createElement("canvas"),this.canvas.width=(null===e||void 0===e?void 0:e.width)||a,this.canvas.height=(null===e||void 0===e?void 0:e.height)||r,this.ctx=this.canvas.getContext("2d")}var i=this.ctx,o=this.canvas;return i&&o&&(n.mirrored&&(i.translate(o.width,0),i.scale(-1,1)),i.imageSmoothingEnabled=n.imageSmoothing,i.drawImage(this.video,0,0,(null===e||void 0===e?void 0:e.width)||o.width,(null===e||void 0===e?void 0:e.height)||o.height),n.mirrored&&(i.scale(-1,1),i.translate(-o.width,0))),o},t.prototype.requestUserMedia=function(){var e=this,n=this.props,a=function(a,r){var s={video:"undefined"===typeof r||r};n.audio&&(s.audio="undefined"===typeof a||a),navigator.mediaDevices.getUserMedia(s).then((function(n){e.unmounted?t.stopMediaStream(n):e.handleUserMedia(null,n)})).catch((function(t){e.handleUserMedia(t)}))};if("mediaDevices"in navigator)a(n.audioConstraints,n.videoConstraints);else{var r=function(e){return{optional:[{sourceId:e}]}},s=function(e){var t=e.deviceId;return"string"===typeof t?t:Array.isArray(t)&&t.length>0?t[0]:"object"===typeof t&&t.ideal?t.ideal:null};MediaStreamTrack.getSources((function(e){var t=null,i=null;e.forEach((function(e){"audio"===e.kind?t=e.id:"video"===e.kind&&(i=e.id)}));var o=s(n.audioConstraints);o&&(t=o);var c=s(n.videoConstraints);c&&(i=c),a(r(t),r(i))}))}},t.prototype.handleUserMedia=function(e,t){var n=this.props;if(e||!t)return this.setState({hasUserMedia:!1}),void n.onUserMediaError(e);this.stream=t;try{this.video&&(this.video.srcObject=t),this.setState({hasUserMedia:!0})}catch(a){this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(t)})}n.onUserMedia(t)},t.prototype.render=function(){var e=this,t=this.state,n=this.props,r=n.audio,o=(n.forceScreenshotSourceSize,n.onUserMedia,n.onUserMediaError,n.screenshotFormat,n.screenshotQuality,n.minScreenshotWidth,n.minScreenshotHeight,n.audioConstraints,n.videoConstraints,n.imageSmoothing,n.mirrored),c=n.style,l=void 0===c?{}:c,u=i(n,["audio","forceScreenshotSourceSize","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style"]),d=o?s(s({},l),{transform:(l.transform||"")+" scaleX(-1)"}):l;return a.createElement("video",s({autoPlay:!0,src:t.src,muted:r,playsInline:!0,ref:function(t){e.video=t},style:d},u))},t.defaultProps={audio:!0,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},t}(a.Component);t.default=c},react:function(t,n){t.exports=e}}).default},e.exports=a(n(41))},,,function(e,t,n){"use strict";var a=n(178),r="function"===typeof Symbol&&Symbol.for,s=r?Symbol.for("react.element"):60103,i=r?Symbol.for("react.portal"):60106,o=r?Symbol.for("react.fragment"):60107,c=r?Symbol.for("react.strict_mode"):60108,l=r?Symbol.for("react.profiler"):60114,u=r?Symbol.for("react.provider"):60109,d=r?Symbol.for("react.context"):60110,h=r?Symbol.for("react.forward_ref"):60112,p=r?Symbol.for("react.suspense"):60113,f=r?Symbol.for("react.memo"):60115,m=r?Symbol.for("react.lazy"):60116,g="function"===typeof Symbol&&Symbol.iterator;function b(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var y={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},v={};function x(e,t,n){this.props=e,this.context=t,this.refs=v,this.updater=n||y}function w(){}function k(e,t,n){this.props=e,this.context=t,this.refs=v,this.updater=n||y}x.prototype.isReactComponent={},x.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error(b(85));this.updater.enqueueSetState(this,e,t,"setState")},x.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},w.prototype=x.prototype;var I=k.prototype=new w;I.constructor=k,a(I,x.prototype),I.isPureReactComponent=!0;var S={current:null},N=Object.prototype.hasOwnProperty,T={key:!0,ref:!0,__self:!0,__source:!0};function O(e,t,n){var a,r={},i=null,o=null;if(null!=t)for(a in void 0!==t.ref&&(o=t.ref),void 0!==t.key&&(i=""+t.key),t)N.call(t,a)&&!T.hasOwnProperty(a)&&(r[a]=t[a]);var c=arguments.length-2;if(1===c)r.children=n;else if(1<c){for(var l=Array(c),u=0;u<c;u++)l[u]=arguments[u+2];r.children=l}if(e&&e.defaultProps)for(a in c=e.defaultProps)void 0===r[a]&&(r[a]=c[a]);return{$$typeof:s,type:e,key:i,ref:o,props:r,_owner:S.current}}function C(e){return"object"===typeof e&&null!==e&&e.$$typeof===s}var E=/\/+/g,_=[];function A(e,t,n,a){if(_.length){var r=_.pop();return r.result=e,r.keyPrefix=t,r.func=n,r.context=a,r.count=0,r}return{result:e,keyPrefix:t,func:n,context:a,count:0}}function R(e){e.result=null,e.keyPrefix=null,e.func=null,e.context=null,e.count=0,10>_.length&&_.push(e)}function D(e,t,n){return null==e?0:function e(t,n,a,r){var o=typeof t;"undefined"!==o&&"boolean"!==o||(t=null);var c=!1;if(null===t)c=!0;else switch(o){case"string":case"number":c=!0;break;case"object":switch(t.$$typeof){case s:case i:c=!0}}if(c)return a(r,t,""===n?"."+F(t,0):n),1;if(c=0,n=""===n?".":n+":",Array.isArray(t))for(var l=0;l<t.length;l++){var u=n+F(o=t[l],l);c+=e(o,u,a,r)}else if(null===t||"object"!==typeof t?u=null:u="function"===typeof(u=g&&t[g]||t["@@iterator"])?u:null,"function"===typeof u)for(t=u.call(t),l=0;!(o=t.next()).done;)c+=e(o=o.value,u=n+F(o,l++),a,r);else if("object"===o)throw a=""+t,Error(b(31,"[object Object]"===a?"object with keys {"+Object.keys(t).join(", ")+"}":a,""));return c}(e,"",t,n)}function F(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+(""+e).replace(/[=:]/g,(function(e){return t[e]}))}(e.key):t.toString(36)}function M(e,t){e.func.call(e.context,t,e.count++)}function j(e,t,n){var a=e.result,r=e.keyPrefix;e=e.func.call(e.context,t,e.count++),Array.isArray(e)?z(e,a,n,(function(e){return e})):null!=e&&(C(e)&&(e=function(e,t){return{$$typeof:s,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(e,r+(!e.key||t&&t.key===e.key?"":(""+e.key).replace(E,"$&/")+"/")+n)),a.push(e))}function z(e,t,n,a,r){var s="";null!=n&&(s=(""+n).replace(E,"$&/")+"/"),D(e,j,t=A(t,s,a,r)),R(t)}var L={current:null};function P(){var e=L.current;if(null===e)throw Error(b(321));return e}var B={ReactCurrentDispatcher:L,ReactCurrentBatchConfig:{suspense:null},ReactCurrentOwner:S,IsSomeRendererActing:{current:!1},assign:a};t.Children={map:function(e,t,n){if(null==e)return e;var a=[];return z(e,a,null,t,n),a},forEach:function(e,t,n){if(null==e)return e;D(e,M,t=A(null,null,t,n)),R(t)},count:function(e){return D(e,(function(){return null}),null)},toArray:function(e){var t=[];return z(e,t,null,(function(e){return e})),t},only:function(e){if(!C(e))throw Error(b(143));return e}},t.Component=x,t.Fragment=o,t.Profiler=l,t.PureComponent=k,t.StrictMode=c,t.Suspense=p,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B,t.cloneElement=function(e,t,n){if(null===e||void 0===e)throw Error(b(267,e));var r=a({},e.props),i=e.key,o=e.ref,c=e._owner;if(null!=t){if(void 0!==t.ref&&(o=t.ref,c=S.current),void 0!==t.key&&(i=""+t.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(u in t)N.call(t,u)&&!T.hasOwnProperty(u)&&(r[u]=void 0===t[u]&&void 0!==l?l[u]:t[u])}var u=arguments.length-2;if(1===u)r.children=n;else if(1<u){l=Array(u);for(var d=0;d<u;d++)l[d]=arguments[d+2];r.children=l}return{$$typeof:s,type:e.type,key:i,ref:o,props:r,_owner:c}},t.createContext=function(e,t){return void 0===t&&(t=null),(e={$$typeof:d,_calculateChangedBits:t,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider={$$typeof:u,_context:e},e.Consumer=e},t.createElement=O,t.createFactory=function(e){var t=O.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:h,render:e}},t.isValidElement=C,t.lazy=function(e){return{$$typeof:m,_ctor:e,_status:-1,_result:null}},t.memo=function(e,t){return{$$typeof:f,type:e,compare:void 0===t?null:t}},t.useCallback=function(e,t){return P().useCallback(e,t)},t.useContext=function(e,t){return P().useContext(e,t)},t.useDebugValue=function(){},t.useEffect=function(e,t){return P().useEffect(e,t)},t.useImperativeHandle=function(e,t,n){return P().useImperativeHandle(e,t,n)},t.useLayoutEffect=function(e,t){return P().useLayoutEffect(e,t)},t.useMemo=function(e,t){return P().useMemo(e,t)},t.useReducer=function(e,t,n){return P().useReducer(e,t,n)},t.useRef=function(e){return P().useRef(e)},t.useState=function(e){return P().useState(e)},t.version="16.14.0"},function(e,t,n){"use strict";var a=n(41),r=n(178),s=n(230);function i(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!a)throw Error(i(227));function o(e,t,n,a,r,s,i,o,c){var l=Array.prototype.slice.call(arguments,3);try{t.apply(n,l)}catch(u){this.onError(u)}}var c=!1,l=null,u=!1,d=null,h={onError:function(e){c=!0,l=e}};function p(e,t,n,a,r,s,i,u,d){c=!1,l=null,o.apply(h,arguments)}var f=null,m=null,g=null;function b(e,t,n){var a=e.type||"unknown-event";e.currentTarget=g(n),function(e,t,n,a,r,s,o,h,f){if(p.apply(this,arguments),c){if(!c)throw Error(i(198));var m=l;c=!1,l=null,u||(u=!0,d=m)}}(a,t,void 0,e),e.currentTarget=null}var y=null,v={};function x(){if(y)for(var e in v){var t=v[e],n=y.indexOf(e);if(!(-1<n))throw Error(i(96,e));if(!k[n]){if(!t.extractEvents)throw Error(i(97,e));for(var a in k[n]=t,n=t.eventTypes){var r=void 0,s=n[a],o=t,c=a;if(I.hasOwnProperty(c))throw Error(i(99,c));I[c]=s;var l=s.phasedRegistrationNames;if(l){for(r in l)l.hasOwnProperty(r)&&w(l[r],o,c);r=!0}else s.registrationName?(w(s.registrationName,o,c),r=!0):r=!1;if(!r)throw Error(i(98,a,e))}}}}function w(e,t,n){if(S[e])throw Error(i(100,e));S[e]=t,N[e]=t.eventTypes[n].dependencies}var k=[],I={},S={},N={};function T(e){var t,n=!1;for(t in e)if(e.hasOwnProperty(t)){var a=e[t];if(!v.hasOwnProperty(t)||v[t]!==a){if(v[t])throw Error(i(102,t));v[t]=a,n=!0}}n&&x()}var O=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),C=null,E=null,_=null;function A(e){if(e=m(e)){if("function"!==typeof C)throw Error(i(280));var t=e.stateNode;t&&(t=f(t),C(e.stateNode,e.type,t))}}function R(e){E?_?_.push(e):_=[e]:E=e}function D(){if(E){var e=E,t=_;if(_=E=null,A(e),t)for(e=0;e<t.length;e++)A(t[e])}}function F(e,t){return e(t)}function M(e,t,n,a,r){return e(t,n,a,r)}function j(){}var z=F,L=!1,P=!1;function B(){null===E&&null===_||(j(),D())}function W(e,t,n){if(P)return e(t,n);P=!0;try{return z(e,t,n)}finally{P=!1,B()}}var U=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,V=Object.prototype.hasOwnProperty,G={},H={};function q(e,t,n,a,r,s){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=a,this.attributeNamespace=r,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=s}var K={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){K[e]=new q(e,0,!1,e,null,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];K[t]=new q(t,1,!1,e[1],null,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){K[e]=new q(e,2,!1,e.toLowerCase(),null,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){K[e]=new q(e,2,!1,e,null,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){K[e]=new q(e,3,!1,e.toLowerCase(),null,!1)})),["checked","multiple","muted","selected"].forEach((function(e){K[e]=new q(e,3,!0,e,null,!1)})),["capture","download"].forEach((function(e){K[e]=new q(e,4,!1,e,null,!1)})),["cols","rows","size","span"].forEach((function(e){K[e]=new q(e,6,!1,e,null,!1)})),["rowSpan","start"].forEach((function(e){K[e]=new q(e,5,!1,e.toLowerCase(),null,!1)}));var X=/[\-:]([a-z])/g;function Z(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(X,Z);K[t]=new q(t,1,!1,e,null,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(X,Z);K[t]=new q(t,1,!1,e,"http://www.w3.org/1999/xlink",!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(X,Z);K[t]=new q(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1)})),["tabIndex","crossOrigin"].forEach((function(e){K[e]=new q(e,1,!1,e.toLowerCase(),null,!1)})),K.xlinkHref=new q("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0),["src","href","action","formAction"].forEach((function(e){K[e]=new q(e,1,!1,e.toLowerCase(),null,!0)}));var Y=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;function J(e,t,n,a){var r=K.hasOwnProperty(t)?K[t]:null;(null!==r?0===r.type:!a&&(2<t.length&&("o"===t[0]||"O"===t[0])&&("n"===t[1]||"N"===t[1])))||(function(e,t,n,a){if(null===t||"undefined"===typeof t||function(e,t,n,a){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!a&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,a))return!0;if(a)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,r,a)&&(n=null),a||null===r?function(e){return!!V.call(H,e)||!V.call(G,e)&&(U.test(e)?H[e]=!0:(G[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):r.mustUseProperty?e[r.propertyName]=null===n?3!==r.type&&"":n:(t=r.attributeName,a=r.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(r=r.type)||4===r&&!0===n?"":""+n,a?e.setAttributeNS(a,t,n):e.setAttribute(t,n))))}Y.hasOwnProperty("ReactCurrentDispatcher")||(Y.ReactCurrentDispatcher={current:null}),Y.hasOwnProperty("ReactCurrentBatchConfig")||(Y.ReactCurrentBatchConfig={suspense:null});var Q=/^(.*)[\\\/]/,$="function"===typeof Symbol&&Symbol.for,ee=$?Symbol.for("react.element"):60103,te=$?Symbol.for("react.portal"):60106,ne=$?Symbol.for("react.fragment"):60107,ae=$?Symbol.for("react.strict_mode"):60108,re=$?Symbol.for("react.profiler"):60114,se=$?Symbol.for("react.provider"):60109,ie=$?Symbol.for("react.context"):60110,oe=$?Symbol.for("react.concurrent_mode"):60111,ce=$?Symbol.for("react.forward_ref"):60112,le=$?Symbol.for("react.suspense"):60113,ue=$?Symbol.for("react.suspense_list"):60120,de=$?Symbol.for("react.memo"):60115,he=$?Symbol.for("react.lazy"):60116,pe=$?Symbol.for("react.block"):60121,fe="function"===typeof Symbol&&Symbol.iterator;function me(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=fe&&e[fe]||e["@@iterator"])?e:null}function ge(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case ne:return"Fragment";case te:return"Portal";case re:return"Profiler";case ae:return"StrictMode";case le:return"Suspense";case ue:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case ie:return"Context.Consumer";case se:return"Context.Provider";case ce:var t=e.render;return t=t.displayName||t.name||"",e.displayName||(""!==t?"ForwardRef("+t+")":"ForwardRef");case de:return ge(e.type);case pe:return ge(e.render);case he:if(e=1===e._status?e._result:null)return ge(e)}return null}function be(e){var t="";do{e:switch(e.tag){case 3:case 4:case 6:case 7:case 10:case 9:var n="";break e;default:var a=e._debugOwner,r=e._debugSource,s=ge(e.type);n=null,a&&(n=ge(a.type)),a=s,s="",r?s=" (at "+r.fileName.replace(Q,"")+":"+r.lineNumber+")":n&&(s=" (created by "+n+")"),n="\n    in "+(a||"Unknown")+s}t+=n,e=e.return}while(e);return t}function ye(e){switch(typeof e){case"boolean":case"number":case"object":case"string":case"undefined":return e;default:return""}}function ve(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function xe(e){e._valueTracker||(e._valueTracker=function(e){var t=ve(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),a=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var r=n.get,s=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return r.call(this)},set:function(e){a=""+e,s.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return a},setValue:function(e){a=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function we(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),a="";return e&&(a=ve(e)?e.checked?"true":"false":e.value),(e=a)!==n&&(t.setValue(e),!0)}function ke(e,t){var n=t.checked;return r({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Ie(e,t){var n=null==t.defaultValue?"":t.defaultValue,a=null!=t.checked?t.checked:t.defaultChecked;n=ye(null!=t.value?t.value:n),e._wrapperState={initialChecked:a,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function Se(e,t){null!=(t=t.checked)&&J(e,"checked",t,!1)}function Ne(e,t){Se(e,t);var n=ye(t.value),a=t.type;if(null!=n)"number"===a?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===a||"reset"===a)return void e.removeAttribute("value");t.hasOwnProperty("value")?Oe(e,t.type,n):t.hasOwnProperty("defaultValue")&&Oe(e,t.type,ye(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function Te(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var a=t.type;if(!("submit"!==a&&"reset"!==a||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function Oe(e,t,n){"number"===t&&e.ownerDocument.activeElement===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}function Ce(e,t){return e=r({children:void 0},t),(t=function(e){var t="";return a.Children.forEach(e,(function(e){null!=e&&(t+=e)})),t}(t.children))&&(e.children=t),e}function Ee(e,t,n,a){if(e=e.options,t){t={};for(var r=0;r<n.length;r++)t["$"+n[r]]=!0;for(n=0;n<e.length;n++)r=t.hasOwnProperty("$"+e[n].value),e[n].selected!==r&&(e[n].selected=r),r&&a&&(e[n].defaultSelected=!0)}else{for(n=""+ye(n),t=null,r=0;r<e.length;r++){if(e[r].value===n)return e[r].selected=!0,void(a&&(e[r].defaultSelected=!0));null!==t||e[r].disabled||(t=e[r])}null!==t&&(t.selected=!0)}}function _e(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(i(91));return r({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function Ae(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(i(92));if(Array.isArray(n)){if(!(1>=n.length))throw Error(i(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:ye(n)}}function Re(e,t){var n=ye(t.value),a=ye(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=a&&(e.defaultValue=""+a)}function De(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}var Fe="http://www.w3.org/1999/xhtml",Me="http://www.w3.org/2000/svg";function je(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ze(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?je(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var Le,Pe=function(e){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(t,n,a,r){MSApp.execUnsafeLocalFunction((function(){return e(t,n)}))}:e}((function(e,t){if(e.namespaceURI!==Me||"innerHTML"in e)e.innerHTML=t;else{for((Le=Le||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=Le.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}}));function Be(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}function We(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var Ue={animationend:We("Animation","AnimationEnd"),animationiteration:We("Animation","AnimationIteration"),animationstart:We("Animation","AnimationStart"),transitionend:We("Transition","TransitionEnd")},Ve={},Ge={};function He(e){if(Ve[e])return Ve[e];if(!Ue[e])return e;var t,n=Ue[e];for(t in n)if(n.hasOwnProperty(t)&&t in Ge)return Ve[e]=n[t];return e}O&&(Ge=document.createElement("div").style,"AnimationEvent"in window||(delete Ue.animationend.animation,delete Ue.animationiteration.animation,delete Ue.animationstart.animation),"TransitionEvent"in window||delete Ue.transitionend.transition);var qe=He("animationend"),Ke=He("animationiteration"),Xe=He("animationstart"),Ze=He("transitionend"),Ye="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Je=new("function"===typeof WeakMap?WeakMap:Map);function Qe(e){var t=Je.get(e);return void 0===t&&(t=new Map,Je.set(e,t)),t}function $e(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(1026&(t=e).effectTag)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function et(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function tt(e){if($e(e)!==e)throw Error(i(188))}function nt(e){if(!(e=function(e){var t=e.alternate;if(!t){if(null===(t=$e(e)))throw Error(i(188));return t!==e?null:e}for(var n=e,a=t;;){var r=n.return;if(null===r)break;var s=r.alternate;if(null===s){if(null!==(a=r.return)){n=a;continue}break}if(r.child===s.child){for(s=r.child;s;){if(s===n)return tt(r),e;if(s===a)return tt(r),t;s=s.sibling}throw Error(i(188))}if(n.return!==a.return)n=r,a=s;else{for(var o=!1,c=r.child;c;){if(c===n){o=!0,n=r,a=s;break}if(c===a){o=!0,a=r,n=s;break}c=c.sibling}if(!o){for(c=s.child;c;){if(c===n){o=!0,n=s,a=r;break}if(c===a){o=!0,a=s,n=r;break}c=c.sibling}if(!o)throw Error(i(189))}}if(n.alternate!==a)throw Error(i(190))}if(3!==n.tag)throw Error(i(188));return n.stateNode.current===n?e:t}(e)))return null;for(var t=e;;){if(5===t.tag||6===t.tag)return t;if(t.child)t.child.return=t,t=t.child;else{if(t===e)break;for(;!t.sibling;){if(!t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}}return null}function at(e,t){if(null==t)throw Error(i(30));return null==e?t:Array.isArray(e)?Array.isArray(t)?(e.push.apply(e,t),e):(e.push(t),e):Array.isArray(t)?[e].concat(t):[e,t]}function rt(e,t,n){Array.isArray(e)?e.forEach(t,n):e&&t.call(n,e)}var st=null;function it(e){if(e){var t=e._dispatchListeners,n=e._dispatchInstances;if(Array.isArray(t))for(var a=0;a<t.length&&!e.isPropagationStopped();a++)b(e,t[a],n[a]);else t&&b(e,t,n);e._dispatchListeners=null,e._dispatchInstances=null,e.isPersistent()||e.constructor.release(e)}}function ot(e){if(null!==e&&(st=at(st,e)),e=st,st=null,e){if(rt(e,it),st)throw Error(i(95));if(u)throw e=d,u=!1,d=null,e}}function ct(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}function lt(e){if(!O)return!1;var t=(e="on"+e)in document;return t||((t=document.createElement("div")).setAttribute(e,"return;"),t="function"===typeof t[e]),t}var ut=[];function dt(e){e.topLevelType=null,e.nativeEvent=null,e.targetInst=null,e.ancestors.length=0,10>ut.length&&ut.push(e)}function ht(e,t,n,a){if(ut.length){var r=ut.pop();return r.topLevelType=e,r.eventSystemFlags=a,r.nativeEvent=t,r.targetInst=n,r}return{topLevelType:e,eventSystemFlags:a,nativeEvent:t,targetInst:n,ancestors:[]}}function pt(e){var t=e.targetInst,n=t;do{if(!n){e.ancestors.push(n);break}var a=n;if(3===a.tag)a=a.stateNode.containerInfo;else{for(;a.return;)a=a.return;a=3!==a.tag?null:a.stateNode.containerInfo}if(!a)break;5!==(t=n.tag)&&6!==t||e.ancestors.push(n),n=On(a)}while(n);for(n=0;n<e.ancestors.length;n++){t=e.ancestors[n];var r=ct(e.nativeEvent);a=e.topLevelType;var s=e.nativeEvent,i=e.eventSystemFlags;0===n&&(i|=64);for(var o=null,c=0;c<k.length;c++){var l=k[c];l&&(l=l.extractEvents(a,t,s,r,i))&&(o=at(o,l))}ot(o)}}function ft(e,t,n){if(!n.has(e)){switch(e){case"scroll":Xt(t,"scroll",!0);break;case"focus":case"blur":Xt(t,"focus",!0),Xt(t,"blur",!0),n.set("blur",null),n.set("focus",null);break;case"cancel":case"close":lt(e)&&Xt(t,e,!0);break;case"invalid":case"submit":case"reset":break;default:-1===Ye.indexOf(e)&&Kt(e,t)}n.set(e,null)}}var mt,gt,bt,yt=!1,vt=[],xt=null,wt=null,kt=null,It=new Map,St=new Map,Nt=[],Tt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),Ot="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" ");function Ct(e,t,n,a,r){return{blockedOn:e,topLevelType:t,eventSystemFlags:32|n,nativeEvent:r,container:a}}function Et(e,t){switch(e){case"focus":case"blur":xt=null;break;case"dragenter":case"dragleave":wt=null;break;case"mouseover":case"mouseout":kt=null;break;case"pointerover":case"pointerout":It.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":St.delete(t.pointerId)}}function _t(e,t,n,a,r,s){return null===e||e.nativeEvent!==s?(e=Ct(t,n,a,r,s),null!==t&&(null!==(t=Cn(t))&&gt(t)),e):(e.eventSystemFlags|=a,e)}function At(e){var t=On(e.target);if(null!==t){var n=$e(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=et(n)))return e.blockedOn=t,void s.unstable_runWithPriority(e.priority,(function(){bt(n)}))}else if(3===t&&n.stateNode.hydrate)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function Rt(e){if(null!==e.blockedOn)return!1;var t=Qt(e.topLevelType,e.eventSystemFlags,e.container,e.nativeEvent);if(null!==t){var n=Cn(t);return null!==n&&gt(n),e.blockedOn=t,!1}return!0}function Dt(e,t,n){Rt(e)&&n.delete(t)}function Ft(){for(yt=!1;0<vt.length;){var e=vt[0];if(null!==e.blockedOn){null!==(e=Cn(e.blockedOn))&&mt(e);break}var t=Qt(e.topLevelType,e.eventSystemFlags,e.container,e.nativeEvent);null!==t?e.blockedOn=t:vt.shift()}null!==xt&&Rt(xt)&&(xt=null),null!==wt&&Rt(wt)&&(wt=null),null!==kt&&Rt(kt)&&(kt=null),It.forEach(Dt),St.forEach(Dt)}function Mt(e,t){e.blockedOn===t&&(e.blockedOn=null,yt||(yt=!0,s.unstable_scheduleCallback(s.unstable_NormalPriority,Ft)))}function jt(e){function t(t){return Mt(t,e)}if(0<vt.length){Mt(vt[0],e);for(var n=1;n<vt.length;n++){var a=vt[n];a.blockedOn===e&&(a.blockedOn=null)}}for(null!==xt&&Mt(xt,e),null!==wt&&Mt(wt,e),null!==kt&&Mt(kt,e),It.forEach(t),St.forEach(t),n=0;n<Nt.length;n++)(a=Nt[n]).blockedOn===e&&(a.blockedOn=null);for(;0<Nt.length&&null===(n=Nt[0]).blockedOn;)At(n),null===n.blockedOn&&Nt.shift()}var zt={},Lt=new Map,Pt=new Map,Bt=["abort","abort",qe,"animationEnd",Ke,"animationIteration",Xe,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",Ze,"transitionEnd","waiting","waiting"];function Wt(e,t){for(var n=0;n<e.length;n+=2){var a=e[n],r=e[n+1],s="on"+(r[0].toUpperCase()+r.slice(1));s={phasedRegistrationNames:{bubbled:s,captured:s+"Capture"},dependencies:[a],eventPriority:t},Pt.set(a,t),Lt.set(a,s),zt[r]=s}}Wt("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0),Wt("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1),Wt(Bt,2);for(var Ut="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),Vt=0;Vt<Ut.length;Vt++)Pt.set(Ut[Vt],0);var Gt=s.unstable_UserBlockingPriority,Ht=s.unstable_runWithPriority,qt=!0;function Kt(e,t){Xt(t,e,!1)}function Xt(e,t,n){var a=Pt.get(t);switch(void 0===a?2:a){case 0:a=Zt.bind(null,t,1,e);break;case 1:a=Yt.bind(null,t,1,e);break;default:a=Jt.bind(null,t,1,e)}n?e.addEventListener(t,a,!0):e.addEventListener(t,a,!1)}function Zt(e,t,n,a){L||j();var r=Jt,s=L;L=!0;try{M(r,e,t,n,a)}finally{(L=s)||B()}}function Yt(e,t,n,a){Ht(Gt,Jt.bind(null,e,t,n,a))}function Jt(e,t,n,a){if(qt)if(0<vt.length&&-1<Tt.indexOf(e))e=Ct(null,e,t,n,a),vt.push(e);else{var r=Qt(e,t,n,a);if(null===r)Et(e,a);else if(-1<Tt.indexOf(e))e=Ct(r,e,t,n,a),vt.push(e);else if(!function(e,t,n,a,r){switch(t){case"focus":return xt=_t(xt,e,t,n,a,r),!0;case"dragenter":return wt=_t(wt,e,t,n,a,r),!0;case"mouseover":return kt=_t(kt,e,t,n,a,r),!0;case"pointerover":var s=r.pointerId;return It.set(s,_t(It.get(s)||null,e,t,n,a,r)),!0;case"gotpointercapture":return s=r.pointerId,St.set(s,_t(St.get(s)||null,e,t,n,a,r)),!0}return!1}(r,e,t,n,a)){Et(e,a),e=ht(e,a,null,t);try{W(pt,e)}finally{dt(e)}}}}function Qt(e,t,n,a){if(null!==(n=On(n=ct(a)))){var r=$e(n);if(null===r)n=null;else{var s=r.tag;if(13===s){if(null!==(n=et(r)))return n;n=null}else if(3===s){if(r.stateNode.hydrate)return 3===r.tag?r.stateNode.containerInfo:null;n=null}else r!==n&&(n=null)}}e=ht(e,a,n,t);try{W(pt,e)}finally{dt(e)}return null}var $t={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},en=["Webkit","ms","Moz","O"];function tn(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||$t.hasOwnProperty(e)&&$t[e]?(""+t).trim():t+"px"}function nn(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var a=0===n.indexOf("--"),r=tn(n,t[n],a);"float"===n&&(n="cssFloat"),a?e.setProperty(n,r):e[n]=r}}Object.keys($t).forEach((function(e){en.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),$t[t]=$t[e]}))}));var an=r({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function rn(e,t){if(t){if(an[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(i(137,e,""));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(i(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(i(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(i(62,""))}}function sn(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var on=Fe;function cn(e,t){var n=Qe(e=9===e.nodeType||11===e.nodeType?e:e.ownerDocument);t=N[t];for(var a=0;a<t.length;a++)ft(t[a],e,n)}function ln(){}function un(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function dn(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function hn(e,t){var n,a=dn(e);for(e=0;a;){if(3===a.nodeType){if(n=e+a.textContent.length,e<=t&&n>=t)return{node:a,offset:t-e};e=n}e:{for(;a;){if(a.nextSibling){a=a.nextSibling;break e}a=a.parentNode}a=void 0}a=dn(a)}}function pn(){for(var e=window,t=un();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(a){n=!1}if(!n)break;t=un((e=t.contentWindow).document)}return t}function fn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}var mn=null,gn=null;function bn(e,t){switch(e){case"button":case"input":case"select":case"textarea":return!!t.autoFocus}return!1}function yn(e,t){return"textarea"===e||"option"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var vn="function"===typeof setTimeout?setTimeout:void 0,xn="function"===typeof clearTimeout?clearTimeout:void 0;function wn(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break}return e}function kn(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var In=Math.random().toString(36).slice(2),Sn="__reactInternalInstance$"+In,Nn="__reactEventHandlers$"+In,Tn="__reactContainere$"+In;function On(e){var t=e[Sn];if(t)return t;for(var n=e.parentNode;n;){if(t=n[Tn]||n[Sn]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=kn(e);null!==e;){if(n=e[Sn])return n;e=kn(e)}return t}n=(e=n).parentNode}return null}function Cn(e){return!(e=e[Sn]||e[Tn])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function En(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(i(33))}function _n(e){return e[Nn]||null}function An(e){do{e=e.return}while(e&&5!==e.tag);return e||null}function Rn(e,t){var n=e.stateNode;if(!n)return null;var a=f(n);if(!a)return null;n=a[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(a=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!a;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(i(231,t,typeof n));return n}function Dn(e,t,n){(t=Rn(e,n.dispatchConfig.phasedRegistrationNames[t]))&&(n._dispatchListeners=at(n._dispatchListeners,t),n._dispatchInstances=at(n._dispatchInstances,e))}function Fn(e){if(e&&e.dispatchConfig.phasedRegistrationNames){for(var t=e._targetInst,n=[];t;)n.push(t),t=An(t);for(t=n.length;0<t--;)Dn(n[t],"captured",e);for(t=0;t<n.length;t++)Dn(n[t],"bubbled",e)}}function Mn(e,t,n){e&&n&&n.dispatchConfig.registrationName&&(t=Rn(e,n.dispatchConfig.registrationName))&&(n._dispatchListeners=at(n._dispatchListeners,t),n._dispatchInstances=at(n._dispatchInstances,e))}function jn(e){e&&e.dispatchConfig.registrationName&&Mn(e._targetInst,null,e)}function zn(e){rt(e,Fn)}var Ln=null,Pn=null,Bn=null;function Wn(){if(Bn)return Bn;var e,t,n=Pn,a=n.length,r="value"in Ln?Ln.value:Ln.textContent,s=r.length;for(e=0;e<a&&n[e]===r[e];e++);var i=a-e;for(t=1;t<=i&&n[a-t]===r[s-t];t++);return Bn=r.slice(e,1<t?1-t:void 0)}function Un(){return!0}function Vn(){return!1}function Gn(e,t,n,a){for(var r in this.dispatchConfig=e,this._targetInst=t,this.nativeEvent=n,e=this.constructor.Interface)e.hasOwnProperty(r)&&((t=e[r])?this[r]=t(n):"target"===r?this.target=a:this[r]=n[r]);return this.isDefaultPrevented=(null!=n.defaultPrevented?n.defaultPrevented:!1===n.returnValue)?Un:Vn,this.isPropagationStopped=Vn,this}function Hn(e,t,n,a){if(this.eventPool.length){var r=this.eventPool.pop();return this.call(r,e,t,n,a),r}return new this(e,t,n,a)}function qn(e){if(!(e instanceof this))throw Error(i(279));e.destructor(),10>this.eventPool.length&&this.eventPool.push(e)}function Kn(e){e.eventPool=[],e.getPooled=Hn,e.release=qn}r(Gn.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=Un)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=Un)},persist:function(){this.isPersistent=Un},isPersistent:Vn,destructor:function(){var e,t=this.constructor.Interface;for(e in t)this[e]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null,this.isPropagationStopped=this.isDefaultPrevented=Vn,this._dispatchInstances=this._dispatchListeners=null}}),Gn.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null},Gn.extend=function(e){function t(){}function n(){return a.apply(this,arguments)}var a=this;t.prototype=a.prototype;var s=new t;return r(s,n.prototype),n.prototype=s,n.prototype.constructor=n,n.Interface=r({},a.Interface,e),n.extend=a.extend,Kn(n),n},Kn(Gn);var Xn=Gn.extend({data:null}),Zn=Gn.extend({data:null}),Yn=[9,13,27,32],Jn=O&&"CompositionEvent"in window,Qn=null;O&&"documentMode"in document&&(Qn=document.documentMode);var $n=O&&"TextEvent"in window&&!Qn,ea=O&&(!Jn||Qn&&8<Qn&&11>=Qn),ta=String.fromCharCode(32),na={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},aa=!1;function ra(e,t){switch(e){case"keyup":return-1!==Yn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"blur":return!0;default:return!1}}function sa(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var ia=!1;var oa={eventTypes:na,extractEvents:function(e,t,n,a){var r;if(Jn)e:{switch(e){case"compositionstart":var s=na.compositionStart;break e;case"compositionend":s=na.compositionEnd;break e;case"compositionupdate":s=na.compositionUpdate;break e}s=void 0}else ia?ra(e,n)&&(s=na.compositionEnd):"keydown"===e&&229===n.keyCode&&(s=na.compositionStart);return s?(ea&&"ko"!==n.locale&&(ia||s!==na.compositionStart?s===na.compositionEnd&&ia&&(r=Wn()):(Pn="value"in(Ln=a)?Ln.value:Ln.textContent,ia=!0)),s=Xn.getPooled(s,t,n,a),r?s.data=r:null!==(r=sa(n))&&(s.data=r),zn(s),r=s):r=null,(e=$n?function(e,t){switch(e){case"compositionend":return sa(t);case"keypress":return 32!==t.which?null:(aa=!0,ta);case"textInput":return(e=t.data)===ta&&aa?null:e;default:return null}}(e,n):function(e,t){if(ia)return"compositionend"===e||!Jn&&ra(e,t)?(e=Wn(),Bn=Pn=Ln=null,ia=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return ea&&"ko"!==t.locale?null:t.data;default:return null}}(e,n))?((t=Zn.getPooled(na.beforeInput,t,n,a)).data=e,zn(t)):t=null,null===r?t:null===t?r:[r,t]}},ca={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function la(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!ca[e.type]:"textarea"===t}var ua={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}};function da(e,t,n){return(e=Gn.getPooled(ua.change,e,t,n)).type="change",R(n),zn(e),e}var ha=null,pa=null;function fa(e){ot(e)}function ma(e){if(we(En(e)))return e}function ga(e,t){if("change"===e)return t}var ba=!1;function ya(){ha&&(ha.detachEvent("onpropertychange",va),pa=ha=null)}function va(e){if("value"===e.propertyName&&ma(pa))if(e=da(pa,e,ct(e)),L)ot(e);else{L=!0;try{F(fa,e)}finally{L=!1,B()}}}function xa(e,t,n){"focus"===e?(ya(),pa=n,(ha=t).attachEvent("onpropertychange",va)):"blur"===e&&ya()}function wa(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return ma(pa)}function ka(e,t){if("click"===e)return ma(t)}function Ia(e,t){if("input"===e||"change"===e)return ma(t)}O&&(ba=lt("input")&&(!document.documentMode||9<document.documentMode));var Sa={eventTypes:ua,_isInputEventSupported:ba,extractEvents:function(e,t,n,a){var r=t?En(t):window,s=r.nodeName&&r.nodeName.toLowerCase();if("select"===s||"input"===s&&"file"===r.type)var i=ga;else if(la(r))if(ba)i=Ia;else{i=wa;var o=xa}else(s=r.nodeName)&&"input"===s.toLowerCase()&&("checkbox"===r.type||"radio"===r.type)&&(i=ka);if(i&&(i=i(e,t)))return da(i,n,a);o&&o(e,r,t),"blur"===e&&(e=r._wrapperState)&&e.controlled&&"number"===r.type&&Oe(r,"number",r.value)}},Na=Gn.extend({view:null,detail:null}),Ta={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Oa(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Ta[e])&&!!t[e]}function Ca(){return Oa}var Ea=0,_a=0,Aa=!1,Ra=!1,Da=Na.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:Ca,button:null,buttons:null,relatedTarget:function(e){return e.relatedTarget||(e.fromElement===e.srcElement?e.toElement:e.fromElement)},movementX:function(e){if("movementX"in e)return e.movementX;var t=Ea;return Ea=e.screenX,Aa?"mousemove"===e.type?e.screenX-t:0:(Aa=!0,0)},movementY:function(e){if("movementY"in e)return e.movementY;var t=_a;return _a=e.screenY,Ra?"mousemove"===e.type?e.screenY-t:0:(Ra=!0,0)}}),Fa=Da.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),Ma={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout","pointerover"]}},ja={eventTypes:Ma,extractEvents:function(e,t,n,a,r){var s="mouseover"===e||"pointerover"===e,i="mouseout"===e||"pointerout"===e;if(s&&0===(32&r)&&(n.relatedTarget||n.fromElement)||!i&&!s)return null;(s=a.window===a?a:(s=a.ownerDocument)?s.defaultView||s.parentWindow:window,i)?(i=t,null!==(t=(t=n.relatedTarget||n.toElement)?On(t):null)&&(t!==$e(t)||5!==t.tag&&6!==t.tag)&&(t=null)):i=null;if(i===t)return null;if("mouseout"===e||"mouseover"===e)var o=Da,c=Ma.mouseLeave,l=Ma.mouseEnter,u="mouse";else"pointerout"!==e&&"pointerover"!==e||(o=Fa,c=Ma.pointerLeave,l=Ma.pointerEnter,u="pointer");if(e=null==i?s:En(i),s=null==t?s:En(t),(c=o.getPooled(c,i,n,a)).type=u+"leave",c.target=e,c.relatedTarget=s,(n=o.getPooled(l,t,n,a)).type=u+"enter",n.target=s,n.relatedTarget=e,u=t,(a=i)&&u)e:{for(l=u,i=0,e=o=a;e;e=An(e))i++;for(e=0,t=l;t;t=An(t))e++;for(;0<i-e;)o=An(o),i--;for(;0<e-i;)l=An(l),e--;for(;i--;){if(o===l||o===l.alternate)break e;o=An(o),l=An(l)}o=null}else o=null;for(l=o,o=[];a&&a!==l&&(null===(i=a.alternate)||i!==l);)o.push(a),a=An(a);for(a=[];u&&u!==l&&(null===(i=u.alternate)||i!==l);)a.push(u),u=An(u);for(u=0;u<o.length;u++)Mn(o[u],"bubbled",c);for(u=a.length;0<u--;)Mn(a[u],"captured",n);return 0===(64&r)?[c]:[c,n]}};var za="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t},La=Object.prototype.hasOwnProperty;function Pa(e,t){if(za(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),a=Object.keys(t);if(n.length!==a.length)return!1;for(a=0;a<n.length;a++)if(!La.call(t,n[a])||!za(e[n[a]],t[n[a]]))return!1;return!0}var Ba=O&&"documentMode"in document&&11>=document.documentMode,Wa={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},Ua=null,Va=null,Ga=null,Ha=!1;function qa(e,t){var n=t.window===t?t.document:9===t.nodeType?t:t.ownerDocument;return Ha||null==Ua||Ua!==un(n)?null:("selectionStart"in(n=Ua)&&fn(n)?n={start:n.selectionStart,end:n.selectionEnd}:n={anchorNode:(n=(n.ownerDocument&&n.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:n.anchorOffset,focusNode:n.focusNode,focusOffset:n.focusOffset},Ga&&Pa(Ga,n)?null:(Ga=n,(e=Gn.getPooled(Wa.select,Va,e,t)).type="select",e.target=Ua,zn(e),e))}var Ka={eventTypes:Wa,extractEvents:function(e,t,n,a,r,s){if(!(s=!(r=s||(a.window===a?a.document:9===a.nodeType?a:a.ownerDocument)))){e:{r=Qe(r),s=N.onSelect;for(var i=0;i<s.length;i++)if(!r.has(s[i])){r=!1;break e}r=!0}s=!r}if(s)return null;switch(r=t?En(t):window,e){case"focus":(la(r)||"true"===r.contentEditable)&&(Ua=r,Va=t,Ga=null);break;case"blur":Ga=Va=Ua=null;break;case"mousedown":Ha=!0;break;case"contextmenu":case"mouseup":case"dragend":return Ha=!1,qa(n,a);case"selectionchange":if(Ba)break;case"keydown":case"keyup":return qa(n,a)}return null}},Xa=Gn.extend({animationName:null,elapsedTime:null,pseudoElement:null}),Za=Gn.extend({clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),Ya=Na.extend({relatedTarget:null});function Ja(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}var Qa={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},$a={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},er=Na.extend({key:function(e){if(e.key){var t=Qa[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=Ja(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?$a[e.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:Ca,charCode:function(e){return"keypress"===e.type?Ja(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?Ja(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),tr=Da.extend({dataTransfer:null}),nr=Na.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:Ca}),ar=Gn.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),rr=Da.extend({deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:null,deltaMode:null}),sr={eventTypes:zt,extractEvents:function(e,t,n,a){var r=Lt.get(e);if(!r)return null;switch(e){case"keypress":if(0===Ja(n))return null;case"keydown":case"keyup":e=er;break;case"blur":case"focus":e=Ya;break;case"click":if(2===n.button)return null;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":e=Da;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":e=tr;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":e=nr;break;case qe:case Ke:case Xe:e=Xa;break;case Ze:e=ar;break;case"scroll":e=Na;break;case"wheel":e=rr;break;case"copy":case"cut":case"paste":e=Za;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":e=Fa;break;default:e=Gn}return zn(t=e.getPooled(r,t,n,a)),t}};if(y)throw Error(i(101));y=Array.prototype.slice.call("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" ")),x(),f=_n,m=Cn,g=En,T({SimpleEventPlugin:sr,EnterLeaveEventPlugin:ja,ChangeEventPlugin:Sa,SelectEventPlugin:Ka,BeforeInputEventPlugin:oa});var ir=[],or=-1;function cr(e){0>or||(e.current=ir[or],ir[or]=null,or--)}function lr(e,t){or++,ir[or]=e.current,e.current=t}var ur={},dr={current:ur},hr={current:!1},pr=ur;function fr(e,t){var n=e.type.contextTypes;if(!n)return ur;var a=e.stateNode;if(a&&a.__reactInternalMemoizedUnmaskedChildContext===t)return a.__reactInternalMemoizedMaskedChildContext;var r,s={};for(r in n)s[r]=t[r];return a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=s),s}function mr(e){return null!==(e=e.childContextTypes)&&void 0!==e}function gr(){cr(hr),cr(dr)}function br(e,t,n){if(dr.current!==ur)throw Error(i(168));lr(dr,t),lr(hr,n)}function yr(e,t,n){var a=e.stateNode;if(e=t.childContextTypes,"function"!==typeof a.getChildContext)return n;for(var s in a=a.getChildContext())if(!(s in e))throw Error(i(108,ge(t)||"Unknown",s));return r({},n,{},a)}function vr(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||ur,pr=dr.current,lr(dr,e),lr(hr,hr.current),!0}function xr(e,t,n){var a=e.stateNode;if(!a)throw Error(i(169));n?(e=yr(e,t,pr),a.__reactInternalMemoizedMergedChildContext=e,cr(hr),cr(dr),lr(dr,e)):cr(hr),lr(hr,n)}var wr=s.unstable_runWithPriority,kr=s.unstable_scheduleCallback,Ir=s.unstable_cancelCallback,Sr=s.unstable_requestPaint,Nr=s.unstable_now,Tr=s.unstable_getCurrentPriorityLevel,Or=s.unstable_ImmediatePriority,Cr=s.unstable_UserBlockingPriority,Er=s.unstable_NormalPriority,_r=s.unstable_LowPriority,Ar=s.unstable_IdlePriority,Rr={},Dr=s.unstable_shouldYield,Fr=void 0!==Sr?Sr:function(){},Mr=null,jr=null,zr=!1,Lr=Nr(),Pr=1e4>Lr?Nr:function(){return Nr()-Lr};function Br(){switch(Tr()){case Or:return 99;case Cr:return 98;case Er:return 97;case _r:return 96;case Ar:return 95;default:throw Error(i(332))}}function Wr(e){switch(e){case 99:return Or;case 98:return Cr;case 97:return Er;case 96:return _r;case 95:return Ar;default:throw Error(i(332))}}function Ur(e,t){return e=Wr(e),wr(e,t)}function Vr(e,t,n){return e=Wr(e),kr(e,t,n)}function Gr(e){return null===Mr?(Mr=[e],jr=kr(Or,qr)):Mr.push(e),Rr}function Hr(){if(null!==jr){var e=jr;jr=null,Ir(e)}qr()}function qr(){if(!zr&&null!==Mr){zr=!0;var e=0;try{var t=Mr;Ur(99,(function(){for(;e<t.length;e++){var n=t[e];do{n=n(!0)}while(null!==n)}})),Mr=null}catch(n){throw null!==Mr&&(Mr=Mr.slice(e+1)),kr(Or,Hr),n}finally{zr=!1}}}function Kr(e,t,n){return 1073741821-(1+((1073741821-e+t/10)/(n/=10)|0))*n}function Xr(e,t){if(e&&e.defaultProps)for(var n in t=r({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}var Zr={current:null},Yr=null,Jr=null,Qr=null;function $r(){Qr=Jr=Yr=null}function es(e){var t=Zr.current;cr(Zr),e.type._context._currentValue=t}function ts(e,t){for(;null!==e;){var n=e.alternate;if(e.childExpirationTime<t)e.childExpirationTime=t,null!==n&&n.childExpirationTime<t&&(n.childExpirationTime=t);else{if(!(null!==n&&n.childExpirationTime<t))break;n.childExpirationTime=t}e=e.return}}function ns(e,t){Yr=e,Qr=Jr=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(e.expirationTime>=t&&(Ei=!0),e.firstContext=null)}function as(e,t){if(Qr!==e&&!1!==t&&0!==t)if("number"===typeof t&&1073741823!==t||(Qr=e,t=1073741823),t={context:e,observedBits:t,next:null},null===Jr){if(null===Yr)throw Error(i(308));Jr=t,Yr.dependencies={expirationTime:0,firstContext:t,responders:null}}else Jr=Jr.next=t;return e._currentValue}var rs=!1;function ss(e){e.updateQueue={baseState:e.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function is(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,baseQueue:e.baseQueue,shared:e.shared,effects:e.effects})}function os(e,t){return(e={expirationTime:e,suspenseConfig:t,tag:0,payload:null,callback:null,next:null}).next=e}function cs(e,t){if(null!==(e=e.updateQueue)){var n=(e=e.shared).pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}}function ls(e,t){var n=e.alternate;null!==n&&is(n,e),null===(n=(e=e.updateQueue).baseQueue)?(e.baseQueue=t.next=t,t.next=t):(t.next=n.next,n.next=t)}function us(e,t,n,a){var s=e.updateQueue;rs=!1;var i=s.baseQueue,o=s.shared.pending;if(null!==o){if(null!==i){var c=i.next;i.next=o.next,o.next=c}i=o,s.shared.pending=null,null!==(c=e.alternate)&&(null!==(c=c.updateQueue)&&(c.baseQueue=o))}if(null!==i){c=i.next;var l=s.baseState,u=0,d=null,h=null,p=null;if(null!==c)for(var f=c;;){if((o=f.expirationTime)<a){var m={expirationTime:f.expirationTime,suspenseConfig:f.suspenseConfig,tag:f.tag,payload:f.payload,callback:f.callback,next:null};null===p?(h=p=m,d=l):p=p.next=m,o>u&&(u=o)}else{null!==p&&(p=p.next={expirationTime:1073741823,suspenseConfig:f.suspenseConfig,tag:f.tag,payload:f.payload,callback:f.callback,next:null}),sc(o,f.suspenseConfig);e:{var g=e,b=f;switch(o=t,m=n,b.tag){case 1:if("function"===typeof(g=b.payload)){l=g.call(m,l,o);break e}l=g;break e;case 3:g.effectTag=-4097&g.effectTag|64;case 0:if(null===(o="function"===typeof(g=b.payload)?g.call(m,l,o):g)||void 0===o)break e;l=r({},l,o);break e;case 2:rs=!0}}null!==f.callback&&(e.effectTag|=32,null===(o=s.effects)?s.effects=[f]:o.push(f))}if(null===(f=f.next)||f===c){if(null===(o=s.shared.pending))break;f=i.next=o.next,o.next=c,s.baseQueue=i=o,s.shared.pending=null}}null===p?d=l:p.next=h,s.baseState=d,s.baseQueue=p,ic(u),e.expirationTime=u,e.memoizedState=l}}function ds(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var a=e[t],r=a.callback;if(null!==r){if(a.callback=null,a=r,r=n,"function"!==typeof a)throw Error(i(191,a));a.call(r)}}}var hs=Y.ReactCurrentBatchConfig,ps=(new a.Component).refs;function fs(e,t,n,a){n=null===(n=n(a,t=e.memoizedState))||void 0===n?t:r({},t,n),e.memoizedState=n,0===e.expirationTime&&(e.updateQueue.baseState=n)}var ms={isMounted:function(e){return!!(e=e._reactInternalFiber)&&$e(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternalFiber;var a=qo(),r=hs.suspense;(r=os(a=Ko(a,e,r),r)).payload=t,void 0!==n&&null!==n&&(r.callback=n),cs(e,r),Xo(e,a)},enqueueReplaceState:function(e,t,n){e=e._reactInternalFiber;var a=qo(),r=hs.suspense;(r=os(a=Ko(a,e,r),r)).tag=1,r.payload=t,void 0!==n&&null!==n&&(r.callback=n),cs(e,r),Xo(e,a)},enqueueForceUpdate:function(e,t){e=e._reactInternalFiber;var n=qo(),a=hs.suspense;(a=os(n=Ko(n,e,a),a)).tag=2,void 0!==t&&null!==t&&(a.callback=t),cs(e,a),Xo(e,n)}};function gs(e,t,n,a,r,s,i){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(a,s,i):!t.prototype||!t.prototype.isPureReactComponent||(!Pa(n,a)||!Pa(r,s))}function bs(e,t,n){var a=!1,r=ur,s=t.contextType;return"object"===typeof s&&null!==s?s=as(s):(r=mr(t)?pr:dr.current,s=(a=null!==(a=t.contextTypes)&&void 0!==a)?fr(e,r):ur),t=new t(n,s),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=ms,e.stateNode=t,t._reactInternalFiber=e,a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=r,e.__reactInternalMemoizedMaskedChildContext=s),t}function ys(e,t,n,a){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,a),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,a),t.state!==e&&ms.enqueueReplaceState(t,t.state,null)}function vs(e,t,n,a){var r=e.stateNode;r.props=n,r.state=e.memoizedState,r.refs=ps,ss(e);var s=t.contextType;"object"===typeof s&&null!==s?r.context=as(s):(s=mr(t)?pr:dr.current,r.context=fr(e,s)),us(e,n,r,a),r.state=e.memoizedState,"function"===typeof(s=t.getDerivedStateFromProps)&&(fs(e,t,s,n),r.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof r.getSnapshotBeforeUpdate||"function"!==typeof r.UNSAFE_componentWillMount&&"function"!==typeof r.componentWillMount||(t=r.state,"function"===typeof r.componentWillMount&&r.componentWillMount(),"function"===typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount(),t!==r.state&&ms.enqueueReplaceState(r,r.state,null),us(e,n,r,a),r.state=e.memoizedState),"function"===typeof r.componentDidMount&&(e.effectTag|=4)}var xs=Array.isArray;function ws(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(i(309));var a=n.stateNode}if(!a)throw Error(i(147,e));var r=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===r?t.ref:((t=function(e){var t=a.refs;t===ps&&(t=a.refs={}),null===e?delete t[r]:t[r]=e})._stringRef=r,t)}if("string"!==typeof e)throw Error(i(284));if(!n._owner)throw Error(i(290,e))}return e}function ks(e,t){if("textarea"!==e.type)throw Error(i(31,"[object Object]"===Object.prototype.toString.call(t)?"object with keys {"+Object.keys(t).join(", ")+"}":t,""))}function Is(e){function t(t,n){if(e){var a=t.lastEffect;null!==a?(a.nextEffect=n,t.lastEffect=n):t.firstEffect=t.lastEffect=n,n.nextEffect=null,n.effectTag=8}}function n(n,a){if(!e)return null;for(;null!==a;)t(n,a),a=a.sibling;return null}function a(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function r(e,t){return(e=Tc(e,t)).index=0,e.sibling=null,e}function s(t,n,a){return t.index=a,e?null!==(a=t.alternate)?(a=a.index)<n?(t.effectTag=2,n):a:(t.effectTag=2,n):n}function o(t){return e&&null===t.alternate&&(t.effectTag=2),t}function c(e,t,n,a){return null===t||6!==t.tag?((t=Ec(n,e.mode,a)).return=e,t):((t=r(t,n)).return=e,t)}function l(e,t,n,a){return null!==t&&t.elementType===n.type?((a=r(t,n.props)).ref=ws(e,t,n),a.return=e,a):((a=Oc(n.type,n.key,n.props,null,e.mode,a)).ref=ws(e,t,n),a.return=e,a)}function u(e,t,n,a){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=_c(n,e.mode,a)).return=e,t):((t=r(t,n.children||[])).return=e,t)}function d(e,t,n,a,s){return null===t||7!==t.tag?((t=Cc(n,e.mode,a,s)).return=e,t):((t=r(t,n)).return=e,t)}function h(e,t,n){if("string"===typeof t||"number"===typeof t)return(t=Ec(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case ee:return(n=Oc(t.type,t.key,t.props,null,e.mode,n)).ref=ws(e,null,t),n.return=e,n;case te:return(t=_c(t,e.mode,n)).return=e,t}if(xs(t)||me(t))return(t=Cc(t,e.mode,n,null)).return=e,t;ks(e,t)}return null}function p(e,t,n,a){var r=null!==t?t.key:null;if("string"===typeof n||"number"===typeof n)return null!==r?null:c(e,t,""+n,a);if("object"===typeof n&&null!==n){switch(n.$$typeof){case ee:return n.key===r?n.type===ne?d(e,t,n.props.children,a,r):l(e,t,n,a):null;case te:return n.key===r?u(e,t,n,a):null}if(xs(n)||me(n))return null!==r?null:d(e,t,n,a,null);ks(e,n)}return null}function f(e,t,n,a,r){if("string"===typeof a||"number"===typeof a)return c(t,e=e.get(n)||null,""+a,r);if("object"===typeof a&&null!==a){switch(a.$$typeof){case ee:return e=e.get(null===a.key?n:a.key)||null,a.type===ne?d(t,e,a.props.children,r,a.key):l(t,e,a,r);case te:return u(t,e=e.get(null===a.key?n:a.key)||null,a,r)}if(xs(a)||me(a))return d(t,e=e.get(n)||null,a,r,null);ks(t,a)}return null}function m(r,i,o,c){for(var l=null,u=null,d=i,m=i=0,g=null;null!==d&&m<o.length;m++){d.index>m?(g=d,d=null):g=d.sibling;var b=p(r,d,o[m],c);if(null===b){null===d&&(d=g);break}e&&d&&null===b.alternate&&t(r,d),i=s(b,i,m),null===u?l=b:u.sibling=b,u=b,d=g}if(m===o.length)return n(r,d),l;if(null===d){for(;m<o.length;m++)null!==(d=h(r,o[m],c))&&(i=s(d,i,m),null===u?l=d:u.sibling=d,u=d);return l}for(d=a(r,d);m<o.length;m++)null!==(g=f(d,r,m,o[m],c))&&(e&&null!==g.alternate&&d.delete(null===g.key?m:g.key),i=s(g,i,m),null===u?l=g:u.sibling=g,u=g);return e&&d.forEach((function(e){return t(r,e)})),l}function g(r,o,c,l){var u=me(c);if("function"!==typeof u)throw Error(i(150));if(null==(c=u.call(c)))throw Error(i(151));for(var d=u=null,m=o,g=o=0,b=null,y=c.next();null!==m&&!y.done;g++,y=c.next()){m.index>g?(b=m,m=null):b=m.sibling;var v=p(r,m,y.value,l);if(null===v){null===m&&(m=b);break}e&&m&&null===v.alternate&&t(r,m),o=s(v,o,g),null===d?u=v:d.sibling=v,d=v,m=b}if(y.done)return n(r,m),u;if(null===m){for(;!y.done;g++,y=c.next())null!==(y=h(r,y.value,l))&&(o=s(y,o,g),null===d?u=y:d.sibling=y,d=y);return u}for(m=a(r,m);!y.done;g++,y=c.next())null!==(y=f(m,r,g,y.value,l))&&(e&&null!==y.alternate&&m.delete(null===y.key?g:y.key),o=s(y,o,g),null===d?u=y:d.sibling=y,d=y);return e&&m.forEach((function(e){return t(r,e)})),u}return function(e,a,s,c){var l="object"===typeof s&&null!==s&&s.type===ne&&null===s.key;l&&(s=s.props.children);var u="object"===typeof s&&null!==s;if(u)switch(s.$$typeof){case ee:e:{for(u=s.key,l=a;null!==l;){if(l.key===u){switch(l.tag){case 7:if(s.type===ne){n(e,l.sibling),(a=r(l,s.props.children)).return=e,e=a;break e}break;default:if(l.elementType===s.type){n(e,l.sibling),(a=r(l,s.props)).ref=ws(e,l,s),a.return=e,e=a;break e}}n(e,l);break}t(e,l),l=l.sibling}s.type===ne?((a=Cc(s.props.children,e.mode,c,s.key)).return=e,e=a):((c=Oc(s.type,s.key,s.props,null,e.mode,c)).ref=ws(e,a,s),c.return=e,e=c)}return o(e);case te:e:{for(l=s.key;null!==a;){if(a.key===l){if(4===a.tag&&a.stateNode.containerInfo===s.containerInfo&&a.stateNode.implementation===s.implementation){n(e,a.sibling),(a=r(a,s.children||[])).return=e,e=a;break e}n(e,a);break}t(e,a),a=a.sibling}(a=_c(s,e.mode,c)).return=e,e=a}return o(e)}if("string"===typeof s||"number"===typeof s)return s=""+s,null!==a&&6===a.tag?(n(e,a.sibling),(a=r(a,s)).return=e,e=a):(n(e,a),(a=Ec(s,e.mode,c)).return=e,e=a),o(e);if(xs(s))return m(e,a,s,c);if(me(s))return g(e,a,s,c);if(u&&ks(e,s),"undefined"===typeof s&&!l)switch(e.tag){case 1:case 0:throw e=e.type,Error(i(152,e.displayName||e.name||"Component"))}return n(e,a)}}var Ss=Is(!0),Ns=Is(!1),Ts={},Os={current:Ts},Cs={current:Ts},Es={current:Ts};function _s(e){if(e===Ts)throw Error(i(174));return e}function As(e,t){switch(lr(Es,t),lr(Cs,e),lr(Os,Ts),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:ze(null,"");break;default:t=ze(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}cr(Os),lr(Os,t)}function Rs(){cr(Os),cr(Cs),cr(Es)}function Ds(e){_s(Es.current);var t=_s(Os.current),n=ze(t,e.type);t!==n&&(lr(Cs,e),lr(Os,n))}function Fs(e){Cs.current===e&&(cr(Os),cr(Cs))}var Ms={current:0};function js(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(64&t.effectTag))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}function zs(e,t){return{responder:e,props:t}}var Ls=Y.ReactCurrentDispatcher,Ps=Y.ReactCurrentBatchConfig,Bs=0,Ws=null,Us=null,Vs=null,Gs=!1;function Hs(){throw Error(i(321))}function qs(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!za(e[n],t[n]))return!1;return!0}function Ks(e,t,n,a,r,s){if(Bs=s,Ws=t,t.memoizedState=null,t.updateQueue=null,t.expirationTime=0,Ls.current=null===e||null===e.memoizedState?gi:bi,e=n(a,r),t.expirationTime===Bs){s=0;do{if(t.expirationTime=0,!(25>s))throw Error(i(301));s+=1,Vs=Us=null,t.updateQueue=null,Ls.current=yi,e=n(a,r)}while(t.expirationTime===Bs)}if(Ls.current=mi,t=null!==Us&&null!==Us.next,Bs=0,Vs=Us=Ws=null,Gs=!1,t)throw Error(i(300));return e}function Xs(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===Vs?Ws.memoizedState=Vs=e:Vs=Vs.next=e,Vs}function Zs(){if(null===Us){var e=Ws.alternate;e=null!==e?e.memoizedState:null}else e=Us.next;var t=null===Vs?Ws.memoizedState:Vs.next;if(null!==t)Vs=t,Us=e;else{if(null===e)throw Error(i(310));e={memoizedState:(Us=e).memoizedState,baseState:Us.baseState,baseQueue:Us.baseQueue,queue:Us.queue,next:null},null===Vs?Ws.memoizedState=Vs=e:Vs=Vs.next=e}return Vs}function Ys(e,t){return"function"===typeof t?t(e):t}function Js(e){var t=Zs(),n=t.queue;if(null===n)throw Error(i(311));n.lastRenderedReducer=e;var a=Us,r=a.baseQueue,s=n.pending;if(null!==s){if(null!==r){var o=r.next;r.next=s.next,s.next=o}a.baseQueue=r=s,n.pending=null}if(null!==r){r=r.next,a=a.baseState;var c=o=s=null,l=r;do{var u=l.expirationTime;if(u<Bs){var d={expirationTime:l.expirationTime,suspenseConfig:l.suspenseConfig,action:l.action,eagerReducer:l.eagerReducer,eagerState:l.eagerState,next:null};null===c?(o=c=d,s=a):c=c.next=d,u>Ws.expirationTime&&(Ws.expirationTime=u,ic(u))}else null!==c&&(c=c.next={expirationTime:1073741823,suspenseConfig:l.suspenseConfig,action:l.action,eagerReducer:l.eagerReducer,eagerState:l.eagerState,next:null}),sc(u,l.suspenseConfig),a=l.eagerReducer===e?l.eagerState:e(a,l.action);l=l.next}while(null!==l&&l!==r);null===c?s=a:c.next=o,za(a,t.memoizedState)||(Ei=!0),t.memoizedState=a,t.baseState=s,t.baseQueue=c,n.lastRenderedState=a}return[t.memoizedState,n.dispatch]}function Qs(e){var t=Zs(),n=t.queue;if(null===n)throw Error(i(311));n.lastRenderedReducer=e;var a=n.dispatch,r=n.pending,s=t.memoizedState;if(null!==r){n.pending=null;var o=r=r.next;do{s=e(s,o.action),o=o.next}while(o!==r);za(s,t.memoizedState)||(Ei=!0),t.memoizedState=s,null===t.baseQueue&&(t.baseState=s),n.lastRenderedState=s}return[s,a]}function $s(e){var t=Xs();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e=(e=t.queue={pending:null,dispatch:null,lastRenderedReducer:Ys,lastRenderedState:e}).dispatch=fi.bind(null,Ws,e),[t.memoizedState,e]}function ei(e,t,n,a){return e={tag:e,create:t,destroy:n,deps:a,next:null},null===(t=Ws.updateQueue)?(t={lastEffect:null},Ws.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(a=n.next,n.next=e,e.next=a,t.lastEffect=e),e}function ti(){return Zs().memoizedState}function ni(e,t,n,a){var r=Xs();Ws.effectTag|=e,r.memoizedState=ei(1|t,n,void 0,void 0===a?null:a)}function ai(e,t,n,a){var r=Zs();a=void 0===a?null:a;var s=void 0;if(null!==Us){var i=Us.memoizedState;if(s=i.destroy,null!==a&&qs(a,i.deps))return void ei(t,n,s,a)}Ws.effectTag|=e,r.memoizedState=ei(1|t,n,s,a)}function ri(e,t){return ni(516,4,e,t)}function si(e,t){return ai(516,4,e,t)}function ii(e,t){return ai(4,2,e,t)}function oi(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function ci(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,ai(4,2,oi.bind(null,t,e),n)}function li(){}function ui(e,t){return Xs().memoizedState=[e,void 0===t?null:t],e}function di(e,t){var n=Zs();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&qs(t,a[1])?a[0]:(n.memoizedState=[e,t],e)}function hi(e,t){var n=Zs();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&qs(t,a[1])?a[0]:(e=e(),n.memoizedState=[e,t],e)}function pi(e,t,n){var a=Br();Ur(98>a?98:a,(function(){e(!0)})),Ur(97<a?97:a,(function(){var a=Ps.suspense;Ps.suspense=void 0===t?null:t;try{e(!1),n()}finally{Ps.suspense=a}}))}function fi(e,t,n){var a=qo(),r=hs.suspense;r={expirationTime:a=Ko(a,e,r),suspenseConfig:r,action:n,eagerReducer:null,eagerState:null,next:null};var s=t.pending;if(null===s?r.next=r:(r.next=s.next,s.next=r),t.pending=r,s=e.alternate,e===Ws||null!==s&&s===Ws)Gs=!0,r.expirationTime=Bs,Ws.expirationTime=Bs;else{if(0===e.expirationTime&&(null===s||0===s.expirationTime)&&null!==(s=t.lastRenderedReducer))try{var i=t.lastRenderedState,o=s(i,n);if(r.eagerReducer=s,r.eagerState=o,za(o,i))return}catch(c){}Xo(e,a)}}var mi={readContext:as,useCallback:Hs,useContext:Hs,useEffect:Hs,useImperativeHandle:Hs,useLayoutEffect:Hs,useMemo:Hs,useReducer:Hs,useRef:Hs,useState:Hs,useDebugValue:Hs,useResponder:Hs,useDeferredValue:Hs,useTransition:Hs},gi={readContext:as,useCallback:ui,useContext:as,useEffect:ri,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,ni(4,2,oi.bind(null,t,e),n)},useLayoutEffect:function(e,t){return ni(4,2,e,t)},useMemo:function(e,t){var n=Xs();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var a=Xs();return t=void 0!==n?n(t):t,a.memoizedState=a.baseState=t,e=(e=a.queue={pending:null,dispatch:null,lastRenderedReducer:e,lastRenderedState:t}).dispatch=fi.bind(null,Ws,e),[a.memoizedState,e]},useRef:function(e){return e={current:e},Xs().memoizedState=e},useState:$s,useDebugValue:li,useResponder:zs,useDeferredValue:function(e,t){var n=$s(e),a=n[0],r=n[1];return ri((function(){var n=Ps.suspense;Ps.suspense=void 0===t?null:t;try{r(e)}finally{Ps.suspense=n}}),[e,t]),a},useTransition:function(e){var t=$s(!1),n=t[0];return t=t[1],[ui(pi.bind(null,t,e),[t,e]),n]}},bi={readContext:as,useCallback:di,useContext:as,useEffect:si,useImperativeHandle:ci,useLayoutEffect:ii,useMemo:hi,useReducer:Js,useRef:ti,useState:function(){return Js(Ys)},useDebugValue:li,useResponder:zs,useDeferredValue:function(e,t){var n=Js(Ys),a=n[0],r=n[1];return si((function(){var n=Ps.suspense;Ps.suspense=void 0===t?null:t;try{r(e)}finally{Ps.suspense=n}}),[e,t]),a},useTransition:function(e){var t=Js(Ys),n=t[0];return t=t[1],[di(pi.bind(null,t,e),[t,e]),n]}},yi={readContext:as,useCallback:di,useContext:as,useEffect:si,useImperativeHandle:ci,useLayoutEffect:ii,useMemo:hi,useReducer:Qs,useRef:ti,useState:function(){return Qs(Ys)},useDebugValue:li,useResponder:zs,useDeferredValue:function(e,t){var n=Qs(Ys),a=n[0],r=n[1];return si((function(){var n=Ps.suspense;Ps.suspense=void 0===t?null:t;try{r(e)}finally{Ps.suspense=n}}),[e,t]),a},useTransition:function(e){var t=Qs(Ys),n=t[0];return t=t[1],[di(pi.bind(null,t,e),[t,e]),n]}},vi=null,xi=null,wi=!1;function ki(e,t){var n=Sc(5,null,null,0);n.elementType="DELETED",n.type="DELETED",n.stateNode=t,n.return=e,n.effectTag=8,null!==e.lastEffect?(e.lastEffect.nextEffect=n,e.lastEffect=n):e.firstEffect=e.lastEffect=n}function Ii(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,!0);case 13:default:return!1}}function Si(e){if(wi){var t=xi;if(t){var n=t;if(!Ii(e,t)){if(!(t=wn(n.nextSibling))||!Ii(e,t))return e.effectTag=-1025&e.effectTag|2,wi=!1,void(vi=e);ki(vi,n)}vi=e,xi=wn(t.firstChild)}else e.effectTag=-1025&e.effectTag|2,wi=!1,vi=e}}function Ni(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;vi=e}function Ti(e){if(e!==vi)return!1;if(!wi)return Ni(e),wi=!0,!1;var t=e.type;if(5!==e.tag||"head"!==t&&"body"!==t&&!yn(t,e.memoizedProps))for(t=xi;t;)ki(e,t),t=wn(t.nextSibling);if(Ni(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(i(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){xi=wn(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}xi=null}}else xi=vi?wn(e.stateNode.nextSibling):null;return!0}function Oi(){xi=vi=null,wi=!1}var Ci=Y.ReactCurrentOwner,Ei=!1;function _i(e,t,n,a){t.child=null===e?Ns(t,null,n,a):Ss(t,e.child,n,a)}function Ai(e,t,n,a,r){n=n.render;var s=t.ref;return ns(t,r),a=Ks(e,t,n,a,s,r),null===e||Ei?(t.effectTag|=1,_i(e,t,a,r),t.child):(t.updateQueue=e.updateQueue,t.effectTag&=-517,e.expirationTime<=r&&(e.expirationTime=0),Ki(e,t,r))}function Ri(e,t,n,a,r,s){if(null===e){var i=n.type;return"function"!==typeof i||Nc(i)||void 0!==i.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Oc(n.type,null,a,null,t.mode,s)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=i,Di(e,t,i,a,r,s))}return i=e.child,r<s&&(r=i.memoizedProps,(n=null!==(n=n.compare)?n:Pa)(r,a)&&e.ref===t.ref)?Ki(e,t,s):(t.effectTag|=1,(e=Tc(i,a)).ref=t.ref,e.return=t,t.child=e)}function Di(e,t,n,a,r,s){return null!==e&&Pa(e.memoizedProps,a)&&e.ref===t.ref&&(Ei=!1,r<s)?(t.expirationTime=e.expirationTime,Ki(e,t,s)):Mi(e,t,n,a,s)}function Fi(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.effectTag|=128)}function Mi(e,t,n,a,r){var s=mr(n)?pr:dr.current;return s=fr(t,s),ns(t,r),n=Ks(e,t,n,a,s,r),null===e||Ei?(t.effectTag|=1,_i(e,t,n,r),t.child):(t.updateQueue=e.updateQueue,t.effectTag&=-517,e.expirationTime<=r&&(e.expirationTime=0),Ki(e,t,r))}function ji(e,t,n,a,r){if(mr(n)){var s=!0;vr(t)}else s=!1;if(ns(t,r),null===t.stateNode)null!==e&&(e.alternate=null,t.alternate=null,t.effectTag|=2),bs(t,n,a),vs(t,n,a,r),a=!0;else if(null===e){var i=t.stateNode,o=t.memoizedProps;i.props=o;var c=i.context,l=n.contextType;"object"===typeof l&&null!==l?l=as(l):l=fr(t,l=mr(n)?pr:dr.current);var u=n.getDerivedStateFromProps,d="function"===typeof u||"function"===typeof i.getSnapshotBeforeUpdate;d||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==a||c!==l)&&ys(t,i,a,l),rs=!1;var h=t.memoizedState;i.state=h,us(t,a,i,r),c=t.memoizedState,o!==a||h!==c||hr.current||rs?("function"===typeof u&&(fs(t,n,u,a),c=t.memoizedState),(o=rs||gs(t,n,o,a,h,c,l))?(d||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(t.effectTag|=4)):("function"===typeof i.componentDidMount&&(t.effectTag|=4),t.memoizedProps=a,t.memoizedState=c),i.props=a,i.state=c,i.context=l,a=o):("function"===typeof i.componentDidMount&&(t.effectTag|=4),a=!1)}else i=t.stateNode,is(e,t),o=t.memoizedProps,i.props=t.type===t.elementType?o:Xr(t.type,o),c=i.context,"object"===typeof(l=n.contextType)&&null!==l?l=as(l):l=fr(t,l=mr(n)?pr:dr.current),(d="function"===typeof(u=n.getDerivedStateFromProps)||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==a||c!==l)&&ys(t,i,a,l),rs=!1,c=t.memoizedState,i.state=c,us(t,a,i,r),h=t.memoizedState,o!==a||c!==h||hr.current||rs?("function"===typeof u&&(fs(t,n,u,a),h=t.memoizedState),(u=rs||gs(t,n,o,a,c,h,l))?(d||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(a,h,l),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(a,h,l)),"function"===typeof i.componentDidUpdate&&(t.effectTag|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(t.effectTag|=256)):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&c===e.memoizedState||(t.effectTag|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&c===e.memoizedState||(t.effectTag|=256),t.memoizedProps=a,t.memoizedState=h),i.props=a,i.state=h,i.context=l,a=u):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&c===e.memoizedState||(t.effectTag|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&c===e.memoizedState||(t.effectTag|=256),a=!1);return zi(e,t,n,a,s,r)}function zi(e,t,n,a,r,s){Fi(e,t);var i=0!==(64&t.effectTag);if(!a&&!i)return r&&xr(t,n,!1),Ki(e,t,s);a=t.stateNode,Ci.current=t;var o=i&&"function"!==typeof n.getDerivedStateFromError?null:a.render();return t.effectTag|=1,null!==e&&i?(t.child=Ss(t,e.child,null,s),t.child=Ss(t,null,o,s)):_i(e,t,o,s),t.memoizedState=a.state,r&&xr(t,n,!0),t.child}function Li(e){var t=e.stateNode;t.pendingContext?br(0,t.pendingContext,t.pendingContext!==t.context):t.context&&br(0,t.context,!1),As(e,t.containerInfo)}var Pi,Bi,Wi,Ui={dehydrated:null,retryTime:0};function Vi(e,t,n){var a,r=t.mode,s=t.pendingProps,i=Ms.current,o=!1;if((a=0!==(64&t.effectTag))||(a=0!==(2&i)&&(null===e||null!==e.memoizedState)),a?(o=!0,t.effectTag&=-65):null!==e&&null===e.memoizedState||void 0===s.fallback||!0===s.unstable_avoidThisFallback||(i|=1),lr(Ms,1&i),null===e){if(void 0!==s.fallback&&Si(t),o){if(o=s.fallback,(s=Cc(null,r,0,null)).return=t,0===(2&t.mode))for(e=null!==t.memoizedState?t.child.child:t.child,s.child=e;null!==e;)e.return=s,e=e.sibling;return(n=Cc(o,r,n,null)).return=t,s.sibling=n,t.memoizedState=Ui,t.child=s,n}return r=s.children,t.memoizedState=null,t.child=Ns(t,null,r,n)}if(null!==e.memoizedState){if(r=(e=e.child).sibling,o){if(s=s.fallback,(n=Tc(e,e.pendingProps)).return=t,0===(2&t.mode)&&(o=null!==t.memoizedState?t.child.child:t.child)!==e.child)for(n.child=o;null!==o;)o.return=n,o=o.sibling;return(r=Tc(r,s)).return=t,n.sibling=r,n.childExpirationTime=0,t.memoizedState=Ui,t.child=n,r}return n=Ss(t,e.child,s.children,n),t.memoizedState=null,t.child=n}if(e=e.child,o){if(o=s.fallback,(s=Cc(null,r,0,null)).return=t,s.child=e,null!==e&&(e.return=s),0===(2&t.mode))for(e=null!==t.memoizedState?t.child.child:t.child,s.child=e;null!==e;)e.return=s,e=e.sibling;return(n=Cc(o,r,n,null)).return=t,s.sibling=n,n.effectTag|=2,s.childExpirationTime=0,t.memoizedState=Ui,t.child=s,n}return t.memoizedState=null,t.child=Ss(t,e,s.children,n)}function Gi(e,t){e.expirationTime<t&&(e.expirationTime=t);var n=e.alternate;null!==n&&n.expirationTime<t&&(n.expirationTime=t),ts(e.return,t)}function Hi(e,t,n,a,r,s){var i=e.memoizedState;null===i?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:a,tail:n,tailExpiration:0,tailMode:r,lastEffect:s}:(i.isBackwards=t,i.rendering=null,i.renderingStartTime=0,i.last=a,i.tail=n,i.tailExpiration=0,i.tailMode=r,i.lastEffect=s)}function qi(e,t,n){var a=t.pendingProps,r=a.revealOrder,s=a.tail;if(_i(e,t,a.children,n),0!==(2&(a=Ms.current)))a=1&a|2,t.effectTag|=64;else{if(null!==e&&0!==(64&e.effectTag))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Gi(e,n);else if(19===e.tag)Gi(e,n);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}a&=1}if(lr(Ms,a),0===(2&t.mode))t.memoizedState=null;else switch(r){case"forwards":for(n=t.child,r=null;null!==n;)null!==(e=n.alternate)&&null===js(e)&&(r=n),n=n.sibling;null===(n=r)?(r=t.child,t.child=null):(r=n.sibling,n.sibling=null),Hi(t,!1,r,n,s,t.lastEffect);break;case"backwards":for(n=null,r=t.child,t.child=null;null!==r;){if(null!==(e=r.alternate)&&null===js(e)){t.child=r;break}e=r.sibling,r.sibling=n,n=r,r=e}Hi(t,!0,n,null,s,t.lastEffect);break;case"together":Hi(t,!1,null,null,void 0,t.lastEffect);break;default:t.memoizedState=null}return t.child}function Ki(e,t,n){null!==e&&(t.dependencies=e.dependencies);var a=t.expirationTime;if(0!==a&&ic(a),t.childExpirationTime<n)return null;if(null!==e&&t.child!==e.child)throw Error(i(153));if(null!==t.child){for(n=Tc(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Tc(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Xi(e,t){switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var a=null;null!==n;)null!==n.alternate&&(a=n),n=n.sibling;null===a?t||null===e.tail?e.tail=null:e.tail.sibling=null:a.sibling=null}}function Zi(e,t,n){var a=t.pendingProps;switch(t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return mr(t.type)&&gr(),null;case 3:return Rs(),cr(hr),cr(dr),(n=t.stateNode).pendingContext&&(n.context=n.pendingContext,n.pendingContext=null),null!==e&&null!==e.child||!Ti(t)||(t.effectTag|=4),null;case 5:Fs(t),n=_s(Es.current);var s=t.type;if(null!==e&&null!=t.stateNode)Bi(e,t,s,a,n),e.ref!==t.ref&&(t.effectTag|=128);else{if(!a){if(null===t.stateNode)throw Error(i(166));return null}if(e=_s(Os.current),Ti(t)){a=t.stateNode,s=t.type;var o=t.memoizedProps;switch(a[Sn]=t,a[Nn]=o,s){case"iframe":case"object":case"embed":Kt("load",a);break;case"video":case"audio":for(e=0;e<Ye.length;e++)Kt(Ye[e],a);break;case"source":Kt("error",a);break;case"img":case"image":case"link":Kt("error",a),Kt("load",a);break;case"form":Kt("reset",a),Kt("submit",a);break;case"details":Kt("toggle",a);break;case"input":Ie(a,o),Kt("invalid",a),cn(n,"onChange");break;case"select":a._wrapperState={wasMultiple:!!o.multiple},Kt("invalid",a),cn(n,"onChange");break;case"textarea":Ae(a,o),Kt("invalid",a),cn(n,"onChange")}for(var c in rn(s,o),e=null,o)if(o.hasOwnProperty(c)){var l=o[c];"children"===c?"string"===typeof l?a.textContent!==l&&(e=["children",l]):"number"===typeof l&&a.textContent!==""+l&&(e=["children",""+l]):S.hasOwnProperty(c)&&null!=l&&cn(n,c)}switch(s){case"input":xe(a),Te(a,o,!0);break;case"textarea":xe(a),De(a);break;case"select":case"option":break;default:"function"===typeof o.onClick&&(a.onclick=ln)}n=e,t.updateQueue=n,null!==n&&(t.effectTag|=4)}else{switch(c=9===n.nodeType?n:n.ownerDocument,e===on&&(e=je(s)),e===on?"script"===s?((e=c.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof a.is?e=c.createElement(s,{is:a.is}):(e=c.createElement(s),"select"===s&&(c=e,a.multiple?c.multiple=!0:a.size&&(c.size=a.size))):e=c.createElementNS(e,s),e[Sn]=t,e[Nn]=a,Pi(e,t),t.stateNode=e,c=sn(s,a),s){case"iframe":case"object":case"embed":Kt("load",e),l=a;break;case"video":case"audio":for(l=0;l<Ye.length;l++)Kt(Ye[l],e);l=a;break;case"source":Kt("error",e),l=a;break;case"img":case"image":case"link":Kt("error",e),Kt("load",e),l=a;break;case"form":Kt("reset",e),Kt("submit",e),l=a;break;case"details":Kt("toggle",e),l=a;break;case"input":Ie(e,a),l=ke(e,a),Kt("invalid",e),cn(n,"onChange");break;case"option":l=Ce(e,a);break;case"select":e._wrapperState={wasMultiple:!!a.multiple},l=r({},a,{value:void 0}),Kt("invalid",e),cn(n,"onChange");break;case"textarea":Ae(e,a),l=_e(e,a),Kt("invalid",e),cn(n,"onChange");break;default:l=a}rn(s,l);var u=l;for(o in u)if(u.hasOwnProperty(o)){var d=u[o];"style"===o?nn(e,d):"dangerouslySetInnerHTML"===o?null!=(d=d?d.__html:void 0)&&Pe(e,d):"children"===o?"string"===typeof d?("textarea"!==s||""!==d)&&Be(e,d):"number"===typeof d&&Be(e,""+d):"suppressContentEditableWarning"!==o&&"suppressHydrationWarning"!==o&&"autoFocus"!==o&&(S.hasOwnProperty(o)?null!=d&&cn(n,o):null!=d&&J(e,o,d,c))}switch(s){case"input":xe(e),Te(e,a,!1);break;case"textarea":xe(e),De(e);break;case"option":null!=a.value&&e.setAttribute("value",""+ye(a.value));break;case"select":e.multiple=!!a.multiple,null!=(n=a.value)?Ee(e,!!a.multiple,n,!1):null!=a.defaultValue&&Ee(e,!!a.multiple,a.defaultValue,!0);break;default:"function"===typeof l.onClick&&(e.onclick=ln)}bn(s,a)&&(t.effectTag|=4)}null!==t.ref&&(t.effectTag|=128)}return null;case 6:if(e&&null!=t.stateNode)Wi(0,t,e.memoizedProps,a);else{if("string"!==typeof a&&null===t.stateNode)throw Error(i(166));n=_s(Es.current),_s(Os.current),Ti(t)?(n=t.stateNode,a=t.memoizedProps,n[Sn]=t,n.nodeValue!==a&&(t.effectTag|=4)):((n=(9===n.nodeType?n:n.ownerDocument).createTextNode(a))[Sn]=t,t.stateNode=n)}return null;case 13:return cr(Ms),a=t.memoizedState,0!==(64&t.effectTag)?(t.expirationTime=n,t):(n=null!==a,a=!1,null===e?void 0!==t.memoizedProps.fallback&&Ti(t):(a=null!==(s=e.memoizedState),n||null===s||null!==(s=e.child.sibling)&&(null!==(o=t.firstEffect)?(t.firstEffect=s,s.nextEffect=o):(t.firstEffect=t.lastEffect=s,s.nextEffect=null),s.effectTag=8)),n&&!a&&0!==(2&t.mode)&&(null===e&&!0!==t.memoizedProps.unstable_avoidThisFallback||0!==(1&Ms.current)?Oo===xo&&(Oo=wo):(Oo!==xo&&Oo!==wo||(Oo=ko),0!==Ro&&null!==So&&(Dc(So,To),Fc(So,Ro)))),(n||a)&&(t.effectTag|=4),null);case 4:return Rs(),null;case 10:return es(t),null;case 17:return mr(t.type)&&gr(),null;case 19:if(cr(Ms),null===(a=t.memoizedState))return null;if(s=0!==(64&t.effectTag),null===(o=a.rendering)){if(s)Xi(a,!1);else if(Oo!==xo||null!==e&&0!==(64&e.effectTag))for(o=t.child;null!==o;){if(null!==(e=js(o))){for(t.effectTag|=64,Xi(a,!1),null!==(s=e.updateQueue)&&(t.updateQueue=s,t.effectTag|=4),null===a.lastEffect&&(t.firstEffect=null),t.lastEffect=a.lastEffect,a=t.child;null!==a;)o=n,(s=a).effectTag&=2,s.nextEffect=null,s.firstEffect=null,s.lastEffect=null,null===(e=s.alternate)?(s.childExpirationTime=0,s.expirationTime=o,s.child=null,s.memoizedProps=null,s.memoizedState=null,s.updateQueue=null,s.dependencies=null):(s.childExpirationTime=e.childExpirationTime,s.expirationTime=e.expirationTime,s.child=e.child,s.memoizedProps=e.memoizedProps,s.memoizedState=e.memoizedState,s.updateQueue=e.updateQueue,o=e.dependencies,s.dependencies=null===o?null:{expirationTime:o.expirationTime,firstContext:o.firstContext,responders:o.responders}),a=a.sibling;return lr(Ms,1&Ms.current|2),t.child}o=o.sibling}}else{if(!s)if(null!==(e=js(o))){if(t.effectTag|=64,s=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.effectTag|=4),Xi(a,!0),null===a.tail&&"hidden"===a.tailMode&&!o.alternate)return null!==(t=t.lastEffect=a.lastEffect)&&(t.nextEffect=null),null}else 2*Pr()-a.renderingStartTime>a.tailExpiration&&1<n&&(t.effectTag|=64,s=!0,Xi(a,!1),t.expirationTime=t.childExpirationTime=n-1);a.isBackwards?(o.sibling=t.child,t.child=o):(null!==(n=a.last)?n.sibling=o:t.child=o,a.last=o)}return null!==a.tail?(0===a.tailExpiration&&(a.tailExpiration=Pr()+500),n=a.tail,a.rendering=n,a.tail=n.sibling,a.lastEffect=t.lastEffect,a.renderingStartTime=Pr(),n.sibling=null,t=Ms.current,lr(Ms,s?1&t|2:1&t),n):null}throw Error(i(156,t.tag))}function Yi(e){switch(e.tag){case 1:mr(e.type)&&gr();var t=e.effectTag;return 4096&t?(e.effectTag=-4097&t|64,e):null;case 3:if(Rs(),cr(hr),cr(dr),0!==(64&(t=e.effectTag)))throw Error(i(285));return e.effectTag=-4097&t|64,e;case 5:return Fs(e),null;case 13:return cr(Ms),4096&(t=e.effectTag)?(e.effectTag=-4097&t|64,e):null;case 19:return cr(Ms),null;case 4:return Rs(),null;case 10:return es(e),null;default:return null}}function Ji(e,t){return{value:e,source:t,stack:be(t)}}Pi=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Bi=function(e,t,n,a,s){var i=e.memoizedProps;if(i!==a){var o,c,l=t.stateNode;switch(_s(Os.current),e=null,n){case"input":i=ke(l,i),a=ke(l,a),e=[];break;case"option":i=Ce(l,i),a=Ce(l,a),e=[];break;case"select":i=r({},i,{value:void 0}),a=r({},a,{value:void 0}),e=[];break;case"textarea":i=_e(l,i),a=_e(l,a),e=[];break;default:"function"!==typeof i.onClick&&"function"===typeof a.onClick&&(l.onclick=ln)}for(o in rn(n,a),n=null,i)if(!a.hasOwnProperty(o)&&i.hasOwnProperty(o)&&null!=i[o])if("style"===o)for(c in l=i[o])l.hasOwnProperty(c)&&(n||(n={}),n[c]="");else"dangerouslySetInnerHTML"!==o&&"children"!==o&&"suppressContentEditableWarning"!==o&&"suppressHydrationWarning"!==o&&"autoFocus"!==o&&(S.hasOwnProperty(o)?e||(e=[]):(e=e||[]).push(o,null));for(o in a){var u=a[o];if(l=null!=i?i[o]:void 0,a.hasOwnProperty(o)&&u!==l&&(null!=u||null!=l))if("style"===o)if(l){for(c in l)!l.hasOwnProperty(c)||u&&u.hasOwnProperty(c)||(n||(n={}),n[c]="");for(c in u)u.hasOwnProperty(c)&&l[c]!==u[c]&&(n||(n={}),n[c]=u[c])}else n||(e||(e=[]),e.push(o,n)),n=u;else"dangerouslySetInnerHTML"===o?(u=u?u.__html:void 0,l=l?l.__html:void 0,null!=u&&l!==u&&(e=e||[]).push(o,u)):"children"===o?l===u||"string"!==typeof u&&"number"!==typeof u||(e=e||[]).push(o,""+u):"suppressContentEditableWarning"!==o&&"suppressHydrationWarning"!==o&&(S.hasOwnProperty(o)?(null!=u&&cn(s,o),e||l===u||(e=[])):(e=e||[]).push(o,u))}n&&(e=e||[]).push("style",n),s=e,(t.updateQueue=s)&&(t.effectTag|=4)}},Wi=function(e,t,n,a){n!==a&&(t.effectTag|=4)};var Qi="function"===typeof WeakSet?WeakSet:Set;function $i(e,t){var n=t.source,a=t.stack;null===a&&null!==n&&(a=be(n)),null!==n&&ge(n.type),t=t.value,null!==e&&1===e.tag&&ge(e.type);try{console.error(t)}catch(r){setTimeout((function(){throw r}))}}function eo(e){var t=e.ref;if(null!==t)if("function"===typeof t)try{t(null)}catch(n){yc(e,n)}else t.current=null}function to(e,t){switch(t.tag){case 0:case 11:case 15:case 22:return;case 1:if(256&t.effectTag&&null!==e){var n=e.memoizedProps,a=e.memoizedState;t=(e=t.stateNode).getSnapshotBeforeUpdate(t.elementType===t.type?n:Xr(t.type,n),a),e.__reactInternalSnapshotBeforeUpdate=t}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(i(163))}function no(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var a=n.destroy;n.destroy=void 0,void 0!==a&&a()}n=n.next}while(n!==t)}}function ao(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var a=n.create;n.destroy=a()}n=n.next}while(n!==t)}}function ro(e,t,n){switch(n.tag){case 0:case 11:case 15:case 22:return void ao(3,n);case 1:if(e=n.stateNode,4&n.effectTag)if(null===t)e.componentDidMount();else{var a=n.elementType===n.type?t.memoizedProps:Xr(n.type,t.memoizedProps);e.componentDidUpdate(a,t.memoizedState,e.__reactInternalSnapshotBeforeUpdate)}return void(null!==(t=n.updateQueue)&&ds(n,t,e));case 3:if(null!==(t=n.updateQueue)){if(e=null,null!==n.child)switch(n.child.tag){case 5:e=n.child.stateNode;break;case 1:e=n.child.stateNode}ds(n,t,e)}return;case 5:return e=n.stateNode,void(null===t&&4&n.effectTag&&bn(n.type,n.memoizedProps)&&e.focus());case 6:case 4:case 12:return;case 13:return void(null===n.memoizedState&&(n=n.alternate,null!==n&&(n=n.memoizedState,null!==n&&(n=n.dehydrated,null!==n&&jt(n)))));case 19:case 17:case 20:case 21:return}throw Error(i(163))}function so(e,t,n){switch("function"===typeof kc&&kc(t),t.tag){case 0:case 11:case 14:case 15:case 22:if(null!==(e=t.updateQueue)&&null!==(e=e.lastEffect)){var a=e.next;Ur(97<n?97:n,(function(){var e=a;do{var n=e.destroy;if(void 0!==n){var r=t;try{n()}catch(s){yc(r,s)}}e=e.next}while(e!==a)}))}break;case 1:eo(t),"function"===typeof(n=t.stateNode).componentWillUnmount&&function(e,t){try{t.props=e.memoizedProps,t.state=e.memoizedState,t.componentWillUnmount()}catch(n){yc(e,n)}}(t,n);break;case 5:eo(t);break;case 4:lo(e,t,n)}}function io(e){var t=e.alternate;e.return=null,e.child=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null,e.alternate=null,e.firstEffect=null,e.lastEffect=null,e.pendingProps=null,e.memoizedProps=null,e.stateNode=null,null!==t&&io(t)}function oo(e){return 5===e.tag||3===e.tag||4===e.tag}function co(e){e:{for(var t=e.return;null!==t;){if(oo(t)){var n=t;break e}t=t.return}throw Error(i(160))}switch(t=n.stateNode,n.tag){case 5:var a=!1;break;case 3:case 4:t=t.containerInfo,a=!0;break;default:throw Error(i(161))}16&n.effectTag&&(Be(t,""),n.effectTag&=-17);e:t:for(n=e;;){for(;null===n.sibling;){if(null===n.return||oo(n.return)){n=null;break e}n=n.return}for(n.sibling.return=n.return,n=n.sibling;5!==n.tag&&6!==n.tag&&18!==n.tag;){if(2&n.effectTag)continue t;if(null===n.child||4===n.tag)continue t;n.child.return=n,n=n.child}if(!(2&n.effectTag)){n=n.stateNode;break e}}a?function e(t,n,a){var r=t.tag,s=5===r||6===r;if(s)t=s?t.stateNode:t.stateNode.instance,n?8===a.nodeType?a.parentNode.insertBefore(t,n):a.insertBefore(t,n):(8===a.nodeType?(n=a.parentNode).insertBefore(t,a):(n=a).appendChild(t),null!==(a=a._reactRootContainer)&&void 0!==a||null!==n.onclick||(n.onclick=ln));else if(4!==r&&null!==(t=t.child))for(e(t,n,a),t=t.sibling;null!==t;)e(t,n,a),t=t.sibling}(e,n,t):function e(t,n,a){var r=t.tag,s=5===r||6===r;if(s)t=s?t.stateNode:t.stateNode.instance,n?a.insertBefore(t,n):a.appendChild(t);else if(4!==r&&null!==(t=t.child))for(e(t,n,a),t=t.sibling;null!==t;)e(t,n,a),t=t.sibling}(e,n,t)}function lo(e,t,n){for(var a,r,s=t,o=!1;;){if(!o){o=s.return;e:for(;;){if(null===o)throw Error(i(160));switch(a=o.stateNode,o.tag){case 5:r=!1;break e;case 3:case 4:a=a.containerInfo,r=!0;break e}o=o.return}o=!0}if(5===s.tag||6===s.tag){e:for(var c=e,l=s,u=n,d=l;;)if(so(c,d,u),null!==d.child&&4!==d.tag)d.child.return=d,d=d.child;else{if(d===l)break e;for(;null===d.sibling;){if(null===d.return||d.return===l)break e;d=d.return}d.sibling.return=d.return,d=d.sibling}r?(c=a,l=s.stateNode,8===c.nodeType?c.parentNode.removeChild(l):c.removeChild(l)):a.removeChild(s.stateNode)}else if(4===s.tag){if(null!==s.child){a=s.stateNode.containerInfo,r=!0,s.child.return=s,s=s.child;continue}}else if(so(e,s,n),null!==s.child){s.child.return=s,s=s.child;continue}if(s===t)break;for(;null===s.sibling;){if(null===s.return||s.return===t)return;4===(s=s.return).tag&&(o=!1)}s.sibling.return=s.return,s=s.sibling}}function uo(e,t){switch(t.tag){case 0:case 11:case 14:case 15:case 22:return void no(3,t);case 1:return;case 5:var n=t.stateNode;if(null!=n){var a=t.memoizedProps,r=null!==e?e.memoizedProps:a;e=t.type;var s=t.updateQueue;if(t.updateQueue=null,null!==s){for(n[Nn]=a,"input"===e&&"radio"===a.type&&null!=a.name&&Se(n,a),sn(e,r),t=sn(e,a),r=0;r<s.length;r+=2){var o=s[r],c=s[r+1];"style"===o?nn(n,c):"dangerouslySetInnerHTML"===o?Pe(n,c):"children"===o?Be(n,c):J(n,o,c,t)}switch(e){case"input":Ne(n,a);break;case"textarea":Re(n,a);break;case"select":t=n._wrapperState.wasMultiple,n._wrapperState.wasMultiple=!!a.multiple,null!=(e=a.value)?Ee(n,!!a.multiple,e,!1):t!==!!a.multiple&&(null!=a.defaultValue?Ee(n,!!a.multiple,a.defaultValue,!0):Ee(n,!!a.multiple,a.multiple?[]:"",!1))}}}return;case 6:if(null===t.stateNode)throw Error(i(162));return void(t.stateNode.nodeValue=t.memoizedProps);case 3:return void((t=t.stateNode).hydrate&&(t.hydrate=!1,jt(t.containerInfo)));case 12:return;case 13:if(n=t,null===t.memoizedState?a=!1:(a=!0,n=t.child,Fo=Pr()),null!==n)e:for(e=n;;){if(5===e.tag)s=e.stateNode,a?"function"===typeof(s=s.style).setProperty?s.setProperty("display","none","important"):s.display="none":(s=e.stateNode,r=void 0!==(r=e.memoizedProps.style)&&null!==r&&r.hasOwnProperty("display")?r.display:null,s.style.display=tn("display",r));else if(6===e.tag)e.stateNode.nodeValue=a?"":e.memoizedProps;else{if(13===e.tag&&null!==e.memoizedState&&null===e.memoizedState.dehydrated){(s=e.child.sibling).return=e,e=s;continue}if(null!==e.child){e.child.return=e,e=e.child;continue}}if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}return void ho(t);case 19:return void ho(t);case 17:return}throw Error(i(163))}function ho(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Qi),t.forEach((function(t){var a=xc.bind(null,e,t);n.has(t)||(n.add(t),t.then(a,a))}))}}var po="function"===typeof WeakMap?WeakMap:Map;function fo(e,t,n){(n=os(n,null)).tag=3,n.payload={element:null};var a=t.value;return n.callback=function(){jo||(jo=!0,zo=a),$i(e,t)},n}function mo(e,t,n){(n=os(n,null)).tag=3;var a=e.type.getDerivedStateFromError;if("function"===typeof a){var r=t.value;n.payload=function(){return $i(e,t),a(r)}}var s=e.stateNode;return null!==s&&"function"===typeof s.componentDidCatch&&(n.callback=function(){"function"!==typeof a&&(null===Lo?Lo=new Set([this]):Lo.add(this),$i(e,t));var n=t.stack;this.componentDidCatch(t.value,{componentStack:null!==n?n:""})}),n}var go,bo=Math.ceil,yo=Y.ReactCurrentDispatcher,vo=Y.ReactCurrentOwner,xo=0,wo=3,ko=4,Io=0,So=null,No=null,To=0,Oo=xo,Co=null,Eo=1073741823,_o=1073741823,Ao=null,Ro=0,Do=!1,Fo=0,Mo=null,jo=!1,zo=null,Lo=null,Po=!1,Bo=null,Wo=90,Uo=null,Vo=0,Go=null,Ho=0;function qo(){return 0!==(48&Io)?1073741821-(Pr()/10|0):0!==Ho?Ho:Ho=1073741821-(Pr()/10|0)}function Ko(e,t,n){if(0===(2&(t=t.mode)))return 1073741823;var a=Br();if(0===(4&t))return 99===a?1073741823:1073741822;if(0!==(16&Io))return To;if(null!==n)e=Kr(e,0|n.timeoutMs||5e3,250);else switch(a){case 99:e=1073741823;break;case 98:e=Kr(e,150,100);break;case 97:case 96:e=Kr(e,5e3,250);break;case 95:e=2;break;default:throw Error(i(326))}return null!==So&&e===To&&--e,e}function Xo(e,t){if(50<Vo)throw Vo=0,Go=null,Error(i(185));if(null!==(e=Zo(e,t))){var n=Br();1073741823===t?0!==(8&Io)&&0===(48&Io)?$o(e):(Jo(e),0===Io&&Hr()):Jo(e),0===(4&Io)||98!==n&&99!==n||(null===Uo?Uo=new Map([[e,t]]):(void 0===(n=Uo.get(e))||n>t)&&Uo.set(e,t))}}function Zo(e,t){e.expirationTime<t&&(e.expirationTime=t);var n=e.alternate;null!==n&&n.expirationTime<t&&(n.expirationTime=t);var a=e.return,r=null;if(null===a&&3===e.tag)r=e.stateNode;else for(;null!==a;){if(n=a.alternate,a.childExpirationTime<t&&(a.childExpirationTime=t),null!==n&&n.childExpirationTime<t&&(n.childExpirationTime=t),null===a.return&&3===a.tag){r=a.stateNode;break}a=a.return}return null!==r&&(So===r&&(ic(t),Oo===ko&&Dc(r,To)),Fc(r,t)),r}function Yo(e){var t=e.lastExpiredTime;if(0!==t)return t;if(!Rc(e,t=e.firstPendingTime))return t;var n=e.lastPingedTime;return 2>=(e=n>(e=e.nextKnownPendingLevel)?n:e)&&t!==e?0:e}function Jo(e){if(0!==e.lastExpiredTime)e.callbackExpirationTime=1073741823,e.callbackPriority=99,e.callbackNode=Gr($o.bind(null,e));else{var t=Yo(e),n=e.callbackNode;if(0===t)null!==n&&(e.callbackNode=null,e.callbackExpirationTime=0,e.callbackPriority=90);else{var a=qo();if(1073741823===t?a=99:1===t||2===t?a=95:a=0>=(a=10*(1073741821-t)-10*(1073741821-a))?99:250>=a?98:5250>=a?97:95,null!==n){var r=e.callbackPriority;if(e.callbackExpirationTime===t&&r>=a)return;n!==Rr&&Ir(n)}e.callbackExpirationTime=t,e.callbackPriority=a,t=1073741823===t?Gr($o.bind(null,e)):Vr(a,Qo.bind(null,e),{timeout:10*(1073741821-t)-Pr()}),e.callbackNode=t}}}function Qo(e,t){if(Ho=0,t)return Mc(e,t=qo()),Jo(e),null;var n=Yo(e);if(0!==n){if(t=e.callbackNode,0!==(48&Io))throw Error(i(327));if(mc(),e===So&&n===To||nc(e,n),null!==No){var a=Io;Io|=16;for(var r=rc();;)try{cc();break}catch(c){ac(e,c)}if($r(),Io=a,yo.current=r,1===Oo)throw t=Co,nc(e,n),Dc(e,n),Jo(e),t;if(null===No)switch(r=e.finishedWork=e.current.alternate,e.finishedExpirationTime=n,a=Oo,So=null,a){case xo:case 1:throw Error(i(345));case 2:Mc(e,2<n?2:n);break;case wo:if(Dc(e,n),n===(a=e.lastSuspendedTime)&&(e.nextKnownPendingLevel=dc(r)),1073741823===Eo&&10<(r=Fo+500-Pr())){if(Do){var s=e.lastPingedTime;if(0===s||s>=n){e.lastPingedTime=n,nc(e,n);break}}if(0!==(s=Yo(e))&&s!==n)break;if(0!==a&&a!==n){e.lastPingedTime=a;break}e.timeoutHandle=vn(hc.bind(null,e),r);break}hc(e);break;case ko:if(Dc(e,n),n===(a=e.lastSuspendedTime)&&(e.nextKnownPendingLevel=dc(r)),Do&&(0===(r=e.lastPingedTime)||r>=n)){e.lastPingedTime=n,nc(e,n);break}if(0!==(r=Yo(e))&&r!==n)break;if(0!==a&&a!==n){e.lastPingedTime=a;break}if(1073741823!==_o?a=10*(1073741821-_o)-Pr():1073741823===Eo?a=0:(a=10*(1073741821-Eo)-5e3,0>(a=(r=Pr())-a)&&(a=0),(n=10*(1073741821-n)-r)<(a=(120>a?120:480>a?480:1080>a?1080:1920>a?1920:3e3>a?3e3:4320>a?4320:1960*bo(a/1960))-a)&&(a=n)),10<a){e.timeoutHandle=vn(hc.bind(null,e),a);break}hc(e);break;case 5:if(1073741823!==Eo&&null!==Ao){s=Eo;var o=Ao;if(0>=(a=0|o.busyMinDurationMs)?a=0:(r=0|o.busyDelayMs,a=(s=Pr()-(10*(1073741821-s)-(0|o.timeoutMs||5e3)))<=r?0:r+a-s),10<a){Dc(e,n),e.timeoutHandle=vn(hc.bind(null,e),a);break}}hc(e);break;default:throw Error(i(329))}if(Jo(e),e.callbackNode===t)return Qo.bind(null,e)}}return null}function $o(e){var t=e.lastExpiredTime;if(t=0!==t?t:1073741823,0!==(48&Io))throw Error(i(327));if(mc(),e===So&&t===To||nc(e,t),null!==No){var n=Io;Io|=16;for(var a=rc();;)try{oc();break}catch(r){ac(e,r)}if($r(),Io=n,yo.current=a,1===Oo)throw n=Co,nc(e,t),Dc(e,t),Jo(e),n;if(null!==No)throw Error(i(261));e.finishedWork=e.current.alternate,e.finishedExpirationTime=t,So=null,hc(e),Jo(e)}return null}function ec(e,t){var n=Io;Io|=1;try{return e(t)}finally{0===(Io=n)&&Hr()}}function tc(e,t){var n=Io;Io&=-2,Io|=8;try{return e(t)}finally{0===(Io=n)&&Hr()}}function nc(e,t){e.finishedWork=null,e.finishedExpirationTime=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,xn(n)),null!==No)for(n=No.return;null!==n;){var a=n;switch(a.tag){case 1:null!==(a=a.type.childContextTypes)&&void 0!==a&&gr();break;case 3:Rs(),cr(hr),cr(dr);break;case 5:Fs(a);break;case 4:Rs();break;case 13:case 19:cr(Ms);break;case 10:es(a)}n=n.return}So=e,No=Tc(e.current,null),To=t,Oo=xo,Co=null,_o=Eo=1073741823,Ao=null,Ro=0,Do=!1}function ac(e,t){for(;;){try{if($r(),Ls.current=mi,Gs)for(var n=Ws.memoizedState;null!==n;){var a=n.queue;null!==a&&(a.pending=null),n=n.next}if(Bs=0,Vs=Us=Ws=null,Gs=!1,null===No||null===No.return)return Oo=1,Co=t,No=null;e:{var r=e,s=No.return,i=No,o=t;if(t=To,i.effectTag|=2048,i.firstEffect=i.lastEffect=null,null!==o&&"object"===typeof o&&"function"===typeof o.then){var c=o;if(0===(2&i.mode)){var l=i.alternate;l?(i.updateQueue=l.updateQueue,i.memoizedState=l.memoizedState,i.expirationTime=l.expirationTime):(i.updateQueue=null,i.memoizedState=null)}var u=0!==(1&Ms.current),d=s;do{var h;if(h=13===d.tag){var p=d.memoizedState;if(null!==p)h=null!==p.dehydrated;else{var f=d.memoizedProps;h=void 0!==f.fallback&&(!0!==f.unstable_avoidThisFallback||!u)}}if(h){var m=d.updateQueue;if(null===m){var g=new Set;g.add(c),d.updateQueue=g}else m.add(c);if(0===(2&d.mode)){if(d.effectTag|=64,i.effectTag&=-2981,1===i.tag)if(null===i.alternate)i.tag=17;else{var b=os(1073741823,null);b.tag=2,cs(i,b)}i.expirationTime=1073741823;break e}o=void 0,i=t;var y=r.pingCache;if(null===y?(y=r.pingCache=new po,o=new Set,y.set(c,o)):void 0===(o=y.get(c))&&(o=new Set,y.set(c,o)),!o.has(i)){o.add(i);var v=vc.bind(null,r,c,i);c.then(v,v)}d.effectTag|=4096,d.expirationTime=t;break e}d=d.return}while(null!==d);o=Error((ge(i.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+be(i))}5!==Oo&&(Oo=2),o=Ji(o,i),d=s;do{switch(d.tag){case 3:c=o,d.effectTag|=4096,d.expirationTime=t,ls(d,fo(d,c,t));break e;case 1:c=o;var x=d.type,w=d.stateNode;if(0===(64&d.effectTag)&&("function"===typeof x.getDerivedStateFromError||null!==w&&"function"===typeof w.componentDidCatch&&(null===Lo||!Lo.has(w)))){d.effectTag|=4096,d.expirationTime=t,ls(d,mo(d,c,t));break e}}d=d.return}while(null!==d)}No=uc(No)}catch(k){t=k;continue}break}}function rc(){var e=yo.current;return yo.current=mi,null===e?mi:e}function sc(e,t){e<Eo&&2<e&&(Eo=e),null!==t&&e<_o&&2<e&&(_o=e,Ao=t)}function ic(e){e>Ro&&(Ro=e)}function oc(){for(;null!==No;)No=lc(No)}function cc(){for(;null!==No&&!Dr();)No=lc(No)}function lc(e){var t=go(e.alternate,e,To);return e.memoizedProps=e.pendingProps,null===t&&(t=uc(e)),vo.current=null,t}function uc(e){No=e;do{var t=No.alternate;if(e=No.return,0===(2048&No.effectTag)){if(t=Zi(t,No,To),1===To||1!==No.childExpirationTime){for(var n=0,a=No.child;null!==a;){var r=a.expirationTime,s=a.childExpirationTime;r>n&&(n=r),s>n&&(n=s),a=a.sibling}No.childExpirationTime=n}if(null!==t)return t;null!==e&&0===(2048&e.effectTag)&&(null===e.firstEffect&&(e.firstEffect=No.firstEffect),null!==No.lastEffect&&(null!==e.lastEffect&&(e.lastEffect.nextEffect=No.firstEffect),e.lastEffect=No.lastEffect),1<No.effectTag&&(null!==e.lastEffect?e.lastEffect.nextEffect=No:e.firstEffect=No,e.lastEffect=No))}else{if(null!==(t=Yi(No)))return t.effectTag&=2047,t;null!==e&&(e.firstEffect=e.lastEffect=null,e.effectTag|=2048)}if(null!==(t=No.sibling))return t;No=e}while(null!==No);return Oo===xo&&(Oo=5),null}function dc(e){var t=e.expirationTime;return t>(e=e.childExpirationTime)?t:e}function hc(e){var t=Br();return Ur(99,pc.bind(null,e,t)),null}function pc(e,t){do{mc()}while(null!==Bo);if(0!==(48&Io))throw Error(i(327));var n=e.finishedWork,a=e.finishedExpirationTime;if(null===n)return null;if(e.finishedWork=null,e.finishedExpirationTime=0,n===e.current)throw Error(i(177));e.callbackNode=null,e.callbackExpirationTime=0,e.callbackPriority=90,e.nextKnownPendingLevel=0;var r=dc(n);if(e.firstPendingTime=r,a<=e.lastSuspendedTime?e.firstSuspendedTime=e.lastSuspendedTime=e.nextKnownPendingLevel=0:a<=e.firstSuspendedTime&&(e.firstSuspendedTime=a-1),a<=e.lastPingedTime&&(e.lastPingedTime=0),a<=e.lastExpiredTime&&(e.lastExpiredTime=0),e===So&&(No=So=null,To=0),1<n.effectTag?null!==n.lastEffect?(n.lastEffect.nextEffect=n,r=n.firstEffect):r=n:r=n.firstEffect,null!==r){var s=Io;Io|=32,vo.current=null,mn=qt;var o=pn();if(fn(o)){if("selectionStart"in o)var c={start:o.selectionStart,end:o.selectionEnd};else e:{var l=(c=(c=o.ownerDocument)&&c.defaultView||window).getSelection&&c.getSelection();if(l&&0!==l.rangeCount){c=l.anchorNode;var u=l.anchorOffset,d=l.focusNode;l=l.focusOffset;try{c.nodeType,d.nodeType}catch(T){c=null;break e}var h=0,p=-1,f=-1,m=0,g=0,b=o,y=null;t:for(;;){for(var v;b!==c||0!==u&&3!==b.nodeType||(p=h+u),b!==d||0!==l&&3!==b.nodeType||(f=h+l),3===b.nodeType&&(h+=b.nodeValue.length),null!==(v=b.firstChild);)y=b,b=v;for(;;){if(b===o)break t;if(y===c&&++m===u&&(p=h),y===d&&++g===l&&(f=h),null!==(v=b.nextSibling))break;y=(b=y).parentNode}b=v}c=-1===p||-1===f?null:{start:p,end:f}}else c=null}c=c||{start:0,end:0}}else c=null;gn={activeElementDetached:null,focusedElem:o,selectionRange:c},qt=!1,Mo=r;do{try{fc()}catch(T){if(null===Mo)throw Error(i(330));yc(Mo,T),Mo=Mo.nextEffect}}while(null!==Mo);Mo=r;do{try{for(o=e,c=t;null!==Mo;){var x=Mo.effectTag;if(16&x&&Be(Mo.stateNode,""),128&x){var w=Mo.alternate;if(null!==w){var k=w.ref;null!==k&&("function"===typeof k?k(null):k.current=null)}}switch(1038&x){case 2:co(Mo),Mo.effectTag&=-3;break;case 6:co(Mo),Mo.effectTag&=-3,uo(Mo.alternate,Mo);break;case 1024:Mo.effectTag&=-1025;break;case 1028:Mo.effectTag&=-1025,uo(Mo.alternate,Mo);break;case 4:uo(Mo.alternate,Mo);break;case 8:lo(o,u=Mo,c),io(u)}Mo=Mo.nextEffect}}catch(T){if(null===Mo)throw Error(i(330));yc(Mo,T),Mo=Mo.nextEffect}}while(null!==Mo);if(k=gn,w=pn(),x=k.focusedElem,c=k.selectionRange,w!==x&&x&&x.ownerDocument&&function e(t,n){return!(!t||!n)&&(t===n||(!t||3!==t.nodeType)&&(n&&3===n.nodeType?e(t,n.parentNode):"contains"in t?t.contains(n):!!t.compareDocumentPosition&&!!(16&t.compareDocumentPosition(n))))}(x.ownerDocument.documentElement,x)){null!==c&&fn(x)&&(w=c.start,void 0===(k=c.end)&&(k=w),"selectionStart"in x?(x.selectionStart=w,x.selectionEnd=Math.min(k,x.value.length)):(k=(w=x.ownerDocument||document)&&w.defaultView||window).getSelection&&(k=k.getSelection(),u=x.textContent.length,o=Math.min(c.start,u),c=void 0===c.end?o:Math.min(c.end,u),!k.extend&&o>c&&(u=c,c=o,o=u),u=hn(x,o),d=hn(x,c),u&&d&&(1!==k.rangeCount||k.anchorNode!==u.node||k.anchorOffset!==u.offset||k.focusNode!==d.node||k.focusOffset!==d.offset)&&((w=w.createRange()).setStart(u.node,u.offset),k.removeAllRanges(),o>c?(k.addRange(w),k.extend(d.node,d.offset)):(w.setEnd(d.node,d.offset),k.addRange(w))))),w=[];for(k=x;k=k.parentNode;)1===k.nodeType&&w.push({element:k,left:k.scrollLeft,top:k.scrollTop});for("function"===typeof x.focus&&x.focus(),x=0;x<w.length;x++)(k=w[x]).element.scrollLeft=k.left,k.element.scrollTop=k.top}qt=!!mn,gn=mn=null,e.current=n,Mo=r;do{try{for(x=e;null!==Mo;){var I=Mo.effectTag;if(36&I&&ro(x,Mo.alternate,Mo),128&I){w=void 0;var S=Mo.ref;if(null!==S){var N=Mo.stateNode;switch(Mo.tag){case 5:w=N;break;default:w=N}"function"===typeof S?S(w):S.current=w}}Mo=Mo.nextEffect}}catch(T){if(null===Mo)throw Error(i(330));yc(Mo,T),Mo=Mo.nextEffect}}while(null!==Mo);Mo=null,Fr(),Io=s}else e.current=n;if(Po)Po=!1,Bo=e,Wo=t;else for(Mo=r;null!==Mo;)t=Mo.nextEffect,Mo.nextEffect=null,Mo=t;if(0===(t=e.firstPendingTime)&&(Lo=null),1073741823===t?e===Go?Vo++:(Vo=0,Go=e):Vo=0,"function"===typeof wc&&wc(n.stateNode,a),Jo(e),jo)throw jo=!1,e=zo,zo=null,e;return 0!==(8&Io)||Hr(),null}function fc(){for(;null!==Mo;){var e=Mo.effectTag;0!==(256&e)&&to(Mo.alternate,Mo),0===(512&e)||Po||(Po=!0,Vr(97,(function(){return mc(),null}))),Mo=Mo.nextEffect}}function mc(){if(90!==Wo){var e=97<Wo?97:Wo;return Wo=90,Ur(e,gc)}}function gc(){if(null===Bo)return!1;var e=Bo;if(Bo=null,0!==(48&Io))throw Error(i(331));var t=Io;for(Io|=32,e=e.current.firstEffect;null!==e;){try{var n=e;if(0!==(512&n.effectTag))switch(n.tag){case 0:case 11:case 15:case 22:no(5,n),ao(5,n)}}catch(a){if(null===e)throw Error(i(330));yc(e,a)}n=e.nextEffect,e.nextEffect=null,e=n}return Io=t,Hr(),!0}function bc(e,t,n){cs(e,t=fo(e,t=Ji(n,t),1073741823)),null!==(e=Zo(e,1073741823))&&Jo(e)}function yc(e,t){if(3===e.tag)bc(e,e,t);else for(var n=e.return;null!==n;){if(3===n.tag){bc(n,e,t);break}if(1===n.tag){var a=n.stateNode;if("function"===typeof n.type.getDerivedStateFromError||"function"===typeof a.componentDidCatch&&(null===Lo||!Lo.has(a))){cs(n,e=mo(n,e=Ji(t,e),1073741823)),null!==(n=Zo(n,1073741823))&&Jo(n);break}}n=n.return}}function vc(e,t,n){var a=e.pingCache;null!==a&&a.delete(t),So===e&&To===n?Oo===ko||Oo===wo&&1073741823===Eo&&Pr()-Fo<500?nc(e,To):Do=!0:Rc(e,n)&&(0!==(t=e.lastPingedTime)&&t<n||(e.lastPingedTime=n,Jo(e)))}function xc(e,t){var n=e.stateNode;null!==n&&n.delete(t),0===(t=0)&&(t=Ko(t=qo(),e,null)),null!==(e=Zo(e,t))&&Jo(e)}go=function(e,t,n){var a=t.expirationTime;if(null!==e){var r=t.pendingProps;if(e.memoizedProps!==r||hr.current)Ei=!0;else{if(a<n){switch(Ei=!1,t.tag){case 3:Li(t),Oi();break;case 5:if(Ds(t),4&t.mode&&1!==n&&r.hidden)return t.expirationTime=t.childExpirationTime=1,null;break;case 1:mr(t.type)&&vr(t);break;case 4:As(t,t.stateNode.containerInfo);break;case 10:a=t.memoizedProps.value,r=t.type._context,lr(Zr,r._currentValue),r._currentValue=a;break;case 13:if(null!==t.memoizedState)return 0!==(a=t.child.childExpirationTime)&&a>=n?Vi(e,t,n):(lr(Ms,1&Ms.current),null!==(t=Ki(e,t,n))?t.sibling:null);lr(Ms,1&Ms.current);break;case 19:if(a=t.childExpirationTime>=n,0!==(64&e.effectTag)){if(a)return qi(e,t,n);t.effectTag|=64}if(null!==(r=t.memoizedState)&&(r.rendering=null,r.tail=null),lr(Ms,Ms.current),!a)return null}return Ki(e,t,n)}Ei=!1}}else Ei=!1;switch(t.expirationTime=0,t.tag){case 2:if(a=t.type,null!==e&&(e.alternate=null,t.alternate=null,t.effectTag|=2),e=t.pendingProps,r=fr(t,dr.current),ns(t,n),r=Ks(null,t,a,e,r,n),t.effectTag|=1,"object"===typeof r&&null!==r&&"function"===typeof r.render&&void 0===r.$$typeof){if(t.tag=1,t.memoizedState=null,t.updateQueue=null,mr(a)){var s=!0;vr(t)}else s=!1;t.memoizedState=null!==r.state&&void 0!==r.state?r.state:null,ss(t);var o=a.getDerivedStateFromProps;"function"===typeof o&&fs(t,a,o,e),r.updater=ms,t.stateNode=r,r._reactInternalFiber=t,vs(t,a,e,n),t=zi(null,t,a,!0,s,n)}else t.tag=0,_i(null,t,r,n),t=t.child;return t;case 16:e:{if(r=t.elementType,null!==e&&(e.alternate=null,t.alternate=null,t.effectTag|=2),e=t.pendingProps,function(e){if(-1===e._status){e._status=0;var t=e._ctor;t=t(),e._result=t,t.then((function(t){0===e._status&&(t=t.default,e._status=1,e._result=t)}),(function(t){0===e._status&&(e._status=2,e._result=t)}))}}(r),1!==r._status)throw r._result;switch(r=r._result,t.type=r,s=t.tag=function(e){if("function"===typeof e)return Nc(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===ce)return 11;if(e===de)return 14}return 2}(r),e=Xr(r,e),s){case 0:t=Mi(null,t,r,e,n);break e;case 1:t=ji(null,t,r,e,n);break e;case 11:t=Ai(null,t,r,e,n);break e;case 14:t=Ri(null,t,r,Xr(r.type,e),a,n);break e}throw Error(i(306,r,""))}return t;case 0:return a=t.type,r=t.pendingProps,Mi(e,t,a,r=t.elementType===a?r:Xr(a,r),n);case 1:return a=t.type,r=t.pendingProps,ji(e,t,a,r=t.elementType===a?r:Xr(a,r),n);case 3:if(Li(t),a=t.updateQueue,null===e||null===a)throw Error(i(282));if(a=t.pendingProps,r=null!==(r=t.memoizedState)?r.element:null,is(e,t),us(t,a,null,n),(a=t.memoizedState.element)===r)Oi(),t=Ki(e,t,n);else{if((r=t.stateNode.hydrate)&&(xi=wn(t.stateNode.containerInfo.firstChild),vi=t,r=wi=!0),r)for(n=Ns(t,null,a,n),t.child=n;n;)n.effectTag=-3&n.effectTag|1024,n=n.sibling;else _i(e,t,a,n),Oi();t=t.child}return t;case 5:return Ds(t),null===e&&Si(t),a=t.type,r=t.pendingProps,s=null!==e?e.memoizedProps:null,o=r.children,yn(a,r)?o=null:null!==s&&yn(a,s)&&(t.effectTag|=16),Fi(e,t),4&t.mode&&1!==n&&r.hidden?(t.expirationTime=t.childExpirationTime=1,t=null):(_i(e,t,o,n),t=t.child),t;case 6:return null===e&&Si(t),null;case 13:return Vi(e,t,n);case 4:return As(t,t.stateNode.containerInfo),a=t.pendingProps,null===e?t.child=Ss(t,null,a,n):_i(e,t,a,n),t.child;case 11:return a=t.type,r=t.pendingProps,Ai(e,t,a,r=t.elementType===a?r:Xr(a,r),n);case 7:return _i(e,t,t.pendingProps,n),t.child;case 8:case 12:return _i(e,t,t.pendingProps.children,n),t.child;case 10:e:{a=t.type._context,r=t.pendingProps,o=t.memoizedProps,s=r.value;var c=t.type._context;if(lr(Zr,c._currentValue),c._currentValue=s,null!==o)if(c=o.value,0===(s=za(c,s)?0:0|("function"===typeof a._calculateChangedBits?a._calculateChangedBits(c,s):1073741823))){if(o.children===r.children&&!hr.current){t=Ki(e,t,n);break e}}else for(null!==(c=t.child)&&(c.return=t);null!==c;){var l=c.dependencies;if(null!==l){o=c.child;for(var u=l.firstContext;null!==u;){if(u.context===a&&0!==(u.observedBits&s)){1===c.tag&&((u=os(n,null)).tag=2,cs(c,u)),c.expirationTime<n&&(c.expirationTime=n),null!==(u=c.alternate)&&u.expirationTime<n&&(u.expirationTime=n),ts(c.return,n),l.expirationTime<n&&(l.expirationTime=n);break}u=u.next}}else o=10===c.tag&&c.type===t.type?null:c.child;if(null!==o)o.return=c;else for(o=c;null!==o;){if(o===t){o=null;break}if(null!==(c=o.sibling)){c.return=o.return,o=c;break}o=o.return}c=o}_i(e,t,r.children,n),t=t.child}return t;case 9:return r=t.type,a=(s=t.pendingProps).children,ns(t,n),a=a(r=as(r,s.unstable_observedBits)),t.effectTag|=1,_i(e,t,a,n),t.child;case 14:return s=Xr(r=t.type,t.pendingProps),Ri(e,t,r,s=Xr(r.type,s),a,n);case 15:return Di(e,t,t.type,t.pendingProps,a,n);case 17:return a=t.type,r=t.pendingProps,r=t.elementType===a?r:Xr(a,r),null!==e&&(e.alternate=null,t.alternate=null,t.effectTag|=2),t.tag=1,mr(a)?(e=!0,vr(t)):e=!1,ns(t,n),bs(t,a,r),vs(t,a,r,n),zi(null,t,a,!0,e,n);case 19:return qi(e,t,n)}throw Error(i(156,t.tag))};var wc=null,kc=null;function Ic(e,t,n,a){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.effectTag=0,this.lastEffect=this.firstEffect=this.nextEffect=null,this.childExpirationTime=this.expirationTime=0,this.alternate=null}function Sc(e,t,n,a){return new Ic(e,t,n,a)}function Nc(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Tc(e,t){var n=e.alternate;return null===n?((n=Sc(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.effectTag=0,n.nextEffect=null,n.firstEffect=null,n.lastEffect=null),n.childExpirationTime=e.childExpirationTime,n.expirationTime=e.expirationTime,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{expirationTime:t.expirationTime,firstContext:t.firstContext,responders:t.responders},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Oc(e,t,n,a,r,s){var o=2;if(a=e,"function"===typeof e)Nc(e)&&(o=1);else if("string"===typeof e)o=5;else e:switch(e){case ne:return Cc(n.children,r,s,t);case oe:o=8,r|=7;break;case ae:o=8,r|=1;break;case re:return(e=Sc(12,n,t,8|r)).elementType=re,e.type=re,e.expirationTime=s,e;case le:return(e=Sc(13,n,t,r)).type=le,e.elementType=le,e.expirationTime=s,e;case ue:return(e=Sc(19,n,t,r)).elementType=ue,e.expirationTime=s,e;default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case se:o=10;break e;case ie:o=9;break e;case ce:o=11;break e;case de:o=14;break e;case he:o=16,a=null;break e;case pe:o=22;break e}throw Error(i(130,null==e?e:typeof e,""))}return(t=Sc(o,n,t,r)).elementType=e,t.type=a,t.expirationTime=s,t}function Cc(e,t,n,a){return(e=Sc(7,e,a,t)).expirationTime=n,e}function Ec(e,t,n){return(e=Sc(6,e,null,t)).expirationTime=n,e}function _c(e,t,n){return(t=Sc(4,null!==e.children?e.children:[],e.key,t)).expirationTime=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function Ac(e,t,n){this.tag=t,this.current=null,this.containerInfo=e,this.pingCache=this.pendingChildren=null,this.finishedExpirationTime=0,this.finishedWork=null,this.timeoutHandle=-1,this.pendingContext=this.context=null,this.hydrate=n,this.callbackNode=null,this.callbackPriority=90,this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Rc(e,t){var n=e.firstSuspendedTime;return e=e.lastSuspendedTime,0!==n&&n>=t&&e<=t}function Dc(e,t){var n=e.firstSuspendedTime,a=e.lastSuspendedTime;n<t&&(e.firstSuspendedTime=t),(a>t||0===n)&&(e.lastSuspendedTime=t),t<=e.lastPingedTime&&(e.lastPingedTime=0),t<=e.lastExpiredTime&&(e.lastExpiredTime=0)}function Fc(e,t){t>e.firstPendingTime&&(e.firstPendingTime=t);var n=e.firstSuspendedTime;0!==n&&(t>=n?e.firstSuspendedTime=e.lastSuspendedTime=e.nextKnownPendingLevel=0:t>=e.lastSuspendedTime&&(e.lastSuspendedTime=t+1),t>e.nextKnownPendingLevel&&(e.nextKnownPendingLevel=t))}function Mc(e,t){var n=e.lastExpiredTime;(0===n||n>t)&&(e.lastExpiredTime=t)}function jc(e,t,n,a){var r=t.current,s=qo(),o=hs.suspense;s=Ko(s,r,o);e:if(n){t:{if($e(n=n._reactInternalFiber)!==n||1!==n.tag)throw Error(i(170));var c=n;do{switch(c.tag){case 3:c=c.stateNode.context;break t;case 1:if(mr(c.type)){c=c.stateNode.__reactInternalMemoizedMergedChildContext;break t}}c=c.return}while(null!==c);throw Error(i(171))}if(1===n.tag){var l=n.type;if(mr(l)){n=yr(n,l,c);break e}}n=c}else n=ur;return null===t.context?t.context=n:t.pendingContext=n,(t=os(s,o)).payload={element:e},null!==(a=void 0===a?null:a)&&(t.callback=a),cs(r,t),Xo(r,s),s}function zc(e){if(!(e=e.current).child)return null;switch(e.child.tag){case 5:default:return e.child.stateNode}}function Lc(e,t){null!==(e=e.memoizedState)&&null!==e.dehydrated&&e.retryTime<t&&(e.retryTime=t)}function Pc(e,t){Lc(e,t),(e=e.alternate)&&Lc(e,t)}function Bc(e,t,n){var a=new Ac(e,t,n=null!=n&&!0===n.hydrate),r=Sc(3,null,null,2===t?7:1===t?3:0);a.current=r,r.stateNode=a,ss(r),e[Tn]=a.current,n&&0!==t&&function(e,t){var n=Qe(t);Tt.forEach((function(e){ft(e,t,n)})),Ot.forEach((function(e){ft(e,t,n)}))}(0,9===e.nodeType?e:e.ownerDocument),this._internalRoot=a}function Wc(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Uc(e,t,n,a,r){var s=n._reactRootContainer;if(s){var i=s._internalRoot;if("function"===typeof r){var o=r;r=function(){var e=zc(i);o.call(e)}}jc(t,i,e,r)}else{if(s=n._reactRootContainer=function(e,t){if(t||(t=!(!(t=e?9===e.nodeType?e.documentElement:e.firstChild:null)||1!==t.nodeType||!t.hasAttribute("data-reactroot"))),!t)for(var n;n=e.lastChild;)e.removeChild(n);return new Bc(e,0,t?{hydrate:!0}:void 0)}(n,a),i=s._internalRoot,"function"===typeof r){var c=r;r=function(){var e=zc(i);c.call(e)}}tc((function(){jc(t,i,e,r)}))}return zc(i)}function Vc(e,t,n){var a=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:te,key:null==a?null:""+a,children:e,containerInfo:t,implementation:n}}function Gc(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Wc(t))throw Error(i(200));return Vc(e,t,null,n)}Bc.prototype.render=function(e){jc(e,this._internalRoot,null,null)},Bc.prototype.unmount=function(){var e=this._internalRoot,t=e.containerInfo;jc(null,e,null,(function(){t[Tn]=null}))},mt=function(e){if(13===e.tag){var t=Kr(qo(),150,100);Xo(e,t),Pc(e,t)}},gt=function(e){13===e.tag&&(Xo(e,3),Pc(e,3))},bt=function(e){if(13===e.tag){var t=qo();Xo(e,t=Ko(t,e,null)),Pc(e,t)}},C=function(e,t,n){switch(t){case"input":if(Ne(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var a=n[t];if(a!==e&&a.form===e.form){var r=_n(a);if(!r)throw Error(i(90));we(a),Ne(a,r)}}}break;case"textarea":Re(e,n);break;case"select":null!=(t=n.value)&&Ee(e,!!n.multiple,t,!1)}},F=ec,M=function(e,t,n,a,r){var s=Io;Io|=4;try{return Ur(98,e.bind(null,t,n,a,r))}finally{0===(Io=s)&&Hr()}},j=function(){0===(49&Io)&&(function(){if(null!==Uo){var e=Uo;Uo=null,e.forEach((function(e,t){Mc(t,e),Jo(t)})),Hr()}}(),mc())},z=function(e,t){var n=Io;Io|=2;try{return e(t)}finally{0===(Io=n)&&Hr()}};var Hc={Events:[Cn,En,_n,T,I,zn,function(e){rt(e,jn)},R,D,Jt,ot,mc,{current:!1}]};!function(e){var t=e.findFiberByHostInstance;(function(e){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var t=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(t.isDisabled||!t.supportsFiber)return!0;try{var n=t.inject(e);wc=function(e){try{t.onCommitFiberRoot(n,e,void 0,64===(64&e.current.effectTag))}catch(a){}},kc=function(e){try{t.onCommitFiberUnmount(n,e)}catch(a){}}}catch(a){}})(r({},e,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Y.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=nt(e))?null:e.stateNode},findFiberByHostInstance:function(e){return t?t(e):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))}({findFiberByHostInstance:On,bundleType:0,version:"16.14.0",rendererPackageName:"react-dom"}),t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Hc,t.createPortal=Gc,t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternalFiber;if(void 0===t){if("function"===typeof e.render)throw Error(i(188));throw Error(i(268,Object.keys(e)))}return e=null===(e=nt(t))?null:e.stateNode},t.flushSync=function(e,t){if(0!==(48&Io))throw Error(i(187));var n=Io;Io|=1;try{return Ur(99,e.bind(null,t))}finally{Io=n,Hr()}},t.hydrate=function(e,t,n){if(!Wc(t))throw Error(i(200));return Uc(null,e,t,!0,n)},t.render=function(e,t,n){if(!Wc(t))throw Error(i(200));return Uc(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Wc(e))throw Error(i(40));return!!e._reactRootContainer&&(tc((function(){Uc(null,null,e,!1,(function(){e._reactRootContainer=null,e[Tn]=null}))})),!0)},t.unstable_batchedUpdates=ec,t.unstable_createPortal=function(e,t){return Gc(e,t,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)},t.unstable_renderSubtreeIntoContainer=function(e,t,n,a){if(!Wc(n))throw Error(i(200));if(null==e||void 0===e._reactInternalFiber)throw Error(i(38));return Uc(e,t,n,!1,a)},t.version="16.14.0"},function(e,t,n){"use strict";e.exports=n(231)},function(e,t,n){"use strict";var a,r,s,i,o;if("undefined"===typeof window||"function"!==typeof MessageChannel){var c=null,l=null,u=function(){if(null!==c)try{var e=t.unstable_now();c(!0,e),c=null}catch(n){throw setTimeout(u,0),n}},d=Date.now();t.unstable_now=function(){return Date.now()-d},a=function(e){null!==c?setTimeout(a,0,e):(c=e,setTimeout(u,0))},r=function(e,t){l=setTimeout(e,t)},s=function(){clearTimeout(l)},i=function(){return!1},o=t.unstable_forceFrameRate=function(){}}else{var h=window.performance,p=window.Date,f=window.setTimeout,m=window.clearTimeout;if("undefined"!==typeof console){var g=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),"function"!==typeof g&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills")}if("object"===typeof h&&"function"===typeof h.now)t.unstable_now=function(){return h.now()};else{var b=p.now();t.unstable_now=function(){return p.now()-b}}var y=!1,v=null,x=-1,w=5,k=0;i=function(){return t.unstable_now()>=k},o=function(){},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):w=0<e?Math.floor(1e3/e):5};var I=new MessageChannel,S=I.port2;I.port1.onmessage=function(){if(null!==v){var e=t.unstable_now();k=e+w;try{v(!0,e)?S.postMessage(null):(y=!1,v=null)}catch(n){throw S.postMessage(null),n}}else y=!1},a=function(e){v=e,y||(y=!0,S.postMessage(null))},r=function(e,n){x=f((function(){e(t.unstable_now())}),n)},s=function(){m(x),x=-1}}function N(e,t){var n=e.length;e.push(t);e:for(;;){var a=n-1>>>1,r=e[a];if(!(void 0!==r&&0<C(r,t)))break e;e[a]=t,e[n]=r,n=a}}function T(e){return void 0===(e=e[0])?null:e}function O(e){var t=e[0];if(void 0!==t){var n=e.pop();if(n!==t){e[0]=n;e:for(var a=0,r=e.length;a<r;){var s=2*(a+1)-1,i=e[s],o=s+1,c=e[o];if(void 0!==i&&0>C(i,n))void 0!==c&&0>C(c,i)?(e[a]=c,e[o]=n,a=o):(e[a]=i,e[s]=n,a=s);else{if(!(void 0!==c&&0>C(c,n)))break e;e[a]=c,e[o]=n,a=o}}}return t}return null}function C(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}var E=[],_=[],A=1,R=null,D=3,F=!1,M=!1,j=!1;function z(e){for(var t=T(_);null!==t;){if(null===t.callback)O(_);else{if(!(t.startTime<=e))break;O(_),t.sortIndex=t.expirationTime,N(E,t)}t=T(_)}}function L(e){if(j=!1,z(e),!M)if(null!==T(E))M=!0,a(P);else{var t=T(_);null!==t&&r(L,t.startTime-e)}}function P(e,n){M=!1,j&&(j=!1,s()),F=!0;var a=D;try{for(z(n),R=T(E);null!==R&&(!(R.expirationTime>n)||e&&!i());){var o=R.callback;if(null!==o){R.callback=null,D=R.priorityLevel;var c=o(R.expirationTime<=n);n=t.unstable_now(),"function"===typeof c?R.callback=c:R===T(E)&&O(E),z(n)}else O(E);R=T(E)}if(null!==R)var l=!0;else{var u=T(_);null!==u&&r(L,u.startTime-n),l=!1}return l}finally{R=null,D=a,F=!1}}function B(e){switch(e){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1e4;default:return 5e3}}var W=o;t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){M||F||(M=!0,a(P))},t.unstable_getCurrentPriorityLevel=function(){return D},t.unstable_getFirstCallbackNode=function(){return T(E)},t.unstable_next=function(e){switch(D){case 1:case 2:case 3:var t=3;break;default:t=D}var n=D;D=t;try{return e()}finally{D=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=W,t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=D;D=e;try{return t()}finally{D=n}},t.unstable_scheduleCallback=function(e,n,i){var o=t.unstable_now();if("object"===typeof i&&null!==i){var c=i.delay;c="number"===typeof c&&0<c?o+c:o,i="number"===typeof i.timeout?i.timeout:B(e)}else i=B(e),c=o;return e={id:A++,callback:n,priorityLevel:e,startTime:c,expirationTime:i=c+i,sortIndex:-1},c>o?(e.sortIndex=c,N(_,e),null===T(E)&&e===T(_)&&(j?s():j=!0,r(L,c-o))):(e.sortIndex=i,N(E,e),M||F||(M=!0,a(P))),e},t.unstable_shouldYield=function(){var e=t.unstable_now();z(e);var n=T(E);return n!==R&&null!==R&&null!==n&&null!==n.callback&&n.startTime<=e&&n.expirationTime<R.expirationTime||i()},t.unstable_wrapCallback=function(e){var t=D;return function(){var n=D;D=t;try{return e.apply(this,arguments)}finally{D=n}}}},,function(e,t,n){"use strict";t.byteLength=function(e){var t=l(e),n=t[0],a=t[1];return 3*(n+a)/4-a},t.toByteArray=function(e){var t,n,a=l(e),i=a[0],o=a[1],c=new s(function(e,t,n){return 3*(t+n)/4-n}(0,i,o)),u=0,d=o>0?i-4:i;for(n=0;n<d;n+=4)t=r[e.charCodeAt(n)]<<18|r[e.charCodeAt(n+1)]<<12|r[e.charCodeAt(n+2)]<<6|r[e.charCodeAt(n+3)],c[u++]=t>>16&255,c[u++]=t>>8&255,c[u++]=255&t;2===o&&(t=r[e.charCodeAt(n)]<<2|r[e.charCodeAt(n+1)]>>4,c[u++]=255&t);1===o&&(t=r[e.charCodeAt(n)]<<10|r[e.charCodeAt(n+1)]<<4|r[e.charCodeAt(n+2)]>>2,c[u++]=t>>8&255,c[u++]=255&t);return c},t.fromByteArray=function(e){for(var t,n=e.length,r=n%3,s=[],i=0,o=n-r;i<o;i+=16383)s.push(u(e,i,i+16383>o?o:i+16383));1===r?(t=e[n-1],s.push(a[t>>2]+a[t<<4&63]+"==")):2===r&&(t=(e[n-2]<<8)+e[n-1],s.push(a[t>>10]+a[t>>4&63]+a[t<<2&63]+"="));return s.join("")};for(var a=[],r=[],s="undefined"!==typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o=0,c=i.length;o<c;++o)a[o]=i[o],r[i.charCodeAt(o)]=o;function l(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");return-1===n&&(n=t),[n,n===t?0:4-n%4]}function u(e,t,n){for(var r,s,i=[],o=t;o<n;o+=3)r=(e[o]<<16&16711680)+(e[o+1]<<8&65280)+(255&e[o+2]),i.push(a[(s=r)>>18&63]+a[s>>12&63]+a[s>>6&63]+a[63&s]);return i.join("")}r["-".charCodeAt(0)]=62,r["_".charCodeAt(0)]=63},function(e,t){t.read=function(e,t,n,a,r){var s,i,o=8*r-a-1,c=(1<<o)-1,l=c>>1,u=-7,d=n?r-1:0,h=n?-1:1,p=e[t+d];for(d+=h,s=p&(1<<-u)-1,p>>=-u,u+=o;u>0;s=256*s+e[t+d],d+=h,u-=8);for(i=s&(1<<-u)-1,s>>=-u,u+=a;u>0;i=256*i+e[t+d],d+=h,u-=8);if(0===s)s=1-l;else{if(s===c)return i?NaN:1/0*(p?-1:1);i+=Math.pow(2,a),s-=l}return(p?-1:1)*i*Math.pow(2,s-a)},t.write=function(e,t,n,a,r,s){var i,o,c,l=8*s-r-1,u=(1<<l)-1,d=u>>1,h=23===r?Math.pow(2,-24)-Math.pow(2,-77):0,p=a?0:s-1,f=a?1:-1,m=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,i=u):(i=Math.floor(Math.log(t)/Math.LN2),t*(c=Math.pow(2,-i))<1&&(i--,c*=2),(t+=i+d>=1?h/c:h*Math.pow(2,1-d))*c>=2&&(i++,c/=2),i+d>=u?(o=0,i=u):i+d>=1?(o=(t*c-1)*Math.pow(2,r),i+=d):(o=t*Math.pow(2,d-1)*Math.pow(2,r),i=0));r>=8;e[n+p]=255&o,p+=f,o/=256,r-=8);for(i=i<<r|o,l+=r;l>0;e[n+p]=255&i,p+=f,i/=256,l-=8);e[n+p-f]|=128*m}},function(e,t){var n={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==n.call(e)}},function(e,t,n){"use strict";(function(e){var t=n(19);const a=()=>n(237);let r;class s{constructor(){this.util=n(238),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return null!=Object(t.b)().global.fetch?Object(t.b)().global.fetch(e,n):(null==r&&(r=a()),r(e,n))}now(){const t=e.hrtime();return 1e3*t[0]+t[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}}Object(t.b)().get("IS_NODE")&&!Object(t.b)().get("IS_BROWSER")&&Object(t.b)().setPlatform("node",new s)}).call(this,n(101))},,,function(e,t,n){(function(e){var a;!function(e,r,s){function i(e){var t=this,n=function(){var e=4022871197;return function(t){t=String(t);for(var n=0;n<t.length;n++){var a=.02519603282416938*(e+=t.charCodeAt(n));a-=e=a>>>0,e=(a*=e)>>>0,e+=4294967296*(a-=e)}return 2.3283064365386963e-10*(e>>>0)}}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function o(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function c(e,t){var n=new i(e),a=t&&t.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,a&&("object"==typeof a&&o(a,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=c:n(59)&&n(79)?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.alea=c}(0,e,n(59))}).call(this,n(102)(e))},function(e,t,n){(function(e){var a;!function(e,r,s){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function c(e,t){var n=new i(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&o(a,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=c:n(59)&&n(79)?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xor128=c}(0,e,n(59))}).call(this,n(102)(e))},function(e,t,n){(function(e){var a;!function(e,r,s){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),a==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function c(e,t){var n=new i(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&o(a,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=c:n(59)&&n(79)?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xorwow=c}(0,e,n(59))}).call(this,n(102)(e))},function(e,t,n){(function(e){var a;!function(e,r,s){function i(e){var t=this;t.next=function(){var e,n,a=t.x,r=t.i;return e=a[r],n=(e^=e>>>7)^e<<24,n^=(e=a[r+1&7])^e>>>10,n^=(e=a[r+3&7])^e>>>3,n^=(e=a[r+4&7])^e<<7,e=a[r+7&7],n^=(e^=e<<13)^e<<9,a[r]=n,t.i=r+1&7,n},function(e,t){var n,a=[];if(t===(0|t))a[0]=t;else for(t=""+t,n=0;n<t.length;++n)a[7&n]=a[7&n]<<15^t.charCodeAt(n)+a[n+1&7]<<13;for(;a.length<8;)a.push(0);for(n=0;n<8&&0===a[n];++n);for(8==n?a[7]=-1:a[n],e.x=a,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function o(e,t){return t.x=e.x.slice(),t.i=e.i,t}function c(e,t){null==e&&(e=+new Date);var n=new i(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.x&&o(a,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=c:n(59)&&n(79)?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xorshift7=c}(0,e,n(59))}).call(this,n(102)(e))},function(e,t,n){(function(e){var a;!function(e,r,s){function i(e){var t=this;t.next=function(){var e,n,a=t.w,r=t.X,s=t.i;return t.w=a=a+1640531527|0,n=r[s+34&127],e=r[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=r[s]=n^e,t.i=s,n+(a^a>>>16)|0},function(e,t){var n,a,r,s,i,o=[],c=128;for(t===(0|t)?(a=t,t=null):(t+="\0",a=0,c=Math.max(c,t.length)),r=0,s=-32;s<c;++s)t&&(a^=t.charCodeAt((s+32)%t.length)),0===s&&(i=a),a^=a<<10,a^=a>>>15,a^=a<<4,a^=a>>>13,s>=0&&(i=i+1640531527|0,r=0==(n=o[127&s]^=a+i)?r+1:0);for(r>=128&&(o[127&(t&&t.length||0)]=-1),r=127,s=512;s>0;--s)a=o[r+34&127],n=o[r=r+1&127],a^=a<<13,n^=n<<17,a^=a>>>15,n^=n>>>12,o[r]=a^n;e.w=i,e.X=o,e.i=r}(t,e)}function o(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function c(e,t){null==e&&(e=+new Date);var n=new i(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.X&&o(a,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=c:n(59)&&n(79)?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xor4096=c}(0,e,n(59))}).call(this,n(102)(e))},function(e,t,n){(function(e){var a;!function(e,r,s){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,a=t.d,r=t.a;return e=e<<25^e>>>7^n,n=n-a|0,a=a<<24^a>>>8^r,r=r-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-a|0,t.d=a<<16^n>>>16^r,t.a=r-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var a=0;a<n.length+20;a++)t.b^=0|n.charCodeAt(a),t.next()}function o(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function c(e,t){var n=new i(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&o(a,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=c:n(59)&&n(79)?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.tychei=c}(0,e,n(59))}).call(this,n(102)(e))},function(e,t,n){var a;!function(r,s,i){var o,c=i.pow(256,6),l=i.pow(2,52),u=2*l;function d(e,t,n){var a=[],d=f(function e(t,n){var a,r=[],s=typeof t;if(n&&"object"==s)for(a in t)try{r.push(e(t[a],n-1))}catch(i){}return r.length?r:"string"==s?t:t+"\0"}((t=1==t?{entropy:!0}:t||{}).entropy?[e,m(s)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(256):(e=new Uint8Array(256),(r.crypto||r.msCrypto).getRandomValues(e)),m(e)}catch(a){var t=r.navigator,n=t&&t.plugins;return[+new Date,r,n,r.screen,m(s)]}}():e,3),a),g=new h(a),b=function(){for(var e=g.g(6),t=c,n=0;e<l;)e=256*(e+n),t*=256,n=g.g(1);for(;e>=u;)e/=2,t/=2,n>>>=1;return(e+n)/t};return b.int32=function(){return 0|g.g(4)},b.quick=function(){return g.g(4)/4294967296},b.double=b,f(m(g.S),s),(t.pass||n||function(e,t,n,a){return a&&(a.S&&p(a,g),e.state=function(){return p(g,{})}),n?(i.random=e,t):e})(b,d,"global"in t?t.global:this==i,t.state)}function h(e){var t,n=e.length,a=this,r=0,s=a.i=a.j=0,i=a.S=[];for(n||(e=[n++]);r<256;)i[r]=r++;for(r=0;r<256;r++)i[r]=i[s=255&s+e[r%n]+(t=i[r])],i[s]=t;(a.g=function(e){for(var t,n=0,r=a.i,s=a.j,i=a.S;e--;)t=i[r=255&r+1],n=256*n+i[255&(i[r]=i[s=255&s+t])+(i[s]=t)];return a.i=r,a.j=s,n})(256)}function p(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function f(e,t){for(var n,a=e+"",r=0;r<a.length;)t[255&r]=255&(n^=19*t[255&r])+a.charCodeAt(r++);return m(t)}function m(e){return String.fromCharCode.apply(0,e)}if(f(i.random(),s),e.exports){e.exports=d;try{o=n(246)}catch(g){}}else void 0===(a=function(){return d}.call(t,n,t,e))||(e.exports=a)}("undefined"!==typeof self?self:this,[],Math)},,function(e,t,n){(function(e,t){!function(e,n){"use strict";if(!e.setImmediate){var a,r=1,s={},i=!1,o=e.document,c=Object.getPrototypeOf&&Object.getPrototypeOf(e);c=c&&c.setTimeout?c:e,"[object process]"==={}.toString.call(e.process)?a=function(e){t.nextTick((function(){u(e)}))}:function(){if(e.postMessage&&!e.importScripts){var t=!0,n=e.onmessage;return e.onmessage=function(){t=!1},e.postMessage("","*"),e.onmessage=n,t}}()?function(){var t="setImmediate$"+Math.random()+"$",n=function(n){n.source===e&&"string"===typeof n.data&&0===n.data.indexOf(t)&&u(+n.data.slice(t.length))};e.addEventListener?e.addEventListener("message",n,!1):e.attachEvent("onmessage",n),a=function(n){e.postMessage(t+n,"*")}}():e.MessageChannel?function(){var e=new MessageChannel;e.port1.onmessage=function(e){u(e.data)},a=function(t){e.port2.postMessage(t)}}():o&&"onreadystatechange"in o.createElement("script")?function(){var e=o.documentElement;a=function(t){var n=o.createElement("script");n.onreadystatechange=function(){u(t),n.onreadystatechange=null,e.removeChild(n),n=null},e.appendChild(n)}}():a=function(e){setTimeout(u,0,e)},c.setImmediate=function(e){"function"!==typeof e&&(e=new Function(""+e));for(var t=new Array(arguments.length-1),n=0;n<t.length;n++)t[n]=arguments[n+1];var i={callback:e,args:t};return s[r]=i,a(r),r++},c.clearImmediate=l}function l(e){delete s[e]}function u(e){if(i)setTimeout(u,0,e);else{var t=s[e];if(t){i=!0;try{!function(e){var t=e.callback,n=e.args;switch(n.length){case 0:t();break;case 1:t(n[0]);break;case 2:t(n[0],n[1]);break;case 3:t(n[0],n[1],n[2]);break;default:t.apply(void 0,n)}}(t)}finally{l(e),i=!1}}}}}("undefined"===typeof self?"undefined"===typeof e?this:e:self)}).call(this,n(100),n(101))}]]);
//# sourceMappingURL=2.49e59758.chunk.js.map